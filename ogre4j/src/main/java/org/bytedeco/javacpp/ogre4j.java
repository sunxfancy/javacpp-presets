// Targeted by JavaCPP version 1.2.5-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class ogre4j extends org.bytedeco.javacpp.presets.ogre4j {
    static { Loader.load(); }

@Name("std::list<Ogre::BySkeletonDef>") public static class BySkeletonDefListRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public BySkeletonDefListRef(Pointer p) { super(p); }
    public BySkeletonDefListRef(BySkeletonDef ... array) { this(array.length); put(array); }
    public BySkeletonDefListRef()       { allocate();  }
    public BySkeletonDefListRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef BySkeletonDefListRef put(@ByRef BySkeletonDefListRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef BySkeletonDef get(@Cast("size_t") long i);
    public native BySkeletonDefListRef put(@Cast("size_t") long i, BySkeletonDef value);

    public BySkeletonDefListRef put(BySkeletonDef ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::list<Ogre::MovableObject*>") public static class MovableObjectPtrListRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MovableObjectPtrListRef(Pointer p) { super(p); }
    public MovableObjectPtrListRef(MovableObject ... array) { this(array.length); put(array); }
    public MovableObjectPtrListRef()       { allocate();  }
    public MovableObjectPtrListRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef MovableObjectPtrListRef put(@ByRef MovableObjectPtrListRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native MovableObject get(@Cast("size_t") long i);
    public native MovableObjectPtrListRef put(@Cast("size_t") long i, MovableObject value);

    public MovableObjectPtrListRef put(MovableObject ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::list<Ogre::Plane>") public static class PlaneListRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PlaneListRef(Pointer p) { super(p); }
    public PlaneListRef(Plane ... array) { this(array.length); put(array); }
    public PlaneListRef()       { allocate();  }
    public PlaneListRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef PlaneListRef put(@ByRef PlaneListRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef Plane get(@Cast("size_t") long i);
    public native PlaneListRef put(@Cast("size_t") long i, Plane value);

    public PlaneListRef put(Plane ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::list<Ogre::ResourceGroupManager::ResourceDeclaration>") public static class ResourceDeclarationListRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ResourceDeclarationListRef(Pointer p) { super(p); }
    public ResourceDeclarationListRef(ResourceDeclaration ... array) { this(array.length); put(array); }
    public ResourceDeclarationListRef()       { allocate();  }
    public ResourceDeclarationListRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef ResourceDeclarationListRef put(@ByRef ResourceDeclarationListRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef ResourceDeclaration get(@Cast("size_t") long i);
    public native ResourceDeclarationListRef put(@Cast("size_t") long i, ResourceDeclaration value);

    public ResourceDeclarationListRef put(ResourceDeclaration ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::list<Ogre::ResourceGroupManager::ResourceLocation*>") public static class ResourceLocationPtrListRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ResourceLocationPtrListRef(Pointer p) { super(p); }
    public ResourceLocationPtrListRef(ResourceLocation ... array) { this(array.length); put(array); }
    public ResourceLocationPtrListRef()       { allocate();  }
    public ResourceLocationPtrListRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef ResourceLocationPtrListRef put(@ByRef ResourceLocationPtrListRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native ResourceLocation get(@Cast("size_t") long i);
    public native ResourceLocationPtrListRef put(@Cast("size_t") long i, ResourceLocation value);

    public ResourceLocationPtrListRef put(ResourceLocation ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::list<Ogre::SceneQuery::WorldFragment*>") public static class WorldFragmentPtrListRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public WorldFragmentPtrListRef(Pointer p) { super(p); }
    public WorldFragmentPtrListRef(WorldFragment ... array) { this(array.length); put(array); }
    public WorldFragmentPtrListRef()       { allocate();  }
    public WorldFragmentPtrListRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef WorldFragmentPtrListRef put(@ByRef WorldFragmentPtrListRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native WorldFragment get(@Cast("size_t") long i);
    public native WorldFragmentPtrListRef put(@Cast("size_t") long i, WorldFragment value);

    public WorldFragmentPtrListRef put(WorldFragment ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::list<Ogre::SceneQueryMovableObjectPair>") public static class SceneQueryMovableObjectPairListRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SceneQueryMovableObjectPairListRef(Pointer p) { super(p); }
    public SceneQueryMovableObjectPairListRef(SceneQueryMovableObjectPair ... array) { this(array.length); put(array); }
    public SceneQueryMovableObjectPairListRef()       { allocate();  }
    public SceneQueryMovableObjectPairListRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef SceneQueryMovableObjectPairListRef put(@ByRef SceneQueryMovableObjectPairListRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef SceneQueryMovableObjectPair get(@Cast("size_t") long i);
    public native SceneQueryMovableObjectPairListRef put(@Cast("size_t") long i, SceneQueryMovableObjectPair value);

    public SceneQueryMovableObjectPairListRef put(SceneQueryMovableObjectPair ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::list<Ogre::SceneQueryMovableObjectWorldFragmentPair>") public static class SceneQueryMovableObjectWorldFragmentPairListRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SceneQueryMovableObjectWorldFragmentPairListRef(Pointer p) { super(p); }
    public SceneQueryMovableObjectWorldFragmentPairListRef(SceneQueryMovableObjectWorldFragmentPair ... array) { this(array.length); put(array); }
    public SceneQueryMovableObjectWorldFragmentPairListRef()       { allocate();  }
    public SceneQueryMovableObjectWorldFragmentPairListRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef SceneQueryMovableObjectWorldFragmentPairListRef put(@ByRef SceneQueryMovableObjectWorldFragmentPairListRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef SceneQueryMovableObjectWorldFragmentPair get(@Cast("size_t") long i);
    public native SceneQueryMovableObjectWorldFragmentPairListRef put(@Cast("size_t") long i, SceneQueryMovableObjectWorldFragmentPair value);

    public SceneQueryMovableObjectWorldFragmentPairListRef put(SceneQueryMovableObjectWorldFragmentPair ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::list<Ogre::v1::VertexElement>") public static class VertexElementListRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VertexElementListRef(Pointer p) { super(p); }
    public VertexElementListRef(VertexElement ... array) { this(array.length); put(array); }
    public VertexElementListRef()       { allocate();  }
    public VertexElementListRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef VertexElementListRef put(@ByRef VertexElementListRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef VertexElement get(@Cast("size_t") long i);
    public native VertexElementListRef put(@Cast("size_t") long i, VertexElement value);

    public VertexElementListRef put(VertexElement ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::map<Ogre::RenderTarget*,Ogre::ResourceAccess::ResourceAccess>") public static class ResourceAccessRenderTargetPtrRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ResourceAccessRenderTargetPtrRef(Pointer p) { super(p); }
    public ResourceAccessRenderTargetPtrRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef ResourceAccessRenderTargetPtrRef put(@ByRef ResourceAccessRenderTargetPtrRef x);

    public native long size();

    @Index public native @ByRef ResourceAccess get(RenderTarget i);
    public native ResourceAccessRenderTargetPtrRef put(RenderTarget i, ResourceAccess value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter RenderTarget first();
        public native @Name("operator*().second") @MemberGetter @ByRef ResourceAccess second();
    }
}

@Name("std::map<Ogre::RenderTarget*,Ogre::ResourceLayout::Layout>") public static class LayoutRenderTargetPtrRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LayoutRenderTargetPtrRef(Pointer p) { super(p); }
    public LayoutRenderTargetPtrRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef LayoutRenderTargetPtrRef put(@ByRef LayoutRenderTargetPtrRef x);

    public native long size();

    @Index public native @ByRef Layout get(RenderTarget i);
    public native LayoutRenderTargetPtrRef put(RenderTarget i, Layout value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter RenderTarget first();
        public native @Name("operator*().second") @MemberGetter @ByRef Layout second();
    }
}

@Name("std::map<Ogre::String,bool>") public static class SBoolUMapRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SBoolUMapRef(Pointer p) { super(p); }
    public SBoolUMapRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef SBoolUMapRef put(@ByRef SBoolUMapRef x);

    public native long size();

    @Index public native @Cast("bool") boolean get(String i);
    public native SBoolUMapRef put(String i, boolean value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter String first();
        public native @Name("operator*().second") @MemberGetter @Cast("bool") boolean second();
    }
}

@Name("std::map<Ogre::String,Ogre::ConfigOption>") public static class SConfigOptionMapRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SConfigOptionMapRef(Pointer p) { super(p); }
    public SConfigOptionMapRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef SConfigOptionMapRef put(@ByRef SConfigOptionMapRef x);

    public native long size();

    @Index public native @ByRef ConfigOption get(String i);
    public native SConfigOptionMapRef put(String i, ConfigOption value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter String first();
        public native @Name("operator*().second") @MemberGetter @ByRef ConfigOption second();
    }
}

@Name("std::map<Ogre::String,Ogre::GpuConstantDefinition>") public static class GpuConstantDefinitionMapRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GpuConstantDefinitionMapRef(Pointer p) { super(p); }
    public GpuConstantDefinitionMapRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef GpuConstantDefinitionMapRef put(@ByRef GpuConstantDefinitionMapRef x);

    public native long size();

    @Index public native @ByRef GpuConstantDefinition get(String i);
    public native GpuConstantDefinitionMapRef put(String i, GpuConstantDefinition value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter String first();
        public native @Name("operator*().second") @MemberGetter @ByRef GpuConstantDefinition second();
    }
}

@Name("std::map<Ogre::String,Ogre::GpuSharedParametersPtr>") public static class GpuSharedParametersPtrMapRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GpuSharedParametersPtrMapRef(Pointer p) { super(p); }
    public GpuSharedParametersPtrMapRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef GpuSharedParametersPtrMapRef put(@ByRef GpuSharedParametersPtrMapRef x);

    public native long size();

    @Index public native @ByRef GpuSharedParametersPtr get(String i);
    public native GpuSharedParametersPtrMapRef put(String i, GpuSharedParametersPtr value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter String first();
        public native @Name("operator*().second") @MemberGetter @ByRef GpuSharedParametersPtr second();
    }
}

@Name("std::map<Ogre::String,Ogre::ProfileInstance*>") public static class ProfileInstanceMapRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ProfileInstanceMapRef(Pointer p) { super(p); }
    public ProfileInstanceMapRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef ProfileInstanceMapRef put(@ByRef ProfileInstanceMapRef x);

    public native long size();

    @Index public native ProfileInstance get(String i);
    public native ProfileInstanceMapRef put(String i, ProfileInstance value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter String first();
        public native @Name("operator*().second") @MemberGetter ProfileInstance second();
    }
}

@Name("std::map<Ogre::String,Ogre::String>") public static class SStringMapRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SStringMapRef(Pointer p) { super(p); }
    public SStringMapRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef SStringMapRef put(@ByRef SStringMapRef x);

    public native long size();

    @Index public native @ByRef String get(String i);
    public native SStringMapRef put(String i, String value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter String first();
        public native @Name("operator*().second") @MemberGetter @ByRef String second();
    }
}

@Name("std::map<Ogre::String,Ogre::ushort>") public static class SUshortMapRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SUshortMapRef(Pointer p) { super(p); }
    public SUshortMapRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef SUshortMapRef put(@ByRef SUshortMapRef x);

    public native long size();

    @Index public native short get(String i);
    public native SUshortMapRef put(String i, short value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter String first();
        public native @Name("operator*().second") @MemberGetter short second();
    }
}

@Name("std::map<Ogre::String,Ogre::v1::Animation*>") public static class AnimationMapRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AnimationMapRef(Pointer p) { super(p); }
    public AnimationMapRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef AnimationMapRef put(@ByRef AnimationMapRef x);

    public native long size();

    @Index public native Animation get(String i);
    public native AnimationMapRef put(String i, Animation value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter String first();
        public native @Name("operator*().second") @MemberGetter Animation second();
    }
}

@Name("std::map<Ogre::ushort,Ogre::ushort>") public static class UshortMapRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public UshortMapRef(Pointer p) { super(p); }
    public UshortMapRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef UshortMapRef put(@ByRef UshortMapRef x);

    public native long size();

    @Index public native short get(short i);
    public native UshortMapRef put(short i, short value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter short first();
        public native @Name("operator*().second") @MemberGetter short second();
    }
}

@Name("std::map<Ogre::VertexBufferPacked*,Ogre::VertexBufferPacked*>") public static class VertexBufferPackedPtrSelfMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VertexBufferPackedPtrSelfMap(Pointer p) { super(p); }
    public VertexBufferPackedPtrSelfMap()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef VertexBufferPackedPtrSelfMap put(@ByRef VertexBufferPackedPtrSelfMap x);

    public native long size();

    @Index public native VertexBufferPacked get(VertexBufferPacked i);
    public native VertexBufferPackedPtrSelfMap put(VertexBufferPacked i, VertexBufferPacked value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter VertexBufferPacked first();
        public native @Name("operator*().second") @MemberGetter VertexBufferPacked second();
    }
}

@Name("std::map<size_t,Ogre::GpuLogicalIndexUse>") public static class GpuLogicalIndexUseMapRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GpuLogicalIndexUseMapRef(Pointer p) { super(p); }
    public GpuLogicalIndexUseMapRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef GpuLogicalIndexUseMapRef put(@ByRef GpuLogicalIndexUseMapRef x);

    public native long size();

    @Index public native @ByRef GpuLogicalIndexUse get(long i);
    public native GpuLogicalIndexUseMapRef put(long i, GpuLogicalIndexUse value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter long first();
        public native @Name("operator*().second") @MemberGetter @ByRef GpuLogicalIndexUse second();
    }
}

@Name("std::map<size_t,Ogre::Vector3>") public static class Vector3MapRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Vector3MapRef(Pointer p) { super(p); }
    public Vector3MapRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef Vector3MapRef put(@ByRef Vector3MapRef x);

    public native long size();

    @Index public native @ByRef Vector3 get(long i);
    public native Vector3MapRef put(long i, Vector3 value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter long first();
        public native @Name("operator*().second") @MemberGetter @ByRef Vector3 second();
    }
}

@Name("std::map<unsigned short,NumericAnimationTrack*>") public static class NumericTrackListRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public NumericTrackListRef(Pointer p) { super(p); }
    public NumericTrackListRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef NumericTrackListRef put(@ByRef NumericTrackListRef x);

    public native long size();

    @Index public native NumericAnimationTrack get(short i);
    public native NumericTrackListRef put(short i, NumericAnimationTrack value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter short first();
        public native @Name("operator*().second") @MemberGetter NumericAnimationTrack second();
    }
}

@Name("std::map<unsigned short,Ogre::v1::HardwareVertexBufferSharedPtr>") public static class HardwareVertexBufferSharedPtrMapRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public HardwareVertexBufferSharedPtrMapRef(Pointer p) { super(p); }
    public HardwareVertexBufferSharedPtrMapRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef HardwareVertexBufferSharedPtrMapRef put(@ByRef HardwareVertexBufferSharedPtrMapRef x);

    public native long size();

    @Index public native @ByRef HardwareVertexBufferSharedPtr get(short i);
    public native HardwareVertexBufferSharedPtrMapRef put(short i, HardwareVertexBufferSharedPtr value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter short first();
        public native @Name("operator*().second") @MemberGetter @ByRef HardwareVertexBufferSharedPtr second();
    }
}

@Name("std::map<unsigned short,Ogre::v1::NumericAnimationTrack*>") public static class NumericAnimationTrackPtrMapRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public NumericAnimationTrackPtrMapRef(Pointer p) { super(p); }
    public NumericAnimationTrackPtrMapRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef NumericAnimationTrackPtrMapRef put(@ByRef NumericAnimationTrackPtrMapRef x);

    public native long size();

    @Index public native NumericAnimationTrack get(short i);
    public native NumericAnimationTrackPtrMapRef put(short i, NumericAnimationTrack value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter short first();
        public native @Name("operator*().second") @MemberGetter NumericAnimationTrack second();
    }
}

@Name("std::map<unsigned short,Ogre::v1::OldNodeAnimationTrack*>") public static class OldNodeAnimationTrackPtrMapRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OldNodeAnimationTrackPtrMapRef(Pointer p) { super(p); }
    public OldNodeAnimationTrackPtrMapRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef OldNodeAnimationTrackPtrMapRef put(@ByRef OldNodeAnimationTrackPtrMapRef x);

    public native long size();

    @Index public native OldNodeAnimationTrack get(short i);
    public native OldNodeAnimationTrackPtrMapRef put(short i, OldNodeAnimationTrack value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter short first();
        public native @Name("operator*().second") @MemberGetter OldNodeAnimationTrack second();
    }
}

@Name("std::map<unsigned short,Ogre::VertexAnimationTrack*>") public static class VertexAnimationTrackPtrMapRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VertexAnimationTrackPtrMapRef(Pointer p) { super(p); }
    public VertexAnimationTrackPtrMapRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef VertexAnimationTrackPtrMapRef put(@ByRef VertexAnimationTrackPtrMapRef x);

    public native long size();

    @Index public native VertexAnimationTrack get(short i);
    public native VertexAnimationTrackPtrMapRef put(short i, VertexAnimationTrack value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter short first();
        public native @Name("operator*().second") @MemberGetter VertexAnimationTrack second();
    }
}

@Name("std::map<unsigned short,OldNodeAnimationTrack*>") public static class OldNodeTrackListRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OldNodeTrackListRef(Pointer p) { super(p); }
    public OldNodeTrackListRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef OldNodeTrackListRef put(@ByRef OldNodeTrackListRef x);

    public native long size();

    @Index public native OldNodeAnimationTrack get(short i);
    public native OldNodeTrackListRef put(short i, OldNodeAnimationTrack value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter short first();
        public native @Name("operator*().second") @MemberGetter OldNodeAnimationTrack second();
    }
}

@Name("std::map<unsigned short,VertexAnimationTrack*>") public static class VertexTrackListRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VertexTrackListRef(Pointer p) { super(p); }
    public VertexTrackListRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef VertexTrackListRef put(@ByRef VertexTrackListRef x);

    public native long size();

    @Index public native VertexAnimationTrack get(short i);
    public native VertexTrackListRef put(short i, VertexAnimationTrack value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter short first();
        public native @Name("operator*().second") @MemberGetter VertexAnimationTrack second();
    }
}

@Name("std::set<Ogre::v1::Entity*>") public static class EntityPtrSetRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public EntityPtrSetRef(Pointer p) { super(p); }
    public EntityPtrSetRef(Entity ... array) { this(array.length); put(array); }
    public EntityPtrSetRef()       { allocate();  }
    public EntityPtrSetRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef EntityPtrSetRef put(@ByRef EntityPtrSetRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native Entity get(@Cast("size_t") long i);
    public native EntityPtrSetRef put(@Cast("size_t") long i, Entity value);

    public EntityPtrSetRef put(Entity ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::set<std::string>") public static class StringSetRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringSetRef(Pointer p) { super(p); }
    public StringSetRef(String ... array) { this(array.length); put(array); }
    public StringSetRef()       { allocate();  }
    public StringSetRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef StringSetRef put(@ByRef StringSetRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef String get(@Cast("size_t") long i);
    public native StringSetRef put(@Cast("size_t") long i, String value);

    public StringSetRef put(String ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::set<Ogre::SceneQuery::WorldFragmentType>") public static class WorldFragmentTypeSetRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public WorldFragmentTypeSetRef(Pointer p) { super(p); }
    public WorldFragmentTypeSetRef(WorldFragmentType ... array) { this(array.length); put(array); }
    public WorldFragmentTypeSetRef()       { allocate();  }
    public WorldFragmentTypeSetRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef WorldFragmentTypeSetRef put(@ByRef WorldFragmentTypeSetRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef WorldFragmentType get(@Cast("size_t") long i);
    public native WorldFragmentTypeSetRef put(@Cast("size_t") long i, WorldFragmentType value);

    public WorldFragmentTypeSetRef put(WorldFragmentType ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<char*>") public static class CharPtrVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CharPtrVectorRef(Pointer p) { super(p); }
    public CharPtrVectorRef(BytePointer ... array) { this(array.length); put(array); }
    public CharPtrVectorRef(ByteBuffer ... array) { this(array.length); put(array); }
    public CharPtrVectorRef(byte[] ... array) { this(array.length); put(array); }
    public CharPtrVectorRef()       { allocate();  }
    public CharPtrVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef CharPtrVectorRef put(@ByRef CharPtrVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @Cast("char*") BytePointer get(@Cast("size_t") long i);
    public native CharPtrVectorRef put(@Cast("size_t") long i, BytePointer value);
    @ValueSetter @Index public native CharPtrVectorRef put(@Cast("size_t") long i, @Cast("char*") ByteBuffer value);
    @ValueSetter @Index public native CharPtrVectorRef put(@Cast("size_t") long i, @Cast("char*") byte[] value);

    public CharPtrVectorRef put(BytePointer ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }

    public CharPtrVectorRef put(ByteBuffer ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }

    public CharPtrVectorRef put(byte[] ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<char>") public static class CharVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CharVectorRef(Pointer p) { super(p); }
    public CharVectorRef(byte ... array) { this(array.length); put(array); }
    public CharVectorRef()       { allocate();  }
    public CharVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef CharVectorRef put(@ByRef CharVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @Cast("char") byte get(@Cast("size_t") long i);
    public native CharVectorRef put(@Cast("size_t") long i, byte value);

    public CharVectorRef put(byte ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<const Ogre::Image*>") public static class ImagePtrVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ImagePtrVectorRef(Pointer p) { super(p); }
    public ImagePtrVectorRef(Image ... array) { this(array.length); put(array); }
    public ImagePtrVectorRef()       { allocate();  }
    public ImagePtrVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef ImagePtrVectorRef put(@ByRef ImagePtrVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @Const Image get(@Cast("size_t") long i);
    public native ImagePtrVectorRef put(@Cast("size_t") long i, Image value);

    public ImagePtrVectorRef put(Image ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<double>") public static class DoubleVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DoubleVectorRef(Pointer p) { super(p); }
    public DoubleVectorRef(double ... array) { this(array.length); put(array); }
    public DoubleVectorRef()       { allocate();  }
    public DoubleVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef DoubleVectorRef put(@ByRef DoubleVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native double get(@Cast("size_t") long i);
    public native DoubleVectorRef put(@Cast("size_t") long i, double value);

    public DoubleVectorRef put(double ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<float>") public static class FloatVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FloatVectorRef(Pointer p) { super(p); }
    public FloatVectorRef(float ... array) { this(array.length); put(array); }
    public FloatVectorRef()       { allocate();  }
    public FloatVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef FloatVectorRef put(@ByRef FloatVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native float get(@Cast("size_t") long i);
    public native FloatVectorRef put(@Cast("size_t") long i, float value);

    public FloatVectorRef put(float ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<IndexData*>") public static class IndexDataPtrVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IndexDataPtrVectorRef(Pointer p) { super(p); }
    public IndexDataPtrVectorRef(IndexData ... array) { this(array.length); put(array); }
    public IndexDataPtrVectorRef()       { allocate();  }
    public IndexDataPtrVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef IndexDataPtrVectorRef put(@ByRef IndexDataPtrVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native IndexData get(@Cast("size_t") long i);
    public native IndexDataPtrVectorRef put(@Cast("size_t") long i, IndexData value);

    public IndexDataPtrVectorRef put(IndexData ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<int>") public static class IntVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IntVectorRef(Pointer p) { super(p); }
    public IntVectorRef(int ... array) { this(array.length); put(array); }
    public IntVectorRef()       { allocate();  }
    public IntVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef IntVectorRef put(@ByRef IntVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native int get(@Cast("size_t") long i);
    public native IntVectorRef put(@Cast("size_t") long i, int value);

    public IntVectorRef put(int ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::Bone*>") public static class BonePtrVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public BonePtrVectorRef(Pointer p) { super(p); }
    public BonePtrVectorRef(Bone ... array) { this(array.length); put(array); }
    public BonePtrVectorRef()       { allocate();  }
    public BonePtrVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef BonePtrVectorRef put(@ByRef BonePtrVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native Bone get(@Cast("size_t") long i);
    public native BonePtrVectorRef put(@Cast("size_t") long i, Bone value);

    public BonePtrVectorRef put(Bone ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::Camera*>") public static class CameraPtrVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CameraPtrVectorRef(Pointer p) { super(p); }
    public CameraPtrVectorRef(Camera ... array) { this(array.length); put(array); }
    public CameraPtrVectorRef()       { allocate();  }
    public CameraPtrVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef CameraPtrVectorRef put(@ByRef CameraPtrVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native Camera get(@Cast("size_t") long i);
    public native CameraPtrVectorRef put(@Cast("size_t") long i, Camera value);

    public CameraPtrVectorRef put(Camera ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::CompositorPassDef*>") public static class CompositorPassDefPtrVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CompositorPassDefPtrVectorRef(Pointer p) { super(p); }
    public CompositorPassDefPtrVectorRef(CompositorPassDef ... array) { this(array.length); put(array); }
    public CompositorPassDefPtrVectorRef()       { allocate();  }
    public CompositorPassDefPtrVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef CompositorPassDefPtrVectorRef put(@ByRef CompositorPassDefPtrVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native CompositorPassDef get(@Cast("size_t") long i);
    public native CompositorPassDefPtrVectorRef put(@Cast("size_t") long i, CompositorPassDef value);

    public CompositorPassDefPtrVectorRef put(CompositorPassDef ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::CompositorPassDef::UavDependency>") public static class UavDependencyVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public UavDependencyVectorRef(Pointer p) { super(p); }
    public UavDependencyVectorRef(UavDependency ... array) { this(array.length); put(array); }
    public UavDependencyVectorRef()       { allocate();  }
    public UavDependencyVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef UavDependencyVectorRef put(@ByRef UavDependencyVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef UavDependency get(@Cast("size_t") long i);
    public native UavDependencyVectorRef put(@Cast("size_t") long i, UavDependency value);

    public UavDependencyVectorRef put(UavDependency ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::CompositorTexture>") public static class CompositorTextureVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CompositorTextureVectorRef(Pointer p) { super(p); }
    public CompositorTextureVectorRef(CompositorTexture ... array) { this(array.length); put(array); }
    public CompositorTextureVectorRef()       { allocate();  }
    public CompositorTextureVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef CompositorTextureVectorRef put(@ByRef CompositorTextureVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef CompositorTexture get(@Cast("size_t") long i);
    public native CompositorTextureVectorRef put(@Cast("size_t") long i, CompositorTexture value);

    public CompositorTextureVectorRef put(CompositorTexture ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::Frustum*>") public static class FrustumPtrVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FrustumPtrVectorRef(Pointer p) { super(p); }
    public FrustumPtrVectorRef(Frustum ... array) { this(array.length); put(array); }
    public FrustumPtrVectorRef()       { allocate();  }
    public FrustumPtrVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef FrustumPtrVectorRef put(@ByRef FrustumPtrVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native Frustum get(@Cast("size_t") long i);
    public native FrustumPtrVectorRef put(@Cast("size_t") long i, Frustum value);

    public FrustumPtrVectorRef put(Frustum ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::GpuProgramParameters::AutoConstantEntry>") public static class AutoConstantEntryVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AutoConstantEntryVectorRef(Pointer p) { super(p); }
    public AutoConstantEntryVectorRef(AutoConstantEntry ... array) { this(array.length); put(array); }
    public AutoConstantEntryVectorRef()       { allocate();  }
    public AutoConstantEntryVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef AutoConstantEntryVectorRef put(@ByRef AutoConstantEntryVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef AutoConstantEntry get(@Cast("size_t") long i);
    public native AutoConstantEntryVectorRef put(@Cast("size_t") long i, AutoConstantEntry value);

    public AutoConstantEntryVectorRef put(AutoConstantEntry ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::GpuSharedParametersUsage>") public static class GpuSharedParametersUsageVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GpuSharedParametersUsageVectorRef(Pointer p) { super(p); }
    public GpuSharedParametersUsageVectorRef(GpuSharedParametersUsage ... array) { this(array.length); put(array); }
    public GpuSharedParametersUsageVectorRef()       { allocate();  }
    public GpuSharedParametersUsageVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef GpuSharedParametersUsageVectorRef put(@ByRef GpuSharedParametersUsageVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef GpuSharedParametersUsage get(@Cast("size_t") long i);
    public native GpuSharedParametersUsageVectorRef put(@Cast("size_t") long i, GpuSharedParametersUsage value);

    public GpuSharedParametersUsageVectorRef put(GpuSharedParametersUsage ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::IdString>") public static class IdStringVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IdStringVectorRef(Pointer p) { super(p); }
    public IdStringVectorRef(IdString ... array) { this(array.length); put(array); }
    public IdStringVectorRef()       { allocate();  }
    public IdStringVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef IdStringVectorRef put(@ByRef IdStringVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef IdString get(@Cast("size_t") long i);
    public native IdStringVectorRef put(@Cast("size_t") long i, IdString value);

    public IdStringVectorRef put(IdString ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::InstancedEntity*>") public static class InstancedEntityPtrVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public InstancedEntityPtrVectorRef(Pointer p) { super(p); }
    public InstancedEntityPtrVectorRef(InstancedEntity ... array) { this(array.length); put(array); }
    public InstancedEntityPtrVectorRef()       { allocate();  }
    public InstancedEntityPtrVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef InstancedEntityPtrVectorRef put(@ByRef InstancedEntityPtrVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native InstancedEntity get(@Cast("size_t") long i);
    public native InstancedEntityPtrVectorRef put(@Cast("size_t") long i, InstancedEntity value);

    public InstancedEntityPtrVectorRef put(InstancedEntity ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::KeyFrameRig>") public static class KeyFrameRigVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public KeyFrameRigVectorRef(Pointer p) { super(p); }
    public KeyFrameRigVectorRef(KeyFrameRig ... array) { this(array.length); put(array); }
    public KeyFrameRigVectorRef()       { allocate();  }
    public KeyFrameRigVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef KeyFrameRigVectorRef put(@ByRef KeyFrameRigVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef KeyFrameRig get(@Cast("size_t") long i);
    public native KeyFrameRigVectorRef put(@Cast("size_t") long i, KeyFrameRig value);

    public KeyFrameRigVectorRef put(KeyFrameRig ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::ObjectMemoryManager*>") public static class ObjectMemoryManagerPtrVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ObjectMemoryManagerPtrVectorRef(Pointer p) { super(p); }
    public ObjectMemoryManagerPtrVectorRef(ObjectMemoryManager ... array) { this(array.length); put(array); }
    public ObjectMemoryManagerPtrVectorRef()       { allocate();  }
    public ObjectMemoryManagerPtrVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef ObjectMemoryManagerPtrVectorRef put(@ByRef ObjectMemoryManagerPtrVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native ObjectMemoryManager get(@Cast("size_t") long i);
    public native ObjectMemoryManagerPtrVectorRef put(@Cast("size_t") long i, ObjectMemoryManager value);

    public ObjectMemoryManagerPtrVectorRef put(ObjectMemoryManager ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::ParameterDef>") public static class ParameterDefVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ParameterDefVectorRef(Pointer p) { super(p); }
    public ParameterDefVectorRef(ParameterDef ... array) { this(array.length); put(array); }
    public ParameterDefVectorRef()       { allocate();  }
    public ParameterDefVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef ParameterDefVectorRef put(@ByRef ParameterDefVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef ParameterDef get(@Cast("size_t") long i);
    public native ParameterDefVectorRef put(@Cast("size_t") long i, ParameterDef value);

    public ParameterDefVectorRef put(ParameterDef ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::Plane>") public static class PlaneVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PlaneVectorRef(Pointer p) { super(p); }
    public PlaneVectorRef(Plane ... array) { this(array.length); put(array); }
    public PlaneVectorRef()       { allocate();  }
    public PlaneVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef PlaneVectorRef put(@ByRef PlaneVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef Plane get(@Cast("size_t") long i);
    public native PlaneVectorRef put(@Cast("size_t") long i, Plane value);

    public PlaneVectorRef put(Plane ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::PlaneBoundedVolume>") public static class PlaneBoundedVolumeVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PlaneBoundedVolumeVectorRef(Pointer p) { super(p); }
    public PlaneBoundedVolumeVectorRef(PlaneBoundedVolume ... array) { this(array.length); put(array); }
    public PlaneBoundedVolumeVectorRef()       { allocate();  }
    public PlaneBoundedVolumeVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef PlaneBoundedVolumeVectorRef put(@ByRef PlaneBoundedVolumeVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef PlaneBoundedVolume get(@Cast("size_t") long i);
    public native PlaneBoundedVolumeVectorRef put(@Cast("size_t") long i, PlaneBoundedVolume value);

    public PlaneBoundedVolumeVectorRef put(PlaneBoundedVolume ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::Plugin*>") public static class PluginPtrVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PluginPtrVectorRef(Pointer p) { super(p); }
    public PluginPtrVectorRef(Plugin ... array) { this(array.length); put(array); }
    public PluginPtrVectorRef()       { allocate();  }
    public PluginPtrVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef PluginPtrVectorRef put(@ByRef PluginPtrVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native Plugin get(@Cast("size_t") long i);
    public native PluginPtrVectorRef put(@Cast("size_t") long i, Plugin value);

    public PluginPtrVectorRef put(Plugin ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::RaySceneQueryResultEntry>") public static class RaySceneQueryResultEntryVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RaySceneQueryResultEntryVectorRef(Pointer p) { super(p); }
    public RaySceneQueryResultEntryVectorRef(RaySceneQueryResultEntry ... array) { this(array.length); put(array); }
    public RaySceneQueryResultEntryVectorRef()       { allocate();  }
    public RaySceneQueryResultEntryVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef RaySceneQueryResultEntryVectorRef put(@ByRef RaySceneQueryResultEntryVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef RaySceneQueryResultEntry get(@Cast("size_t") long i);
    public native RaySceneQueryResultEntryVectorRef put(@Cast("size_t") long i, RaySceneQueryResultEntry value);

    public RaySceneQueryResultEntryVectorRef put(RaySceneQueryResultEntry ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::Real>") public static class RealVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RealVectorRef(Pointer p) { super(p); }
    public RealVectorRef(double ... array) { this(array.length); put(array); }
    public RealVectorRef()       { allocate();  }
    public RealVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef RealVectorRef put(@ByRef RealVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native double get(@Cast("size_t") long i);
    public native RealVectorRef put(@Cast("size_t") long i, double value);

    public RealVectorRef put(double ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::RenderSystem*>") public static class RenderSystemPtrVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RenderSystemPtrVectorRef(Pointer p) { super(p); }
    public RenderSystemPtrVectorRef(RenderSystem ... array) { this(array.length); put(array); }
    public RenderSystemPtrVectorRef()       { allocate();  }
    public RenderSystemPtrVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef RenderSystemPtrVectorRef put(@ByRef RenderSystemPtrVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native RenderSystem get(@Cast("size_t") long i);
    public native RenderSystemPtrVectorRef put(@Cast("size_t") long i, RenderSystem value);

    public RenderSystemPtrVectorRef put(RenderSystem ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::RenderTexture*>") public static class RenderTexturePtrVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RenderTexturePtrVectorRef(Pointer p) { super(p); }
    public RenderTexturePtrVectorRef(RenderTexture ... array) { this(array.length); put(array); }
    public RenderTexturePtrVectorRef()       { allocate();  }
    public RenderTexturePtrVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef RenderTexturePtrVectorRef put(@ByRef RenderTexturePtrVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @Cast("Ogre::RenderTexture*") RenderTexture get(@Cast("size_t") long i);
    public native RenderTexturePtrVectorRef put(@Cast("size_t") long i, RenderTexture value);

    public RenderTexturePtrVectorRef put(RenderTexture ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::RenderWindow*>") public static class RenderWindowPtrVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RenderWindowPtrVectorRef(Pointer p) { super(p); }
    public RenderWindowPtrVectorRef(RenderWindow ... array) { this(array.length); put(array); }
    public RenderWindowPtrVectorRef()       { allocate();  }
    public RenderWindowPtrVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef RenderWindowPtrVectorRef put(@ByRef RenderWindowPtrVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native RenderWindow get(@Cast("size_t") long i);
    public native RenderWindowPtrVectorRef put(@Cast("size_t") long i, RenderWindow value);

    public RenderWindowPtrVectorRef put(RenderWindow ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::RenderWindowDescription>") public static class RenderWindowDescriptionVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RenderWindowDescriptionVectorRef(Pointer p) { super(p); }
    public RenderWindowDescriptionVectorRef(RenderWindowDescription ... array) { this(array.length); put(array); }
    public RenderWindowDescriptionVectorRef()       { allocate();  }
    public RenderWindowDescriptionVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef RenderWindowDescriptionVectorRef put(@ByRef RenderWindowDescriptionVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef RenderWindowDescription get(@Cast("size_t") long i);
    public native RenderWindowDescriptionVectorRef put(@Cast("size_t") long i, RenderWindowDescription value);

    public RenderWindowDescriptionVectorRef put(RenderWindowDescription ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::ShadowTextureConfig>") public static class ShadowTextureConfigVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ShadowTextureConfigVectorRef(Pointer p) { super(p); }
    public ShadowTextureConfigVectorRef(ShadowTextureConfig ... array) { this(array.length); put(array); }
    public ShadowTextureConfigVectorRef()       { allocate();  }
    public ShadowTextureConfigVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef ShadowTextureConfigVectorRef put(@ByRef ShadowTextureConfigVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef ShadowTextureConfig get(@Cast("size_t") long i);
    public native ShadowTextureConfigVectorRef put(@Cast("size_t") long i, ShadowTextureConfig value);

    public ShadowTextureConfigVectorRef put(ShadowTextureConfig ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::SkeletonAnimation>") public static class SkeletonAnimationVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SkeletonAnimationVectorRef(Pointer p) { super(p); }
    public SkeletonAnimationVectorRef(SkeletonAnimation ... array) { this(array.length); put(array); }
    public SkeletonAnimationVectorRef()       { allocate();  }
    public SkeletonAnimationVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef SkeletonAnimationVectorRef put(@ByRef SkeletonAnimationVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef SkeletonAnimation get(@Cast("size_t") long i);
    public native SkeletonAnimationVectorRef put(@Cast("size_t") long i, SkeletonAnimation value);

    public SkeletonAnimationVectorRef put(SkeletonAnimation ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::String>") public static class StringVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringVectorRef(Pointer p) { super(p); }
    public StringVectorRef(String ... array) { this(array.length); put(array); }
    public StringVectorRef()       { allocate();  }
    public StringVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef StringVectorRef put(@ByRef StringVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef String get(@Cast("size_t") long i);
    public native StringVectorRef put(@Cast("size_t") long i, String value);

    public StringVectorRef put(String ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::TexturePtr>") public static class TexturePtrVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TexturePtrVectorRef(Pointer p) { super(p); }
    public TexturePtrVectorRef(TexturePtr ... array) { this(array.length); put(array); }
    public TexturePtrVectorRef()       { allocate();  }
    public TexturePtrVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef TexturePtrVectorRef put(@ByRef TexturePtrVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef TexturePtr get(@Cast("size_t") long i);
    public native TexturePtrVectorRef put(@Cast("size_t") long i, TexturePtr value);

    public TexturePtrVectorRef put(TexturePtr ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::ThreadHandlePtr>") public static class ThreadHandlePtrVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ThreadHandlePtrVectorRef(Pointer p) { super(p); }
    public ThreadHandlePtrVectorRef(ThreadHandlePtr ... array) { this(array.length); put(array); }
    public ThreadHandlePtrVectorRef()       { allocate();  }
    public ThreadHandlePtrVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef ThreadHandlePtrVectorRef put(@ByRef ThreadHandlePtrVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef ThreadHandlePtr get(@Cast("size_t") long i);
    public native ThreadHandlePtrVectorRef put(@Cast("size_t") long i, ThreadHandlePtr value);

    public ThreadHandlePtrVectorRef put(ThreadHandlePtr ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::uint>") public static class UintVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public UintVectorRef(Pointer p) { super(p); }
    public UintVectorRef(uint ... array) { this(array.length); put(array); }
    public UintVectorRef()       { allocate();  }
    public UintVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef UintVectorRef put(@ByRef UintVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef uint get(@Cast("size_t") long i);
    public native UintVectorRef put(@Cast("size_t") long i, uint value);

    public UintVectorRef put(uint ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::ushort>") public static class UshortVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public UshortVectorRef(Pointer p) { super(p); }
    public UshortVectorRef(short ... array) { this(array.length); put(array); }
    public UshortVectorRef()       { allocate();  }
    public UshortVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef UshortVectorRef put(@ByRef UshortVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native short get(@Cast("size_t") long i);
    public native UshortVectorRef put(@Cast("size_t") long i, short value);

    public UshortVectorRef put(short ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::v1::EdgeData::Edge>") public static class EdgeVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public EdgeVectorRef(Pointer p) { super(p); }
    public EdgeVectorRef(Edge ... array) { this(array.length); put(array); }
    public EdgeVectorRef()       { allocate();  }
    public EdgeVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef EdgeVectorRef put(@ByRef EdgeVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef Edge get(@Cast("size_t") long i);
    public native EdgeVectorRef put(@Cast("size_t") long i, Edge value);

    public EdgeVectorRef put(Edge ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::v1::EdgeData::EdgeGroup>") public static class EdgeGroupVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public EdgeGroupVectorRef(Pointer p) { super(p); }
    public EdgeGroupVectorRef(EdgeGroup ... array) { this(array.length); put(array); }
    public EdgeGroupVectorRef()       { allocate();  }
    public EdgeGroupVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef EdgeGroupVectorRef put(@ByRef EdgeGroupVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef EdgeGroup get(@Cast("size_t") long i);
    public native EdgeGroupVectorRef put(@Cast("size_t") long i, EdgeGroup value);

    public EdgeGroupVectorRef put(EdgeGroup ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::v1::EdgeData::Triangle>") public static class TriangleVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TriangleVectorRef(Pointer p) { super(p); }
    public TriangleVectorRef(Triangle ... array) { this(array.length); put(array); }
    public TriangleVectorRef()       { allocate();  }
    public TriangleVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef TriangleVectorRef put(@ByRef TriangleVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef Triangle get(@Cast("size_t") long i);
    public native TriangleVectorRef put(@Cast("size_t") long i, Triangle value);

    public TriangleVectorRef put(Triangle ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::v1::HardwareBuffer::Usage>") public static class HardwareBufferUsageVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public HardwareBufferUsageVectorRef(Pointer p) { super(p); }
    public HardwareBufferUsageVectorRef(Usage ... array) { this(array.length); put(array); }
    public HardwareBufferUsageVectorRef()       { allocate();  }
    public HardwareBufferUsageVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef HardwareBufferUsageVectorRef put(@ByRef HardwareBufferUsageVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef Usage get(@Cast("size_t") long i);
    public native HardwareBufferUsageVectorRef put(@Cast("size_t") long i, Usage value);

    public HardwareBufferUsageVectorRef put(Usage ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::v1::NodeAnimationTrack*>") public static class NodeAnimationTrackPtrVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public NodeAnimationTrackPtrVectorRef(Pointer p) { super(p); }
    public NodeAnimationTrackPtrVectorRef(NodeAnimationTrack ... array) { this(array.length); put(array); }
    public NodeAnimationTrackPtrVectorRef()       { allocate();  }
    public NodeAnimationTrackPtrVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef NodeAnimationTrackPtrVectorRef put(@ByRef NodeAnimationTrackPtrVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native NodeAnimationTrack get(@Cast("size_t") long i);
    public native NodeAnimationTrackPtrVectorRef put(@Cast("size_t") long i, NodeAnimationTrack value);

    public NodeAnimationTrackPtrVectorRef put(NodeAnimationTrack ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::v1::StaticGeometry::SubMeshLodGeometryLink>") public static class SubMeshLodGeometryLinkVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SubMeshLodGeometryLinkVectorRef(Pointer p) { super(p); }
    public SubMeshLodGeometryLinkVectorRef(SubMeshLodGeometryLink ... array) { this(array.length); put(array); }
    public SubMeshLodGeometryLinkVectorRef()       { allocate();  }
    public SubMeshLodGeometryLinkVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef SubMeshLodGeometryLinkVectorRef put(@ByRef SubMeshLodGeometryLinkVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef SubMeshLodGeometryLink get(@Cast("size_t") long i);
    public native SubMeshLodGeometryLinkVectorRef put(@Cast("size_t") long i, SubMeshLodGeometryLink value);

    public SubMeshLodGeometryLinkVectorRef put(SubMeshLodGeometryLink ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::v1::VertexData::HardwareAnimationData>") public static class HardwareAnimationDataVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public HardwareAnimationDataVectorRef(Pointer p) { super(p); }
    public HardwareAnimationDataVectorRef(HardwareAnimationData ... array) { this(array.length); put(array); }
    public HardwareAnimationDataVectorRef()       { allocate();  }
    public HardwareAnimationDataVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef HardwareAnimationDataVectorRef put(@ByRef HardwareAnimationDataVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef HardwareAnimationData get(@Cast("size_t") long i);
    public native HardwareAnimationDataVectorRef put(@Cast("size_t") long i, HardwareAnimationData value);

    public HardwareAnimationDataVectorRef put(HardwareAnimationData ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::v1::VertexPoseKeyFrame::PoseRef>") public static class PoseRefVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PoseRefVectorRef(Pointer p) { super(p); }
    public PoseRefVectorRef(PoseRef ... array) { this(array.length); put(array); }
    public PoseRefVectorRef()       { allocate();  }
    public PoseRefVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef PoseRefVectorRef put(@ByRef PoseRefVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef PoseRef get(@Cast("size_t") long i);
    public native PoseRefVectorRef put(@Cast("size_t") long i, PoseRef value);

    public PoseRefVectorRef put(PoseRef ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::Vector3>") public static class Vector3VectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Vector3VectorRef(Pointer p) { super(p); }
    public Vector3VectorRef(Vector3 ... array) { this(array.length); put(array); }
    public Vector3VectorRef()       { allocate();  }
    public Vector3VectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef Vector3VectorRef put(@ByRef Vector3VectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef Vector3 get(@Cast("size_t") long i);
    public native Vector3VectorRef put(@Cast("size_t") long i, Vector3 value);

    public Vector3VectorRef put(Vector3 ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::Vector4>") public static class Vector4VectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Vector4VectorRef(Pointer p) { super(p); }
    public Vector4VectorRef(Vector4 ... array) { this(array.length); put(array); }
    public Vector4VectorRef()       { allocate();  }
    public Vector4VectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef Vector4VectorRef put(@ByRef Vector4VectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef Vector4 get(@Cast("size_t") long i);
    public native Vector4VectorRef put(@Cast("size_t") long i, Vector4 value);

    public Vector4VectorRef put(Vector4 ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::VertexBufferPacked*>") public static class VertexBufferPackedPtrVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VertexBufferPackedPtrVectorRef(Pointer p) { super(p); }
    public VertexBufferPackedPtrVectorRef(VertexBufferPacked ... array) { this(array.length); put(array); }
    public VertexBufferPackedPtrVectorRef()       { allocate();  }
    public VertexBufferPackedPtrVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef VertexBufferPackedPtrVectorRef put(@ByRef VertexBufferPackedPtrVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native VertexBufferPacked get(@Cast("size_t") long i);
    public native VertexBufferPackedPtrVectorRef put(@Cast("size_t") long i, VertexBufferPacked value);

    public VertexBufferPackedPtrVectorRef put(VertexBufferPacked ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::VertexElement2>") public static class VertexElement2VectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VertexElement2VectorRef(Pointer p) { super(p); }
    public VertexElement2VectorRef(VertexElement2 ... array) { this(array.length); put(array); }
    public VertexElement2VectorRef()       { allocate();  }
    public VertexElement2VectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef VertexElement2VectorRef put(@ByRef VertexElement2VectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef VertexElement2 get(@Cast("size_t") long i);
    public native VertexElement2VectorRef put(@Cast("size_t") long i, VertexElement2 value);

    public VertexElement2VectorRef put(VertexElement2 ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<Ogre::VertexElement2Vec>") public static class VertexElement2VecVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VertexElement2VecVectorRef(Pointer p) { super(p); }
    public VertexElement2VecVectorRef(VertexElement2Vec ... array) { this(array.length); put(array); }
    public VertexElement2VecVectorRef()       { allocate();  }
    public VertexElement2VecVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef VertexElement2VecVectorRef put(@ByRef VertexElement2VecVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef VertexElement2Vec get(@Cast("size_t") long i);
    public native VertexElement2VecVectorRef put(@Cast("size_t") long i, VertexElement2Vec value);

    public VertexElement2VecVectorRef put(VertexElement2Vec ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<size_t>") public static class SizeVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SizeVectorRef(Pointer p) { super(p); }
    public SizeVectorRef(long ... array) { this(array.length); put(array); }
    public SizeVectorRef()       { allocate();  }
    public SizeVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef SizeVectorRef put(@ByRef SizeVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @Cast("size_t") long get(@Cast("size_t") long i);
    public native SizeVectorRef put(@Cast("size_t") long i, long value);

    public SizeVectorRef put(long ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<std::pair<Ogre::String,Ogre::String> >") public static class StringPairVectorRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringPairVectorRef(Pointer p) { super(p); }
    public StringPairVectorRef(String[] firstValue, String[] secondValue) { this(Math.min(firstValue.length, secondValue.length)); put(firstValue, secondValue); }
    public StringPairVectorRef()       { allocate();  }
    public StringPairVectorRef(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef StringPairVectorRef put(@ByRef StringPairVectorRef x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef String first(@Cast("size_t") long i); public native StringPairVectorRef first(@Cast("size_t") long i, String first);
    @Index public native @ByRef String second(@Cast("size_t") long i);  public native StringPairVectorRef second(@Cast("size_t") long i, String second);

    public StringPairVectorRef put(String[] firstValue, String[] secondValue) {
        for (int i = 0; i < firstValue.length && i < secondValue.length; i++) {
            first(i, firstValue[i]);
            second(i, secondValue[i]);
        }
        return this;
    }
}

@NoOffset @Name("std::pair<bool,Ogre::Real>") public static class RealPairRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RealPairRef(Pointer p) { super(p); }
    public RealPairRef(boolean firstValue, double secondValue) { this(); put(firstValue, secondValue); }
    public RealPairRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef RealPairRef put(@ByRef RealPairRef x);


    @MemberGetter public native boolean first(); public native RealPairRef first(boolean first);
    @MemberGetter public native double second();  public native RealPairRef second(double second);

    public RealPairRef put(boolean firstValue, double secondValue) {
        first(firstValue);
        second(secondValue);
        return this;
    }
}

@NoOffset @Name("std::pair<size_t,size_t>") public static class SizetPairRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SizetPairRef(Pointer p) { super(p); }
    public SizetPairRef(long firstValue, long secondValue) { this(); put(firstValue, secondValue); }
    public SizetPairRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef SizetPairRef put(@ByRef SizetPairRef x);


    @MemberGetter public native long first(); public native SizetPairRef first(long first);
    @MemberGetter public native @Cast("size_t") long second();  public native SizetPairRef second(long second);

    public SizetPairRef put(long firstValue, long secondValue) {
        first(firstValue);
        second(secondValue);
        return this;
    }
}

@NoOffset @Name("std::pair<bool,Ogre::ResourcePtr>") public static class ResourcePtrPairRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ResourcePtrPairRef(Pointer p) { super(p); }
    public ResourcePtrPairRef(boolean firstValue, ResourcePtr secondValue) { this(); put(firstValue, secondValue); }
    public ResourcePtrPairRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef ResourcePtrPairRef put(@ByRef ResourcePtrPairRef x);


    @MemberGetter public native boolean first(); public native ResourcePtrPairRef first(boolean first);
    @MemberGetter public native @ByRef ResourcePtr second();  public native ResourcePtrPairRef second(ResourcePtr second);

    public ResourcePtrPairRef put(boolean firstValue, ResourcePtr secondValue) {
        first(firstValue);
        second(secondValue);
        return this;
    }
}

@Name("std::unordered_map<Ogre::String,ushort>") public static class SUshortUnorderedMapRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SUshortUnorderedMapRef(Pointer p) { super(p); }
    public SUshortUnorderedMapRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef SUshortUnorderedMapRef put(@ByRef SUshortUnorderedMapRef x);

    public native long size();

    @Index public native @ByRef ushort get(String i);
    public native SUshortUnorderedMapRef put(String i, ushort value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter String first();
        public native @Name("operator*().second") @MemberGetter @ByRef ushort second();
    }
}

@Name("std::unordered_map<unsigned int,Ogre::String>") public static class StringUnorderedMapRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringUnorderedMapRef(Pointer p) { super(p); }
    public StringUnorderedMapRef()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef StringUnorderedMapRef put(@ByRef StringUnorderedMapRef x);

    public native long size();

    @Index public native @ByRef String get(int i);
    public native StringUnorderedMapRef put(int i, String value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter int first();
        public native @Name("operator*().second") @MemberGetter @ByRef String second();
    }
}

// Parsed from OgreHeader.hpp



    @Namespace("Ogre") @Opaque public static class ArchiveFactory extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public ArchiveFactory() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ArchiveFactory(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class AsyncTicket extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public AsyncTicket() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public AsyncTicket(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class Barrier extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public Barrier() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Barrier(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class BufferInterface extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public BufferInterface() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public BufferInterface(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class CbBase extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public CbBase() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public CbBase(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class CbDrawCallIndexed extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public CbDrawCallIndexed() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public CbDrawCallIndexed(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class CbDrawCallStrip extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public CbDrawCallStrip() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public CbDrawCallStrip(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class Codec extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public Codec() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Codec(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class CommandBuffer extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public CommandBuffer() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public CommandBuffer(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class ConfigDialog extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public ConfigDialog() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ConfigDialog(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class ConstBufferPacked extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public ConstBufferPacked() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ConstBufferPacked(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class DefaultWorkQueue extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public DefaultWorkQueue() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public DefaultWorkQueue(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class DepthBuffer extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public DepthBuffer() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public DepthBuffer(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class DynLib extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public DynLib() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public DynLib(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class DynLibManager extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public DynLibManager() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public DynLibManager(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class ErrorDialog extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public ErrorDialog() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ErrorDialog(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class ExternalTextureSourceManager extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public ExternalTextureSourceManager() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ExternalTextureSourceManager(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class Factory extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public Factory() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Factory(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class Forward3D extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public Forward3D() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Forward3D(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class GpuProgramUsage extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public GpuProgramUsage() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public GpuProgramUsage(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class Hlms extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public Hlms() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Hlms(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class HlmsBlendblock extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public HlmsBlendblock() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HlmsBlendblock(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class HlmsCache extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public HlmsCache() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HlmsCache(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class HlmsDatablock extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public HlmsDatablock() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HlmsDatablock(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class HlmsListener extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public HlmsListener() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HlmsListener(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class HlmsLowLevel extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public HlmsLowLevel() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HlmsLowLevel(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class HlmsLowLevelDatablock extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public HlmsLowLevelDatablock() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HlmsLowLevelDatablock(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class HlmsMacroblock extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public HlmsMacroblock() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HlmsMacroblock(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class HlmsManager extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public HlmsManager() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HlmsManager(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class HlmsSamplerblock extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public HlmsSamplerblock() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HlmsSamplerblock(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class HlmsTextureManager extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public HlmsTextureManager() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HlmsTextureManager(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class HlmsTexturePack extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public HlmsTexturePack() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HlmsTexturePack(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class IndirectBufferPacked extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public IndirectBufferPacked() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public IndirectBufferPacked(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class InstanceBatchHW extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public InstanceBatchHW() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public InstanceBatchHW(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class InstanceBatchHW_VTF extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public InstanceBatchHW_VTF() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public InstanceBatchHW_VTF(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class InstanceBatchShader extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public InstanceBatchShader() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public InstanceBatchShader(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class InstanceBatchVTF extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public InstanceBatchVTF() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public InstanceBatchVTF(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class Item extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public Item() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Item(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class LodStrategyManager extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public LodStrategyManager() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public LodStrategyManager(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class MemoryManager extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public MemoryManager() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MemoryManager(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class MultiSourceVertexBufferPool extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public MultiSourceVertexBufferPool() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MultiSourceVertexBufferPool(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class ParticleAffectorFactory extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public ParticleAffectorFactory() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ParticleAffectorFactory(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class ParticleEmitterFactory extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public ParticleEmitterFactory() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ParticleEmitterFactory(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class ParticleSystemRenderer extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public ParticleSystemRenderer() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ParticleSystemRenderer(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class ParticleSystemRendererFactory extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public ParticleSystemRendererFactory() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ParticleSystemRendererFactory(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class Plugin extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public Plugin() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Plugin(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class RenderPriorityGroup extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public RenderPriorityGroup() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderPriorityGroup(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class RenderSystemCapabilitiesManager extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public RenderSystemCapabilitiesManager() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderSystemCapabilitiesManager(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class RenderSystemCapabilitiesSerializer extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public RenderSystemCapabilitiesSerializer() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderSystemCapabilitiesSerializer(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class ScriptCompiler extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public ScriptCompiler() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ScriptCompiler(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class ScriptCompilerManager extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public ScriptCompilerManager() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ScriptCompilerManager(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class SkeletonDef extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public SkeletonDef() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SkeletonDef(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class SkeletonManager extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public SkeletonManager() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SkeletonManager(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class StagingBuffer extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public StagingBuffer() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public StagingBuffer(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class StreamSerialiser extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public StreamSerialiser() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public StreamSerialiser(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class SubItem extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public SubItem() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SubItem(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class TagPoint extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public TagPoint() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public TagPoint(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class TexBufferPacked extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public TexBufferPacked() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public TexBufferPacked(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class ExternalTextureSource extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public ExternalTextureSource() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ExternalTextureSource(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class WireBoundingBox extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public WireBoundingBox() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public WireBoundingBox(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class CompositorManager2 extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public CompositorManager2() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public CompositorManager2(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class CompositorWorkspace extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public CompositorWorkspace() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public CompositorWorkspace(Pointer p) { super(p); }
    }
        @Namespace("Ogre::v1") @Opaque public static class CbRenderOp extends Pointer {
            /** Empty constructor. Calls {@code super((Pointer)null)}. */
            public CbRenderOp() { super((Pointer)null); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CbRenderOp(Pointer p) { super(p); }
        }
        @Namespace("Ogre::v1") @Opaque public static class RenderToVertexBuffer extends Pointer {
            /** Empty constructor. Calls {@code super((Pointer)null)}. */
            public RenderToVertexBuffer() { super((Pointer)null); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public RenderToVertexBuffer(Pointer p) { super(p); }
        }
    

    @Name("Ogre::FastArray<Ogre::Ogre::Real>") @NoOffset public static class RealFastArrayRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RealFastArrayRef(Pointer p) { super(p); }
    

        public RealFastArrayRef() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native void swap( @Cast("Ogre::FastArray<Ogre::Ogre::Real>*") @ByRef RealFastArrayRef other );

        public RealFastArrayRef( @Cast("const Ogre::FastArray<Ogre::Ogre::Real>*") @ByRef RealFastArrayRef copy ) { super((Pointer)null); allocate(copy); }
        private native void allocate( @Cast("const Ogre::FastArray<Ogre::Ogre::Real>*") @ByRef RealFastArrayRef copy );

        public native @Name("operator =") void put( @Cast("const Ogre::FastArray<Ogre::Ogre::Real>*") @ByRef RealFastArrayRef copy );


        public RealFastArrayRef( @Cast("size_t") long reserveAmount ) { super((Pointer)null); allocate(reserveAmount); }
        private native void allocate( @Cast("size_t") long reserveAmount );


        public RealFastArrayRef( @Cast("size_t") long count, @Cast("const Ogre::Ogre::Real") float value ) { super((Pointer)null); allocate(count, value); }
        private native void allocate( @Cast("size_t") long count, @Cast("const Ogre::Ogre::Real") float value );

        public native @Cast("size_t") long size();
        public native @Cast("size_t") @Name("capacity") long _capacity();

        public native void push_back( @Cast("const Ogre::Ogre::Real") float val );

        public native void pop_back();

        public native @Cast("Ogre::FastArray<Ogre::Ogre::Real>::iterator") float insert( @Cast("Ogre::FastArray<Ogre::Ogre::Real>::iterator") float where, @Cast("const Ogre::Ogre::Real") float val );


        public native @Cast("Ogre::FastArray<Ogre::Ogre::Real>::iterator") float insertPOD( @Cast("Ogre::FastArray<Ogre::Ogre::Real>::iterator") float where, @Cast("Ogre::FastArray<Ogre::Ogre::Real>::const_iterator") float otherBegin, @Cast("Ogre::FastArray<Ogre::Ogre::Real>::const_iterator") float otherEnd );

        public native void appendPOD( @Cast("Ogre::FastArray<Ogre::Ogre::Real>::const_iterator") float otherBegin, @Cast("Ogre::FastArray<Ogre::Ogre::Real>::const_iterator") float otherEnd );

        public native @Cast("Ogre::FastArray<Ogre::Ogre::Real>::iterator") float erase( @Cast("Ogre::FastArray<Ogre::Ogre::Real>::iterator") float toErase );

        public native @Cast("Ogre::FastArray<Ogre::Ogre::Real>::iterator") float erase( @Cast("Ogre::FastArray<Ogre::Ogre::Real>::iterator") float first, @Cast("Ogre::FastArray<Ogre::Ogre::Real>::iterator") float last );

        public native @Cast("Ogre::FastArray<Ogre::Ogre::Real>::iterator") float erasePOD( @Cast("Ogre::FastArray<Ogre::Ogre::Real>::iterator") float first, @Cast("Ogre::FastArray<Ogre::Ogre::Real>::iterator") float last );

        public native void clear();

        public native @Cast("bool") boolean empty();

        public native void reserve( @Cast("size_t") long reserveAmount );

        public native void resize( @Cast("size_t") long newSize, @Cast("const Ogre::Ogre::Real") float value/*=T()*/ );
        public native void resize( @Cast("size_t") long newSize );

        public native @Cast("Ogre::Ogre::Real*") @ByRef @Name("operator []") FloatPointer get( @Cast("size_t") long idx );

        public native @Cast("Ogre::Ogre::Real*") @ByRef FloatPointer back();

        public native @Cast("Ogre::Ogre::Real*") @ByRef FloatPointer front();

        public native @Cast("Ogre::FastArray<Ogre::Ogre::Real>::iterator") float begin();
        public native @Cast("Ogre::FastArray<Ogre::Ogre::Real>::iterator") float end();
    }
    @Name("Ogre::FastArray<Ogre::SkeletonInstance*>") @NoOffset public static class SkeletonInstancePtrFastArrayRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SkeletonInstancePtrFastArrayRef(Pointer p) { super(p); }
    

        public SkeletonInstancePtrFastArrayRef() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native void swap( @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>*") @ByRef SkeletonInstancePtrFastArrayRef other );

        public SkeletonInstancePtrFastArrayRef( @Cast("const Ogre::FastArray<Ogre::SkeletonInstance*>*") @ByRef SkeletonInstancePtrFastArrayRef copy ) { super((Pointer)null); allocate(copy); }
        private native void allocate( @Cast("const Ogre::FastArray<Ogre::SkeletonInstance*>*") @ByRef SkeletonInstancePtrFastArrayRef copy );

        public native @Name("operator =") void put( @Cast("const Ogre::FastArray<Ogre::SkeletonInstance*>*") @ByRef SkeletonInstancePtrFastArrayRef copy );


        public SkeletonInstancePtrFastArrayRef( @Cast("size_t") long reserveAmount ) { super((Pointer)null); allocate(reserveAmount); }
        private native void allocate( @Cast("size_t") long reserveAmount );


        public SkeletonInstancePtrFastArrayRef( @Cast("size_t") long count, @ByPtrRef SkeletonInstance value ) { super((Pointer)null); allocate(count, value); }
        private native void allocate( @Cast("size_t") long count, @ByPtrRef SkeletonInstance value );

        public native @Cast("size_t") long size();
        public native @Cast("size_t") @Name("capacity") long _capacity();

        public native void push_back( @ByPtrRef SkeletonInstance val );

        public native void pop_back();

        public native @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::iterator") SkeletonInstance insert( @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::iterator") SkeletonInstance where, @ByPtrRef SkeletonInstance val );


        public native @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::iterator") SkeletonInstance insertPOD( @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::iterator") SkeletonInstance where, @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::const_iterator") SkeletonInstance otherBegin, @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::const_iterator") SkeletonInstance otherEnd );

        public native void appendPOD( @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::const_iterator") SkeletonInstance otherBegin, @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::const_iterator") SkeletonInstance otherEnd );

        public native @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::iterator") SkeletonInstance erase( @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::iterator") SkeletonInstance toErase );

        public native @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::iterator") SkeletonInstance erase( @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::iterator") SkeletonInstance first, @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::iterator") SkeletonInstance last );

        public native @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::iterator") SkeletonInstance erasePOD( @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::iterator") SkeletonInstance first, @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::iterator") SkeletonInstance last );

        public native void clear();

        public native @Cast("bool") boolean empty();

        public native void reserve( @Cast("size_t") long reserveAmount );

        public native void resize( @Cast("size_t") long newSize, @ByPtrRef SkeletonInstance value/*=T()*/ );
        public native void resize( @Cast("size_t") long newSize );

        public native @ByPtrRef @Name("operator []") SkeletonInstance get( @Cast("size_t") long idx );

        public native @ByPtrRef SkeletonInstance back();

        public native @ByPtrRef SkeletonInstance front();

        public native @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::iterator") SkeletonInstance begin();
        public native @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>::iterator") SkeletonInstance end();
    }
    @Name("Ogre::FastArray<size_t>") @NoOffset public static class SizeFastArrayRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SizeFastArrayRef(Pointer p) { super(p); }
    

        public SizeFastArrayRef() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native void swap( @Cast("Ogre::FastArray<size_t>*") @ByRef SizeFastArrayRef other );

        public SizeFastArrayRef( @Cast("const Ogre::FastArray<size_t>*") @ByRef SizeFastArrayRef copy ) { super((Pointer)null); allocate(copy); }
        private native void allocate( @Cast("const Ogre::FastArray<size_t>*") @ByRef SizeFastArrayRef copy );

        public native @Name("operator =") void put( @Cast("const Ogre::FastArray<size_t>*") @ByRef SizeFastArrayRef copy );


        public SizeFastArrayRef( @Cast("size_t") long reserveAmount ) { super((Pointer)null); allocate(reserveAmount); }
        private native void allocate( @Cast("size_t") long reserveAmount );


        public SizeFastArrayRef( @Cast("size_t") long count, @Cast("const size_t") long value ) { super((Pointer)null); allocate(count, value); }
        private native void allocate( @Cast("size_t") long count, @Cast("const size_t") long value );

        public native @Cast("size_t") long size();
        public native @Cast("size_t") @Name("capacity") long _capacity();

        public native void push_back( @Cast("const size_t") long val );

        public native void pop_back();

        public native @Cast("Ogre::FastArray<size_t>::iterator") long insert( @Cast("Ogre::FastArray<size_t>::iterator") long where, @Cast("const size_t") long val );


        public native @Cast("Ogre::FastArray<size_t>::iterator") long insertPOD( @Cast("Ogre::FastArray<size_t>::iterator") long where, @Cast("Ogre::FastArray<size_t>::const_iterator") long otherBegin, @Cast("Ogre::FastArray<size_t>::const_iterator") long otherEnd );

        public native void appendPOD( @Cast("Ogre::FastArray<size_t>::const_iterator") long otherBegin, @Cast("Ogre::FastArray<size_t>::const_iterator") long otherEnd );

        public native @Cast("Ogre::FastArray<size_t>::iterator") long erase( @Cast("Ogre::FastArray<size_t>::iterator") long toErase );

        public native @Cast("Ogre::FastArray<size_t>::iterator") long erase( @Cast("Ogre::FastArray<size_t>::iterator") long first, @Cast("Ogre::FastArray<size_t>::iterator") long last );

        public native @Cast("Ogre::FastArray<size_t>::iterator") long erasePOD( @Cast("Ogre::FastArray<size_t>::iterator") long first, @Cast("Ogre::FastArray<size_t>::iterator") long last );

        public native void clear();

        public native @Cast("bool") boolean empty();

        public native void reserve( @Cast("size_t") long reserveAmount );

        public native void resize( @Cast("size_t") long newSize, @Cast("const size_t") long value/*=T()*/ );
        public native void resize( @Cast("size_t") long newSize );

        public native @Cast("size_t*") @ByRef @Name("operator []") SizeTPointer get( @Cast("size_t") long idx );

        public native @Cast("size_t*") @ByRef SizeTPointer back();

        public native @Cast("size_t*") @ByRef SizeTPointer front();

        public native @Cast("Ogre::FastArray<size_t>::iterator") long begin();
        public native @Cast("Ogre::FastArray<size_t>::iterator") long end();
    }
    @Name("Ogre::FastArray<unsigned char>") @NoOffset public static class ByteFastArrayRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ByteFastArrayRef(Pointer p) { super(p); }
    

        public ByteFastArrayRef() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native void swap( @Cast("Ogre::FastArray<unsigned char>*") @ByRef ByteFastArrayRef other );

        public ByteFastArrayRef( @Cast("const Ogre::FastArray<unsigned char>*") @ByRef ByteFastArrayRef copy ) { super((Pointer)null); allocate(copy); }
        private native void allocate( @Cast("const Ogre::FastArray<unsigned char>*") @ByRef ByteFastArrayRef copy );

        public native @Name("operator =") void put( @Cast("const Ogre::FastArray<unsigned char>*") @ByRef ByteFastArrayRef copy );


        public ByteFastArrayRef( @Cast("size_t") long reserveAmount ) { super((Pointer)null); allocate(reserveAmount); }
        private native void allocate( @Cast("size_t") long reserveAmount );


        public ByteFastArrayRef( @Cast("size_t") long count, @Cast("const unsigned char") byte value ) { super((Pointer)null); allocate(count, value); }
        private native void allocate( @Cast("size_t") long count, @Cast("const unsigned char") byte value );

        public native @Cast("size_t") long size();
        public native @Cast("size_t") @Name("capacity") long _capacity();

        public native void push_back( @Cast("const unsigned char") byte val );

        public native void pop_back();

        public native @Cast("Ogre::FastArray<unsigned char>::iterator") byte insert( @Cast("Ogre::FastArray<unsigned char>::iterator") byte where, @Cast("const unsigned char") byte val );


        public native @Cast("Ogre::FastArray<unsigned char>::iterator") byte insertPOD( @Cast("Ogre::FastArray<unsigned char>::iterator") byte where, @Cast("Ogre::FastArray<unsigned char>::const_iterator") byte otherBegin, @Cast("Ogre::FastArray<unsigned char>::const_iterator") byte otherEnd );

        public native void appendPOD( @Cast("Ogre::FastArray<unsigned char>::const_iterator") byte otherBegin, @Cast("Ogre::FastArray<unsigned char>::const_iterator") byte otherEnd );

        public native @Cast("Ogre::FastArray<unsigned char>::iterator") byte erase( @Cast("Ogre::FastArray<unsigned char>::iterator") byte toErase );

        public native @Cast("Ogre::FastArray<unsigned char>::iterator") byte erase( @Cast("Ogre::FastArray<unsigned char>::iterator") byte first, @Cast("Ogre::FastArray<unsigned char>::iterator") byte last );

        public native @Cast("Ogre::FastArray<unsigned char>::iterator") byte erasePOD( @Cast("Ogre::FastArray<unsigned char>::iterator") byte first, @Cast("Ogre::FastArray<unsigned char>::iterator") byte last );

        public native void clear();

        public native @Cast("bool") boolean empty();

        public native void reserve( @Cast("size_t") long reserveAmount );

        public native void resize( @Cast("size_t") long newSize, @Cast("const unsigned char") byte value/*=T()*/ );
        public native void resize( @Cast("size_t") long newSize );

        public native @Cast("unsigned char*") @ByRef @Name("operator []") BytePointer get( @Cast("size_t") long idx );

        public native @Cast("unsigned char*") @ByRef BytePointer back();

        public native @Cast("unsigned char*") @ByRef BytePointer front();

        public native @Cast("Ogre::FastArray<unsigned char>::iterator") byte begin();
        public native @Cast("Ogre::FastArray<unsigned char>::iterator") byte end();
    }
    @Name("Ogre::FastArray<unsigned short>") @NoOffset public static class UshortFastArrayRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public UshortFastArrayRef(Pointer p) { super(p); }
    

        public UshortFastArrayRef() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native void swap( @Cast("Ogre::FastArray<unsigned short>*") @ByRef UshortFastArrayRef other );

        public UshortFastArrayRef( @Cast("const Ogre::FastArray<unsigned short>*") @ByRef UshortFastArrayRef copy ) { super((Pointer)null); allocate(copy); }
        private native void allocate( @Cast("const Ogre::FastArray<unsigned short>*") @ByRef UshortFastArrayRef copy );

        public native @Name("operator =") void put( @Cast("const Ogre::FastArray<unsigned short>*") @ByRef UshortFastArrayRef copy );


        public UshortFastArrayRef( @Cast("size_t") long reserveAmount ) { super((Pointer)null); allocate(reserveAmount); }
        private native void allocate( @Cast("size_t") long reserveAmount );


        public UshortFastArrayRef( @Cast("size_t") long count, @Cast("const unsigned short") short value ) { super((Pointer)null); allocate(count, value); }
        private native void allocate( @Cast("size_t") long count, @Cast("const unsigned short") short value );

        public native @Cast("size_t") long size();
        public native @Cast("size_t") @Name("capacity") long _capacity();

        public native void push_back( @Cast("const unsigned short") short val );

        public native void pop_back();

        public native @Cast("Ogre::FastArray<unsigned short>::iterator") short insert( @Cast("Ogre::FastArray<unsigned short>::iterator") short where, @Cast("const unsigned short") short val );


        public native @Cast("Ogre::FastArray<unsigned short>::iterator") short insertPOD( @Cast("Ogre::FastArray<unsigned short>::iterator") short where, @Cast("Ogre::FastArray<unsigned short>::const_iterator") short otherBegin, @Cast("Ogre::FastArray<unsigned short>::const_iterator") short otherEnd );

        public native void appendPOD( @Cast("Ogre::FastArray<unsigned short>::const_iterator") short otherBegin, @Cast("Ogre::FastArray<unsigned short>::const_iterator") short otherEnd );

        public native @Cast("Ogre::FastArray<unsigned short>::iterator") short erase( @Cast("Ogre::FastArray<unsigned short>::iterator") short toErase );

        public native @Cast("Ogre::FastArray<unsigned short>::iterator") short erase( @Cast("Ogre::FastArray<unsigned short>::iterator") short first, @Cast("Ogre::FastArray<unsigned short>::iterator") short last );

        public native @Cast("Ogre::FastArray<unsigned short>::iterator") short erasePOD( @Cast("Ogre::FastArray<unsigned short>::iterator") short first, @Cast("Ogre::FastArray<unsigned short>::iterator") short last );

        public native void clear();

        public native @Cast("bool") boolean empty();

        public native void reserve( @Cast("size_t") long reserveAmount );

        public native void resize( @Cast("size_t") long newSize, @Cast("const unsigned short") short value/*=T()*/ );
        public native void resize( @Cast("size_t") long newSize );

        public native @Cast("unsigned short*") @ByRef @Name("operator []") ShortPointer get( @Cast("size_t") long idx );

        public native @Cast("unsigned short*") @ByRef ShortPointer back();

        public native @Cast("unsigned short*") @ByRef ShortPointer front();

        public native @Cast("Ogre::FastArray<unsigned short>::iterator") short begin();
        public native @Cast("Ogre::FastArray<unsigned short>::iterator") short end();
    }







    /** enum Ogre::MemoryCategory */
    public static final int

        MEMCATEGORY_GENERAL = 0,

        MEMCATEGORY_GEOMETRY = 1,

        MEMCATEGORY_ANIMATION = 2,

        MEMCATEGORY_SCENE_CONTROL = 3,

        MEMCATEGORY_SCENE_OBJECTS = 4,

        MEMCATEGORY_RESOURCE = 5,

        MEMCATEGORY_SCRIPTING = 6,

        MEMCATEGORY_RENDERSYS = 7,



        MEMCATEGORY_COUNT = 8;










    @Namespace("Ogre") public static class NedPoolingImpl extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public NedPoolingImpl() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public NedPoolingImpl(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public NedPoolingImpl(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public NedPoolingImpl position(long position) {
            return (NedPoolingImpl)super.position(position);
        }
    
        public static native Pointer allocBytes(@Cast("size_t") long count,
                    @Cast("const char*") BytePointer file, int line, @Cast("const char*") BytePointer func);
        public static native Pointer allocBytes(@Cast("size_t") long count,
                    String file, int line, String func);
        public static native void deallocBytes(Pointer ptr);
        public static native Pointer allocBytesAligned(@Cast("size_t") long align, @Cast("size_t") long count,
                    @Cast("const char*") BytePointer file, int line, @Cast("const char*") BytePointer func);
        public static native Pointer allocBytesAligned(@Cast("size_t") long align, @Cast("size_t") long count,
                    String file, int line, String func);
        public static native void deallocBytesAligned(@Cast("size_t") long align, Pointer ptr);

    }
    @Namespace("Ogre") public static class NedPoolingPolicy extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public NedPoolingPolicy(Pointer p) { super(p); }
    
        public static native Pointer allocateBytes(@Cast("size_t") long count,
                    @Cast("const char*") BytePointer file/*=0*/, int line/*=0*/, @Cast("const char*") BytePointer func/*=0*/);
        public static native Pointer allocateBytes(@Cast("size_t") long count);
        public static native Pointer allocateBytes(@Cast("size_t") long count,
                    String file/*=0*/, int line/*=0*/, String func/*=0*/);
        public static native void deallocateBytes(Pointer ptr);

        public static native @Cast("size_t") long getMaxAllocationSize();
    }



















@Name("Ogre::IteratorWrapper<Ogre::Material::Techniques,Ogre::Material::Techniques::iterator,Ogre::Material::Techniques::value_type>") @NoOffset public static class TechniquesVectorIteratorWrapperBaseRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TechniquesVectorIteratorWrapperBaseRef(Pointer p) { super(p); }







        public TechniquesVectorIteratorWrapperBaseRef( @ByVal iterator start, @ByVal iterator last ) { super((Pointer)null); allocate(start, last); }
        private native void allocate( @ByVal iterator start, @ByVal iterator last );



        public native @Cast("bool") boolean hasMoreElements( );



        public native void moveNext( );


        public native @Const @ByRef iterator begin();



        public native @ByRef iterator current();


        public native @Const @ByRef iterator end();


}
@Name("Ogre::IteratorWrapper<Ogre::v1::VertexPoseKeyFrame::PoseRefList,Ogre::v1::VertexPoseKeyFrame::PoseRefList::iterator,Ogre::v1::VertexPoseKeyFrame::value_type>") @NoOffset public static class PoseRefListVectorIteratorBaseRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PoseRefListVectorIteratorBaseRef(Pointer p) { super(p); }







        public PoseRefListVectorIteratorBaseRef( @ByVal iterator start, @ByVal iterator last ) { super((Pointer)null); allocate(start, last); }
        private native void allocate( @ByVal iterator start, @ByVal iterator last );



        public native @Cast("bool") boolean hasMoreElements( );



        public native void moveNext( );


        public native @Const @ByRef iterator begin();



        public native @ByRef iterator current();


        public native @Const @ByRef iterator end();


}
@Name("Ogre::IteratorWrapper<Ogre::ArchiveManager::ArchiveMap,Ogre::ArchiveManager::ArchiveMap::iterator,Ogre::ArchiveManager::ArchiveMap::value_type>") @NoOffset public static class ArchiveMapIteratorBaseRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ArchiveMapIteratorBaseRef(Pointer p) { super(p); }







        public ArchiveMapIteratorBaseRef( @ByVal iterator start, @ByVal iterator last ) { super((Pointer)null); allocate(start, last); }
        private native void allocate( @ByVal iterator start, @ByVal iterator last );



        public native @Cast("bool") boolean hasMoreElements( );



        public native void moveNext( );


        public native @Const @ByRef iterator begin();



        public native @ByRef iterator current();


        public native @Const @ByRef iterator end();


}
@Name("Ogre::IteratorWrapper<Ogre::ConfigFile::SettingsBySection,Ogre::ConfigFile::SettingsBySection::iterator,Ogre::ConfigFile::SettingsBySection::value_type>") @NoOffset public static class SettingsBySectionIteratorBaseRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SettingsBySectionIteratorBaseRef(Pointer p) { super(p); }







        public SettingsBySectionIteratorBaseRef( @ByVal iterator start, @ByVal iterator last ) { super((Pointer)null); allocate(start, last); }
        private native void allocate( @ByVal iterator start, @ByVal iterator last );



        public native @Cast("bool") boolean hasMoreElements( );



        public native void moveNext( );


        public native @Const @ByRef iterator begin();



        public native @ByRef iterator current();


        public native @Const @ByRef iterator end();


}
@Name("Ogre::IteratorWrapper<Ogre::ConfigFile::SettingsMultiMap,Ogre::ConfigFile::SettingsMultiMap::iterator,Ogre::ConfigFile::SettingsMultiMap::value_type>") @NoOffset public static class SettingsMultiMapIteratorBaseRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SettingsMultiMapIteratorBaseRef(Pointer p) { super(p); }







        public SettingsMultiMapIteratorBaseRef( @ByVal iterator start, @ByVal iterator last ) { super((Pointer)null); allocate(start, last); }
        private native void allocate( @ByVal iterator start, @ByVal iterator last );



        public native @Cast("bool") boolean hasMoreElements( );



        public native void moveNext( );


        public native @Const @ByRef iterator begin();



        public native @ByRef iterator current();


        public native @Const @ByRef iterator end();


}
@Name("Ogre::VectorIteratorWrapper<Ogre::Material::Techniques,Ogre::Material::Techniques::iterator>") public static class TechniquesVectorIteratorWrapperRef extends TechniquesVectorIteratorWrapperBaseRef {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TechniquesVectorIteratorWrapperRef(Pointer p) { super(p); }

        public TechniquesVectorIteratorWrapperRef( @ByVal iterator start, @ByVal iterator last ) { super((Pointer)null); allocate(start, last); }
        private native void allocate( @ByVal iterator start, @ByVal iterator last );



        public native @ByVal @Cast("Ogre::VectorIteratorWrapper<Ogre::Material::Techniques,Ogre::Material::Techniques::iterator>::ValueType*") Ogre::Material::Techniques::value_type peekNext( );


        public native @Cast("Ogre::VectorIteratorWrapper<Ogre::Material::Techniques,Ogre::Material::Techniques::iterator>::PointerType") Ogre::Material::Techniques::value_type peekNextPtr( );


        public native @ByVal @Cast("Ogre::VectorIteratorWrapper<Ogre::Material::Techniques,Ogre::Material::Techniques::iterator>::ValueType*") Ogre::Material::Techniques::value_type getNext( );

}
@Name("Ogre::VectorIteratorWrapper<Ogre::v1::VertexPoseKeyFrame::PoseRefList,Ogre::v1::VertexPoseKeyFrame::PoseRefList::iterator>") public static class PoseRefListVectorIteratorRef extends Ogre::IteratorWrapper<Ogre::v1::VertexPoseKeyFrame::PoseRefList,Ogre::v1::VertexPoseKeyFrame::PoseRefList::iterator,Ogre::v1::VertexPoseKeyFrame::PoseRefList::value_type> {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PoseRefListVectorIteratorRef(Pointer p) { super(p); }

        public PoseRefListVectorIteratorRef( @ByVal iterator start, @ByVal iterator last ) { super((Pointer)null); allocate(start, last); }
        private native void allocate( @ByVal iterator start, @ByVal iterator last );



        public native @ByVal @Cast("Ogre::VectorIteratorWrapper<Ogre::v1::VertexPoseKeyFrame::PoseRefList,Ogre::v1::VertexPoseKeyFrame::PoseRefList::iterator>::ValueType*") IteratorWrapper<Ogre::v1::VertexPoseKeyFrame::PoseRefList,Ogre::v1::VertexPoseKeyFrame::PoseRefList::iterator,Ogre::v1::VertexPoseKeyFrame::PoseRefList::value_type>::ValueType peekNext( );


        public native @ByVal @Cast("Ogre::VectorIteratorWrapper<Ogre::v1::VertexPoseKeyFrame::PoseRefList,Ogre::v1::VertexPoseKeyFrame::PoseRefList::iterator>::PointerType*") IteratorWrapper<Ogre::v1::VertexPoseKeyFrame::PoseRefList,Ogre::v1::VertexPoseKeyFrame::PoseRefList::iterator,Ogre::v1::VertexPoseKeyFrame::PoseRefList::value_type>::PointerType peekNextPtr( );


        public native @ByVal @Cast("Ogre::VectorIteratorWrapper<Ogre::v1::VertexPoseKeyFrame::PoseRefList,Ogre::v1::VertexPoseKeyFrame::PoseRefList::iterator>::ValueType*") IteratorWrapper<Ogre::v1::VertexPoseKeyFrame::PoseRefList,Ogre::v1::VertexPoseKeyFrame::PoseRefList::iterator,Ogre::v1::VertexPoseKeyFrame::PoseRefList::value_type>::ValueType getNext( );

}
@Name("Ogre::VectorIteratorWrapper<Ogre::NodeTrackList,Ogre::NodeTrackList::const_iterator>") public static class NodeTrackIteratorRef extends Ogre::IteratorWrapper<Ogre::NodeTrackList,Ogre::NodeTrackList::const_iterator,Ogre::NodeTrackList::value_type> {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public NodeTrackIteratorRef(Pointer p) { super(p); }

        public NodeTrackIteratorRef( @ByVal const_iterator start, @ByVal const_iterator last ) { super((Pointer)null); allocate(start, last); }
        private native void allocate( @ByVal const_iterator start, @ByVal const_iterator last );



        public native @ByVal @Cast("Ogre::VectorIteratorWrapper<Ogre::NodeTrackList,Ogre::NodeTrackList::const_iterator>::ValueType*") IteratorWrapper<Ogre::NodeTrackList,Ogre::NodeTrackList::const_iterator,Ogre::NodeTrackList::value_type>::ValueType peekNext( );


        public native @ByVal @Cast("Ogre::VectorIteratorWrapper<Ogre::NodeTrackList,Ogre::NodeTrackList::const_iterator>::PointerType*") IteratorWrapper<Ogre::NodeTrackList,Ogre::NodeTrackList::const_iterator,Ogre::NodeTrackList::value_type>::PointerType peekNextPtr( );


        public native @ByVal @Cast("Ogre::VectorIteratorWrapper<Ogre::NodeTrackList,Ogre::NodeTrackList::const_iterator>::ValueType*") IteratorWrapper<Ogre::NodeTrackList,Ogre::NodeTrackList::const_iterator,Ogre::NodeTrackList::value_type>::ValueType getNext( );

}
@Name("Ogre::VectorIterator<Ogre::Material::Techniques>") public static class TechniquesVectorIteratorRef extends TechniquesVectorIteratorWrapperRef {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TechniquesVectorIteratorRef(Pointer p) { super(p); }





        public TechniquesVectorIteratorRef( @ByVal iterator start, @ByVal iterator last ) { super((Pointer)null); allocate(start, last); }
        private native void allocate( @ByVal iterator start, @ByVal iterator last );





        public TechniquesVectorIteratorRef( @ByRef Techniques c ) { super((Pointer)null); allocate(c); }
        private native void allocate( @ByRef Techniques c );

}
@Name("Ogre::MapIteratorWrapper<Ogre::AnimationStateMap,Ogre::AnimationStateMap::iterator>") public static class AnimationStateMapIteratorRef extends Ogre::IteratorWrapper<Ogre::AnimationStateMap,Ogre::AnimationStateMap::iterator,Ogre::AnimationStateMap::mapped_type> {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AnimationStateMapIteratorRef(Pointer p) { super(p); }






        public AnimationStateMapIteratorRef( @ByVal iterator start, @ByVal iterator last ) { super((Pointer)null); allocate(start, last); }
        private native void allocate( @ByVal iterator start, @ByVal iterator last );


        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::AnimationStateMap,Ogre::AnimationStateMap::iterator>::KeyType*") Ogre::AnimationStateMap::key_type peekNextKey();



        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::AnimationStateMap,Ogre::AnimationStateMap::iterator>::ValueType*") IteratorWrapper<Ogre::AnimationStateMap,Ogre::AnimationStateMap::iterator,Ogre::AnimationStateMap::mapped_type>::ValueType peekNextValue( );




        public native @ByVal @Cast("const Ogre::MapIteratorWrapper<Ogre::AnimationStateMap,Ogre::AnimationStateMap::iterator>::PointerType*") IteratorWrapper<Ogre::AnimationStateMap,Ogre::AnimationStateMap::iterator,Ogre::AnimationStateMap::mapped_type>::PointerType peekNextValuePtr( );



        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::AnimationStateMap,Ogre::AnimationStateMap::iterator>::ValueType*") IteratorWrapper<Ogre::AnimationStateMap,Ogre::AnimationStateMap::iterator,Ogre::AnimationStateMap::mapped_type>::ValueType getNext();


}
@Name("Ogre::MapIteratorWrapper<Ogre::ArchiveManager::ArchiveMap,Ogre::ArchiveManager::ArchiveMap::iterator>") public static class ArchiveMapIteratorRef extends Ogre::IteratorWrapper<Ogre::ArchiveManager::ArchiveMap,Ogre::ArchiveManager::ArchiveMap::iterator,Ogre::ArchiveManager::ArchiveMap::mapped_type> {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ArchiveMapIteratorRef(Pointer p) { super(p); }






        public ArchiveMapIteratorRef( @ByVal iterator start, @ByVal iterator last ) { super((Pointer)null); allocate(start, last); }
        private native void allocate( @ByVal iterator start, @ByVal iterator last );


        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::ArchiveManager::ArchiveMap,Ogre::ArchiveManager::ArchiveMap::iterator>::KeyType*") Ogre::ArchiveManager::ArchiveMap::key_type peekNextKey();



        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::ArchiveManager::ArchiveMap,Ogre::ArchiveManager::ArchiveMap::iterator>::ValueType*") IteratorWrapper<Ogre::ArchiveManager::ArchiveMap,Ogre::ArchiveManager::ArchiveMap::iterator,Ogre::ArchiveManager::ArchiveMap::mapped_type>::ValueType peekNextValue( );




        public native @ByVal @Cast("const Ogre::MapIteratorWrapper<Ogre::ArchiveManager::ArchiveMap,Ogre::ArchiveManager::ArchiveMap::iterator>::PointerType*") IteratorWrapper<Ogre::ArchiveManager::ArchiveMap,Ogre::ArchiveManager::ArchiveMap::iterator,Ogre::ArchiveManager::ArchiveMap::mapped_type>::PointerType peekNextValuePtr( );



        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::ArchiveManager::ArchiveMap,Ogre::ArchiveManager::ArchiveMap::iterator>::ValueType*") IteratorWrapper<Ogre::ArchiveManager::ArchiveMap,Ogre::ArchiveManager::ArchiveMap::iterator,Ogre::ArchiveManager::ArchiveMap::mapped_type>::ValueType getNext();


}
@Name("Ogre::MapIteratorWrapper<Ogre::ConfigFile::SettingsBySection,Ogre::ConfigFile::SettingsBySection::iterator>") public static class SettingsBySectionIteratorRef extends Ogre::IteratorWrapper<Ogre::ConfigFile::SettingsBySection,Ogre::ConfigFile::SettingsBySection::iterator,Ogre::ConfigFile::SettingsBySection::mapped_type> {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SettingsBySectionIteratorRef(Pointer p) { super(p); }






        public SettingsBySectionIteratorRef( @ByVal iterator start, @ByVal iterator last ) { super((Pointer)null); allocate(start, last); }
        private native void allocate( @ByVal iterator start, @ByVal iterator last );


        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::ConfigFile::SettingsBySection,Ogre::ConfigFile::SettingsBySection::iterator>::KeyType*") Ogre::ConfigFile::SettingsBySection::key_type peekNextKey();



        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::ConfigFile::SettingsBySection,Ogre::ConfigFile::SettingsBySection::iterator>::ValueType*") IteratorWrapper<Ogre::ConfigFile::SettingsBySection,Ogre::ConfigFile::SettingsBySection::iterator,Ogre::ConfigFile::SettingsBySection::mapped_type>::ValueType peekNextValue( );




        public native @ByVal @Cast("const Ogre::MapIteratorWrapper<Ogre::ConfigFile::SettingsBySection,Ogre::ConfigFile::SettingsBySection::iterator>::PointerType*") IteratorWrapper<Ogre::ConfigFile::SettingsBySection,Ogre::ConfigFile::SettingsBySection::iterator,Ogre::ConfigFile::SettingsBySection::mapped_type>::PointerType peekNextValuePtr( );



        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::ConfigFile::SettingsBySection,Ogre::ConfigFile::SettingsBySection::iterator>::ValueType*") IteratorWrapper<Ogre::ConfigFile::SettingsBySection,Ogre::ConfigFile::SettingsBySection::iterator,Ogre::ConfigFile::SettingsBySection::mapped_type>::ValueType getNext();


}
@Name("Ogre::MapIteratorWrapper<Ogre::ConfigFile::SettingsMultiMap,Ogre::ConfigFile::SettingsMultiMap::iterator>") public static class SettingsMultiMapIteratorRef extends Ogre::IteratorWrapper<Ogre::ConfigFile::SettingsMultiMap,Ogre::ConfigFile::SettingsMultiMap::iterator,Ogre::ConfigFile::SettingsMultiMap::mapped_type> {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SettingsMultiMapIteratorRef(Pointer p) { super(p); }






        public SettingsMultiMapIteratorRef( @ByVal iterator start, @ByVal iterator last ) { super((Pointer)null); allocate(start, last); }
        private native void allocate( @ByVal iterator start, @ByVal iterator last );


        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::ConfigFile::SettingsMultiMap,Ogre::ConfigFile::SettingsMultiMap::iterator>::KeyType*") Ogre::ConfigFile::SettingsMultiMap::key_type peekNextKey();



        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::ConfigFile::SettingsMultiMap,Ogre::ConfigFile::SettingsMultiMap::iterator>::ValueType*") IteratorWrapper<Ogre::ConfigFile::SettingsMultiMap,Ogre::ConfigFile::SettingsMultiMap::iterator,Ogre::ConfigFile::SettingsMultiMap::mapped_type>::ValueType peekNextValue( );




        public native @ByVal @Cast("const Ogre::MapIteratorWrapper<Ogre::ConfigFile::SettingsMultiMap,Ogre::ConfigFile::SettingsMultiMap::iterator>::PointerType*") IteratorWrapper<Ogre::ConfigFile::SettingsMultiMap,Ogre::ConfigFile::SettingsMultiMap::iterator,Ogre::ConfigFile::SettingsMultiMap::mapped_type>::PointerType peekNextValuePtr( );



        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::ConfigFile::SettingsMultiMap,Ogre::ConfigFile::SettingsMultiMap::iterator>::ValueType*") IteratorWrapper<Ogre::ConfigFile::SettingsMultiMap,Ogre::ConfigFile::SettingsMultiMap::iterator,Ogre::ConfigFile::SettingsMultiMap::mapped_type>::ValueType getNext();


}
@Name("Ogre::MapIteratorWrapper<Ogre::NumericTrackList,Ogre::NumericTrackList::const_iterator>") public static class NumericTrackIteratorRef extends Ogre::IteratorWrapper<Ogre::NumericTrackList,Ogre::NumericTrackList::const_iterator,Ogre::NumericTrackList::mapped_type> {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public NumericTrackIteratorRef(Pointer p) { super(p); }






        public NumericTrackIteratorRef( @ByVal const_iterator start, @ByVal const_iterator last ) { super((Pointer)null); allocate(start, last); }
        private native void allocate( @ByVal const_iterator start, @ByVal const_iterator last );


        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::NumericTrackList,Ogre::NumericTrackList::const_iterator>::KeyType*") Ogre::NumericTrackList::key_type peekNextKey();



        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::NumericTrackList,Ogre::NumericTrackList::const_iterator>::ValueType*") IteratorWrapper<Ogre::NumericTrackList,Ogre::NumericTrackList::const_iterator,Ogre::NumericTrackList::mapped_type>::ValueType peekNextValue( );




        public native @ByVal @Cast("const Ogre::MapIteratorWrapper<Ogre::NumericTrackList,Ogre::NumericTrackList::const_iterator>::PointerType*") IteratorWrapper<Ogre::NumericTrackList,Ogre::NumericTrackList::const_iterator,Ogre::NumericTrackList::mapped_type>::PointerType peekNextValuePtr( );



        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::NumericTrackList,Ogre::NumericTrackList::const_iterator>::ValueType*") IteratorWrapper<Ogre::NumericTrackList,Ogre::NumericTrackList::const_iterator,Ogre::NumericTrackList::mapped_type>::ValueType getNext();


}
@Name("Ogre::MapIteratorWrapper<Ogre::OldNodeTrackList,Ogre::OldNodeTrackList::const_iterator>") public static class OldNodeTrackIteratorRef extends Ogre::IteratorWrapper<Ogre::OldNodeTrackList,Ogre::OldNodeTrackList::const_iterator,Ogre::OldNodeTrackList::mapped_type> {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OldNodeTrackIteratorRef(Pointer p) { super(p); }






        public OldNodeTrackIteratorRef( @ByVal const_iterator start, @ByVal const_iterator last ) { super((Pointer)null); allocate(start, last); }
        private native void allocate( @ByVal const_iterator start, @ByVal const_iterator last );


        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::OldNodeTrackList,Ogre::OldNodeTrackList::const_iterator>::KeyType*") Ogre::OldNodeTrackList::key_type peekNextKey();



        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::OldNodeTrackList,Ogre::OldNodeTrackList::const_iterator>::ValueType*") IteratorWrapper<Ogre::OldNodeTrackList,Ogre::OldNodeTrackList::const_iterator,Ogre::OldNodeTrackList::mapped_type>::ValueType peekNextValue( );




        public native @ByVal @Cast("const Ogre::MapIteratorWrapper<Ogre::OldNodeTrackList,Ogre::OldNodeTrackList::const_iterator>::PointerType*") IteratorWrapper<Ogre::OldNodeTrackList,Ogre::OldNodeTrackList::const_iterator,Ogre::OldNodeTrackList::mapped_type>::PointerType peekNextValuePtr( );



        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::OldNodeTrackList,Ogre::OldNodeTrackList::const_iterator>::ValueType*") IteratorWrapper<Ogre::OldNodeTrackList,Ogre::OldNodeTrackList::const_iterator,Ogre::OldNodeTrackList::mapped_type>::ValueType getNext();


}
@Name("Ogre::MapIteratorWrapper<Ogre::VertexTrackList,Ogre::VertexTrackList::const_iterator>") public static class VertexTrackIteratorRef extends Ogre::IteratorWrapper<Ogre::VertexTrackList,Ogre::VertexTrackList::const_iterator,Ogre::VertexTrackList::mapped_type> {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VertexTrackIteratorRef(Pointer p) { super(p); }






        public VertexTrackIteratorRef( @ByVal const_iterator start, @ByVal const_iterator last ) { super((Pointer)null); allocate(start, last); }
        private native void allocate( @ByVal const_iterator start, @ByVal const_iterator last );


        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::VertexTrackList,Ogre::VertexTrackList::const_iterator>::KeyType*") Ogre::VertexTrackList::key_type peekNextKey();



        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::VertexTrackList,Ogre::VertexTrackList::const_iterator>::ValueType*") IteratorWrapper<Ogre::VertexTrackList,Ogre::VertexTrackList::const_iterator,Ogre::VertexTrackList::mapped_type>::ValueType peekNextValue( );




        public native @ByVal @Cast("const Ogre::MapIteratorWrapper<Ogre::VertexTrackList,Ogre::VertexTrackList::const_iterator>::PointerType*") IteratorWrapper<Ogre::VertexTrackList,Ogre::VertexTrackList::const_iterator,Ogre::VertexTrackList::mapped_type>::PointerType peekNextValuePtr( );



        public native @ByVal @Cast("Ogre::MapIteratorWrapper<Ogre::VertexTrackList,Ogre::VertexTrackList::const_iterator>::ValueType*") IteratorWrapper<Ogre::VertexTrackList,Ogre::VertexTrackList::const_iterator,Ogre::VertexTrackList::mapped_type>::ValueType getNext();


}










// #pragma GCC diagnostic push



// #pragma GCC diagnostic ignored "-Wdocumentation"

// #pragma GCC diagnostic ignored "-Wshadow"
// #pragma GCC diagnostic ignored "-Wpadded"
// #pragma GCC diagnostic ignored "-Wweak-vtables"
// #pragma GCC diagnostic ignored "-Wall"
// #pragma GCC diagnostic ignored "-Wundef"





// #pragma GCC diagnostic pop




    @Namespace("Ogre") public static class PlatformInformation extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public PlatformInformation() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public PlatformInformation(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public PlatformInformation(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public PlatformInformation position(long position) {
            return (PlatformInformation)super.position(position);
        }
    


        /** enum Ogre::PlatformInformation::CpuFeatures */
        public static final int

            CPU_FEATURE_SSE =  1 << 0,
            CPU_FEATURE_SSE2 =  1 << 1,
            CPU_FEATURE_SSE3 =  1 << 2,
            CPU_FEATURE_MMX =  1 << 3,
            CPU_FEATURE_MMXEXT =  1 << 4,
            CPU_FEATURE_3DNOW =  1 << 5,
            CPU_FEATURE_3DNOWEXT =  1 << 6,
            CPU_FEATURE_CMOV =  1 << 7,
            CPU_FEATURE_TSC =  1 << 8,
            CPU_FEATURE_FPU =  1 << 9,
            CPU_FEATURE_PRO =  1 << 10,
            CPU_FEATURE_HTT =  1 << 11,







            CPU_FEATURE_NONE = 0;






        public static native @Const @ByRef String getCpuIdentifier();






        public static native @Cast("Ogre::uint") int getCpuFeatures();






        public static native @Cast("bool") boolean hasCpuFeature(@Cast("Ogre::PlatformInformation::CpuFeatures") int feature);





        public static native @Cast("Ogre::uint32") int getNumLogicalCores();



        public static native void log(Log pLog);

    }




    @Namespace("Ogre") public static native @Cast("Ogre::uint32") int FastHash(@Cast("const char*") BytePointer data, int len, @Cast("Ogre::uint32") int hashSoFar/*=0*/);
    @Namespace("Ogre") public static native @Cast("Ogre::uint32") int FastHash(@Cast("const char*") BytePointer data, int len);
    @Namespace("Ogre") public static native @Cast("Ogre::uint32") int FastHash(String data, int len, @Cast("Ogre::uint32") int hashSoFar/*=0*/);
    @Namespace("Ogre") public static native @Cast("Ogre::uint32") int FastHash(String data, int len);

    /** enum Ogre::VertexPass */
    public static final int
        VpNormal = 0,
        VpShadow = 1,
        NumVertexPass = 2;




    /** enum Ogre::CompareFunction */
    public static final int
        CMPF_ALWAYS_FAIL = 0,
        CMPF_ALWAYS_PASS = 1,
        CMPF_LESS = 2,
        CMPF_LESS_EQUAL = 3,
        CMPF_EQUAL = 4,
        CMPF_NOT_EQUAL = 5,
        CMPF_GREATER_EQUAL = 6,
        CMPF_GREATER = 7,
        NUM_COMPARE_FUNCTIONS = 8;


    /** enum Ogre::StencilOperation */
    public static final int

        SOP_KEEP = 0,

        SOP_ZERO = 1,

        SOP_REPLACE = 2,

        SOP_INCREMENT = 3,

        SOP_DECREMENT = 4,

        SOP_INCREMENT_WRAP = 5,

        SOP_DECREMENT_WRAP = 6,

        SOP_INVERT = 7;



    /** enum Ogre::TextureFilterOptions */
    public static final int

        TFO_NONE = 0,

        TFO_BILINEAR = 1,

        TFO_TRILINEAR = 2,

        TFO_ANISOTROPIC = 3;

    /** enum Ogre::FilterType */
    public static final int

        FT_MIN = 0,

        FT_MAG = 1,

        FT_MIP = 2;

    /** enum Ogre::FilterOptions */
    public static final int

        FO_NONE = 0,

        FO_POINT = 1,

        FO_LINEAR = 2,

        FO_ANISOTROPIC = 3;


    /** enum Ogre::ShadeOptions */
    public static final int
        SO_FLAT = 0,
        SO_GOURAUD = 1,
        SO_PHONG = 2;


    /** enum Ogre::FogMode */
    public static final int

        FOG_NONE = 0,

        FOG_EXP = 1,

        FOG_EXP2 = 2,

        FOG_LINEAR = 3;
    /** enum Ogre::CullingMode */
    public static final int

        CULL_NONE = 1,

        CULL_CLOCKWISE = 2,

        CULL_ANTICLOCKWISE = 3;


    /** enum Ogre::WaveformType */
    public static final int

        WFT_SINE = 0,

        WFT_TRIANGLE = 1,

        WFT_SQUARE = 2,

        WFT_SAWTOOTH = 3,

        WFT_INVERSE_SAWTOOTH = 4,


        WFT_PWM = 5;


    /** enum Ogre::PolygonMode */
    public static final int

        PM_POINTS = 1,

        PM_WIREFRAME = 2,

        PM_SOLID = 3;
    /** enum Ogre::TrackVertexColourEnum */
    public static final int
        TVC_NONE =  0x0,
        TVC_AMBIENT =  0x1,
        TVC_DIFFUSE =  0x2,
        TVC_SPECULAR =  0x4,
        TVC_EMISSIVE =  0x8;


    /** enum Ogre::SortMode */
    public static final int

        SM_DIRECTION = 0,

        SM_DISTANCE = 1;


    /** enum Ogre::FrameBufferType */
    public static final int
        FBT_COLOUR =  0x1,
        FBT_DEPTH =  0x2,
        FBT_STENCIL =  0x4;


    /** enum Ogre::ColourBufferType */
    public static final int
      CBT_BACK =  0x0,
      CBT_BACK_LEFT =  0x0 + 1,
      CBT_BACK_RIGHT =  0x0 + 2;


    /** enum Ogre::StereoModeType */
    public static final int
      SMT_NONE =  0x0,
      SMT_FRAME_SEQUENTIAL =  0x0 + 1;

    /** enum Ogre::ShaderType */
    public static final int
        VertexShader = 0,
        PixelShader = 1,
        GeometryShader = 2,
        HullShader = 3,
        DomainShader = 4,
        NumShaderTypes = 5;


    /** enum Ogre::InstanceManagerFlags */
    public static final int



        IM_USE16BIT =  0x0001,



        IM_VTFBESTFIT =  0x0002,



        IM_VTFBONEMATRIXLOOKUP =  0x0004,

        IM_USEBONEDUALQUATERNIONS =  0x0008,


        IM_USEONEWEIGHT =  0x0010,


        IM_FORCEONEWEIGHT =  0x0020,

        IM_USEALL =  IM_USE16BIT|IM_VTFBESTFIT|IM_USEONEWEIGHT;
    /** enum Ogre::SceneMemoryMgrTypes */
    public static final int
        SCENE_DYNAMIC = 0,
        SCENE_STATIC = 1,
        NUM_SCENE_MEMORY_MANAGER_TYPES = 2;


    @Namespace("Ogre") @NoOffset public static class LightClosest extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public LightClosest(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public LightClosest(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public LightClosest position(long position) {
            return (LightClosest)super.position(position);
        }
    
        public native @Const({false, true}) Light light(); public native LightClosest light(Light light);
        public native @Cast("size_t") long globalIndex(); public native LightClosest globalIndex(long globalIndex);
        public native double distance(); public native LightClosest distance(double distance);

        public LightClosest() { super((Pointer)null); allocate(); }
        private native void allocate();
        public LightClosest( Light _light, @Cast("size_t") long _globalIndex, double _distance ) { super((Pointer)null); allocate(_light, _globalIndex, _distance); }
        private native void allocate( Light _light, @Cast("size_t") long _globalIndex, double _distance );

        public native @Cast("bool") @Name("operator <") boolean lessThan( @Const @ByRef LightClosest right );
    }

    @Namespace("Ogre") @NoOffset public static class LightListInfo extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public LightListInfo(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public LightListInfo(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public LightListInfo position(long position) {
            return (LightListInfo)super.position(position);
        }
    
        public native @ByRef @Cast("Ogre::LightArray*") RealFastArrayRef lights(); public native LightListInfo lights(RealFastArrayRef lights);

        public native @Cast("Ogre::uint32*") IntPointer visibilityMask(); public native LightListInfo visibilityMask(IntPointer visibilityMask);
        public native Sphere boundingSphere(); public native LightListInfo boundingSphere(Sphere boundingSphere);

        public LightListInfo() { super((Pointer)null); allocate(); }
        private native void allocate();
    }


    @Namespace("Ogre") @MemberGetter public static native @Const @ByRef String BLANKSTRING();

        @Name("Ogre::TRect<float>") @NoOffset public static class FloatRectRef extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public FloatRectRef(Pointer p) { super(p); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public FloatRectRef(long size) { super((Pointer)null); allocateArray(size); }
            private native void allocateArray(long size);
            @Override public FloatRectRef position(long position) {
                return (FloatRectRef)super.position(position);
            }
        
          public native float left(); public native FloatRectRef left(float left);
          public native float top(); public native FloatRectRef top(float top);
          public native float right(); public native FloatRectRef right(float right);
          public native float bottom(); public native FloatRectRef bottom(float bottom);
          public FloatRectRef() { super((Pointer)null); allocate(); }
          private native void allocate();
          public FloatRectRef( @Const({false, true}) @ByRef FloatPointer l, @Const({false, true}) @ByRef FloatPointer t, @Const({false, true}) @ByRef FloatPointer r, @Const({false, true}) @ByRef FloatPointer b ) { super((Pointer)null); allocate(l, t, r, b); }
          private native void allocate( @Const({false, true}) @ByRef FloatPointer l, @Const({false, true}) @ByRef FloatPointer t, @Const({false, true}) @ByRef FloatPointer r, @Const({false, true}) @ByRef FloatPointer b );
          public FloatRectRef( @Const({false, true}) @ByRef FloatBuffer l, @Const({false, true}) @ByRef FloatBuffer t, @Const({false, true}) @ByRef FloatBuffer r, @Const({false, true}) @ByRef FloatBuffer b ) { super((Pointer)null); allocate(l, t, r, b); }
          private native void allocate( @Const({false, true}) @ByRef FloatBuffer l, @Const({false, true}) @ByRef FloatBuffer t, @Const({false, true}) @ByRef FloatBuffer r, @Const({false, true}) @ByRef FloatBuffer b );
          public FloatRectRef( @Const({false, true}) @ByRef float[] l, @Const({false, true}) @ByRef float[] t, @Const({false, true}) @ByRef float[] r, @Const({false, true}) @ByRef float[] b ) { super((Pointer)null); allocate(l, t, r, b); }
          private native void allocate( @Const({false, true}) @ByRef float[] l, @Const({false, true}) @ByRef float[] t, @Const({false, true}) @ByRef float[] r, @Const({false, true}) @ByRef float[] b );
          public FloatRectRef( @Cast("Ogre::TRect<float> const*") @ByRef FloatRectRef o ) { super((Pointer)null); allocate(o); }
          private native void allocate( @Cast("Ogre::TRect<float> const*") @ByRef FloatRectRef o );
          public native @Cast("Ogre::TRect<float>*") @ByRef @Name("operator =") FloatRectRef put( @Cast("Ogre::TRect<float> const*") @ByRef FloatRectRef o );
          public native float width();
          public native float height();
          public native @Cast("bool") boolean isNull();
          public native void setNull();
          public native @Cast("Ogre::TRect<float>*") @ByRef FloatRectRef merge(@Cast("const Ogre::TRect<float>*") @ByRef FloatRectRef rhs);
          public native @ByVal @Cast("Ogre::TRect<float>*") FloatRectRef intersect(@Cast("const Ogre::TRect<float>*") @ByRef FloatRectRef rhs);

        }

        @Name("Ogre::TRect") @NoOffset public static class TRectRef extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public TRectRef(Pointer p) { super(p); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public TRectRef(long size) { super((Pointer)null); allocateArray(size); }
            private native void allocateArray(long size);
            @Override public TRectRef position(long position) {
                return (TRectRef)super.position(position);
            }
        
          public native @Cast("Ogre::Ogre::Real") float left(); public native TRectRef left(float left);
          public native @Cast("Ogre::Ogre::Real") float top(); public native TRectRef top(float top);
          public native @Cast("Ogre::Ogre::Real") float right(); public native TRectRef right(float right);
          public native @Cast("Ogre::Ogre::Real") float bottom(); public native TRectRef bottom(float bottom);
          public TRectRef() { super((Pointer)null); allocate(); }
          private native void allocate();
          public TRectRef( @Cast("Ogre::Ogre::Real const*") @ByRef FloatPointer l, @Cast("Ogre::Ogre::Real const*") @ByRef FloatPointer t, @Cast("Ogre::Ogre::Real const*") @ByRef FloatPointer r, @Cast("Ogre::Ogre::Real const*") @ByRef FloatPointer b ) { super((Pointer)null); allocate(l, t, r, b); }
          private native void allocate( @Cast("Ogre::Ogre::Real const*") @ByRef FloatPointer l, @Cast("Ogre::Ogre::Real const*") @ByRef FloatPointer t, @Cast("Ogre::Ogre::Real const*") @ByRef FloatPointer r, @Cast("Ogre::Ogre::Real const*") @ByRef FloatPointer b );
          public TRectRef( @Cast("Ogre::Ogre::Real const*") @ByRef FloatBuffer l, @Cast("Ogre::Ogre::Real const*") @ByRef FloatBuffer t, @Cast("Ogre::Ogre::Real const*") @ByRef FloatBuffer r, @Cast("Ogre::Ogre::Real const*") @ByRef FloatBuffer b ) { super((Pointer)null); allocate(l, t, r, b); }
          private native void allocate( @Cast("Ogre::Ogre::Real const*") @ByRef FloatBuffer l, @Cast("Ogre::Ogre::Real const*") @ByRef FloatBuffer t, @Cast("Ogre::Ogre::Real const*") @ByRef FloatBuffer r, @Cast("Ogre::Ogre::Real const*") @ByRef FloatBuffer b );
          public TRectRef( @Cast("Ogre::Ogre::Real const*") @ByRef float[] l, @Cast("Ogre::Ogre::Real const*") @ByRef float[] t, @Cast("Ogre::Ogre::Real const*") @ByRef float[] r, @Cast("Ogre::Ogre::Real const*") @ByRef float[] b ) { super((Pointer)null); allocate(l, t, r, b); }
          private native void allocate( @Cast("Ogre::Ogre::Real const*") @ByRef float[] l, @Cast("Ogre::Ogre::Real const*") @ByRef float[] t, @Cast("Ogre::Ogre::Real const*") @ByRef float[] r, @Cast("Ogre::Ogre::Real const*") @ByRef float[] b );
          public TRectRef( @Cast("Ogre::TRect const*") @ByRef TRectRef o ) { super((Pointer)null); allocate(o); }
          private native void allocate( @Cast("Ogre::TRect const*") @ByRef TRectRef o );
          public native @Cast("Ogre::TRect*") @ByRef @Name("operator =") TRectRef put( @Cast("Ogre::TRect const*") @ByRef TRectRef o );
          public native @Cast("Ogre::Ogre::Real") float width();
          public native @Cast("Ogre::Ogre::Real") float height();
          public native @Cast("bool") boolean isNull();
          public native void setNull();
          public native @Cast("Ogre::TRect*") @ByRef TRectRef merge(@Cast("const Ogre::TRect*") @ByRef TRectRef rhs);
          public native @ByVal @Cast("Ogre::TRect*") TRectRef intersect(@Cast("const Ogre::TRect*") @ByRef TRectRef rhs);

        }

        @Name("Ogre::TRect<long>") @NoOffset public static class RectRef extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public RectRef(Pointer p) { super(p); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public RectRef(long size) { super((Pointer)null); allocateArray(size); }
            private native void allocateArray(long size);
            @Override public RectRef position(long position) {
                return (RectRef)super.position(position);
            }
        
          public native long left(); public native RectRef left(long left);
          public native long top(); public native RectRef top(long top);
          public native long right(); public native RectRef right(long right);
          public native long bottom(); public native RectRef bottom(long bottom);
          public RectRef() { super((Pointer)null); allocate(); }
          private native void allocate();
          public RectRef( @Const({false, true}) @ByRef CLongPointer l, @Const({false, true}) @ByRef CLongPointer t, @Const({false, true}) @ByRef CLongPointer r, @Const({false, true}) @ByRef CLongPointer b ) { super((Pointer)null); allocate(l, t, r, b); }
          private native void allocate( @Const({false, true}) @ByRef CLongPointer l, @Const({false, true}) @ByRef CLongPointer t, @Const({false, true}) @ByRef CLongPointer r, @Const({false, true}) @ByRef CLongPointer b );
          public RectRef( @Cast("Ogre::TRect<long> const*") @ByRef RectRef o ) { super((Pointer)null); allocate(o); }
          private native void allocate( @Cast("Ogre::TRect<long> const*") @ByRef RectRef o );
          public native @Cast("Ogre::TRect<long>*") @ByRef @Name("operator =") RectRef put( @Cast("Ogre::TRect<long> const*") @ByRef RectRef o );
          public native long width();
          public native long height();
          public native @Cast("bool") boolean isNull();
          public native void setNull();
          public native @Cast("Ogre::TRect<long>*") @ByRef RectRef merge(@Cast("const Ogre::TRect<long>*") @ByRef RectRef rhs);
          public native @ByVal @Cast("Ogre::TRect<long>*") RectRef intersect(@Cast("const Ogre::TRect<long>*") @ByRef RectRef rhs);

        }





        @Namespace("Ogre") @NoOffset public static class Box extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Box(Pointer p) { super(p); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public Box(long size) { super((Pointer)null); allocateArray(size); }
            private native void allocateArray(long size);
            @Override public Box position(long position) {
                return (Box)super.position(position);
            }
        
            public native @Cast("Ogre::uint32") int left(); public native Box left(int left);
            public native @Cast("Ogre::uint32") int top(); public native Box top(int top);
            public native @Cast("Ogre::uint32") int right(); public native Box right(int right);
            public native @Cast("Ogre::uint32") int bottom(); public native Box bottom(int bottom);
            public native @Cast("Ogre::uint32") int front(); public native Box front(int front);
            public native @Cast("Ogre::uint32") int back(); public native Box back(int back);

            public Box() { super((Pointer)null); allocate(); }
            private native void allocate();
            public Box( @Cast("Ogre::uint32") int l, @Cast("Ogre::uint32") int t, @Cast("Ogre::uint32") int r, @Cast("Ogre::uint32") int b ) { super((Pointer)null); allocate(l, t, r, b); }
            private native void allocate( @Cast("Ogre::uint32") int l, @Cast("Ogre::uint32") int t, @Cast("Ogre::uint32") int r, @Cast("Ogre::uint32") int b );
            public Box( @Cast("Ogre::uint32") int l, @Cast("Ogre::uint32") int t, @Cast("Ogre::uint32") int ff, @Cast("Ogre::uint32") int r, @Cast("Ogre::uint32") int b, @Cast("Ogre::uint32") int bb ) { super((Pointer)null); allocate(l, t, ff, r, b, bb); }
            private native void allocate( @Cast("Ogre::uint32") int l, @Cast("Ogre::uint32") int t, @Cast("Ogre::uint32") int ff, @Cast("Ogre::uint32") int r, @Cast("Ogre::uint32") int b, @Cast("Ogre::uint32") int bb );


            public native @Cast("bool") boolean contains(@Const @ByRef Box def);


            public native @Cast("Ogre::uint32") int getWidth();

            public native @Cast("Ogre::uint32") int getHeight();

            public native @Cast("Ogre::uint32") int getDepth();
        }
    @Namespace("Ogre") public static native int findCommandLineOpts(int numargs, @Cast("char**") PointerPointer argv, @Cast("Ogre::UnaryOptionList*") @ByRef SBoolUMapRef unaryOptList,
            @Cast("Ogre::BinaryOptionList*") @ByRef SStringMapRef binOptList);
    @Namespace("Ogre") public static native int findCommandLineOpts(int numargs, @Cast("char**") @ByPtrPtr BytePointer argv, @Cast("Ogre::UnaryOptionList*") @ByRef SBoolUMapRef unaryOptList,
            @Cast("Ogre::BinaryOptionList*") @ByRef SStringMapRef binOptList);
    @Namespace("Ogre") public static native int findCommandLineOpts(int numargs, @Cast("char**") @ByPtrPtr ByteBuffer argv, @Cast("Ogre::UnaryOptionList*") @ByRef SBoolUMapRef unaryOptList,
            @Cast("Ogre::BinaryOptionList*") @ByRef SStringMapRef binOptList);
    @Namespace("Ogre") public static native int findCommandLineOpts(int numargs, @Cast("char**") @ByPtrPtr byte[] argv, @Cast("Ogre::UnaryOptionList*") @ByRef SBoolUMapRef unaryOptList,
            @Cast("Ogre::BinaryOptionList*") @ByRef SStringMapRef binOptList);


    /** enum Ogre::ClipResult */
    public static final int

        CLIPPED_NONE = 0,

        CLIPPED_SOME = 1,

        CLIPPED_ALL = 2;


    @Namespace("Ogre") public static class RenderWindowDescription extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public RenderWindowDescription() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public RenderWindowDescription(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderWindowDescription(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public RenderWindowDescription position(long position) {
            return (RenderWindowDescription)super.position(position);
        }
    
        public native @ByRef String name(); public native RenderWindowDescription name(String name);
        public native @Cast("unsigned int") int width(); public native RenderWindowDescription width(int width);
        public native @Cast("unsigned int") int height(); public native RenderWindowDescription height(int height);
        public native @Cast("bool") boolean useFullScreen(); public native RenderWindowDescription useFullScreen(boolean useFullScreen);
        public native @ByRef @Cast("Ogre::NameValuePairList*") SStringMapRef miscParams(); public native RenderWindowDescription miscParams(SStringMapRef miscParams);
    }
    @Namespace("Ogre") public static native @Cast("size_t") long alignToNextMultiple( @Cast("size_t") long offset, @Cast("size_t") long alignment );




    @Namespace("Ogre") public static native float min( float left, float right );
    @Namespace("Ogre") public static native float max( float left, float right );
    @Namespace("Ogre") public static native double min( double left, double right );
    @Namespace("Ogre") public static native double max( double left, double right );

    @Namespace("Ogre") @NoOffset public static class Radian extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Radian(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Radian(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Radian position(long position) {
            return (Radian)super.position(position);
        }
    
        public Radian( double r/*=0*/ ) { super((Pointer)null); allocate(r); }
        private native void allocate( double r/*=0*/ );
        public Radian( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public Radian( @Const @ByRef Degree d ) { super((Pointer)null); allocate(d); }
        private native void allocate( @Const @ByRef Degree d );
        public native @ByRef @Name("operator =") Radian put( double f );
        public native @ByRef @Name("operator =") Radian put( @Const @ByRef Radian r );
        public native @ByRef @Name("operator =") Radian put( @Const @ByRef Degree d );

        public native double valueDegrees();
        public native double valueRadians();
        public native double valueAngleUnits();

        public native @Const @ByRef @Name("operator +") Radian add();
        public native @ByVal @Name("operator +") Radian add( @Const @ByRef Radian r );
        public native @ByVal @Name("operator +") Radian add( @Const @ByRef Degree d );
        public native @ByRef @Name("operator +=") Radian addPut( @Const @ByRef Radian r );
        public native @ByRef @Name("operator +=") Radian addPut( @Const @ByRef Degree d );
        public native @ByVal @Name("operator -") Radian subtract();
        public native @ByVal @Name("operator -") Radian subtract( @Const @ByRef Radian r );
        public native @ByVal @Name("operator -") Radian subtract( @Const @ByRef Degree d );
        public native @ByRef @Name("operator -=") Radian subtractPut( @Const @ByRef Radian r );
        public native @ByRef @Name("operator -=") Radian subtractPut( @Const @ByRef Degree d );
        public native @ByVal @Name("operator *") Radian multiply( double f );
        public native @ByVal @Name("operator *") Radian multiply( @Const @ByRef Radian f );
        public native @ByRef @Name("operator *=") Radian multiplyPut( double f );
        public native @ByVal @Name("operator /") Radian divide( double f );
        public native @ByRef @Name("operator /=") Radian dividePut( double f );

        public native @Cast("bool") @Name("operator <") boolean lessThan( @Const @ByRef Radian r );
        public native @Cast("bool") @Name("operator <=") boolean lessThanEquals( @Const @ByRef Radian r );
        public native @Cast("bool") @Name("operator ==") boolean equals( @Const @ByRef Radian r );
        public native @Cast("bool") @Name("operator !=") boolean notEquals( @Const @ByRef Radian r );
        public native @Cast("bool") @Name("operator >=") boolean greaterThanEquals( @Const @ByRef Radian r );
        public native @Cast("bool") @Name("operator >") boolean greaterThan( @Const @ByRef Radian r );

        
    }






    @Namespace("Ogre") @NoOffset public static class Degree extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Degree(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Degree(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Degree position(long position) {
            return (Degree)super.position(position);
        }
    
        public Degree( double d/*=0*/ ) { super((Pointer)null); allocate(d); }
        private native void allocate( double d/*=0*/ );
        public Degree( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public Degree( @Const @ByRef Radian r ) { super((Pointer)null); allocate(r); }
        private native void allocate( @Const @ByRef Radian r );
        public native @ByRef @Name("operator =") Degree put( double f );
        public native @ByRef @Name("operator =") Degree put( @Const @ByRef Degree d );
        public native @ByRef @Name("operator =") Degree put( @Const @ByRef Radian r );

        public native double valueDegrees();
        public native double valueRadians();
        public native double valueAngleUnits();

        public native @Const @ByRef @Name("operator +") Degree add();
        public native @ByVal @Name("operator +") Degree add( @Const @ByRef Degree d );
        public native @ByVal @Name("operator +") Degree add( @Const @ByRef Radian r );
        public native @ByRef @Name("operator +=") Degree addPut( @Const @ByRef Degree d );
        public native @ByRef @Name("operator +=") Degree addPut( @Const @ByRef Radian r );
        public native @ByVal @Name("operator -") Degree subtract();
        public native @ByVal @Name("operator -") Degree subtract( @Const @ByRef Degree d );
        public native @ByVal @Name("operator -") Degree subtract( @Const @ByRef Radian r );
        public native @ByRef @Name("operator -=") Degree subtractPut( @Const @ByRef Degree d );
        public native @ByRef @Name("operator -=") Degree subtractPut( @Const @ByRef Radian r );
        public native @ByVal @Name("operator *") Degree multiply( double f );
        public native @ByVal @Name("operator *") Degree multiply( @Const @ByRef Degree f );
        public native @ByRef @Name("operator *=") Degree multiplyPut( double f );
        public native @ByVal @Name("operator /") Degree divide( double f );
        public native @ByRef @Name("operator /=") Degree dividePut( double f );

        public native @Cast("bool") @Name("operator <") boolean lessThan( @Const @ByRef Degree d );
        public native @Cast("bool") @Name("operator <=") boolean lessThanEquals( @Const @ByRef Degree d );
        public native @Cast("bool") @Name("operator ==") boolean equals( @Const @ByRef Degree d );
        public native @Cast("bool") @Name("operator !=") boolean notEquals( @Const @ByRef Degree d );
        public native @Cast("bool") @Name("operator >=") boolean greaterThanEquals( @Const @ByRef Degree d );
        public native @Cast("bool") @Name("operator >") boolean greaterThan( @Const @ByRef Degree d );

        
    }







    @Namespace("Ogre") @NoOffset public static class Angle extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Angle(Pointer p) { super(p); }
    
        public Angle( double angle ) { super((Pointer)null); allocate(angle); }
        private native void allocate( double angle );
        public native @ByVal @Name("operator Ogre::Radian") Radian asRadian();
        public native @ByVal @Name("operator Ogre::Degree") Degree asDegree();
    }



    
    
    
    
    
    
    @Namespace("Ogre") @NoOffset public static class Math extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Math(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Math(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Math position(long position) {
            return (Math)super.position(position);
        }
    





       /** enum Ogre::Math::AngleUnit */
       public static final int
           AU_DEGREE = 0,
           AU_RADIAN = 1;




       public static class RandomValueProvider extends Pointer {
           static { Loader.load(); }
           /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
           public RandomValueProvider(Pointer p) { super(p); }
       

            public native double getRandomUnit();
       }





        public Math(@Cast("unsigned int") int trigTableSize/*=4096*/) { super((Pointer)null); allocate(trigTableSize); }
        private native void allocate(@Cast("unsigned int") int trigTableSize/*=4096*/);
        public Math() { super((Pointer)null); allocate(); }
        private native void allocate();

        public static native int IAbs(int iValue);
        public static native int ICeil(float fValue);
        public static native int IFloor(float fValue);
        public static native int ISign(int iValue);





        public static native double Abs(double fValue);





        public static native @ByVal Degree Abs(@Const @ByRef Degree dValue);





        public static native @ByVal Radian Abs(@Const @ByRef Radian rValue);





        public static native @ByVal Radian ACos(double fValue);





        public static native @ByVal Radian ASin(double fValue);





        public static native @ByVal Radian ATan(double fValue);







        public static native @ByVal Radian ATan2(double fY, double fX);







        public static native double Ceil(double fValue);
        public static native @Cast("bool") boolean isNaN(double f);
        public static native double Cos(@Const @ByRef Radian fValue, @Cast("bool") boolean useTables/*=false*/);
        public static native double Cos(@Const @ByRef Radian fValue);







        public static native double Cos(double fValue, @Cast("bool") boolean useTables/*=false*/);
        public static native double Cos(double fValue);

        public static native double Exp(double fValue);







        public static native double Floor(double fValue);

        public static native double Log(double fValue);


        @MemberGetter public static native double LOG2();
        public static final double LOG2 = LOG2();

        public static native double Log2(double fValue);

        public static native double LogN(double base, double fValue);

        public static native double Pow(double fBase, double fExponent);

        public static native double Sign(double fValue);
        public static native @ByVal Radian Sign( @Const @ByRef Radian rValue );
        public static native @ByVal Degree Sign( @Const @ByRef Degree dValue );


        public static native float saturate(float t);
        public static native double saturate(double t);
        public static native double Sin(@Const @ByRef Radian fValue, @Cast("bool") boolean useTables/*=false*/);
        public static native double Sin(@Const @ByRef Radian fValue);







        public static native double Sin(double fValue, @Cast("bool") boolean useTables/*=false*/);
        public static native double Sin(double fValue);





        public static native double Sqr(double fValue);





        public static native double Sqrt(double fValue);







        public static native @ByVal Radian Sqrt(@Const @ByRef Radian fValue);







        public static native @ByVal Degree Sqrt(@Const @ByRef Degree fValue);






        public static native double InvSqrt(double fValue);





        public static native double UnitRandom();
        public static native double RangeRandom(double fLow, double fHigh);





        public static native double SymmetricRandom();

        public static native void SetRandomValueProvider(RandomValueProvider provider);
        public static native double Tan(@Const @ByRef Radian fValue, @Cast("bool") boolean useTables/*=false*/);
        public static native double Tan(@Const @ByRef Radian fValue);







        public static native double Tan(double fValue, @Cast("bool") boolean useTables/*=false*/);
        public static native double Tan(double fValue);

        public static native double DegreesToRadians(double degrees);
        public static native double RadiansToDegrees(double radians);







       public static native void setAngleUnit(@Cast("Ogre::Math::AngleUnit") int unit);

       public static native @Cast("Ogre::Math::AngleUnit") int getAngleUnit();


       public static native double AngleUnitsToRadians(double units);

       public static native double RadiansToAngleUnits(double radians);

       public static native double AngleUnitsToDegrees(double units);

       public static native double DegreesToAngleUnits(double degrees);
        public static native @Cast("bool") boolean pointInTri2D(@Const @ByRef Vector2 p, @Const @ByRef Vector2 a,
                    @Const @ByRef Vector2 b, @Const @ByRef Vector2 c);
        public static native @Cast("bool") boolean pointInTri3D(@Const @ByRef Vector3 p, @Const @ByRef Vector3 a,
                    @Const @ByRef Vector3 b, @Const @ByRef Vector3 c, @Const @ByRef Vector3 normal);

        public static native @ByVal @Cast("std::pair<bool,Ogre::Real>*") RealPairRef intersects(@Const @ByRef Ray ray, @Const @ByRef Plane plane);


        public static native @ByVal @Cast("std::pair<bool,Ogre::Real>*") RealPairRef intersects(@Const @ByRef Ray ray, @Const @ByRef Sphere sphere,
                    @Cast("bool") boolean discardInside/*=true*/);
        public static native @ByVal @Cast("std::pair<bool,Ogre::Real>*") RealPairRef intersects(@Const @ByRef Ray ray, @Const @ByRef Sphere sphere);


        public static native @ByVal @Cast("std::pair<bool,Ogre::Real>*") RealPairRef intersects(@Const @ByRef Ray ray, @Const @ByRef AxisAlignedBox box);
        public static native @Cast("bool") boolean intersects(@Const @ByRef Ray ray, @Const @ByRef AxisAlignedBox box,
                    double d1, double d2);
        public static native @ByVal @Cast("std::pair<bool,Ogre::Real>*") RealPairRef intersects(@Const @ByRef Ray ray, @Const @ByRef Vector3 a,
                    @Const @ByRef Vector3 b, @Const @ByRef Vector3 c, @Const @ByRef Vector3 normal,
                    @Cast("bool") boolean positiveSide/*=true*/, @Cast("bool") boolean negativeSide/*=true*/);
        public static native @ByVal @Cast("std::pair<bool,Ogre::Real>*") RealPairRef intersects(@Const @ByRef Ray ray, @Const @ByRef Vector3 a,
                    @Const @ByRef Vector3 b, @Const @ByRef Vector3 c, @Const @ByRef Vector3 normal);
        public static native @ByVal @Cast("std::pair<bool,Ogre::Real>*") RealPairRef intersects(@Const @ByRef Ray ray, @Const @ByRef Vector3 a,
                    @Const @ByRef Vector3 b, @Const @ByRef Vector3 c,
                    @Cast("bool") boolean positiveSide/*=true*/, @Cast("bool") boolean negativeSide/*=true*/);
        public static native @ByVal @Cast("std::pair<bool,Ogre::Real>*") RealPairRef intersects(@Const @ByRef Ray ray, @Const @ByRef Vector3 a,
                    @Const @ByRef Vector3 b, @Const @ByRef Vector3 c);






        public static native @Cast("bool") boolean intersects(@Const @ByRef Sphere sphere, @Const @ByRef AxisAlignedBox box);


        public static native @Cast("bool") boolean intersects(@Const @ByRef Plane plane, @Const @ByRef AxisAlignedBox box);






        public static native @ByVal @Cast("std::pair<bool,Ogre::Real>*") RealPairRef intersects(
                    @Const @ByRef Ray ray, @Cast("const vector<Ogre::Plane>::type*") @ByRef PlaneVectorRef planeList,
                    @Cast("bool") boolean normalIsOutside);





        public static native @ByVal @Cast("std::pair<bool,Ogre::Real>*") RealPairRef intersects(
                    @Const @ByRef Ray ray, @Cast("const list<Ogre::Plane>::type*") @ByRef PlaneListRef planeList,
                    @Cast("bool") boolean normalIsOutside);




        public static native @Cast("bool") boolean intersects(@Const @ByRef Sphere sphere, @Const @ByRef Plane plane);



        public static native @Cast("bool") boolean RealEqual(double a, double b,
                    double tolerance/*=std::numeric_limits<Ogre::Real>::epsilon()*/);
        public static native @Cast("bool") boolean RealEqual(double a, double b);


        public static native @ByVal Vector3 calculateTangentSpaceVector(
                    @Const @ByRef Vector3 position1, @Const @ByRef Vector3 position2, @Const @ByRef Vector3 position3,
                    double u1, double v1, double u2, double v2, double u3, double v3);


        public static native @ByVal Matrix4 buildReflectionMatrix(@Const @ByRef Plane p);

        public static native @ByVal Vector4 calculateFaceNormal(@Const @ByRef Vector3 v1, @Const @ByRef Vector3 v2, @Const @ByRef Vector3 v3);

        public static native @ByVal Vector3 calculateBasicFaceNormal(@Const @ByRef Vector3 v1, @Const @ByRef Vector3 v2, @Const @ByRef Vector3 v3);

        public static native @ByVal Vector4 calculateFaceNormalWithoutNormalize(@Const @ByRef Vector3 v1, @Const @ByRef Vector3 v2, @Const @ByRef Vector3 v3);

        public static native @ByVal Vector3 calculateBasicFaceNormalWithoutNormalize(@Const @ByRef Vector3 v1, @Const @ByRef Vector3 v2, @Const @ByRef Vector3 v3);




        public static native double gaussianDistribution(double x, double offset/*=0.0f*/, double scale/*=1.0f*/);
        public static native double gaussianDistribution(double x);

        public static native @ByVal Matrix4 makeViewMatrix(@Const @ByRef Vector3 position, @Const @ByRef Quaternion orientation,
                    @Const Matrix4 reflectMatrix/*=0*/);
        public static native @ByVal Matrix4 makeViewMatrix(@Const @ByRef Vector3 position, @Const @ByRef Quaternion orientation);


        public static native double boundingRadiusFromAABB(@Const @ByRef AxisAlignedBox aabb);



        @MemberGetter public static native double POS_INFINITY();
        public static final double POS_INFINITY = POS_INFINITY();
        @MemberGetter public static native double NEG_INFINITY();
        public static final double NEG_INFINITY = NEG_INFINITY();
        @MemberGetter public static native double PI();
        public static final double PI = PI();
        @MemberGetter public static native double TWO_PI();
        public static final double TWO_PI = TWO_PI();
        @MemberGetter public static native double HALF_PI();
        public static final double HALF_PI = HALF_PI();
        @MemberGetter public static native double fDeg2Rad();
        public static final double fDeg2Rad = fDeg2Rad();
        @MemberGetter public static native double fRad2Deg();
        public static final double fRad2Deg = fRad2Deg();

    }

    
    




    

    

    

    

    

    

    @Namespace("Ogre") public static native @ByVal @Name("operator *") Radian multiply( double a, @Const @ByRef Radian b );

    @Namespace("Ogre") public static native @ByVal @Name("operator /") Radian divide( double a, @Const @ByRef Radian b );

    @Namespace("Ogre") public static native @ByVal @Name("operator *") Degree multiply( double a, @Const @ByRef Degree b );

    @Namespace("Ogre") public static native @ByVal @Name("operator /") Degree divide( double a, @Const @ByRef Degree b );



    @Namespace("Ogre") @NoOffset public static class Quaternion extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Quaternion(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Quaternion(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Quaternion position(long position) {
            return (Quaternion)super.position(position);
        }
    

        public Quaternion() { super((Pointer)null); allocate(); }
        private native void allocate();

        public Quaternion(
                    double fW,
                    double fX, double fY, double fZ) { super((Pointer)null); allocate(fW, fX, fY, fZ); }
        private native void allocate(
                    double fW,
                    double fX, double fY, double fZ);

        public Quaternion(@Const @ByRef Matrix3 rot) { super((Pointer)null); allocate(rot); }
        private native void allocate(@Const @ByRef Matrix3 rot);

        public Quaternion(@Const @ByRef Radian rfAngle, @Const @ByRef Vector3 rkAxis) { super((Pointer)null); allocate(rfAngle, rkAxis); }
        private native void allocate(@Const @ByRef Radian rfAngle, @Const @ByRef Vector3 rkAxis);

        public Quaternion(@Const @ByRef Vector3 xaxis, @Const @ByRef Vector3 yaxis, @Const @ByRef Vector3 zaxis) { super((Pointer)null); allocate(xaxis, yaxis, zaxis); }
        private native void allocate(@Const @ByRef Vector3 xaxis, @Const @ByRef Vector3 yaxis, @Const @ByRef Vector3 zaxis);

        public Quaternion(@Const Vector3 akAxis) { super((Pointer)null); allocate(akAxis); }
        private native void allocate(@Const Vector3 akAxis);

        public Quaternion(double valptr) { super((Pointer)null); allocate(valptr); }
        private native void allocate(double valptr);



        public native void swap(@ByRef Quaternion other);


        public native @Name("operator []") double get( @Cast("const size_t") long i );


        public native double ptr();

        public native void FromRotationMatrix(@Const @ByRef Matrix3 kRot);
        public native void ToRotationMatrix(@ByRef Matrix3 kRot);



        public native void FromAngleAxis(@Const @ByRef Radian rfAngle, @Const @ByRef Vector3 rkAxis);
        public native void ToAngleAxis(@ByRef Radian rfAngle, @ByRef Vector3 rkAxis);
        public native void ToAngleAxis(@ByRef Degree dAngle, @ByRef Vector3 rkAxis);



        public native void FromAxes(@Const Vector3 akAxis);
        public native void FromAxes(@Const @ByRef Vector3 xAxis, @Const @ByRef Vector3 yAxis, @Const @ByRef Vector3 zAxis);

        public native void ToAxes(Vector3 akAxis);
        public native void ToAxes(@ByRef Vector3 xAxis, @ByRef Vector3 yAxis, @ByRef Vector3 zAxis);




        public native @ByVal Vector3 xAxis();




        public native @ByVal Vector3 yAxis();




        public native @ByVal Vector3 zAxis();

        public native @ByRef @Name("operator =") Quaternion put(@Const @ByRef Quaternion rkQ);
        public native @ByVal @Name("operator +") Quaternion add(@Const @ByRef Quaternion rkQ);
        public native @ByVal @Name("operator -") Quaternion subtract(@Const @ByRef Quaternion rkQ);
        public native @ByVal @Name("operator *") Quaternion multiply(@Const @ByRef Quaternion rkQ);
        public native @ByVal @Name("operator *") Quaternion multiply(double fScalar);
                    
        public native @ByVal @Name("operator -") Quaternion subtract();
        public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef Quaternion rhs);
        public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef Quaternion rhs);


        public native double Dot(@Const @ByRef Quaternion rkQ);



        public native double Norm();

        public native double normalise();
        public native @ByVal Quaternion Inverse();
        public native @ByVal Quaternion UnitInverse();
        public native @ByVal Quaternion Exp();
        public native @ByVal Quaternion Log();


        public native @ByVal @Name("operator *") Vector3 multiply(@Const @ByRef Vector3 rkVector);
        public native @ByVal Radian getRoll(@Cast("bool") boolean reprojectAxis/*=true*/);
        public native @ByVal Radian getRoll();
        public native @ByVal Radian getPitch(@Cast("bool") boolean reprojectAxis/*=true*/);
        public native @ByVal Radian getPitch();
        public native @ByVal Radian getYaw(@Cast("bool") boolean reprojectAxis/*=true*/);
        public native @ByVal Radian getYaw();





        public native @Cast("bool") boolean equals(@Const @ByRef Quaternion rhs, @Const @ByRef Radian tolerance);
        public native @Cast("bool") boolean orientationEquals( @Const @ByRef Quaternion other, double tolerance/*=1e-3*/ );
        public native @Cast("bool") boolean orientationEquals( @Const @ByRef Quaternion other );
        public static native @ByVal Quaternion Slerp(double fT, @Const @ByRef Quaternion rkP,
                    @Const @ByRef Quaternion rkQ, @Cast("bool") boolean shortestPath/*=false*/);
        public static native @ByVal Quaternion Slerp(double fT, @Const @ByRef Quaternion rkP,
                    @Const @ByRef Quaternion rkQ);





        public static native @ByVal Quaternion SlerpExtraSpins(double fT,
                    @Const @ByRef Quaternion rkP, @Const @ByRef Quaternion rkQ,
                    int iExtraSpins);


        public static native void Intermediate(@Const @ByRef Quaternion rkQ0,
                    @Const @ByRef Quaternion rkQ1, @Const @ByRef Quaternion rkQ2,
                    @ByRef Quaternion rka, @ByRef Quaternion rkB);


        public static native @ByVal Quaternion Squad(double fT, @Const @ByRef Quaternion rkP,
                    @Const @ByRef Quaternion rkA, @Const @ByRef Quaternion rkB,
                    @Const @ByRef Quaternion rkQ, @Cast("bool") boolean shortestPath/*=false*/);
        public static native @ByVal Quaternion Squad(double fT, @Const @ByRef Quaternion rkP,
                    @Const @ByRef Quaternion rkA, @Const @ByRef Quaternion rkB,
                    @Const @ByRef Quaternion rkQ);
        public static native @ByVal Quaternion nlerp(double fT, @Const @ByRef Quaternion rkP,
                    @Const @ByRef Quaternion rkQ, @Cast("bool") boolean shortestPath/*=false*/);
        public static native @ByVal Quaternion nlerp(double fT, @Const @ByRef Quaternion rkP,
                    @Const @ByRef Quaternion rkQ);


        @MemberGetter public static native double msEpsilon();
        public static final double msEpsilon = msEpsilon();


        @MemberGetter public static native @Const @ByRef Quaternion ZERO();
        @MemberGetter public static native @Const @ByRef Quaternion IDENTITY();

        public native double w(); public native Quaternion w(double w);
        public native double x(); public native Quaternion x(double x);
        public native double y(); public native Quaternion y(double y);
        public native double z(); public native Quaternion z(double z);


        public native @Cast("bool") boolean isNaN();




        

    }




    @Namespace("Ogre") @NoOffset public static class Vector3 extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Vector3(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Vector3(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Vector3 position(long position) {
            return (Vector3)super.position(position);
        }
    
        public native double x(); public native Vector3 x(double x);
        public native double y(); public native Vector3 y(double y);
        public native double z(); public native Vector3 z(double z);




        public Vector3() { super((Pointer)null); allocate(); }
        private native void allocate();

        public Vector3( double fX, double fY, double fZ ) { super((Pointer)null); allocate(fX, fY, fZ); }
        private native void allocate( double fX, double fY, double fZ );

        public Vector3( double afCoordinate ) { super((Pointer)null); allocate(afCoordinate); }
        private native void allocate( double afCoordinate );

        public Vector3( @Const IntPointer afCoordinate ) { super((Pointer)null); allocate(afCoordinate); }
        private native void allocate( @Const IntPointer afCoordinate );
        public Vector3( @Const IntBuffer afCoordinate ) { super((Pointer)null); allocate(afCoordinate); }
        private native void allocate( @Const IntBuffer afCoordinate );
        public Vector3( @Const int[] afCoordinate ) { super((Pointer)null); allocate(afCoordinate); }
        private native void allocate( @Const int[] afCoordinate );




        public native void swap(@ByRef Vector3 other);

        public native @Name("operator []") double get( @Cast("const size_t") long i );

        public native double ptr();





        public native @ByRef @Name("operator =") Vector3 put( @Const @ByRef Vector3 rkVector );

        public native @ByRef @Name("operator =") Vector3 put( double fScaler );

        public native @Cast("bool") @Name("operator ==") boolean equals( @Const @ByRef Vector3 rkVector );

        public native @Cast("bool") @Name("operator !=") boolean notEquals( @Const @ByRef Vector3 rkVector );


        public native @ByVal @Name("operator +") Vector3 add( @Const @ByRef Vector3 rkVector );

        public native @ByVal @Name("operator -") Vector3 subtract( @Const @ByRef Vector3 rkVector );

        public native @ByVal @Name("operator *") Vector3 multiply( double fScalar );

        public native @ByVal @Name("operator *") Vector3 multiply( @Const @ByRef Vector3 rhs);

        public native @ByVal @Name("operator /") Vector3 divide( double fScalar );

        public native @ByVal @Name("operator /") Vector3 divide( @Const @ByRef Vector3 rhs);

        public native @Const @ByRef @Name("operator +") Vector3 add();

        public native @ByVal @Name("operator -") Vector3 subtract();


        

        

        

        

        

        


        public native @ByRef @Name("operator +=") Vector3 addPut( @Const @ByRef Vector3 rkVector );

        public native @ByRef @Name("operator +=") Vector3 addPut( double fScalar );

        public native @ByRef @Name("operator -=") Vector3 subtractPut( @Const @ByRef Vector3 rkVector );

        public native @ByRef @Name("operator -=") Vector3 subtractPut( double fScalar );

        public native @ByRef @Name("operator *=") Vector3 multiplyPut( double fScalar );

        public native @ByRef @Name("operator *=") Vector3 multiplyPut( @Const @ByRef Vector3 rkVector );

        public native @ByRef @Name("operator /=") Vector3 dividePut( double fScalar );

        public native @ByRef @Name("operator /=") Vector3 dividePut( @Const @ByRef Vector3 rkVector );
        public native double length();
        public native double squaredLength();
        public native double distance(@Const @ByRef Vector3 rhs);
        public native double squaredDistance(@Const @ByRef Vector3 rhs);
        public native double dotProduct(@Const @ByRef Vector3 vec);
        public native double absDotProduct(@Const @ByRef Vector3 vec);
        public native double normalise();
        public native @ByVal Vector3 crossProduct( @Const @ByRef Vector3 rkVector );




        public native @ByVal Vector3 midPoint( @Const @ByRef Vector3 vec );




        public native @Cast("bool") @Name("operator <") boolean lessThan( @Const @ByRef Vector3 rhs );




        public native @Cast("bool") @Name("operator >") boolean greaterThan( @Const @ByRef Vector3 rhs );
        public native void makeFloor( @Const @ByRef Vector3 cmp );
        public native void makeCeil( @Const @ByRef Vector3 cmp );


        public native void makeAbs();
        public native @ByVal Vector3 perpendicular();
        public native @ByVal Vector3 randomDeviant(
                    @Const @ByRef Radian angle,
                    @Const @ByRef(nullValue = "Ogre::Vector3::ZERO") Vector3 up );
        public native @ByVal Vector3 randomDeviant(
                    @Const @ByRef Radian angle );





        public native @ByVal Radian angleBetween(@Const @ByRef Vector3 dest);
        public native @ByVal Quaternion getRotationTo(@Const @ByRef Vector3 dest,
                    @Const @ByRef(nullValue = "Ogre::Vector3::ZERO") Vector3 fallbackAxis);
        public native @ByVal Quaternion getRotationTo(@Const @ByRef Vector3 dest);


        public native @Cast("bool") boolean isZeroLength();



        public native @ByVal Vector3 normalisedCopy();




        public native @ByVal Vector3 reflect(@Const @ByRef Vector3 normal);







        public native @Cast("bool") boolean positionEquals(@Const @ByRef Vector3 rhs, double tolerance/*=1e-03*/);
        public native @Cast("bool") boolean positionEquals(@Const @ByRef Vector3 rhs);







        public native @Cast("bool") boolean positionCloses(@Const @ByRef Vector3 rhs, double tolerance/*=1e-03f*/);
        public native @Cast("bool") boolean positionCloses(@Const @ByRef Vector3 rhs);
        public native @Cast("bool") boolean directionEquals(@Const @ByRef Vector3 rhs,
                    @Const @ByRef Radian tolerance);


        public native @Cast("bool") boolean isNaN();


        public native @ByVal Vector3 primaryAxis();


        @MemberGetter public static native @Const @ByRef Vector3 ZERO();
        @MemberGetter public static native @Const @ByRef Vector3 UNIT_X();
        @MemberGetter public static native @Const @ByRef Vector3 UNIT_Y();
        @MemberGetter public static native @Const @ByRef Vector3 UNIT_Z();
        @MemberGetter public static native @Const @ByRef Vector3 NEGATIVE_UNIT_X();
        @MemberGetter public static native @Const @ByRef Vector3 NEGATIVE_UNIT_Y();
        @MemberGetter public static native @Const @ByRef Vector3 NEGATIVE_UNIT_Z();
        @MemberGetter public static native @Const @ByRef Vector3 UNIT_SCALE();



        
    }




    @Namespace("Ogre") @NoOffset public static class Matrix3 extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Matrix3(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Matrix3(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Matrix3 position(long position) {
            return (Matrix3)super.position(position);
        }
    




        public Matrix3() { super((Pointer)null); allocate(); }
        private native void allocate();
        public Matrix3(@Cast("const Ogre::Real(* /*[3]*/ )[3]") double arr) { super((Pointer)null); allocate(arr); }
        private native void allocate(@Cast("const Ogre::Real(* /*[3]*/ )[3]") double arr);
        public Matrix3(@Const @ByRef Matrix3 rkMatrix) { super((Pointer)null); allocate(rkMatrix); }
        private native void allocate(@Const @ByRef Matrix3 rkMatrix);
        public Matrix3(double fEntry00, double fEntry01, double fEntry02,
                            double fEntry10, double fEntry11, double fEntry12,
                            double fEntry20, double fEntry21, double fEntry22) { super((Pointer)null); allocate(fEntry00, fEntry01, fEntry02, fEntry10, fEntry11, fEntry12, fEntry20, fEntry21, fEntry22); }
        private native void allocate(double fEntry00, double fEntry01, double fEntry02,
                            double fEntry10, double fEntry11, double fEntry12,
                            double fEntry20, double fEntry21, double fEntry22);



        public native void swap(@ByRef Matrix3 other);

        public native @Name("operator []") double get(@Cast("size_t") long iRow);







        public native @ByVal Vector3 GetColumn(@Cast("size_t") long iCol);
        public native void SetColumn(@Cast("size_t") long iCol, @Const @ByRef Vector3 vec);
        public native void FromAxes(@Const @ByRef Vector3 xAxis, @Const @ByRef Vector3 yAxis, @Const @ByRef Vector3 zAxis);


        public native @ByRef @Name("operator =") Matrix3 put(@Const @ByRef Matrix3 rkMatrix);



        public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef Matrix3 rkMatrix);



        public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef Matrix3 rkMatrix);




        public native @ByVal @Name("operator +") Matrix3 add(@Const @ByRef Matrix3 rkMatrix);



        public native @ByVal @Name("operator -") Matrix3 subtract(@Const @ByRef Matrix3 rkMatrix);



        public native @ByVal @Name("operator *") Matrix3 multiply(@Const @ByRef Matrix3 rkMatrix);
        public native @ByVal @Name("operator -") Matrix3 subtract();


        public native @ByVal @Name("operator *") Vector3 multiply(@Const @ByRef Vector3 rkVector);


                    


        public native @ByVal @Name("operator *") Matrix3 multiply(double fScalar);


                    


        public native @ByVal Matrix3 Transpose();
        public native @Cast("bool") boolean Inverse(@ByRef Matrix3 rkInverse, double fTolerance/*=1e-06*/);
        public native @Cast("bool") boolean Inverse(@ByRef Matrix3 rkInverse);
        public native @ByVal Matrix3 Inverse(double fTolerance/*=1e-06*/);
        public native @ByVal Matrix3 Inverse();
        public native double Determinant();


        public native void SingularValueDecomposition(@ByRef Matrix3 rkL, @ByRef Vector3 rkS,
                    @ByRef Matrix3 rkR);
        public native void SingularValueComposition(@Const @ByRef Matrix3 rkL,
                    @Const @ByRef Vector3 rkS, @Const @ByRef Matrix3 rkR);


        public native void Orthonormalize();


        public native void QDUDecomposition(@ByRef Matrix3 rkQ, @ByRef Vector3 rkD,
                    @ByRef Vector3 rkU);

        public native double SpectralNorm();


        public native void ToAngleAxis(@ByRef Vector3 rkAxis, @ByRef Radian rfAngle);
        public native void ToAngleAxis(@ByRef Vector3 rkAxis, @ByRef Degree rfAngle);
        public native void FromAngleAxis(@Const @ByRef Vector3 rkAxis, @Const @ByRef Radian fRadians);




        public native @Cast("bool") boolean ToEulerAnglesXYZ(@ByRef Radian rfYAngle, @ByRef Radian rfPAngle,
                    @ByRef Radian rfRAngle);
        public native @Cast("bool") boolean ToEulerAnglesXZY(@ByRef Radian rfYAngle, @ByRef Radian rfPAngle,
                    @ByRef Radian rfRAngle);
        public native @Cast("bool") boolean ToEulerAnglesYXZ(@ByRef Radian rfYAngle, @ByRef Radian rfPAngle,
                    @ByRef Radian rfRAngle);
        public native @Cast("bool") boolean ToEulerAnglesYZX(@ByRef Radian rfYAngle, @ByRef Radian rfPAngle,
                    @ByRef Radian rfRAngle);
        public native @Cast("bool") boolean ToEulerAnglesZXY(@ByRef Radian rfYAngle, @ByRef Radian rfPAngle,
                    @ByRef Radian rfRAngle);
        public native @Cast("bool") boolean ToEulerAnglesZYX(@ByRef Radian rfYAngle, @ByRef Radian rfPAngle,
                    @ByRef Radian rfRAngle);
        public native void FromEulerAnglesXYZ(@Const @ByRef Radian fYAngle, @Const @ByRef Radian fPAngle, @Const @ByRef Radian fRAngle);
        public native void FromEulerAnglesXZY(@Const @ByRef Radian fYAngle, @Const @ByRef Radian fPAngle, @Const @ByRef Radian fRAngle);
        public native void FromEulerAnglesYXZ(@Const @ByRef Radian fYAngle, @Const @ByRef Radian fPAngle, @Const @ByRef Radian fRAngle);
        public native void FromEulerAnglesYZX(@Const @ByRef Radian fYAngle, @Const @ByRef Radian fPAngle, @Const @ByRef Radian fRAngle);
        public native void FromEulerAnglesZXY(@Const @ByRef Radian fYAngle, @Const @ByRef Radian fPAngle, @Const @ByRef Radian fRAngle);
        public native void FromEulerAnglesZYX(@Const @ByRef Radian fYAngle, @Const @ByRef Radian fPAngle, @Const @ByRef Radian fRAngle);

        public native void EigenSolveSymmetric(double afEigenvalue,
                    Vector3 akEigenvector);

        public static native void TensorProduct(@Const @ByRef Vector3 rkU, @Const @ByRef Vector3 rkV,
                    @ByRef Matrix3 rkProduct);


        public native @Cast("bool") boolean hasScale();



        

        @MemberGetter public static native double EPSILON();
        public static final double EPSILON = EPSILON();
        @MemberGetter public static native @Const @ByRef Matrix3 ZERO();
        @MemberGetter public static native @Const @ByRef Matrix3 IDENTITY();
    }



    @Namespace("Ogre") @NoOffset public static class Vector4 extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Vector4(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Vector4(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Vector4 position(long position) {
            return (Vector4)super.position(position);
        }
    
        public native double x(); public native Vector4 x(double x);
        public native double y(); public native Vector4 y(double y);
        public native double z(); public native Vector4 z(double z);
        public native double w(); public native Vector4 w(double w);




        public Vector4() { super((Pointer)null); allocate(); }
        private native void allocate();

        public Vector4( double fX, double fY, double fZ, double fW ) { super((Pointer)null); allocate(fX, fY, fZ, fW); }
        private native void allocate( double fX, double fY, double fZ, double fW );

        public Vector4( double afCoordinate ) { super((Pointer)null); allocate(afCoordinate); }
        private native void allocate( double afCoordinate );

        public Vector4( @Const IntPointer afCoordinate ) { super((Pointer)null); allocate(afCoordinate); }
        private native void allocate( @Const IntPointer afCoordinate );
        public Vector4( @Const IntBuffer afCoordinate ) { super((Pointer)null); allocate(afCoordinate); }
        private native void allocate( @Const IntBuffer afCoordinate );
        public Vector4( @Const int[] afCoordinate ) { super((Pointer)null); allocate(afCoordinate); }
        private native void allocate( @Const int[] afCoordinate );

        public Vector4(@Const @ByRef Vector3 rhs) { super((Pointer)null); allocate(rhs); }
        private native void allocate(@Const @ByRef Vector3 rhs);



        public native void swap(@ByRef Vector4 other);

        public native @Name("operator []") double get( @Cast("const size_t") long i );


        public native double ptr();





        public native @ByRef @Name("operator =") Vector4 put( @Const @ByRef Vector4 rkVector );

        public native @ByRef @Name("operator =") Vector4 put( double fScalar);

        public native @Cast("bool") @Name("operator ==") boolean equals( @Const @ByRef Vector4 rkVector );

        public native @Cast("bool") @Name("operator !=") boolean notEquals( @Const @ByRef Vector4 rkVector );

        public native @ByRef @Name("operator =") Vector4 put(@Const @ByRef Vector3 rhs);


        public native @ByVal @Name("operator +") Vector4 add( @Const @ByRef Vector4 rkVector );

        public native @ByVal @Name("operator -") Vector4 subtract( @Const @ByRef Vector4 rkVector );

        public native @ByVal @Name("operator *") Vector4 multiply( double fScalar );

        public native @ByVal @Name("operator *") Vector4 multiply( @Const @ByRef Vector4 rhs);

        public native @ByVal @Name("operator /") Vector4 divide( double fScalar );

        public native @ByVal @Name("operator /") Vector4 divide( @Const @ByRef Vector4 rhs);

        public native @Const @ByRef @Name("operator +") Vector4 add();

        public native @ByVal @Name("operator -") Vector4 subtract();

        

        

        

        

        

        


        public native @ByRef @Name("operator +=") Vector4 addPut( @Const @ByRef Vector4 rkVector );

        public native @ByRef @Name("operator -=") Vector4 subtractPut( @Const @ByRef Vector4 rkVector );

        public native @ByRef @Name("operator *=") Vector4 multiplyPut( double fScalar );

        public native @ByRef @Name("operator +=") Vector4 addPut( double fScalar );

        public native @ByRef @Name("operator -=") Vector4 subtractPut( double fScalar );

        public native @ByRef @Name("operator *=") Vector4 multiplyPut( @Const @ByRef Vector4 rkVector );

        public native @ByRef @Name("operator /=") Vector4 dividePut( double fScalar );

        public native @ByRef @Name("operator /=") Vector4 dividePut( @Const @ByRef Vector4 rkVector );
        public native double dotProduct(@Const @ByRef Vector4 vec);

        public native @Cast("bool") boolean isNaN();


        

        @MemberGetter public static native @Const @ByRef Vector4 ZERO();
    }




    @Namespace("Ogre") @NoOffset public static class Plane extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Plane(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Plane(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Plane position(long position) {
            return (Plane)super.position(position);
        }
    


        public Plane() { super((Pointer)null); allocate(); }
        private native void allocate();
        public Plane(@Const @ByRef Plane rhs) { super((Pointer)null); allocate(rhs); }
        private native void allocate(@Const @ByRef Plane rhs);

        public Plane(@Const @ByRef Vector3 rkNormal, double fConstant) { super((Pointer)null); allocate(rkNormal, fConstant); }
        private native void allocate(@Const @ByRef Vector3 rkNormal, double fConstant);

        public Plane(double a, double b, double c, double d) { super((Pointer)null); allocate(a, b, c, d); }
        private native void allocate(double a, double b, double c, double d);
        public Plane(@Const @ByRef Vector3 rkNormal, @Const @ByRef Vector3 rkPoint) { super((Pointer)null); allocate(rkNormal, rkPoint); }
        private native void allocate(@Const @ByRef Vector3 rkNormal, @Const @ByRef Vector3 rkPoint);
        public Plane(@Const @ByRef Vector3 rkPoint0, @Const @ByRef Vector3 rkPoint1,
                    @Const @ByRef Vector3 rkPoint2) { super((Pointer)null); allocate(rkPoint0, rkPoint1, rkPoint2); }
        private native void allocate(@Const @ByRef Vector3 rkPoint0, @Const @ByRef Vector3 rkPoint1,
                    @Const @ByRef Vector3 rkPoint2);





        /** enum Ogre::Plane::Side */
        public static final int
            NO_SIDE = 0,
            POSITIVE_SIDE = 1,
            NEGATIVE_SIDE = 2,
            BOTH_SIDE = 3;

        public native @Cast("Ogre::Plane::Side") int getSide(@Const @ByRef Vector3 rkPoint);





        public native @Cast("Ogre::Plane::Side") int getSide(@Const @ByRef AxisAlignedBox rkBox);
        public native @Cast("Ogre::Plane::Side") int getSide(@Const @ByRef Vector3 centre, @Const @ByRef Vector3 halfSize);
        public native double getDistance(@Const @ByRef Vector3 rkPoint);


        public native void redefine(@Const @ByRef Vector3 rkPoint0, @Const @ByRef Vector3 rkPoint1,
                    @Const @ByRef Vector3 rkPoint2);


        public native void redefine(@Const @ByRef Vector3 rkNormal, @Const @ByRef Vector3 rkPoint);
        public native @ByVal Vector3 projectVector(@Const @ByRef Vector3 v);
        public native double normalise();

        public native @ByRef Vector3 normal(); public native Plane normal(Vector3 normal);
        public native double d(); public native Plane d(double d);


        public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef Plane rhs);
        public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef Plane rhs);

                    
    }




    @Namespace("Ogre") @NoOffset public static class Matrix4 extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Matrix4(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Matrix4(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Matrix4 position(long position) {
            return (Matrix4)super.position(position);
        }
    




        public Matrix4() { super((Pointer)null); allocate(); }
        private native void allocate();

        public Matrix4(
                    double m00, double m01, double m02, double m03,
                    double m10, double m11, double m12, double m13,
                    double m20, double m21, double m22, double m23,
                    double m30, double m31, double m32, double m33 ) { super((Pointer)null); allocate(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33); }
        private native void allocate(
                    double m00, double m01, double m02, double m03,
                    double m10, double m11, double m12, double m13,
                    double m20, double m21, double m22, double m23,
                    double m30, double m31, double m32, double m33 );




        public Matrix4(@Const @ByRef Matrix3 m3x3) { super((Pointer)null); allocate(m3x3); }
        private native void allocate(@Const @ByRef Matrix3 m3x3);




        public Matrix4(@Const @ByRef Quaternion rot) { super((Pointer)null); allocate(rot); }
        private native void allocate(@Const @ByRef Quaternion rot);




        public native void swap(@ByRef Matrix4 other);

        public native @Name("operator []") double get( @Cast("size_t") long iRow );
        public native @ByVal Matrix4 concatenate(@Const @ByRef Matrix4 m2);




        public native @ByVal @Name("operator *") Matrix4 multiply( @Const @ByRef Matrix4 m2 );
        public native @ByVal @Name("operator *") Vector3 multiply( @Const @ByRef Vector3 v );
        public native @ByVal @Name("operator *") Vector4 multiply(@Const @ByRef Vector4 v);
        public native @ByVal @Name("operator *") Plane multiply(@Const @ByRef Plane p);




        public native @ByVal @Name("operator +") Matrix4 add( @Const @ByRef Matrix4 m2 );



        public native @ByVal @Name("operator -") Matrix4 subtract( @Const @ByRef Matrix4 m2 );



        public native @Cast("bool") @Name("operator ==") boolean equals( @Const @ByRef Matrix4 m2 );



        public native @Cast("bool") @Name("operator !=") boolean notEquals( @Const @ByRef Matrix4 m2 );



        public native @Name("operator =") void put( @Const @ByRef Matrix3 mat3 );

        public native @ByVal Matrix4 transpose();
        public native void setTrans( @Const @ByRef Vector3 v );



        public native @ByVal Vector3 getTrans();




        public native void makeTrans( @Const @ByRef Vector3 v );

        public native void makeTrans( double tx, double ty, double tz );



        public static native @ByVal Matrix4 getTrans( @Const @ByRef Vector3 v );



        public static native @ByVal Matrix4 getTrans( double t_x, double t_y, double t_z );
        public native void setScale( @Const @ByRef Vector3 v );



        public static native @ByVal Matrix4 getScale( @Const @ByRef Vector3 v );



        public static native @ByVal Matrix4 getScale( double s_x, double s_y, double s_z );




        public native void extract3x3Matrix(@ByRef Matrix3 m3x3);


        public native @Cast("bool") boolean hasScale();


        public native @Cast("bool") boolean hasNegativeScale();



        public native @ByVal Quaternion extractQuaternion();

    @MemberGetter public static native @Const @ByRef Matrix4 ZERO();
    @MemberGetter public static native @Const @ByRef Matrix4 ZEROAFFINE();
    @MemberGetter public static native @Const @ByRef Matrix4 IDENTITY();


        @MemberGetter public static native @Const @ByRef Matrix4 CLIPSPACE2DTOIMAGESPACE();

        public native @ByVal @Name("operator *") Matrix4 multiply(double scalar);



        

        public native @ByVal Matrix4 adjoint();
        public native double determinant();
        public native @ByVal Matrix4 inverse();







        public native void makeTransform(@Const @ByRef Vector3 position, @Const @ByRef Vector3 scale, @Const @ByRef Quaternion orientation);






        public native void makeInverseTransform(@Const @ByRef Vector3 position, @Const @ByRef Vector3 scale, @Const @ByRef Quaternion orientation);



        public native void decomposition(@ByRef Vector3 position, @ByRef Vector3 scale, @ByRef Quaternion orientation);






        public native @Cast("bool") boolean isAffine();





        public native @ByVal Matrix4 inverseAffine();





        public native @ByVal Matrix4 concatenateAffine(@Const @ByRef Matrix4 m2);
        public native @ByVal Vector3 transformAffine(@Const @ByRef Vector3 v);





        public native @ByVal Vector4 transformAffine(@Const @ByRef Vector4 v);
    }





    @Namespace("Ogre") public static native @ByVal @Name("operator *") Vector4 multiply(@Const @ByRef Vector4 v, @Const @ByRef Matrix4 mat);



    @Namespace("Ogre") @NoOffset public static class SimpleSpline extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SimpleSpline(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public SimpleSpline(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public SimpleSpline position(long position) {
            return (SimpleSpline)super.position(position);
        }
    
        public SimpleSpline() { super((Pointer)null); allocate(); }
        private native void allocate();


        public native void addPoint(@Const @ByRef Vector3 p);


        public native @Const @ByRef Vector3 getPoint(@Cast("unsigned short") short index);


        public native @Cast("unsigned short") short getNumPoints();


        public native void clear();





        public native void updatePoint(@Cast("unsigned short") short index, @Const @ByRef Vector3 value);







        public native @ByVal Vector3 interpolate(double t);





        public native @ByVal Vector3 interpolate(@Cast("unsigned int") int fromIndex, double t);
        public native void setAutoCalculate(@Cast("bool") boolean autoCalc);






        public native void recalcTangents();



    }




    @Namespace("Ogre") @NoOffset public static class RotationalSpline extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RotationalSpline(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public RotationalSpline(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public RotationalSpline position(long position) {
            return (RotationalSpline)super.position(position);
        }
    
        public RotationalSpline() { super((Pointer)null); allocate(); }
        private native void allocate();


        public native void addPoint(@Const @ByRef Quaternion p);


        public native @Const @ByRef Quaternion getPoint(@Cast("unsigned short") short index);


        public native @Cast("unsigned short") short getNumPoints();


        public native void clear();





        public native void updatePoint(@Cast("unsigned short") short index, @Const @ByRef Quaternion value);
        public native @ByVal Quaternion interpolate(double t, @Cast("bool") boolean useShortestPath/*=true*/);
        public native @ByVal Quaternion interpolate(double t);






        public native @ByVal Quaternion interpolate(@Cast("unsigned int") int fromIndex, double t, @Cast("bool") boolean useShortestPath/*=true*/);
        public native @ByVal Quaternion interpolate(@Cast("unsigned int") int fromIndex, double t);
        public native void setAutoCalculate(@Cast("bool") boolean autoCalc);






        public native void recalcTangents();

    }






    @Namespace("Ogre") @NoOffset public static class Exception extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Exception(Pointer p) { super(p); }
    





        /** enum Ogre::Exception::ExceptionCodes */
        public static final int
            ERR_CANNOT_WRITE_TO_FILE = 0,
            ERR_INVALID_STATE = 1,
            ERR_INVALIDPARAMS = 2,
            ERR_RENDERINGAPI_ERROR = 3,
            ERR_DUPLICATE_ITEM = 4,
            ERR_ITEM_NOT_FOUND = 5,
            ERR_FILE_NOT_FOUND = 6,
            ERR_INTERNAL_ERROR = 7,
            ERR_RT_ASSERTION_FAILED = 8,
            ERR_NOT_IMPLEMENTED = 9,
            ERR_INVALID_CALL = 10;



        public Exception( int number, @Const @ByRef String description, @Const @ByRef String source ) { super((Pointer)null); allocate(number, description, source); }
        private native void allocate( int number, @Const @ByRef String description, @Const @ByRef String source );



        public Exception( int number, @Const @ByRef String description, @Const @ByRef String source, @Cast("const char*") BytePointer type, @Cast("const char*") BytePointer file, long line ) { super((Pointer)null); allocate(number, description, source, type, file, line); }
        private native void allocate( int number, @Const @ByRef String description, @Const @ByRef String source, @Cast("const char*") BytePointer type, @Cast("const char*") BytePointer file, long line );
        public Exception( int number, @Const @ByRef String description, @Const @ByRef String source, String type, String file, long line ) { super((Pointer)null); allocate(number, description, source, type, file, line); }
        private native void allocate( int number, @Const @ByRef String description, @Const @ByRef String source, String type, String file, long line );



        public Exception(@Const @ByRef Exception rhs) { super((Pointer)null); allocate(rhs); }
        private native void allocate(@Const @ByRef Exception rhs);



        public native @ByRef @Name("operator =") Exception put(@Const @ByRef Exception rhs);
        public native @Const @ByRef String getFullDescription();



        public native int getNumber();



        public native @Const @ByRef String getSource();



        public native @Const @ByRef String getFile();



        public native long getLine();





        public native @Const @ByRef String getDescription();


        public native @Cast("const char*") BytePointer what();

    }
    @Namespace("Ogre") public static class UnimplementedException extends Exception {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public UnimplementedException(Pointer p) { super(p); }
    
        public UnimplementedException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine);
        public UnimplementedException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine);
    }
    @Namespace("Ogre") public static class FileNotFoundException extends Exception {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public FileNotFoundException(Pointer p) { super(p); }
    
        public FileNotFoundException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine);
        public FileNotFoundException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine);
    }
    @Namespace("Ogre") public static class IOException extends Exception {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public IOException(Pointer p) { super(p); }
    
        public IOException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine);
        public IOException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine);
    }
    @Namespace("Ogre") public static class InvalidStateException extends Exception {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public InvalidStateException(Pointer p) { super(p); }
    
        public InvalidStateException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine);
        public InvalidStateException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine);
    }
    @Namespace("Ogre") public static class InvalidParametersException extends Exception {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public InvalidParametersException(Pointer p) { super(p); }
    
        public InvalidParametersException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine);
        public InvalidParametersException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine);
    }
    @Namespace("Ogre") public static class ItemIdentityException extends Exception {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ItemIdentityException(Pointer p) { super(p); }
    
        public ItemIdentityException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine);
        public ItemIdentityException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine);
    }
    @Namespace("Ogre") public static class InternalErrorException extends Exception {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public InternalErrorException(Pointer p) { super(p); }
    
        public InternalErrorException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine);
        public InternalErrorException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine);
    }
    @Namespace("Ogre") public static class RenderingAPIException extends Exception {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderingAPIException(Pointer p) { super(p); }
    
        public RenderingAPIException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine);
        public RenderingAPIException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine);
    }
    @Namespace("Ogre") public static class RuntimeAssertionException extends Exception {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RuntimeAssertionException(Pointer p) { super(p); }
    
        public RuntimeAssertionException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine);
        public RuntimeAssertionException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine);
    }
    @Namespace("Ogre") public static class InvalidCallException extends Exception {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public InvalidCallException(Pointer p) { super(p); }
    
        public InvalidCallException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, @Cast("const char*") BytePointer inFile, long inLine);
        public InvalidCallException(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine) { super((Pointer)null); allocate(inNumber, inDescription, inSource, inFile, inLine); }
        private native void allocate(int inNumber, @Const @ByRef String inDescription, @Const @ByRef String inSource, String inFile, long inLine);
    }
    @Namespace("Ogre") public static class ExceptionFactory extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ExceptionFactory(Pointer p) { super(p); }
    
        public static native void throwException(
                    @Cast("Ogre::Exception::ExceptionCodes") int code, int number,
                    @Const @ByRef String desc,
                    @Const @ByRef String src, @Cast("const char*") BytePointer file, long line);
        public static native void throwException(
                    @Cast("Ogre::Exception::ExceptionCodes") int code, int number,
                    @Const @ByRef String desc,
                    @Const @ByRef String src, String file, long line);

    }

    @Namespace("Ogre::v1") @NoOffset public static class HardwareBuffer extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareBuffer(Pointer p) { super(p); }
    

            /** enum Ogre::v1::HardwareBuffer::Usage */
            public static final int



                HBU_STATIC = 1,





                HBU_DYNAMIC = 2,






                HBU_WRITE_ONLY = 4,
                HBU_DISCARDABLE = 8,

                HBU_STATIC_WRITE_ONLY = 5,





                HBU_DYNAMIC_WRITE_ONLY = 6,

                HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE = 14;

            /** enum Ogre::v1::HardwareBuffer::LockOptions */
            public static final int

                HBL_NORMAL = 0,




                HBL_DISCARD = 1,



                HBL_READ_ONLY = 2,



                HBL_NO_OVERWRITE = 3,

                HBL_WRITE_ONLY = 4;




            /** enum Ogre::v1::HardwareBuffer::UploadOptions */
            public static final int



                HBU_DEFAULT =  0x0000,




                HBU_ON_DEMAND =  0x0001;






            public native Pointer lock(@Cast("size_t") long offset, @Cast("size_t") long length, @Cast("Ogre::v1::HardwareBuffer::LockOptions") int options, @Cast("Ogre::v1::HardwareBuffer::UploadOptions") int uploadOpt/*=Ogre::v1::HardwareBuffer::HBU_DEFAULT*/);
            public native Pointer lock(@Cast("size_t") long offset, @Cast("size_t") long length, @Cast("Ogre::v1::HardwareBuffer::LockOptions") int options);





            public native Pointer lock(@Cast("Ogre::v1::HardwareBuffer::LockOptions") int options, @Cast("Ogre::v1::HardwareBuffer::UploadOptions") int uploadOpt/*=Ogre::v1::HardwareBuffer::HBU_DEFAULT*/);
            public native Pointer lock(@Cast("Ogre::v1::HardwareBuffer::LockOptions") int options);
            public native void unlock();







            public native void readData(@Cast("size_t") long offset, @Cast("size_t") long length, Pointer pDest);
            public native void writeData(@Cast("size_t") long offset, @Cast("size_t") long length, @Const Pointer pSource,
                                @Cast("bool") boolean discardWholeBuffer/*=false*/);
            public native void writeData(@Cast("size_t") long offset, @Cast("size_t") long length, @Const Pointer pSource);
            public native void copyData(@ByRef HardwareBuffer srcBuffer, @Cast("size_t") long srcOffset,
                            @Cast("size_t") long dstOffset, @Cast("size_t") long length, @Cast("bool") boolean discardWholeBuffer/*=false*/);
            public native void copyData(@ByRef HardwareBuffer srcBuffer, @Cast("size_t") long srcOffset,
                            @Cast("size_t") long dstOffset, @Cast("size_t") long length);






            public native void copyData(@ByRef HardwareBuffer srcBuffer);


            public native void _updateFromShadow();


            public native @Cast("size_t") long getSizeInBytes();

            public native @Cast("Ogre::v1::HardwareBuffer::Usage") int getUsage();

            public native @Cast("bool") boolean isSystemMemory();

            public native @Cast("bool") boolean hasShadowBuffer();

            public native @Cast("bool") boolean isLocked();

            public native void suppressHardwareUpdate(@Cast("bool") boolean suppress);





    }









    @Name("Ogre::AtomicScalar<Ogre::uint32>") @NoOffset public static class UInt32AtomicScalarRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public UInt32AtomicScalarRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public UInt32AtomicScalarRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public UInt32AtomicScalarRef position(long position) {
            return (UInt32AtomicScalarRef)super.position(position);
        }
    

        public UInt32AtomicScalarRef(@Cast("const Ogre::uint32") int initial) { super((Pointer)null); allocate(initial); }
        private native void allocate(@Cast("const Ogre::uint32") int initial);

        public UInt32AtomicScalarRef(@Cast("const Ogre::AtomicScalar<Ogre::uint32>*") @ByRef UInt32AtomicScalarRef cousin) { super((Pointer)null); allocate(cousin); }
        private native void allocate(@Cast("const Ogre::AtomicScalar<Ogre::uint32>*") @ByRef UInt32AtomicScalarRef cousin);

        public UInt32AtomicScalarRef() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native @Name("operator =") void put(@Cast("const Ogre::AtomicScalar<Ogre::uint32>*") @ByRef UInt32AtomicScalarRef cousin);

        public native @Cast("Ogre::uint32") int get();

        public native void set(@Cast("const Ogre::uint32") int v);

        public native @Cast("bool") boolean cas(@Cast("const Ogre::uint32") int old, @Cast("const Ogre::uint32") int nu);

        public native @Cast("Ogre::uint32") @Name("operator ++") int increment();

        public native @Cast("Ogre::uint32") @Name("operator --") int decrement();

        public native @Cast("Ogre::uint32") @Name("operator ++") int increment(int arg0);

        public native @Cast("Ogre::uint32") @Name("operator --") int decrement(int arg0);

        public native @Cast("Ogre::uint32") @Name("operator +=") int addPut(@Cast("const Ogre::uint32") int add);

        public native @Cast("Ogre::uint32") @Name("operator -=") int subtractPut(@Cast("const Ogre::uint32") int sub);

    }







    @Name("Ogre::AtomicScalar<unsigned int>") @NoOffset public static class UIntAtomicScalarRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public UIntAtomicScalarRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public UIntAtomicScalarRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public UIntAtomicScalarRef position(long position) {
            return (UIntAtomicScalarRef)super.position(position);
        }
    

        public UIntAtomicScalarRef(@Cast("const unsigned int") int initial) { super((Pointer)null); allocate(initial); }
        private native void allocate(@Cast("const unsigned int") int initial);

        public UIntAtomicScalarRef(@Cast("const Ogre::AtomicScalar<unsigned int>*") @ByRef UIntAtomicScalarRef cousin) { super((Pointer)null); allocate(cousin); }
        private native void allocate(@Cast("const Ogre::AtomicScalar<unsigned int>*") @ByRef UIntAtomicScalarRef cousin);

        public UIntAtomicScalarRef() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native @Name("operator =") void put(@Cast("const Ogre::AtomicScalar<unsigned int>*") @ByRef UIntAtomicScalarRef cousin);

        public native @Cast("unsigned int") int get();

        public native void set(@Cast("const unsigned int") int v);

        public native @Cast("bool") boolean cas(@Cast("const unsigned int") int old, @Cast("const unsigned int") int nu);

        public native @Cast("unsigned int") @Name("operator ++") int increment();

        public native @Cast("unsigned int") @Name("operator --") int decrement();

        public native @Cast("unsigned int") @Name("operator ++") int increment(int arg0);

        public native @Cast("unsigned int") @Name("operator --") int decrement(int arg0);

        public native @Cast("unsigned int") @Name("operator +=") int addPut(@Cast("const unsigned int") int add);

        public native @Cast("unsigned int") @Name("operator -=") int subtractPut(@Cast("const unsigned int") int sub);

    }




    /** enum Ogre::SharedPtrFreeMethod */
    public static final int

        SPFM_DELETE = 0,

        SPFM_DELETE_T = 1,

        SPFM_FREE = 2,

        SPFM_NONE = 3;

    @Namespace("Ogre") @NoOffset public static class SharedPtrInfo extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SharedPtrInfo(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public SharedPtrInfo(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public SharedPtrInfo position(long position) {
            return (SharedPtrInfo)super.position(position);
        }
    
        public SharedPtrInfo() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native @ByRef @Cast("Ogre::AtomicScalar<unsigned int>*") UIntAtomicScalarRef useCount(); public native SharedPtrInfo useCount(UIntAtomicScalarRef useCount);
    }

    @Namespace("Ogre") public static class SharedPtrInfoNone extends SharedPtrInfo {
        static { Loader.load(); }
        /** Default native constructor. */
        public SharedPtrInfoNone() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public SharedPtrInfoNone(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SharedPtrInfoNone(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public SharedPtrInfoNone position(long position) {
            return (SharedPtrInfoNone)super.position(position);
        }
    
    }
    @Name("Ogre::SharedPtr<Ogre::ControllerFunction<Ogre::Ogre::Real> >") @NoOffset public static class RealControllerFunctionSPtr extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RealControllerFunctionSPtr(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public RealControllerFunctionSPtr(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public RealControllerFunctionSPtr position(long position) {
            return (RealControllerFunctionSPtr)super.position(position);
        }
    




        public RealControllerFunctionSPtr() { super((Pointer)null); allocate(); }
        private native void allocate();

        public RealControllerFunctionSPtr(@Cast("const Ogre::SharedPtr<Ogre::ControllerFunction<Ogre::Ogre::Real> >*") @ByRef RealControllerFunctionSPtr r) { super((Pointer)null); allocate(r); }
        private native void allocate(@Cast("const Ogre::SharedPtr<Ogre::ControllerFunction<Ogre::Ogre::Real> >*") @ByRef RealControllerFunctionSPtr r);

        public native @Cast("Ogre::SharedPtr<Ogre::ControllerFunction<Ogre::Ogre::Real> >*") @ByRef @Name("operator =") RealControllerFunctionSPtr put(@Cast("const Ogre::SharedPtr<Ogre::ControllerFunction<Ogre::Ogre::Real> >*") @ByRef RealControllerFunctionSPtr r);

        public native @Cast("Ogre::ControllerFunction<Ogre::Ogre::Real>*") @ByRef @Name("operator *") RealControllerFunctionRef multiply();
        public native @Cast("Ogre::ControllerFunction<Ogre::Ogre::Real>*") @Name("operator ->") RealControllerFunctionRef access();
        public native @Cast("Ogre::ControllerFunction<Ogre::Ogre::Real>*") RealControllerFunctionRef get();
        public native void bind(@Cast("Ogre::ControllerFunction<Ogre::Ogre::Real>*") RealControllerFunctionRef rep, @Cast("Ogre::SharedPtrFreeMethod") int inFreeMethod/*=Ogre::SPFM_DELETE*/);
        public native void bind(@Cast("Ogre::ControllerFunction<Ogre::Ogre::Real>*") RealControllerFunctionRef rep);

        public native @Cast("bool") boolean unique();
        public native @Cast("unsigned int") int useCount();
        public native void setUseCount(@Cast("unsigned") int value);

        public native @Cast("Ogre::ControllerFunction<Ogre::Ogre::Real>*") RealControllerFunctionRef getPointer();

        public native @Cast("bool") boolean isNull();

        public native void setNull();
    }
    @Name("Ogre::SharedPtr<Ogre::ControllerValue<Ogre::Ogre::Real> >") @NoOffset public static class RealControllerValueSPtr extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RealControllerValueSPtr(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public RealControllerValueSPtr(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public RealControllerValueSPtr position(long position) {
            return (RealControllerValueSPtr)super.position(position);
        }
    




        public RealControllerValueSPtr() { super((Pointer)null); allocate(); }
        private native void allocate();

        public RealControllerValueSPtr(@Cast("const Ogre::SharedPtr<Ogre::ControllerValue<Ogre::Ogre::Real> >*") @ByRef RealControllerValueSPtr r) { super((Pointer)null); allocate(r); }
        private native void allocate(@Cast("const Ogre::SharedPtr<Ogre::ControllerValue<Ogre::Ogre::Real> >*") @ByRef RealControllerValueSPtr r);

        public native @Cast("Ogre::SharedPtr<Ogre::ControllerValue<Ogre::Ogre::Real> >*") @ByRef @Name("operator =") RealControllerValueSPtr put(@Cast("const Ogre::SharedPtr<Ogre::ControllerValue<Ogre::Ogre::Real> >*") @ByRef RealControllerValueSPtr r);

        public native @Cast("Ogre::ControllerValue<Ogre::Ogre::Real>*") @ByRef @Name("operator *") RealControllerValueRef multiply();
        public native @Cast("Ogre::ControllerValue<Ogre::Ogre::Real>*") @Name("operator ->") RealControllerValueRef access();
        public native @Cast("Ogre::ControllerValue<Ogre::Ogre::Real>*") RealControllerValueRef get();
        public native void bind(@Cast("Ogre::ControllerValue<Ogre::Ogre::Real>*") RealControllerValueRef rep, @Cast("Ogre::SharedPtrFreeMethod") int inFreeMethod/*=Ogre::SPFM_DELETE*/);
        public native void bind(@Cast("Ogre::ControllerValue<Ogre::Ogre::Real>*") RealControllerValueRef rep);

        public native @Cast("bool") boolean unique();
        public native @Cast("unsigned int") int useCount();
        public native void setUseCount(@Cast("unsigned") int value);

        public native @Cast("Ogre::ControllerValue<Ogre::Ogre::Real>*") RealControllerValueRef getPointer();

        public native @Cast("bool") boolean isNull();

        public native void setNull();
    }
    @Name("Ogre::SharedPtr<Ogre::FileInfoList>") @NoOffset public static class FileInfoListPtr extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public FileInfoListPtr(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public FileInfoListPtr(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public FileInfoListPtr position(long position) {
            return (FileInfoListPtr)super.position(position);
        }
    




        public FileInfoListPtr() { super((Pointer)null); allocate(); }
        private native void allocate();

        public FileInfoListPtr(@Cast("const Ogre::SharedPtr<Ogre::FileInfoList>*") @ByRef FileInfoListPtr r) { super((Pointer)null); allocate(r); }
        private native void allocate(@Cast("const Ogre::SharedPtr<Ogre::FileInfoList>*") @ByRef FileInfoListPtr r);

        public native @Cast("Ogre::SharedPtr<Ogre::FileInfoList>*") @ByRef @Name("operator =") FileInfoListPtr put(@Cast("const Ogre::SharedPtr<Ogre::FileInfoList>*") @ByRef FileInfoListPtr r);

        public native @ByRef @Name("operator *") FileInfoList multiply();
        public native @Name("operator ->") FileInfoList access();
        public native FileInfoList get();
        public native void bind(FileInfoList rep, @Cast("Ogre::SharedPtrFreeMethod") int inFreeMethod/*=Ogre::SPFM_DELETE*/);
        public native void bind(FileInfoList rep);

        public native @Cast("bool") boolean unique();
        public native @Cast("unsigned int") int useCount();
        public native void setUseCount(@Cast("unsigned") int value);

        public native FileInfoList getPointer();

        public native @Cast("bool") boolean isNull();

        public native void setNull();
    }
    @Name("Ogre::SharedPtr<Ogre::v1::HardwareCounterBuffer>") @NoOffset public static class HardwareCounterBufferSPtr extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareCounterBufferSPtr(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public HardwareCounterBufferSPtr(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public HardwareCounterBufferSPtr position(long position) {
            return (HardwareCounterBufferSPtr)super.position(position);
        }
    




        public HardwareCounterBufferSPtr() { super((Pointer)null); allocate(); }
        private native void allocate();

        public HardwareCounterBufferSPtr(@Cast("const Ogre::SharedPtr<Ogre::v1::HardwareCounterBuffer>*") @ByRef HardwareCounterBufferSPtr r) { super((Pointer)null); allocate(r); }
        private native void allocate(@Cast("const Ogre::SharedPtr<Ogre::v1::HardwareCounterBuffer>*") @ByRef HardwareCounterBufferSPtr r);

        public native @Cast("Ogre::SharedPtr<Ogre::v1::HardwareCounterBuffer>*") @ByRef @Name("operator =") HardwareCounterBufferSPtr put(@Cast("const Ogre::SharedPtr<Ogre::v1::HardwareCounterBuffer>*") @ByRef HardwareCounterBufferSPtr r);

        public native @ByRef @Name("operator *") HardwareCounterBuffer multiply();
        public native @Name("operator ->") HardwareCounterBuffer access();
        public native HardwareCounterBuffer get();
        public native void bind(HardwareCounterBuffer rep, @Cast("Ogre::SharedPtrFreeMethod") int inFreeMethod/*=Ogre::SPFM_DELETE*/);
        public native void bind(HardwareCounterBuffer rep);

        public native @Cast("bool") boolean unique();
        public native @Cast("unsigned int") int useCount();
        public native void setUseCount(@Cast("unsigned") int value);

        public native HardwareCounterBuffer getPointer();

        public native @Cast("bool") boolean isNull();

        public native void setNull();
    }
    @Name("Ogre::SharedPtr<Ogre::v1::HardwareIndexBuffer>") @NoOffset public static class HardwareIndexBufferSPtr extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareIndexBufferSPtr(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public HardwareIndexBufferSPtr(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public HardwareIndexBufferSPtr position(long position) {
            return (HardwareIndexBufferSPtr)super.position(position);
        }
    




        public HardwareIndexBufferSPtr() { super((Pointer)null); allocate(); }
        private native void allocate();

        public HardwareIndexBufferSPtr(@Cast("const Ogre::SharedPtr<Ogre::v1::HardwareIndexBuffer>*") @ByRef HardwareIndexBufferSPtr r) { super((Pointer)null); allocate(r); }
        private native void allocate(@Cast("const Ogre::SharedPtr<Ogre::v1::HardwareIndexBuffer>*") @ByRef HardwareIndexBufferSPtr r);

        public native @Cast("Ogre::SharedPtr<Ogre::v1::HardwareIndexBuffer>*") @ByRef @Name("operator =") HardwareIndexBufferSPtr put(@Cast("const Ogre::SharedPtr<Ogre::v1::HardwareIndexBuffer>*") @ByRef HardwareIndexBufferSPtr r);

        public native @ByRef @Name("operator *") HardwareIndexBuffer multiply();
        public native @Name("operator ->") HardwareIndexBuffer access();
        public native HardwareIndexBuffer get();
        public native void bind(HardwareIndexBuffer rep, @Cast("Ogre::SharedPtrFreeMethod") int inFreeMethod/*=Ogre::SPFM_DELETE*/);
        public native void bind(HardwareIndexBuffer rep);

        public native @Cast("bool") boolean unique();
        public native @Cast("unsigned int") int useCount();
        public native void setUseCount(@Cast("unsigned") int value);

        public native HardwareIndexBuffer getPointer();

        public native @Cast("bool") boolean isNull();

        public native void setNull();
    }
    @Name("Ogre::SharedPtr<Ogre::v1::HardwarePixelBuffer>") @NoOffset public static class HardwarePixelBufferSPtr extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwarePixelBufferSPtr(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public HardwarePixelBufferSPtr(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public HardwarePixelBufferSPtr position(long position) {
            return (HardwarePixelBufferSPtr)super.position(position);
        }
    




        public HardwarePixelBufferSPtr() { super((Pointer)null); allocate(); }
        private native void allocate();

        public HardwarePixelBufferSPtr(@Cast("const Ogre::SharedPtr<Ogre::v1::HardwarePixelBuffer>*") @ByRef HardwarePixelBufferSPtr r) { super((Pointer)null); allocate(r); }
        private native void allocate(@Cast("const Ogre::SharedPtr<Ogre::v1::HardwarePixelBuffer>*") @ByRef HardwarePixelBufferSPtr r);

        public native @Cast("Ogre::SharedPtr<Ogre::v1::HardwarePixelBuffer>*") @ByRef @Name("operator =") HardwarePixelBufferSPtr put(@Cast("const Ogre::SharedPtr<Ogre::v1::HardwarePixelBuffer>*") @ByRef HardwarePixelBufferSPtr r);

        public native @ByRef @Name("operator *") HardwarePixelBuffer multiply();
        public native @Name("operator ->") HardwarePixelBuffer access();
        public native HardwarePixelBuffer get();
        public native void bind(HardwarePixelBuffer rep, @Cast("Ogre::SharedPtrFreeMethod") int inFreeMethod/*=Ogre::SPFM_DELETE*/);
        public native void bind(HardwarePixelBuffer rep);

        public native @Cast("bool") boolean unique();
        public native @Cast("unsigned int") int useCount();
        public native void setUseCount(@Cast("unsigned") int value);

        public native HardwarePixelBuffer getPointer();

        public native @Cast("bool") boolean isNull();

        public native void setNull();
    }
    @Name("Ogre::SharedPtr<Ogre::v1::HardwareUniformBuffer>") @NoOffset public static class HardwareUniformBufferSPtr extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareUniformBufferSPtr(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public HardwareUniformBufferSPtr(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public HardwareUniformBufferSPtr position(long position) {
            return (HardwareUniformBufferSPtr)super.position(position);
        }
    




        public HardwareUniformBufferSPtr() { super((Pointer)null); allocate(); }
        private native void allocate();

        public HardwareUniformBufferSPtr(@Cast("const Ogre::SharedPtr<Ogre::v1::HardwareUniformBuffer>*") @ByRef HardwareUniformBufferSPtr r) { super((Pointer)null); allocate(r); }
        private native void allocate(@Cast("const Ogre::SharedPtr<Ogre::v1::HardwareUniformBuffer>*") @ByRef HardwareUniformBufferSPtr r);

        public native @Cast("Ogre::SharedPtr<Ogre::v1::HardwareUniformBuffer>*") @ByRef @Name("operator =") HardwareUniformBufferSPtr put(@Cast("const Ogre::SharedPtr<Ogre::v1::HardwareUniformBuffer>*") @ByRef HardwareUniformBufferSPtr r);

        public native @ByRef @Name("operator *") HardwareUniformBuffer multiply();
        public native @Name("operator ->") HardwareUniformBuffer access();
        public native HardwareUniformBuffer get();
        public native void bind(HardwareUniformBuffer rep, @Cast("Ogre::SharedPtrFreeMethod") int inFreeMethod/*=Ogre::SPFM_DELETE*/);
        public native void bind(HardwareUniformBuffer rep);

        public native @Cast("bool") boolean unique();
        public native @Cast("unsigned int") int useCount();
        public native void setUseCount(@Cast("unsigned") int value);

        public native HardwareUniformBuffer getPointer();

        public native @Cast("bool") boolean isNull();

        public native void setNull();
    }
    @Name("Ogre::SharedPtr<Ogre::v1::HardwareVertexBuffer>") @NoOffset public static class HardwareVertexBufferSPtr extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareVertexBufferSPtr(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public HardwareVertexBufferSPtr(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public HardwareVertexBufferSPtr position(long position) {
            return (HardwareVertexBufferSPtr)super.position(position);
        }
    




        public HardwareVertexBufferSPtr() { super((Pointer)null); allocate(); }
        private native void allocate();

        public HardwareVertexBufferSPtr(@Cast("const Ogre::SharedPtr<Ogre::v1::HardwareVertexBuffer>*") @ByRef HardwareVertexBufferSPtr r) { super((Pointer)null); allocate(r); }
        private native void allocate(@Cast("const Ogre::SharedPtr<Ogre::v1::HardwareVertexBuffer>*") @ByRef HardwareVertexBufferSPtr r);

        public native @Cast("Ogre::SharedPtr<Ogre::v1::HardwareVertexBuffer>*") @ByRef @Name("operator =") HardwareVertexBufferSPtr put(@Cast("const Ogre::SharedPtr<Ogre::v1::HardwareVertexBuffer>*") @ByRef HardwareVertexBufferSPtr r);

        public native @ByRef @Name("operator *") HardwareVertexBuffer multiply();
        public native @Name("operator ->") HardwareVertexBuffer access();
        public native HardwareVertexBuffer get();
        public native void bind(HardwareVertexBuffer rep, @Cast("Ogre::SharedPtrFreeMethod") int inFreeMethod/*=Ogre::SPFM_DELETE*/);
        public native void bind(HardwareVertexBuffer rep);

        public native @Cast("bool") boolean unique();
        public native @Cast("unsigned int") int useCount();
        public native void setUseCount(@Cast("unsigned") int value);

        public native HardwareVertexBuffer getPointer();

        public native @Cast("bool") boolean isNull();

        public native void setNull();
    }







        @Name("std::hash<Ogre::SharedPtr<Ogre::_StringBase> >") public static class StringBaseHashRef extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public StringBaseHashRef() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public StringBaseHashRef(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public StringBaseHashRef(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public StringBaseHashRef position(long position) {
                return (StringBaseHashRef)super.position(position);
            }
        

            public native @Cast("std::hash<Ogre::SharedPtr<Ogre::_StringBase> >::result_type") @Name("operator ()") long apply( @Cast("const std::hash<Ogre::SharedPtr<Ogre::_StringBase> >::argument_type*") @ByRef RealControllerFunctionSPtr k );
        }




    @Namespace("Ogre") @NoOffset public static class ColourValue extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ColourValue(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ColourValue(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ColourValue position(long position) {
            return (ColourValue)super.position(position);
        }
    
        @MemberGetter public static native @Const @ByRef ColourValue ZERO();
        @MemberGetter public static native @Const @ByRef ColourValue Black();
        @MemberGetter public static native @Const @ByRef ColourValue White();
        @MemberGetter public static native @Const @ByRef ColourValue Red();
        @MemberGetter public static native @Const @ByRef ColourValue Green();
        @MemberGetter public static native @Const @ByRef ColourValue Blue();

        public ColourValue( float red/*=1.0f*/,
                            float green/*=1.0f*/,
                            float blue/*=1.0f*/,
                            float alpha/*=1.0f*/ ) { super((Pointer)null); allocate(red, green, blue, alpha); }
        private native void allocate( float red/*=1.0f*/,
                            float green/*=1.0f*/,
                            float blue/*=1.0f*/,
                            float alpha/*=1.0f*/ );
        public ColourValue( ) { super((Pointer)null); allocate(); }
        private native void allocate( );

        public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef ColourValue rhs);
        public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef ColourValue rhs);

        public native float r(); public native ColourValue r(float r);
        public native float g(); public native ColourValue g(float g);
        public native float b(); public native ColourValue b(float b);
        public native float a(); public native ColourValue a(float a);



        public native @Cast("Ogre::RGBA") int getAsRGBA();



        public native @Cast("Ogre::ARGB") int getAsARGB();



        public native @Cast("Ogre::BGRA") int getAsBGRA();


        public native @Cast("Ogre::ABGR") int getAsABGR();



        public native void setAsRGBA(@Cast("const Ogre::RGBA") int val);



        public native void setAsARGB(@Cast("const Ogre::ARGB") int val);



        public native void setAsBGRA(@Cast("const Ogre::BGRA") int val);



        public native void setAsABGR(@Cast("const Ogre::ABGR") int val);



        public native void saturate();



        public native @ByVal ColourValue saturateCopy();


        public native @ByRef @Name("operator []") FloatPointer get( @Cast("const size_t") long i );


        public native FloatPointer ptr();



        public native @ByVal @Name("operator +") ColourValue add( @Const @ByRef ColourValue rkVector );

        public native @ByVal @Name("operator -") ColourValue subtract( @Const @ByRef ColourValue rkVector );

        public native @ByVal @Name("operator *") ColourValue multiply(float fScalar );

        public native @ByVal @Name("operator *") ColourValue multiply( @Const @ByRef ColourValue rhs);

        public native @ByVal @Name("operator /") ColourValue divide( @Const @ByRef ColourValue rhs);

        public native @ByVal @Name("operator /") ColourValue divide(float fScalar );

        


        public native @ByRef @Name("operator +=") ColourValue addPut( @Const @ByRef ColourValue rkVector );

        public native @ByRef @Name("operator -=") ColourValue subtractPut( @Const @ByRef ColourValue rkVector );

        public native @ByRef @Name("operator *=") ColourValue multiplyPut(float fScalar );

        public native @ByRef @Name("operator /=") ColourValue dividePut(float fScalar );






        public native void setHSB(double hue, double saturation, double brightness);






        public native void getHSB(double hue, double saturation, double brightness);





        

    }



    /** enum Ogre::BufferType */
    public static final int


        BT_IMMUTABLE = 0,
        BT_DEFAULT = 1,






        BT_DYNAMIC_DEFAULT = 2,


        BT_DYNAMIC_PERSISTENT = 3,


        BT_DYNAMIC_PERSISTENT_COHERENT = 4;

    /** enum Ogre::MappingState */
    public static final int
        MS_UNMAPPED = 0,
        MS_MAPPED = 1,
        NUM_MAPPING_STATE = 2;

    /** enum Ogre::UnmapOptions */
    public static final int

        UO_UNMAP_ALL = 0,



        UO_KEEP_PERSISTENT = 1;

    /** enum Ogre::BufferPackedTypes */
    public static final int
        BP_TYPE_VERTEX = 0,
        BP_TYPE_INDEX = 1,
        BP_TYPE_CONST = 2,
        BP_TYPE_TEX = 3,
        BP_TYPE_INDIRECT = 4,
        NUM_BUFFER_PACKED_TYPES = 5;
    @Namespace("Ogre") @NoOffset public static class FreeOnDestructor extends Pointer {
        static { Loader.load(); }
    
        public native Pointer ptr(); public native FreeOnDestructor ptr(Pointer ptr);
        public FreeOnDestructor( Pointer _ptr ) { super((Pointer)null); allocate(_ptr); }
        private native void allocate( Pointer _ptr );
    }

    @Namespace("Ogre") @NoOffset public static class BufferPacked extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public BufferPacked(Pointer p) { super(p); }
    


        public native @Cast("Ogre::BufferPackedTypes") int getBufferPackedType();

        public native @Cast("Ogre::BufferType") int getBufferType();
        public native BufferInterface getBufferInterface();



        public native @ByVal @Cast("Ogre::AsyncTicketPtr*") RealControllerFunctionSPtr readRequest( @Cast("size_t") long elementStart, @Cast("size_t") long elementCount );
        public native void upload( @Const Pointer data, @Cast("size_t") long elementStart, @Cast("size_t") long elementCount );
        public native Pointer map( @Cast("size_t") long elementStart, @Cast("size_t") long elementCount, @Cast("bool") boolean bAdvanceFrame/*=true*/ );
        public native Pointer map( @Cast("size_t") long elementStart, @Cast("size_t") long elementCount );
        public native void unmap( @Cast("Ogre::UnmapOptions") int unmapOption, @Cast("size_t") long flushStartElem/*=0*/, @Cast("size_t") long flushSizeElem/*=0*/ );
        public native void unmap( @Cast("Ogre::UnmapOptions") int unmapOption );



        public native void advanceFrame();




        public native void regressFrame();





        public native @Cast("Ogre::MappingState") int getMappingState();




        public native @Cast("bool") boolean isCurrentlyMapped();

        public native @Cast("Ogre::uint32") int getNumElements();
        public native @Cast("Ogre::uint32") int getBytesPerElement();
        public native @Cast("Ogre::uint32") int getTotalSizeBytes();

        public native @Cast("size_t") long _getInternalBufferStart();
        public native @Cast("size_t") long _getFinalBufferStart();

        public native @Const Pointer getShadowCopy();
    }


    /** enum Ogre::VertexElementSemantic */
    public static final int

        VES_POSITION = 1,

        VES_BLEND_WEIGHTS = 2,

        VES_BLEND_INDICES = 3,

        VES_NORMAL = 4,

        VES_DIFFUSE = 5,

        VES_SPECULAR = 6,


        VES_TEXTURE_COORDINATES = 7,

        VES_BINORMAL = 8,

        VES_TANGENT = 9,

        VES_BLEND_WEIGHTS2 = 10,

        VES_BLEND_INDICES2 = 11,

        VES_COUNT = 11;




    /** enum Ogre::VertexElementType */
    public static final int
        VET_FLOAT1 = 0,
        VET_FLOAT2 = 1,
        VET_FLOAT3 = 2,
        VET_FLOAT4 = 3,

        VET_COLOUR = 4,

        VET_SHORT2 = 6,

        VET_SHORT4 = 8,
        VET_UBYTE4 = 9,

        VET_COLOUR_ARGB = 10,

        VET_COLOUR_ABGR = 11,
        VET_DOUBLE1 = 12,
        VET_DOUBLE2 = 13,
        VET_DOUBLE3 = 14,
        VET_DOUBLE4 = 15,
        VET_USHORT1_DEPRECATED = 16,
        VET_USHORT2 = 17,
        VET_USHORT3_DEPRECATED = 18,
        VET_USHORT4 = 19,
        VET_INT1 = 20,
        VET_INT2 = 21,
        VET_INT3 = 22,
        VET_INT4 = 23,
        VET_UINT1 = 24,
        VET_UINT2 = 25,
        VET_UINT3 = 26,
        VET_UINT4 = 27,
        VET_BYTE4 = 28,
        VET_BYTE4_SNORM = 29,
        VET_UBYTE4_NORM = 30,
        VET_SHORT2_SNORM = 31,
        VET_SHORT4_SNORM = 32,
        VET_USHORT2_NORM = 33,
        VET_USHORT4_NORM = 34,
        VET_HALF2 = 35,
        VET_HALF4 = 36;

    @Namespace("Ogre") @NoOffset public static class VertexElement2 extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public VertexElement2(Pointer p) { super(p); }
    

        public native @Cast("Ogre::VertexElementType") int mType(); public native VertexElement2 mType(int mType);

        public native @Cast("Ogre::VertexElementSemantic") int mSemantic(); public native VertexElement2 mSemantic(int mSemantic);

        public VertexElement2( @Cast("Ogre::VertexElementType") int type, @Cast("Ogre::VertexElementSemantic") int semantic ) { super((Pointer)null); allocate(type, semantic); }
        private native void allocate( @Cast("Ogre::VertexElementType") int type, @Cast("Ogre::VertexElementSemantic") int semantic );

        public native @Cast("bool") @Name("operator ==") boolean equals( @Const @ByVal VertexElement2 _r );

        public native @Cast("bool") @Name("operator ==") boolean equals( @Cast("Ogre::VertexElementSemantic") int semantic );
    }

    @Namespace("Ogre") @NoOffset public static class VertexBufferPacked extends BufferPacked {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public VertexBufferPacked(Pointer p) { super(p); }
    
        public VertexBufferPacked( @Cast("size_t") long internalBufferStartBytes, @Cast("size_t") long numElements, @Cast("Ogre::uint32") int bytesPerElement,
                                    @Cast("Ogre::BufferType") int bufferType, Pointer initialData, @Cast("bool") boolean keepAsShadow,
                                    VaoManager vaoManager, BufferInterface bufferInterface,
                                    @Cast("const Ogre::VertexElement2Vec*") @ByRef VertexElement2VectorRef vertexElements, @Cast("size_t") long multiSourceId,
                                    MultiSourceVertexBufferPool multiSourcePool, @Cast("Ogre::uint8") byte sourceIdx ) { super((Pointer)null); allocate(internalBufferStartBytes, numElements, bytesPerElement, bufferType, initialData, keepAsShadow, vaoManager, bufferInterface, vertexElements, multiSourceId, multiSourcePool, sourceIdx); }
        private native void allocate( @Cast("size_t") long internalBufferStartBytes, @Cast("size_t") long numElements, @Cast("Ogre::uint32") int bytesPerElement,
                                    @Cast("Ogre::BufferType") int bufferType, Pointer initialData, @Cast("bool") boolean keepAsShadow,
                                    VaoManager vaoManager, BufferInterface bufferInterface,
                                    @Cast("const Ogre::VertexElement2Vec*") @ByRef VertexElement2VectorRef vertexElements, @Cast("size_t") long multiSourceId,
                                    MultiSourceVertexBufferPool multiSourcePool, @Cast("Ogre::uint8") byte sourceIdx );

        public native @Cast("Ogre::BufferPackedTypes") int getBufferPackedType();

        public native @Cast("const Ogre::VertexElement2Vec*") @ByRef VertexElement2VectorRef getVertexElements();

        public native @Cast("size_t") long getMultiSourceId();


        public native MultiSourceVertexBufferPool getMultiSourcePool();






        public native @Cast("Ogre::uint8") byte _getSourceIndex();
    }

    @Namespace("Ogre::v1") @NoOffset public static class HardwareVertexBuffer extends HardwareBuffer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareVertexBuffer(Pointer p) { super(p); }
    

            public HardwareVertexBuffer(HardwareBufferManagerBase mgr, @Cast("size_t") long vertexSize, @Cast("size_t") long numVertices,
                            @Cast("Ogre::v1::HardwareBuffer::Usage") int usage, @Cast("bool") boolean useSystemMemory, @Cast("bool") boolean useShadowBuffer) { super((Pointer)null); allocate(mgr, vertexSize, numVertices, usage, useSystemMemory, useShadowBuffer); }
            private native void allocate(HardwareBufferManagerBase mgr, @Cast("size_t") long vertexSize, @Cast("size_t") long numVertices,
                            @Cast("Ogre::v1::HardwareBuffer::Usage") int usage, @Cast("bool") boolean useSystemMemory, @Cast("bool") boolean useShadowBuffer);

            public native HardwareBufferManagerBase getManager();

            public native @Cast("size_t") long getVertexSize();

            public native @Cast("size_t") long getNumVertices();

            public native @Cast("bool") boolean getIsInstanceData();

            public native void setIsInstanceData(@Cast("const bool") boolean val);

            public native @Cast("size_t") long getInstanceDataStepRate();

            public native void setInstanceDataStepRate(@Cast("const size_t") long val);




    }


    @Namespace("Ogre::v1") public static class HardwareVertexBufferSharedPtr extends HardwareVertexBufferSPtr {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareVertexBufferSharedPtr(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public HardwareVertexBufferSharedPtr(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public HardwareVertexBufferSharedPtr position(long position) {
            return (HardwareVertexBufferSharedPtr)super.position(position);
        }
    
        public HardwareVertexBufferSharedPtr() { super((Pointer)null); allocate(); }
        private native void allocate();
        public HardwareVertexBufferSharedPtr(HardwareVertexBuffer buf) { super((Pointer)null); allocate(buf); }
        private native void allocate(HardwareVertexBuffer buf);


    }

    @Namespace("Ogre::v1") @NoOffset public static class VertexElement extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public VertexElement(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public VertexElement(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public VertexElement position(long position) {
            return (VertexElement)super.position(position);
        }
    

        public VertexElement() { super((Pointer)null); allocate(); }
        private native void allocate();

        public VertexElement(@Cast("unsigned short") short source, @Cast("size_t") long offset, @Cast("Ogre::VertexElementType") int theType,
                    @Cast("Ogre::VertexElementSemantic") int semantic, @Cast("unsigned short") short index/*=0*/) { super((Pointer)null); allocate(source, offset, theType, semantic, index); }
        private native void allocate(@Cast("unsigned short") short source, @Cast("size_t") long offset, @Cast("Ogre::VertexElementType") int theType,
                    @Cast("Ogre::VertexElementSemantic") int semantic, @Cast("unsigned short") short index/*=0*/);
        public VertexElement(@Cast("unsigned short") short source, @Cast("size_t") long offset, @Cast("Ogre::VertexElementType") int theType,
                    @Cast("Ogre::VertexElementSemantic") int semantic) { super((Pointer)null); allocate(source, offset, theType, semantic); }
        private native void allocate(@Cast("unsigned short") short source, @Cast("size_t") long offset, @Cast("Ogre::VertexElementType") int theType,
                    @Cast("Ogre::VertexElementSemantic") int semantic);

        public native @Cast("unsigned short") short getSource();

        public native @Cast("size_t") long getOffset();

        public native @Cast("Ogre::VertexElementType") int getType();

        public native @Cast("Ogre::VertexElementSemantic") int getSemantic();

        public native @Cast("unsigned short") short getIndex();

        public native @Cast("size_t") long getSize();

        public static native @Cast("size_t") long getTypeSize(@Cast("Ogre::VertexElementType") int etype);

        public static native @Cast("unsigned short") short getTypeCount(@Cast("Ogre::VertexElementType") int etype);

        public static native @Cast("bool") boolean isTypeNormalized(@Cast("Ogre::VertexElementType") int etype);



        public static native @Cast("Ogre::VertexElementType") int multiplyTypeCount(@Cast("Ogre::VertexElementType") int baseType, @Cast("unsigned short") short count);



        public static native @Cast("Ogre::VertexElementType") int getBaseType(@Cast("Ogre::VertexElementType") int multiType);







        public static native void convertColourValue(@Cast("Ogre::VertexElementType") int srcType,
                    @Cast("Ogre::VertexElementType") int dstType, @Cast("Ogre::uint32*") IntPointer ptr);
        public static native void convertColourValue(@Cast("Ogre::VertexElementType") int srcType,
                    @Cast("Ogre::VertexElementType") int dstType, @Cast("Ogre::uint32*") IntBuffer ptr);
        public static native void convertColourValue(@Cast("Ogre::VertexElementType") int srcType,
                    @Cast("Ogre::VertexElementType") int dstType, @Cast("Ogre::uint32*") int[] ptr);






        public static native @Cast("Ogre::uint32") int convertColourValue(@Const @ByRef ColourValue src,
                    @Cast("Ogre::VertexElementType") int dst);


        public static native @Cast("Ogre::VertexElementType") int getBestColourVertexElementType();

        public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef VertexElement rhs);







        public native void baseVertexPointerToElement(Pointer pBase, @Cast("void**") PointerPointer pElem);
        public native void baseVertexPointerToElement(Pointer pBase, @Cast("void**") @ByPtrPtr Pointer pElem);







        public native void baseVertexPointerToElement(Pointer pBase, @ByPtrPtr FloatPointer pElem);
        public native void baseVertexPointerToElement(Pointer pBase, @ByPtrPtr FloatBuffer pElem);
        public native void baseVertexPointerToElement(Pointer pBase, @ByPtrPtr float[] pElem);
        public native void baseVertexPointerToElement(Pointer pBase, @Cast("Ogre::RGBA**") @ByPtrPtr IntPointer pElem);
        public native void baseVertexPointerToElement(Pointer pBase, @Cast("Ogre::RGBA**") @ByPtrPtr IntBuffer pElem);
        public native void baseVertexPointerToElement(Pointer pBase, @Cast("Ogre::RGBA**") @ByPtrPtr int[] pElem);







        public native void baseVertexPointerToElement(Pointer pBase, @Cast("unsigned char**") @ByPtrPtr BytePointer pElem);
        public native void baseVertexPointerToElement(Pointer pBase, @Cast("unsigned char**") @ByPtrPtr ByteBuffer pElem);
        public native void baseVertexPointerToElement(Pointer pBase, @Cast("unsigned char**") @ByPtrPtr byte[] pElem);
        public native void baseVertexPointerToElement(Pointer pBase, @Cast("unsigned short**") @ByPtrPtr ShortPointer pElem);
        public native void baseVertexPointerToElement(Pointer pBase, @Cast("unsigned short**") @ByPtrPtr ShortBuffer pElem);
        public native void baseVertexPointerToElement(Pointer pBase, @Cast("unsigned short**") @ByPtrPtr short[] pElem);


    }
    @Namespace("Ogre::v1") @NoOffset public static class VertexDeclaration extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public VertexDeclaration(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public VertexDeclaration(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public VertexDeclaration position(long position) {
            return (VertexDeclaration)super.position(position);
        }
    

        public static native @Cast("bool") boolean vertexElementLess(@Const @ByRef VertexElement e1, @Const @ByRef VertexElement e2);
        public static native @Cast("bool") boolean vertexElementLessForV2(@Const @ByRef VertexElement e1, @Const @ByRef VertexElement e2);

        public VertexDeclaration() { super((Pointer)null); allocate(); }
        private native void allocate();


        public native @Cast("size_t") long getElementCount();

        public native @Cast("const Ogre::v1::VertexDeclaration::VertexElementList*") @ByRef VertexElementListRef getElements();

        public native @Const VertexElement getElement(@Cast("unsigned short") short index);
        public native void sort();

        public native void sortForV2();
        public native void closeGapsInSource();
        public native VertexDeclaration getAutoOrganisedDeclaration(@Cast("bool") boolean skeletalAnimation,
                    @Cast("bool") boolean vertexAnimation, @Cast("bool") boolean vertexAnimationNormals);


        public native @Cast("unsigned short") short getMaxSource();
        public native @Const @ByRef VertexElement addElement(@Cast("unsigned short") short source, @Cast("size_t") long offset, @Cast("Ogre::VertexElementType") int theType,
                    @Cast("Ogre::VertexElementSemantic") int semantic, @Cast("unsigned short") short index/*=0*/);
        public native @Const @ByRef VertexElement addElement(@Cast("unsigned short") short source, @Cast("size_t") long offset, @Cast("Ogre::VertexElementType") int theType,
                    @Cast("Ogre::VertexElementSemantic") int semantic);
        public native @Const @ByRef VertexElement insertElement(@Cast("unsigned short") short atPosition,
                    @Cast("unsigned short") short source, @Cast("size_t") long offset, @Cast("Ogre::VertexElementType") int theType,
                    @Cast("Ogre::VertexElementSemantic") int semantic, @Cast("unsigned short") short index/*=0*/);
        public native @Const @ByRef VertexElement insertElement(@Cast("unsigned short") short atPosition,
                    @Cast("unsigned short") short source, @Cast("size_t") long offset, @Cast("Ogre::VertexElementType") int theType,
                    @Cast("Ogre::VertexElementSemantic") int semantic);


        public native void removeElement(@Cast("unsigned short") short elem_index);







        public native void removeElement(@Cast("Ogre::VertexElementSemantic") int semantic, @Cast("unsigned short") short index/*=0*/);
        public native void removeElement(@Cast("Ogre::VertexElementSemantic") int semantic);


        public native void removeAllElements();






        public native void modifyElement(@Cast("unsigned short") short elem_index, @Cast("unsigned short") short source, @Cast("size_t") long offset, @Cast("Ogre::VertexElementType") int theType,
                    @Cast("Ogre::VertexElementSemantic") int semantic, @Cast("unsigned short") short index/*=0*/);
        public native void modifyElement(@Cast("unsigned short") short elem_index, @Cast("unsigned short") short source, @Cast("size_t") long offset, @Cast("Ogre::VertexElementType") int theType,
                    @Cast("Ogre::VertexElementSemantic") int semantic);






        public native @Const VertexElement findElementBySemantic(@Cast("Ogre::VertexElementSemantic") int sem, @Cast("unsigned short") short index/*=0*/);
        public native @Const VertexElement findElementBySemantic(@Cast("Ogre::VertexElementSemantic") int sem);
        public native @ByVal @Cast("Ogre::v1::VertexDeclaration::VertexElementList*") VertexElementListRef findElementsBySource(@Cast("unsigned short") short source);


        public native @Cast("size_t") long getVertexSize(@Cast("unsigned short") short source);




        public native @Cast("unsigned short") short getNextFreeTextureCoordinate();





        public native VertexDeclaration clone(HardwareBufferManagerBase mgr/*=0*/);
        public native VertexDeclaration clone();

        public native @ByVal @Cast("Ogre::VertexElement2VecVec*") VertexElement2VecVectorRef convertToV2();
        public native void convertFromV2( @Cast("const Ogre::VertexElement2Vec*") @ByRef VertexElement2VectorRef v2Decl );
        public native void convertFromV2( @Cast("const Ogre::VertexElement2VecVec*") @ByRef VertexElement2VecVectorRef v2Decl );

        public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef VertexDeclaration rhs);
        public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef VertexDeclaration rhs);

    }
    @Namespace("Ogre::v1") @NoOffset public static class VertexBufferBinding extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public VertexBufferBinding(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public VertexBufferBinding(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public VertexBufferBinding position(long position) {
            return (VertexBufferBinding)super.position(position);
        }
    

        public VertexBufferBinding() { super((Pointer)null); allocate(); }
        private native void allocate();
        public native void setBinding(@Cast("unsigned short") short index, @Const @ByRef HardwareVertexBufferSharedPtr buffer);

        public native void unsetBinding(@Cast("unsigned short") short index);


        public native void unsetAllBindings();


        public native @Cast("const Ogre::v1::VertexBufferBinding::VertexBufferBindingMap*") @ByRef HardwareVertexBufferSharedPtrMapRef getBindings();


        public native @Const @ByRef HardwareVertexBufferSharedPtr getBuffer(@Cast("unsigned short") short index);

        public native @Cast("bool") boolean isBufferBound(@Cast("unsigned short") short index);

        public native @Cast("size_t") long getBufferCount();






        public native @Cast("unsigned short") short getNextIndex();



        public native @Cast("unsigned short") short getLastBoundIndex();



        public native @Cast("bool") boolean hasGaps();
        public native void closeGaps(@Cast("Ogre::v1::VertexBufferBinding::BindingIndexMap*") @ByRef UshortMapRef bindingIndexMap);


        public native @Cast("bool") boolean getHasInstanceData();


    }






    @Namespace("Ogre::v1") @NoOffset public static class Pose extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Pose(Pointer p) { super(p); }
    





        public Pose(short target, @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String name) { super((Pointer)null); allocate(target, name); }
        private native void allocate(short target, @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String name);
        public Pose(short target) { super((Pointer)null); allocate(target); }
        private native void allocate(short target);

        public native @Const @ByRef String getName();

        public native short getTarget();

        public native @Cast("bool") boolean getIncludesNormals();





        public native void addVertex(@Cast("size_t") long index, @Const @ByRef Vector3 offset);





        public native void addVertex(@Cast("size_t") long index, @Const @ByRef Vector3 offset, @Const @ByRef Vector3 normal);


        public native void removeVertex(@Cast("size_t") long index);


        public native void clearVertices();

        public native @ByVal @Cast("Ogre::v1::Pose::VertexOffsetIterator*") AnimationStateMapIteratorRef getVertexOffsetIterator();

        public native @Cast("const Ogre::v1::Pose::VertexOffsetMap*") @ByRef Vector3MapRef getVertexOffsets();

        public native @ByVal @Cast("Ogre::v1::Pose::NormalsIterator*") AnimationStateMapIteratorRef getNormalsIterator();

        public native @Cast("const Ogre::v1::Pose::NormalsMap*") @ByRef Vector3MapRef getNormals();


        public native @Const @ByRef HardwareVertexBufferSharedPtr _getHardwareVertexBuffer(@Const VertexData origData);




        public native Pose clone();
    }






    @Namespace("Ogre::v1") @NoOffset public static class TimeIndex extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public TimeIndex(Pointer p) { super(p); }
    


        public TimeIndex(double timePos) { super((Pointer)null); allocate(timePos); }
        private native void allocate(double timePos);






        public TimeIndex(double timePos, @Cast("Ogre::uint") int keyIndex) { super((Pointer)null); allocate(timePos, keyIndex); }
        private native void allocate(double timePos, @Cast("Ogre::uint") int keyIndex);

        public native @Cast("bool") boolean hasKeyIndex();

        public native double getTimePos();

        public native @Cast("Ogre::uint") int getKeyIndex();
    }
    @Namespace("Ogre::v1") @NoOffset public static class AnimationTrack extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public AnimationTrack(Pointer p) { super(p); }
    




        public static class Listener extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Listener(Pointer p) { super(p); }
        




            public native @Cast("bool") boolean getInterpolatedKeyFrame(@Const AnimationTrack t, @Const @ByRef TimeIndex timeIndex, KeyFrame kf);
        }


        public native @Cast("unsigned short") short getHandle();


        public native @Cast("unsigned short") short getNumKeyFrames();


        public native KeyFrame getKeyFrame(@Cast("unsigned short") short index);
        public native double getKeyFramesAtTime(@Const @ByRef TimeIndex timeIndex, @Cast("Ogre::v1::KeyFrame**") PointerPointer keyFrame1, @Cast("Ogre::v1::KeyFrame**") PointerPointer keyFrame2,
                    @Cast("unsigned short*") ShortPointer firstKeyIndex/*=0*/);
        public native double getKeyFramesAtTime(@Const @ByRef TimeIndex timeIndex, @ByPtrPtr KeyFrame keyFrame1, @ByPtrPtr KeyFrame keyFrame2);
        public native double getKeyFramesAtTime(@Const @ByRef TimeIndex timeIndex, @ByPtrPtr KeyFrame keyFrame1, @ByPtrPtr KeyFrame keyFrame2,
                    @Cast("unsigned short*") ShortPointer firstKeyIndex/*=0*/);
        public native double getKeyFramesAtTime(@Const @ByRef TimeIndex timeIndex, @ByPtrPtr KeyFrame keyFrame1, @ByPtrPtr KeyFrame keyFrame2,
                    @Cast("unsigned short*") ShortBuffer firstKeyIndex/*=0*/);
        public native double getKeyFramesAtTime(@Const @ByRef TimeIndex timeIndex, @ByPtrPtr KeyFrame keyFrame1, @ByPtrPtr KeyFrame keyFrame2,
                    @Cast("unsigned short*") short[] firstKeyIndex/*=0*/);
        public native KeyFrame createKeyFrame(double timePos);


        public native void removeKeyFrame(@Cast("unsigned short") short index);


        public native void removeAllKeyFrames();
        public native void getInterpolatedKeyFrame(@Const @ByRef TimeIndex timeIndex, KeyFrame kf);
        public native void apply(@Const @ByRef TimeIndex timeIndex, double weight/*=1.0*/, double scale/*=1.0f*/);
        public native void apply(@Const @ByRef TimeIndex timeIndex);



        public native void _keyFrameDataChanged();





        public native @Cast("bool") boolean hasNonZeroKeyFrames();


        public native void optimise();


        public native void _collectKeyFrameTimes(@Cast("vector<Ogre::Real>::type*") @ByRef RealVectorRef keyFrameTimes);



        public native void _buildKeyFrameIndexMap(@Cast("const vector<Ogre::Real>::type*") @ByRef RealVectorRef keyFrameTimes);


        public native void _applyBaseKeyFrame(@Const KeyFrame base);


        public native void setListener(Listener l);


        public native Animation getParent();



    }



    @Namespace("Ogre::v1") @NoOffset public static class NumericAnimationTrack extends AnimationTrack {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public NumericAnimationTrack(Pointer p) { super(p); }
    

        public NumericAnimationTrack(Animation parent, @Cast("unsigned short") short handle) { super((Pointer)null); allocate(parent, handle); }
        private native void allocate(Animation parent, @Cast("unsigned short") short handle);

        public NumericAnimationTrack(Animation parent, @Cast("unsigned short") short handle,
                    @Cast("Ogre::AnimableValuePtr*") @ByRef RealControllerFunctionSPtr target) { super((Pointer)null); allocate(parent, handle, target); }
        private native void allocate(Animation parent, @Cast("unsigned short") short handle,
                    @Cast("Ogre::AnimableValuePtr*") @ByRef RealControllerFunctionSPtr target);
        public native NumericKeyFrame createNumericKeyFrame(double timePos);


        public native void getInterpolatedKeyFrame(@Const @ByRef TimeIndex timeIndex, KeyFrame kf);


        public native void apply(@Const @ByRef TimeIndex timeIndex, double weight/*=1.0*/, double scale/*=1.0f*/);
        public native void apply(@Const @ByRef TimeIndex timeIndex);
        public native void applyToAnimable(@Cast("const Ogre::AnimableValuePtr*") @ByRef RealControllerFunctionSPtr anim, @Const @ByRef TimeIndex timeIndex,
                    double weight/*=1.0*/, double scale/*=1.0f*/);
        public native void applyToAnimable(@Cast("const Ogre::AnimableValuePtr*") @ByRef RealControllerFunctionSPtr anim, @Const @ByRef TimeIndex timeIndex);


        public native @Cast("const Ogre::AnimableValuePtr*") @ByRef RealControllerFunctionSPtr getAssociatedAnimable();



        public native void setAssociatedAnimable(@Cast("const Ogre::AnimableValuePtr*") @ByRef RealControllerFunctionSPtr val);


        public native NumericKeyFrame getNumericKeyFrame(@Cast("unsigned short") short index);


        public native NumericAnimationTrack _clone(Animation newParent);


    }



 @Namespace("Ogre::v1") @NoOffset public static class NodeAnimationTrack extends AnimationTrack {
     static { Loader.load(); }
     /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
     public NodeAnimationTrack(Pointer p) { super(p); }
 

  public NodeAnimationTrack(Animation parent, @Cast("unsigned short") short handle) { super((Pointer)null); allocate(parent, handle); }
  private native void allocate(Animation parent, @Cast("unsigned short") short handle);

  public NodeAnimationTrack(Animation parent, @Cast("unsigned short") short handle, Node targetNode) { super((Pointer)null); allocate(parent, handle, targetNode); }
  private native void allocate(Animation parent, @Cast("unsigned short") short handle, Node targetNode);







  public native TransformKeyFrame createNodeKeyFrame(double timePos);






        public native void getInitialState(Vector3 outPosition, Quaternion outOrientation, Vector3 outScale);
        public native void setInitialState(@Const @ByRef Vector3 position, @Const @ByRef Quaternion orientation, @Const @ByRef Vector3 scale);





  public native void resetNodeToInitialState();


  public native Node getAssociatedNode();


  public native void setAssociatedNode(Node node);


  public native void applyToNode(Node node, @Const @ByRef TimeIndex timeIndex, double weight/*=1.0*/, double scale/*=1.0f*/);
  public native void applyToNode(Node node, @Const @ByRef TimeIndex timeIndex);


  public native void setUseShortestRotationPath(@Cast("bool") boolean useShortestPath);


  public native @Cast("bool") boolean getUseShortestRotationPath();


  public native void getInterpolatedKeyFrame(@Const @ByRef TimeIndex timeIndex, KeyFrame kf);


  public native void apply(@Const @ByRef TimeIndex timeIndex, double weight/*=1.0*/, double scale/*=1.0f*/);
  public native void apply(@Const @ByRef TimeIndex timeIndex);


  public native void _keyFrameDataChanged();


  public native TransformKeyFrame getNodeKeyFrame(@Cast("unsigned short") short index);






  public native @Cast("bool") boolean hasNonZeroKeyFrames();


  public native void optimise();


  public native NodeAnimationTrack _clone(Animation newParent);

  public native void _applyBaseKeyFrame(@Const KeyFrame base);
 }



 @Namespace("Ogre::v1") @NoOffset public static class OldNodeAnimationTrack extends AnimationTrack {
     static { Loader.load(); }
     /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
     public OldNodeAnimationTrack(Pointer p) { super(p); }
 

  public OldNodeAnimationTrack(Animation parent, @Cast("unsigned short") short handle) { super((Pointer)null); allocate(parent, handle); }
  private native void allocate(Animation parent, @Cast("unsigned short") short handle);

  public OldNodeAnimationTrack(Animation parent, @Cast("unsigned short") short handle,
              OldNode targetNode) { super((Pointer)null); allocate(parent, handle, targetNode); }
  private native void allocate(Animation parent, @Cast("unsigned short") short handle,
              OldNode targetNode);







        public native TransformKeyFrame createNodeKeyFrame(double timePos);

  public native OldNode getAssociatedNode();


  public native void setAssociatedNode(OldNode node);


  public native void applyToNode(OldNode node, @Const @ByRef TimeIndex timeIndex, double weight/*=1.0*/,
              double scale/*=1.0f*/);
  public native void applyToNode(OldNode node, @Const @ByRef TimeIndex timeIndex);


        public native void setUseShortestRotationPath(@Cast("bool") boolean useShortestPath);


        public native @Cast("bool") boolean getUseShortestRotationPath();


        public native void getInterpolatedKeyFrame(@Const @ByRef TimeIndex timeIndex, KeyFrame kf);


        public native void apply(@Const @ByRef TimeIndex timeIndex, double weight/*=1.0*/, double scale/*=1.0f*/);
        public native void apply(@Const @ByRef TimeIndex timeIndex);


        public native void _keyFrameDataChanged();


        public native TransformKeyFrame getNodeKeyFrame(@Cast("unsigned short") short index);






        public native @Cast("bool") boolean hasNonZeroKeyFrames();


        public native void optimise();


  public native OldNodeAnimationTrack _clone(Animation newParent);

        public native void _applyBaseKeyFrame(@Const KeyFrame base);
    }
    /** enum Ogre::v1::VertexAnimationType */
    public static final int

        VAT_NONE = 0,

        VAT_MORPH = 1,

        VAT_POSE = 2;




    @Name("Ogre::VertexAnimationTrack") @NoOffset public static class VertexAnimationTrack extends AnimationTrack {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public VertexAnimationTrack(Pointer p) { super(p); }
    

        /** enum Ogre::VertexAnimationTrack::TargetMode */
        public static final int

            TM_SOFTWARE = 0,


            TM_HARDWARE = 1;

        public VertexAnimationTrack(Animation parent, @Cast("unsigned short") short handle, @ByVal VertexAnimationType animType) { super((Pointer)null); allocate(parent, handle, animType); }
        private native void allocate(Animation parent, @Cast("unsigned short") short handle, @ByVal VertexAnimationType animType);

        public VertexAnimationTrack(Animation parent, @Cast("unsigned short") short handle, @ByVal VertexAnimationType animType,
                    VertexData targetData, @Cast("Ogre::VertexAnimationTrack::TargetMode") int target/*=Ogre::VertexAnimationTrack::TM_SOFTWARE*/) { super((Pointer)null); allocate(parent, handle, animType, targetData, target); }
        private native void allocate(Animation parent, @Cast("unsigned short") short handle, @ByVal VertexAnimationType animType,
                    VertexData targetData, @Cast("Ogre::VertexAnimationTrack::TargetMode") int target/*=Ogre::VertexAnimationTrack::TM_SOFTWARE*/);
        public VertexAnimationTrack(Animation parent, @Cast("unsigned short") short handle, @ByVal VertexAnimationType animType,
                    VertexData targetData) { super((Pointer)null); allocate(parent, handle, animType, targetData); }
        private native void allocate(Animation parent, @Cast("unsigned short") short handle, @ByVal VertexAnimationType animType,
                    VertexData targetData);


        public native @ByVal VertexAnimationType getAnimationType();


        public native @Cast("bool") boolean getVertexAnimationIncludesNormals();
        public native VertexMorphKeyFrame createVertexMorphKeyFrame(double timePos);



        public native VertexPoseKeyFrame createVertexPoseKeyFrame(double timePos);



        public native void getInterpolatedKeyFrame(@Const @ByRef TimeIndex timeIndex, KeyFrame kf);


        public native void apply(@Const @ByRef TimeIndex timeIndex, double weight/*=1.0*/, double scale/*=1.0f*/);
        public native void apply(@Const @ByRef TimeIndex timeIndex);



        public native void applyToVertexData(VertexData data,
                    @Const @ByRef TimeIndex timeIndex, double weight/*=1.0*/,
                    @Const PoseList poseList/*=0*/);
        public native void applyToVertexData(VertexData data,
                    @Const @ByRef TimeIndex timeIndex);



        public native VertexMorphKeyFrame getVertexMorphKeyFrame(@Cast("unsigned short") short index);


        public native VertexPoseKeyFrame getVertexPoseKeyFrame(@Cast("unsigned short") short index);


        public native void setAssociatedVertexData(VertexData data);

        public native VertexData getAssociatedVertexData();


        public native void setTargetMode(@Cast("Ogre::VertexAnimationTrack::TargetMode") int m);

        public native @Cast("Ogre::VertexAnimationTrack::TargetMode") int getTargetMode();





        public native @Cast("bool") boolean hasNonZeroKeyFrames();


        public native void optimise();


        public native VertexAnimationTrack _clone(Animation newParent);

        public native void _applyBaseKeyFrame(@Const KeyFrame base);


    }




    @Name("Ogre::ControllerFunction<Ogre::Ogre::Real>") @NoOffset public static class RealControllerFunctionRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RealControllerFunctionRef(Pointer p) { super(p); }
    

        public native @Cast("Ogre::Ogre::Real") float calculate(@Cast("Ogre::Ogre::Real") float sourceValue);
    }




    @Name("Ogre::ControllerValue<Ogre::Ogre::Real>") public static class RealControllerValueRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RealControllerValueRef(Pointer p) { super(p); }
    
        public native @Cast("Ogre::Ogre::Real") float getValue();
        public native void setValue(@Cast("Ogre::Ogre::Real") float value);

    }
    @Name("Ogre::Controller") @NoOffset public static class RealControllerRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RealControllerRef(Pointer p) { super(p); }
    






        public RealControllerRef(@Cast("const Ogre::SharedPtr<Ogre::ControllerValue<Ogre::Ogre::Real> >*") @ByRef RealControllerValueSPtr src,
                    @Cast("const Ogre::SharedPtr<Ogre::ControllerValue<Ogre::Ogre::Real> >*") @ByRef RealControllerValueSPtr dest, @Cast("const Ogre::SharedPtr<Ogre::ControllerFunction<Ogre::Ogre::Real> >*") @ByRef RealControllerFunctionSPtr func) { super((Pointer)null); allocate(src, dest, func); }
        private native void allocate(@Cast("const Ogre::SharedPtr<Ogre::ControllerValue<Ogre::Ogre::Real> >*") @ByRef RealControllerValueSPtr src,
                    @Cast("const Ogre::SharedPtr<Ogre::ControllerValue<Ogre::Ogre::Real> >*") @ByRef RealControllerValueSPtr dest, @Cast("const Ogre::SharedPtr<Ogre::ControllerFunction<Ogre::Ogre::Real> >*") @ByRef RealControllerFunctionSPtr func);



        public native void setSource(@Cast("const Ogre::SharedPtr<Ogre::ControllerValue<Ogre::Ogre::Real> >*") @ByRef RealControllerValueSPtr src);

        public native @Cast("const Ogre::SharedPtr<Ogre::ControllerValue<Ogre::Ogre::Real> >*") @ByRef RealControllerValueSPtr getSource();

        public native void setDestination(@Cast("const Ogre::SharedPtr<Ogre::ControllerValue<Ogre::Ogre::Real> >*") @ByRef RealControllerValueSPtr dest);


        public native @Cast("const Ogre::SharedPtr<Ogre::ControllerValue<Ogre::Ogre::Real> >*") @ByRef RealControllerValueSPtr getDestination();


        public native @Cast("bool") boolean getEnabled();


        public native void setEnabled(@Cast("bool") boolean enabled);



        public native void setFunction(@Cast("const Ogre::SharedPtr<Ogre::ControllerFunction<Ogre::Ogre::Real> >*") @ByRef RealControllerFunctionSPtr func);



        public native @Cast("const Ogre::SharedPtr<Ogre::ControllerFunction<Ogre::Ogre::Real> >*") @ByRef RealControllerFunctionSPtr getFunction();






        public native void update();

    }





    @Namespace("Ogre::v1") @NoOffset public static class AnimationState extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public AnimationState(Pointer p) { super(p); }
    
        public AnimationState(@Const @ByRef String animName, AnimationStateSet parent,
                    double timePos, double length, double weight/*=1.0*/, @Cast("bool") boolean enabled/*=false*/) { super((Pointer)null); allocate(animName, parent, timePos, length, weight, enabled); }
        private native void allocate(@Const @ByRef String animName, AnimationStateSet parent,
                    double timePos, double length, double weight/*=1.0*/, @Cast("bool") boolean enabled/*=false*/);
        public AnimationState(@Const @ByRef String animName, AnimationStateSet parent,
                    double timePos, double length) { super((Pointer)null); allocate(animName, parent, timePos, length); }
        private native void allocate(@Const @ByRef String animName, AnimationStateSet parent,
                    double timePos, double length);

        public AnimationState(AnimationStateSet parent, @Const @ByRef AnimationState rhs) { super((Pointer)null); allocate(parent, rhs); }
        private native void allocate(AnimationStateSet parent, @Const @ByRef AnimationState rhs);


        public native @Const @ByRef String getAnimationName();

        public native double getTimePosition();

        public native void setTimePosition(double timePos);

        public native double getLength();

        public native void setLength(double len);

        public native double getWeight();

        public native void setWeight(double weight);





        public native void addTime(double offset);


        public native @Cast("bool") boolean hasEnded();


        public native @Cast("bool") boolean getEnabled();

        public native void setEnabled(@Cast("bool") boolean enabled);


        public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef AnimationState rhs);

        public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef AnimationState rhs);




        public native void setLoop(@Cast("bool") boolean loop);

        public native @Cast("bool") boolean getLoop();





        public native void copyStateFrom(@Const @ByRef AnimationState animState);


        public native AnimationStateSet getParent();
      public native void createBlendMask(@Cast("size_t") long blendMaskSizeHint, float initialWeight/*=1.0f*/);
      public native void createBlendMask(@Cast("size_t") long blendMaskSizeHint);

      public native void destroyBlendMask();







      public native void _setBlendMaskData(@Const FloatPointer blendMaskData);
      public native void _setBlendMaskData(@Const FloatBuffer blendMaskData);
      public native void _setBlendMaskData(@Const float[] blendMaskData);







      public native void _setBlendMask(@Cast("const Ogre::v1::AnimationState::BoneBlendMask*") FloatVectorRef blendMask);

      public native @Cast("const Ogre::v1::AnimationState::BoneBlendMask*") FloatVectorRef getBlendMask();

      public native @Cast("bool") boolean hasBlendMask();

      public native void setBlendMaskEntry(@Cast("size_t") long boneHandle, float weight);

      public native float getBlendMaskEntry(@Cast("size_t") long boneHandle);

    }



    @Namespace("Ogre::v1") @NoOffset public static class AnimationStateSet extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public AnimationStateSet(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public AnimationStateSet(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public AnimationStateSet position(long position) {
            return (AnimationStateSet)super.position(position);
        }
    

       

        public AnimationStateSet() { super((Pointer)null); allocate(); }
        private native void allocate();

        public AnimationStateSet(@Const @ByRef AnimationStateSet rhs) { super((Pointer)null); allocate(rhs); }
        private native void allocate(@Const @ByRef AnimationStateSet rhs);
        public native AnimationState createAnimationState(@Const @ByRef String animName,
                    double timePos, double length, double weight/*=1.0*/, @Cast("bool") boolean enabled/*=false*/);
        public native AnimationState createAnimationState(@Const @ByRef String animName,
                    double timePos, double length);

        public native AnimationState getAnimationState(@Const @ByRef String name);

        public native @Cast("bool") boolean hasAnimationState(@Const @ByRef String name);

        public native void removeAnimationState(@Const @ByRef String name);

        public native void removeAllAnimationStates();







        public native @ByVal @Cast("Ogre::v1::AnimationStateIterator*") AnimationStateMapIteratorRef getAnimationStateIterator();

        public native void copyMatchingState(AnimationStateSet target);

        public native void _notifyDirty();

        public native @Cast("unsigned long") long getDirtyFrameNumber();


        public native void _notifyAnimationStateEnabled(AnimationState target, @Cast("bool") boolean enabled);

        public native @Cast("bool") boolean hasEnabledAnimationState();






        public native @ByVal @Cast("Ogre::v1::ConstEnabledAnimationStateIterator*") NodeTrackIteratorRef getEnabledAnimationStateIterator();

    }
    @Namespace("Ogre::v1") @NoOffset public static class AnimationStateControllerValue extends RealControllerValueRef {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public AnimationStateControllerValue(Pointer p) { super(p); }
    

        public AnimationStateControllerValue(AnimationState targetAnimationState) { super((Pointer)null); allocate(targetAnimationState); }
        private native void allocate(AnimationState targetAnimationState);

        public native double getValue();


        public native void setValue(double value);

    }





    @Namespace("Ogre::v1") public static class AnimationContainer extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public AnimationContainer(Pointer p) { super(p); }
    


        public native @Cast("unsigned short") short getNumAnimations();


        public native Animation getAnimation(@Cast("unsigned short") short index);


        public native Animation getAnimation(@Const @ByRef String name);


        public native Animation createAnimation(@Const @ByRef String name, double length);


        public native @Cast("bool") boolean hasAnimation(@Const @ByRef String name);


        public native void removeAnimation(@Const @ByRef String name);

    }
    @Namespace("Ogre::v1") @NoOffset public static class Animation extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Animation(Pointer p) { super(p); }
    

        /** enum Ogre::v1::Animation::InterpolationMode */
        public static final int

            IM_LINEAR = 0,

            IM_SPLINE = 1;


        /** enum Ogre::v1::Animation::RotationInterpolationMode */
        public static final int



            RIM_LINEAR = 0,



            RIM_SPHERICAL = 1;




        public Animation(@Const @ByRef String name, double length) { super((Pointer)null); allocate(name, length); }
        private native void allocate(@Const @ByRef String name, double length);


        public native @Const @ByRef String getName();


        public native double getLength();





        public native void setLength(double len);





  public native NodeAnimationTrack createNodeTrack();





  public native OldNodeAnimationTrack createOldNodeTrack(@Cast("unsigned short") short handle);





        public native NumericAnimationTrack createNumericTrack(@Cast("unsigned short") short handle);
        public native VertexAnimationTrack createVertexTrack(@Cast("unsigned short") short handle, @Cast("Ogre::v1::VertexAnimationType") int animType);
  public native NodeAnimationTrack createNodeTrack(Node node);
  public native OldNodeAnimationTrack createOldNodeTrack(@Cast("unsigned short") short handle, OldNode node);






        public native NumericAnimationTrack createNumericTrack(@Cast("unsigned short") short handle,
                    @Cast("const Ogre::AnimableValuePtr*") @ByRef RealControllerFunctionSPtr anim);







        public native VertexAnimationTrack createVertexTrack(@Cast("unsigned short") short handle,
                    VertexData data, @Cast("Ogre::v1::VertexAnimationType") int animType);


  public native @Cast("size_t") long getNumNodeTracks();


  public native NodeAnimationTrack getNodeTrack( @Cast("size_t") long handle );


  public native @Cast("size_t") long getNumOldNodeTracks();


  public native OldNodeAnimationTrack getOldNodeTrack(@Cast("unsigned short") short handle);


  public native @Cast("bool") boolean hasOldNodeTrack(@Cast("unsigned short") short handle);


        public native @Cast("unsigned short") short getNumNumericTracks();


        public native NumericAnimationTrack getNumericTrack(@Cast("unsigned short") short handle);


        public native @Cast("bool") boolean hasNumericTrack(@Cast("unsigned short") short handle);


        public native @Cast("unsigned short") short getNumVertexTracks();


        public native VertexAnimationTrack getVertexTrack(@Cast("unsigned short") short handle);


        public native @Cast("bool") boolean hasVertexTrack(@Cast("unsigned short") short handle);


  public native void destroyOldNodeTrack(@Cast("unsigned short") short handle);


        public native void destroyNumericTrack(@Cast("unsigned short") short handle);


        public native void destroyVertexTrack(@Cast("unsigned short") short handle);


        public native void destroyAllTracks();


        public native void destroyAllNodeTracks();
  public native void destroyAllOldNodeTracks();

        public native void destroyAllNumericTracks();

        public native void destroyAllVertexTracks();
        public native void apply(double timePos, double weight/*=1.0*/, double scale/*=1.0f*/);
        public native void apply(double timePos);
        public native void applyToNode(OldNode node, double timePos, double weight/*=1.0*/, double scale/*=1.0f*/);
        public native void applyToNode(OldNode node, double timePos);
        public native void apply(Skeleton skeleton, double timePos, double weight/*=1.0*/, double scale/*=1.0f*/);
        public native void apply(Skeleton skeleton, double timePos);
        public native void apply(Skeleton skeleton, double timePos, float weight,
                  @Cast("const Ogre::v1::AnimationState::BoneBlendMask*") FloatVectorRef blendMask, double scale);
        public native void apply(Entity entity, double timePos, double weight, @Cast("bool") boolean software,
                    @Cast("bool") boolean hardware);
        public native void applyToAnimable(@Cast("const Ogre::AnimableValuePtr*") @ByRef RealControllerFunctionSPtr anim, double timePos, double weight/*=1.0*/, double scale/*=1.0f*/);
        public native void applyToAnimable(@Cast("const Ogre::AnimableValuePtr*") @ByRef RealControllerFunctionSPtr anim, double timePos);
        public native void applyToVertexData(VertexData data, double timePos, double weight/*=1.0*/);
        public native void applyToVertexData(VertexData data, double timePos);
        public native void setInterpolationMode(@Cast("Ogre::v1::Animation::InterpolationMode") int im);





        public native @Cast("Ogre::v1::Animation::InterpolationMode") int getInterpolationMode();
        public native void setRotationInterpolationMode(@Cast("Ogre::v1::Animation::RotationInterpolationMode") int im);





        public native @Cast("Ogre::v1::Animation::RotationInterpolationMode") int getRotationInterpolationMode();
        public static native void setDefaultInterpolationMode(@Cast("Ogre::v1::Animation::InterpolationMode") int im);


        public static native @Cast("Ogre::v1::Animation::InterpolationMode") int getDefaultInterpolationMode();







        public static native void setDefaultRotationInterpolationMode(@Cast("Ogre::v1::Animation::RotationInterpolationMode") int im);


        public static native @Cast("Ogre::v1::Animation::RotationInterpolationMode") int getDefaultRotationInterpolationMode();


        public native @Cast("const Ogre::v1::Animation::NodeTrackList*") @ByRef NodeAnimationTrackPtrVectorRef _getNodeTrackList();

  public native @Cast("const Ogre::v1::Animation::OldNodeTrackList*") @ByRef OldNodeAnimationTrackPtrMapRef _getOldNodeTrackList();


        public native @ByVal @Cast("Ogre::v1::Animation::NodeTrackIterator*") NodeTrackIteratorRef getNodeTrackIterator();


  public native @ByVal @Cast("Ogre::v1::Animation::OldNodeTrackIterator*") NumericTrackIteratorRef getOldNodeTrackIterator();


        public native @Cast("const Ogre::v1::Animation::NumericTrackList*") @ByRef NumericAnimationTrackPtrMapRef _getNumericTrackList();


        public native @ByVal @Cast("Ogre::v1::Animation::NumericTrackIterator*") NumericTrackIteratorRef getNumericTrackIterator();


        public native @Cast("const Ogre::v1::Animation::VertexTrackList*") @ByRef VertexAnimationTrackPtrMapRef _getVertexTrackList();


        public native @ByVal @Cast("Ogre::v1::Animation::VertexTrackIterator*") NumericTrackIteratorRef getVertexTrackIterator();
        public native void optimise(@Cast("bool") boolean discardIdentityNodeTracks/*=true*/);
        public native void optimise();
  public native void _collectIdentityOldNodeTracks(@Cast("Ogre::v1::Animation::TrackHandleList*") @ByRef UshortSetRef tracks);



  public native void _destroyOldNodeTracks(@Cast("const Ogre::v1::Animation::TrackHandleList*") @ByRef UshortSetRef tracks);







        public native Animation clone(@Const @ByRef String newName);



        public native void _keyFrameListChanged();
        public native @ByVal TimeIndex _getTimeIndex(double timePos);
        public native void setUseBaseKeyFrame(@Cast("bool") boolean useBaseKeyFrame, double keyframeTime/*=0.0f*/, @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String baseAnimName);
        public native void setUseBaseKeyFrame(@Cast("bool") boolean useBaseKeyFrame);

        public native @Cast("bool") boolean getUseBaseKeyFrame();

        public native double getBaseKeyFrameTime();

        public native @Const @ByRef String getBaseKeyFrameAnimationName();


        public native void _applyBaseKeyFrame();

        public native void _notifyContainer(AnimationContainer c);

        public native AnimationContainer getContainer();
    }





    @Namespace("Ogre") @NoOffset public static class Any extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Any(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Any(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Any position(long position) {
            return (Any)super.position(position);
        }
    

        public Any() { super((Pointer)null); allocate(); }
        private native void allocate();

        public Any(@Const @ByRef Any other) { super((Pointer)null); allocate(other); }
        private native void allocate(@Const @ByRef Any other);

        public native @ByRef Any swap(@ByRef Any rhs);

        public native @ByRef @Name("operator =") Any put(@Const @ByRef Any rhs);

        public native @Cast("bool") boolean isEmpty();

        public native @Const @ByRef type_info getType();

        

        public native void destroy();

    }





    @Namespace("Ogre") public static class AnyNumeric extends Any {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public AnyNumeric(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public AnyNumeric(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public AnyNumeric position(long position) {
            return (AnyNumeric)super.position(position);
        }
    
        public AnyNumeric() { super((Pointer)null); allocate(); }
        private native void allocate();

        public AnyNumeric(@Const @ByRef AnyNumeric other) { super((Pointer)null); allocate(other); }
        private native void allocate(@Const @ByRef AnyNumeric other);
        public native @ByRef @Name("operator =") AnyNumeric put(@Const @ByRef AnyNumeric rhs);
        public native @ByVal @Name("operator +") AnyNumeric add(@Const @ByRef AnyNumeric rhs);
        public native @ByVal @Name("operator -") AnyNumeric subtract(@Const @ByRef AnyNumeric rhs);
        public native @ByVal @Name("operator *") AnyNumeric multiply(@Const @ByRef AnyNumeric rhs);
        public native @ByVal @Name("operator *") AnyNumeric multiply(double factor);
        public native @ByVal @Name("operator /") AnyNumeric divide(@Const @ByRef AnyNumeric rhs);
        public native @ByRef @Name("operator +=") AnyNumeric addPut(@Const @ByRef AnyNumeric rhs);
        public native @ByRef @Name("operator -=") AnyNumeric subtractPut(@Const @ByRef AnyNumeric rhs);
        public native @ByRef @Name("operator *=") AnyNumeric multiplyPut(@Const @ByRef AnyNumeric rhs);
        public native @ByRef @Name("operator /=") AnyNumeric dividePut(@Const @ByRef AnyNumeric rhs);




    }





    @Namespace("Ogre") @NoOffset public static class DataStream extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public DataStream(Pointer p) { super(p); }
    
        /** enum Ogre::DataStream::AccessMode */
        public static final int
            READ = 1,
            WRITE = 2;

        public native @Const @ByRef String getName();

        public native @Cast("Ogre::uint16") short getAccessMode();

        public native @Cast("bool") boolean isReadable();

        public native @Cast("bool") boolean isWriteable();






        public native @Cast("size_t") long read(Pointer buf, @Cast("size_t") long count);






        public native @Cast("size_t") long write(@Const Pointer buf, @Cast("size_t") long count);
        public native @Cast("size_t") long readLine(@Cast("char*") BytePointer buf, @Cast("size_t") long maxCount, @Const @ByRef(nullValue = "Ogre::String(\"\n\")") String delim);
        public native @Cast("size_t") long readLine(@Cast("char*") BytePointer buf, @Cast("size_t") long maxCount);
        public native @Cast("size_t") long readLine(@Cast("char*") ByteBuffer buf, @Cast("size_t") long maxCount, @Const @ByRef(nullValue = "Ogre::String(\"\n\")") String delim);
        public native @Cast("size_t") long readLine(@Cast("char*") ByteBuffer buf, @Cast("size_t") long maxCount);
        public native @Cast("size_t") long readLine(@Cast("char*") byte[] buf, @Cast("size_t") long maxCount, @Const @ByRef(nullValue = "Ogre::String(\"\n\")") String delim);
        public native @Cast("size_t") long readLine(@Cast("char*") byte[] buf, @Cast("size_t") long maxCount);
        public native @ByVal String getLine( @Cast("bool") boolean trimAfter/*=true*/ );
        public native @ByVal String getLine( );






        public native @ByVal String getAsString();
        public native @Cast("size_t") long skipLine(@Const @ByRef(nullValue = "Ogre::String(\"\n\")") String delim);
        public native @Cast("size_t") long skipLine();



        public native void skip(long count);



        public native void seek( @Cast("size_t") long pos );


        public native @Cast("size_t") long tell();



        public native @Cast("bool") boolean eof();




        public native @Cast("size_t") long size();


        public native @Name("close") void _close();


    }



    @Namespace("Ogre") @NoOffset public static class MemoryDataStream extends DataStream {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MemoryDataStream(Pointer p) { super(p); }
    
        public MemoryDataStream(Pointer pMem, @Cast("size_t") long size, @Cast("bool") boolean freeOnClose/*=false*/, @Cast("bool") boolean readOnly/*=false*/) { super((Pointer)null); allocate(pMem, size, freeOnClose, readOnly); }
        private native void allocate(Pointer pMem, @Cast("size_t") long size, @Cast("bool") boolean freeOnClose/*=false*/, @Cast("bool") boolean readOnly/*=false*/);
        public MemoryDataStream(Pointer pMem, @Cast("size_t") long size) { super((Pointer)null); allocate(pMem, size); }
        private native void allocate(Pointer pMem, @Cast("size_t") long size);
        public MemoryDataStream(@Const @ByRef String name, Pointer pMem, @Cast("size_t") long size,
                        @Cast("bool") boolean freeOnClose/*=false*/, @Cast("bool") boolean readOnly/*=false*/) { super((Pointer)null); allocate(name, pMem, size, freeOnClose, readOnly); }
        private native void allocate(@Const @ByRef String name, Pointer pMem, @Cast("size_t") long size,
                        @Cast("bool") boolean freeOnClose/*=false*/, @Cast("bool") boolean readOnly/*=false*/);
        public MemoryDataStream(@Const @ByRef String name, Pointer pMem, @Cast("size_t") long size) { super((Pointer)null); allocate(name, pMem, size); }
        private native void allocate(@Const @ByRef String name, Pointer pMem, @Cast("size_t") long size);
        public MemoryDataStream(@ByRef DataStream sourceStream,
                        @Cast("bool") boolean freeOnClose/*=true*/, @Cast("bool") boolean readOnly/*=false*/) { super((Pointer)null); allocate(sourceStream, freeOnClose, readOnly); }
        private native void allocate(@ByRef DataStream sourceStream,
                        @Cast("bool") boolean freeOnClose/*=true*/, @Cast("bool") boolean readOnly/*=false*/);
        public MemoryDataStream(@ByRef DataStream sourceStream) { super((Pointer)null); allocate(sourceStream); }
        private native void allocate(@ByRef DataStream sourceStream);
        public MemoryDataStream(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr sourceStream,
                        @Cast("bool") boolean freeOnClose/*=true*/, @Cast("bool") boolean readOnly/*=false*/) { super((Pointer)null); allocate(sourceStream, freeOnClose, readOnly); }
        private native void allocate(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr sourceStream,
                        @Cast("bool") boolean freeOnClose/*=true*/, @Cast("bool") boolean readOnly/*=false*/);
        public MemoryDataStream(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr sourceStream) { super((Pointer)null); allocate(sourceStream); }
        private native void allocate(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr sourceStream);
        public MemoryDataStream(@Const @ByRef String name, @ByRef DataStream sourceStream,
                        @Cast("bool") boolean freeOnClose/*=true*/, @Cast("bool") boolean readOnly/*=false*/) { super((Pointer)null); allocate(name, sourceStream, freeOnClose, readOnly); }
        private native void allocate(@Const @ByRef String name, @ByRef DataStream sourceStream,
                        @Cast("bool") boolean freeOnClose/*=true*/, @Cast("bool") boolean readOnly/*=false*/);
        public MemoryDataStream(@Const @ByRef String name, @ByRef DataStream sourceStream) { super((Pointer)null); allocate(name, sourceStream); }
        private native void allocate(@Const @ByRef String name, @ByRef DataStream sourceStream);
        public MemoryDataStream(@Const @ByRef String name, @Cast("const Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr sourceStream,
                    @Cast("bool") boolean freeOnClose/*=true*/, @Cast("bool") boolean readOnly/*=false*/) { super((Pointer)null); allocate(name, sourceStream, freeOnClose, readOnly); }
        private native void allocate(@Const @ByRef String name, @Cast("const Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr sourceStream,
                    @Cast("bool") boolean freeOnClose/*=true*/, @Cast("bool") boolean readOnly/*=false*/);
        public MemoryDataStream(@Const @ByRef String name, @Cast("const Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr sourceStream) { super((Pointer)null); allocate(name, sourceStream); }
        private native void allocate(@Const @ByRef String name, @Cast("const Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr sourceStream);







        public MemoryDataStream(@Cast("size_t") long size, @Cast("bool") boolean freeOnClose/*=true*/, @Cast("bool") boolean readOnly/*=false*/) { super((Pointer)null); allocate(size, freeOnClose, readOnly); }
        private native void allocate(@Cast("size_t") long size, @Cast("bool") boolean freeOnClose/*=true*/, @Cast("bool") boolean readOnly/*=false*/);
        public MemoryDataStream(@Cast("size_t") long size) { super((Pointer)null); allocate(size); }
        private native void allocate(@Cast("size_t") long size);







        public MemoryDataStream(@Const @ByRef String name, @Cast("size_t") long size,
                        @Cast("bool") boolean freeOnClose/*=true*/, @Cast("bool") boolean readOnly/*=false*/) { super((Pointer)null); allocate(name, size, freeOnClose, readOnly); }
        private native void allocate(@Const @ByRef String name, @Cast("size_t") long size,
                        @Cast("bool") boolean freeOnClose/*=true*/, @Cast("bool") boolean readOnly/*=false*/);
        public MemoryDataStream(@Const @ByRef String name, @Cast("size_t") long size) { super((Pointer)null); allocate(name, size); }
        private native void allocate(@Const @ByRef String name, @Cast("size_t") long size);


        public native @Cast("Ogre::uchar*") BytePointer getPtr();


        public native @Cast("Ogre::uchar*") BytePointer getCurrentPtr();



        public native @Cast("size_t") long read(Pointer buf, @Cast("size_t") long count);



        public native @Cast("size_t") long write(@Const Pointer buf, @Cast("size_t") long count);



        public native @Cast("size_t") long readLine(@Cast("char*") BytePointer buf, @Cast("size_t") long maxCount, @Const @ByRef(nullValue = "Ogre::String(\"\n\")") String delim);
        public native @Cast("size_t") long readLine(@Cast("char*") BytePointer buf, @Cast("size_t") long maxCount);
        public native @Cast("size_t") long readLine(@Cast("char*") ByteBuffer buf, @Cast("size_t") long maxCount, @Const @ByRef(nullValue = "Ogre::String(\"\n\")") String delim);
        public native @Cast("size_t") long readLine(@Cast("char*") ByteBuffer buf, @Cast("size_t") long maxCount);
        public native @Cast("size_t") long readLine(@Cast("char*") byte[] buf, @Cast("size_t") long maxCount, @Const @ByRef(nullValue = "Ogre::String(\"\n\")") String delim);
        public native @Cast("size_t") long readLine(@Cast("char*") byte[] buf, @Cast("size_t") long maxCount);



        public native @Cast("size_t") long skipLine(@Const @ByRef(nullValue = "Ogre::String(\"\n\")") String delim);
        public native @Cast("size_t") long skipLine();



        public native void skip(long count);



        public native void seek( @Cast("size_t") long pos );



        public native @Cast("size_t") long tell();



        public native @Cast("bool") boolean eof();



        public native @Name("close") void _close();


        public native void setFreeOnClose(@Cast("bool") boolean free);
    }




    @Namespace("Ogre") @NoOffset public static class FileStreamDataStream extends DataStream {
        static { Loader.load(); }
    





        public FileStreamDataStream(@Cast("std::ifstream*") Pointer s,
                    @Cast("bool") boolean freeOnClose/*=true*/) { super((Pointer)null); allocate(s, freeOnClose); }
        private native void allocate(@Cast("std::ifstream*") Pointer s,
                    @Cast("bool") boolean freeOnClose/*=true*/);
        public FileStreamDataStream(@Cast("std::ifstream*") Pointer s) { super((Pointer)null); allocate(s); }
        private native void allocate(@Cast("std::ifstream*") Pointer s);







        public FileStreamDataStream(@Const @ByRef String name,
                    @Cast("std::ifstream*") Pointer s,
                    @Cast("bool") boolean freeOnClose/*=true*/) { super((Pointer)null); allocate(name, s, freeOnClose); }
        private native void allocate(@Const @ByRef String name,
                    @Cast("std::ifstream*") Pointer s,
                    @Cast("bool") boolean freeOnClose/*=true*/);
        public FileStreamDataStream(@Const @ByRef String name,
                    @Cast("std::ifstream*") Pointer s) { super((Pointer)null); allocate(name, s); }
        private native void allocate(@Const @ByRef String name,
                    @Cast("std::ifstream*") Pointer s);
        public FileStreamDataStream(@Const @ByRef String name,
                    @Cast("std::ifstream*") Pointer s,
                    @Cast("size_t") long size,
                    @Cast("bool") boolean freeOnClose/*=true*/) { super((Pointer)null); allocate(name, s, size, freeOnClose); }
        private native void allocate(@Const @ByRef String name,
                    @Cast("std::ifstream*") Pointer s,
                    @Cast("size_t") long size,
                    @Cast("bool") boolean freeOnClose/*=true*/);
        public FileStreamDataStream(@Const @ByRef String name,
                    @Cast("std::ifstream*") Pointer s,
                    @Cast("size_t") long size) { super((Pointer)null); allocate(name, s, size); }
        private native void allocate(@Const @ByRef String name,
                    @Cast("std::ifstream*") Pointer s,
                    @Cast("size_t") long size);



        public native @Cast("size_t") long read(Pointer buf, @Cast("size_t") long count);



        public native @Cast("size_t") long write(@Const Pointer buf, @Cast("size_t") long count);



        public native @Cast("size_t") long readLine(@Cast("char*") BytePointer buf, @Cast("size_t") long maxCount, @Const @ByRef(nullValue = "Ogre::String(\"\n\")") String delim);
        public native @Cast("size_t") long readLine(@Cast("char*") BytePointer buf, @Cast("size_t") long maxCount);
        public native @Cast("size_t") long readLine(@Cast("char*") ByteBuffer buf, @Cast("size_t") long maxCount, @Const @ByRef(nullValue = "Ogre::String(\"\n\")") String delim);
        public native @Cast("size_t") long readLine(@Cast("char*") ByteBuffer buf, @Cast("size_t") long maxCount);
        public native @Cast("size_t") long readLine(@Cast("char*") byte[] buf, @Cast("size_t") long maxCount, @Const @ByRef(nullValue = "Ogre::String(\"\n\")") String delim);
        public native @Cast("size_t") long readLine(@Cast("char*") byte[] buf, @Cast("size_t") long maxCount);



        public native void skip(long count);



        public native void seek( @Cast("size_t") long pos );



        public native @Cast("size_t") long tell();



        public native @Cast("bool") boolean eof();



        public native @Name("close") void _close();


    }
    @Namespace("Ogre") @NoOffset public static class FileHandleDataStream extends DataStream {
        static { Loader.load(); }
    

        public FileHandleDataStream(@Cast("FILE*") Pointer handle, @Cast("Ogre::uint16") short accessMode/*=READ*/) { super((Pointer)null); allocate(handle, accessMode); }
        private native void allocate(@Cast("FILE*") Pointer handle, @Cast("Ogre::uint16") short accessMode/*=READ*/);
        public FileHandleDataStream(@Cast("FILE*") Pointer handle) { super((Pointer)null); allocate(handle); }
        private native void allocate(@Cast("FILE*") Pointer handle);

        public FileHandleDataStream(@Const @ByRef String name, @Cast("FILE*") Pointer handle, @Cast("Ogre::uint16") short accessMode/*=READ*/) { super((Pointer)null); allocate(name, handle, accessMode); }
        private native void allocate(@Const @ByRef String name, @Cast("FILE*") Pointer handle, @Cast("Ogre::uint16") short accessMode/*=READ*/);
        public FileHandleDataStream(@Const @ByRef String name, @Cast("FILE*") Pointer handle) { super((Pointer)null); allocate(name, handle); }
        private native void allocate(@Const @ByRef String name, @Cast("FILE*") Pointer handle);



        public native @Cast("size_t") long read(Pointer buf, @Cast("size_t") long count);



        public native @Cast("size_t") long write(@Const Pointer buf, @Cast("size_t") long count);



        public native void skip(long count);



        public native void seek( @Cast("size_t") long pos );



        public native @Cast("size_t") long tell();



        public native @Cast("bool") boolean eof();



        public native @Name("close") void _close();

    }








    @Namespace("Ogre") public static class FileInfo extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public FileInfo() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public FileInfo(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public FileInfo(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public FileInfo position(long position) {
            return (FileInfo)super.position(position);
        }
    


        public native Archive archive(); public native FileInfo archive(Archive archive);

        public native @ByRef String filename(); public native FileInfo filename(String filename);

        public native @ByRef String path(); public native FileInfo path(String path);

        public native @ByRef String basename(); public native FileInfo basename(String basename);

        public native @Cast("size_t") long compressedSize(); public native FileInfo compressedSize(long compressedSize);

        public native @Cast("size_t") long uncompressedSize(); public native FileInfo uncompressedSize(long uncompressedSize);
    }
    @Namespace("Ogre") @NoOffset public static class Archive extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Archive(Pointer p) { super(p); }
    


        public native @Const @ByRef String getName();


        public native @Cast("bool") boolean isCaseSensitive();
        public native void load();






        public native void unload();




        public native @Cast("bool") boolean isReadOnly();
        public native @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr open(@Const @ByRef String filename, @Cast("bool") boolean readOnly/*=true*/);
        public native @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr open(@Const @ByRef String filename);







        public native @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr create(@Const @ByRef String filename);





        public native void remove(@Const @ByRef String filename);
        public native @ByVal @Cast("Ogre::StringVectorPtr*") RealControllerFunctionSPtr list(@Cast("bool") boolean recursive/*=true*/, @Cast("bool") boolean dirs/*=false*/);
        public native @ByVal @Cast("Ogre::StringVectorPtr*") RealControllerFunctionSPtr list();
        public native @ByVal FileInfoListPtr listFileInfo(@Cast("bool") boolean recursive/*=true*/, @Cast("bool") boolean dirs/*=false*/);
        public native @ByVal FileInfoListPtr listFileInfo();
        public native @ByVal @Cast("Ogre::StringVectorPtr*") RealControllerFunctionSPtr find(@Const @ByRef String pattern, @Cast("bool") boolean recursive/*=true*/,
                    @Cast("bool") boolean dirs/*=false*/);
        public native @ByVal @Cast("Ogre::StringVectorPtr*") RealControllerFunctionSPtr find(@Const @ByRef String pattern);


        public native @Cast("bool") boolean exists(@Const @ByRef String filename);


        public native @ByVal @Cast("time_t*") Pointer getModifiedTime(@Const @ByRef String filename);
        public native @ByVal FileInfoListPtr findFileInfo(@Const @ByRef String pattern,
                    @Cast("bool") boolean recursive/*=true*/, @Cast("bool") boolean dirs/*=false*/);
        public native @ByVal FileInfoListPtr findFileInfo(@Const @ByRef String pattern);


        public native @Const @ByRef String getType();

    }





    @Name("Ogre::Singleton<HardwareBufferManager>") @NoOffset public static class HardwareBufferManagerSgtRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareBufferManagerSgtRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public HardwareBufferManagerSgtRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public HardwareBufferManagerSgtRef position(long position) {
            return (HardwareBufferManagerSgtRef)super.position(position);
        }
    
        public HardwareBufferManagerSgtRef( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public static native @ByRef HardwareBufferManager getSingleton( );
        public static native HardwareBufferManager getSingletonPtr( );
    }
    @Name("Ogre::Singleton<Ogre::ArchiveManager>") @NoOffset public static class ArchiveManagerSgtRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ArchiveManagerSgtRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ArchiveManagerSgtRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ArchiveManagerSgtRef position(long position) {
            return (ArchiveManagerSgtRef)super.position(position);
        }
    
        public ArchiveManagerSgtRef( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public static native @ByRef ArchiveManager getSingleton( );
        public static native ArchiveManager getSingletonPtr( );
    }
    @Name("Ogre::Singleton<Ogre::ControllerManager>") @NoOffset public static class ControllerManagerSgtRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ControllerManagerSgtRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ControllerManagerSgtRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ControllerManagerSgtRef position(long position) {
            return (ControllerManagerSgtRef)super.position(position);
        }
    
        public ControllerManagerSgtRef( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public static native @ByRef ControllerManager getSingleton( );
        public static native ControllerManager getSingletonPtr( );
    }
    @Name("Ogre::Singleton<Ogre::GpuProgramManager>") @NoOffset public static class GpuProgramManagerSgtRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public GpuProgramManagerSgtRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public GpuProgramManagerSgtRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public GpuProgramManagerSgtRef position(long position) {
            return (GpuProgramManagerSgtRef)super.position(position);
        }
    
        public GpuProgramManagerSgtRef( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public static native @ByRef GpuProgramManager getSingleton( );
        public static native GpuProgramManager getSingletonPtr( );
    }
    @Name("Ogre::Singleton<Ogre::HighLevelGpuProgramManager>") @NoOffset public static class HighLevelGpuProgramManagerSgtRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HighLevelGpuProgramManagerSgtRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public HighLevelGpuProgramManagerSgtRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public HighLevelGpuProgramManagerSgtRef position(long position) {
            return (HighLevelGpuProgramManagerSgtRef)super.position(position);
        }
    
        public HighLevelGpuProgramManagerSgtRef( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public static native @ByRef HighLevelGpuProgramManager getSingleton( );
        public static native HighLevelGpuProgramManager getSingletonPtr( );
    }
    @Name("Ogre::Singleton<Ogre::LogManager>") @NoOffset public static class LogManagerSgtRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public LogManagerSgtRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public LogManagerSgtRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public LogManagerSgtRef position(long position) {
            return (LogManagerSgtRef)super.position(position);
        }
    
        public LogManagerSgtRef( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public static native @ByRef LogManager getSingleton( );
        public static native LogManager getSingletonPtr( );
    }
    @Name("Ogre::Singleton<Ogre::MaterialManager>") @NoOffset public static class MaterialManagerSgtRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MaterialManagerSgtRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MaterialManagerSgtRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public MaterialManagerSgtRef position(long position) {
            return (MaterialManagerSgtRef)super.position(position);
        }
    
        public MaterialManagerSgtRef( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public static native @ByRef MaterialManager getSingleton( );
        public static native MaterialManager getSingletonPtr( );
    }
    @Name("Ogre::Singleton<Ogre::MeshManager>") @NoOffset public static class MeshManagerSgtRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MeshManagerSgtRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MeshManagerSgtRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public MeshManagerSgtRef position(long position) {
            return (MeshManagerSgtRef)super.position(position);
        }
    
        public MeshManagerSgtRef( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public static native @ByRef MeshManager getSingleton( );
        public static native MeshManager getSingletonPtr( );
    }
    @Name("Ogre::Singleton<Ogre::ParticleSystemManager>") @NoOffset public static class ParticleSystemManagerSgtRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ParticleSystemManagerSgtRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ParticleSystemManagerSgtRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ParticleSystemManagerSgtRef position(long position) {
            return (ParticleSystemManagerSgtRef)super.position(position);
        }
    
        public ParticleSystemManagerSgtRef( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public static native @ByRef ParticleSystemManager getSingleton( );
        public static native ParticleSystemManager getSingletonPtr( );
    }
    @Name("Ogre::Singleton<Ogre::Profiler>") @NoOffset public static class ProfilerSgtRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ProfilerSgtRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ProfilerSgtRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ProfilerSgtRef position(long position) {
            return (ProfilerSgtRef)super.position(position);
        }
    
        public ProfilerSgtRef( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public static native @ByRef Profiler getSingleton( );
        public static native Profiler getSingletonPtr( );
    }
    @Name("Ogre::Singleton<Ogre::ResourceBackgroundQueue>") @NoOffset public static class ResourceBackgroundQueueSgtRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ResourceBackgroundQueueSgtRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ResourceBackgroundQueueSgtRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ResourceBackgroundQueueSgtRef position(long position) {
            return (ResourceBackgroundQueueSgtRef)super.position(position);
        }
    
        public ResourceBackgroundQueueSgtRef( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public static native @ByRef ResourceBackgroundQueue getSingleton( );
        public static native ResourceBackgroundQueue getSingletonPtr( );
    }
    @Name("Ogre::Singleton<Ogre::ResourceGroupManager>") @NoOffset public static class ResourceGroupManagerSgtRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ResourceGroupManagerSgtRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ResourceGroupManagerSgtRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ResourceGroupManagerSgtRef position(long position) {
            return (ResourceGroupManagerSgtRef)super.position(position);
        }
    
        public ResourceGroupManagerSgtRef( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public static native @ByRef ResourceGroupManager getSingleton( );
        public static native ResourceGroupManager getSingletonPtr( );
    }
    @Name("Ogre::Singleton<Ogre::Root>") @NoOffset public static class RootSgtRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RootSgtRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public RootSgtRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public RootSgtRef position(long position) {
            return (RootSgtRef)super.position(position);
        }
    
        public RootSgtRef( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public static native @ByRef Root getSingleton( );
        public static native Root getSingletonPtr( );
    }
    @Name("Ogre::Singleton<Ogre::SceneManagerEnumerator>") @NoOffset public static class SceneManagerEnumeratorSgtRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SceneManagerEnumeratorSgtRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public SceneManagerEnumeratorSgtRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public SceneManagerEnumeratorSgtRef position(long position) {
            return (SceneManagerEnumeratorSgtRef)super.position(position);
        }
    
        public SceneManagerEnumeratorSgtRef( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public static native @ByRef SceneManagerEnumerator getSingleton( );
        public static native SceneManagerEnumerator getSingletonPtr( );
    }
    @Name("Ogre::Singleton<Ogre::ShadowTextureManager>") @NoOffset public static class ShadowTextureManagerSgtRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ShadowTextureManagerSgtRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ShadowTextureManagerSgtRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ShadowTextureManagerSgtRef position(long position) {
            return (ShadowTextureManagerSgtRef)super.position(position);
        }
    
        public ShadowTextureManagerSgtRef( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public static native @ByRef ShadowTextureManager getSingleton( );
        public static native ShadowTextureManager getSingletonPtr( );
    }
    @Name("Ogre::Singleton<Ogre::TextureManager>") @NoOffset public static class TextureManagerSgtRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public TextureManagerSgtRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public TextureManagerSgtRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public TextureManagerSgtRef position(long position) {
            return (TextureManagerSgtRef)super.position(position);
        }
    
        public TextureManagerSgtRef( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public static native @ByRef TextureManager getSingleton( );
        public static native TextureManager getSingletonPtr( );
    }
    @Name("Ogre::Singleton<Ogre::v1::OldSkeletonManager>") @NoOffset public static class OldSkeletonManagerSgtRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public OldSkeletonManagerSgtRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public OldSkeletonManagerSgtRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public OldSkeletonManagerSgtRef position(long position) {
            return (OldSkeletonManagerSgtRef)super.position(position);
        }
    
        public OldSkeletonManagerSgtRef( ) { super((Pointer)null); allocate(); }
        private native void allocate( );
        public static native @ByRef OldSkeletonManager getSingleton( );
        public static native OldSkeletonManager getSingletonPtr( );
    }




    @Namespace("Ogre") @NoOffset public static class ArchiveManager extends ArchiveManagerSgtRef {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ArchiveManager(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ArchiveManager(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ArchiveManager position(long position) {
            return (ArchiveManager)super.position(position);
        }
        public Pointer asPointer() { return asPointer(this); }
        @Namespace public static native @Name("static_cast<ArchiveAlloc*>") Pointer asPointer(ArchiveManager pointer);
    


        public ArchiveManager() { super((Pointer)null); allocate(); }
        private native void allocate();
        public native Archive load( @Const @ByRef String filename, @Const @ByRef String archiveType, @Cast("bool") boolean readOnly);





        public native void unload(Archive arch);




        public native void unload(@Const @ByRef String filename);

        public native @ByVal @Cast("Ogre::ArchiveManager::ArchiveMapIterator*") ArchiveMapIteratorRef getArchiveIterator();







        public native void addArchiveFactory(ArchiveFactory factory);
        public static native @ByRef ArchiveManager getSingleton();
        public static native ArchiveManager getSingletonPtr();
    }




    @Namespace("Ogre") @NoOffset public static class AxisAlignedBox extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public AxisAlignedBox(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public AxisAlignedBox(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public AxisAlignedBox position(long position) {
            return (AxisAlignedBox)super.position(position);
        }
    
        /** enum Ogre::AxisAlignedBox::Extent */
        public static final int
            EXTENT_NULL = 0,
            EXTENT_FINITE = 1,
            EXTENT_INFINITE = 2;
        /** enum Ogre::AxisAlignedBox::CornerEnum */
        public static final int
            FAR_LEFT_BOTTOM = 0,
            FAR_LEFT_TOP = 1,
            FAR_RIGHT_TOP = 2,
            FAR_RIGHT_BOTTOM = 3,
            NEAR_RIGHT_BOTTOM = 7,
            NEAR_LEFT_BOTTOM = 6,
            NEAR_LEFT_TOP = 5,
            NEAR_RIGHT_TOP = 4;
        public AxisAlignedBox() { super((Pointer)null); allocate(); }
        private native void allocate();
        public AxisAlignedBox(@Cast("Ogre::AxisAlignedBox::Extent") int e) { super((Pointer)null); allocate(e); }
        private native void allocate(@Cast("Ogre::AxisAlignedBox::Extent") int e);

        public AxisAlignedBox(@Const @ByRef AxisAlignedBox rkBox) { super((Pointer)null); allocate(rkBox); }
        private native void allocate(@Const @ByRef AxisAlignedBox rkBox);

        public AxisAlignedBox( @Const @ByRef Vector3 min, @Const @ByRef Vector3 max ) { super((Pointer)null); allocate(min, max); }
        private native void allocate( @Const @ByRef Vector3 min, @Const @ByRef Vector3 max );

        public AxisAlignedBox(
                    double mx, double my, double mz,
                    double Mx, double My, double Mz ) { super((Pointer)null); allocate(mx, my, mz, Mx, My, Mz); }
        private native void allocate(
                    double mx, double my, double mz,
                    double Mx, double My, double Mz );

        public native @ByRef @Name("operator =") AxisAlignedBox put(@Const @ByRef AxisAlignedBox rhs);




        public native @ByRef Vector3 getMinimum();




        public native @ByRef Vector3 getMaximum();




        public native void setMinimum( @Const @ByRef Vector3 vec );

        public native void setMinimum( double x, double y, double z );




        public native void setMinimumX(double x);

        public native void setMinimumY(double y);

        public native void setMinimumZ(double z);



        public native void setMaximum( @Const @ByRef Vector3 vec );

        public native void setMaximum( double x, double y, double z );




        public native void setMaximumX( double x );

        public native void setMaximumY( double y );

        public native void setMaximumZ( double z );



        public native void setExtents( @Const @ByRef Vector3 min, @Const @ByRef Vector3 max );

        public native void setExtents(
                    double mx, double my, double mz,
                    double Mx, double My, double Mz );
        public native @Const Vector3 getAllCorners();



        public native @ByVal Vector3 getCorner(@Cast("Ogre::AxisAlignedBox::CornerEnum") int cornerToGet);

                    




        public native void merge( @Const @ByRef AxisAlignedBox rhs );



        public native void merge( @Const @ByRef Vector3 point );
        public native void transform( @Const @ByRef Matrix4 matrix );
        public native void transformAffine(@Const @ByRef Matrix4 m);



        public native void setNull();



        public native @Cast("bool") boolean isNull();



        public native @Cast("bool") boolean isFinite();



        public native void setInfinite();



        public native @Cast("bool") boolean isInfinite();


        public native @Cast("bool") boolean intersects(@Const @ByRef AxisAlignedBox b2);


        public native @ByVal AxisAlignedBox intersection(@Const @ByRef AxisAlignedBox b2);


        public native double volume();


        public native void scale(@Const @ByRef Vector3 s);


        public native @Cast("bool") boolean intersects(@Const @ByRef Sphere s);

        public native @Cast("bool") boolean intersects(@Const @ByRef Plane p);

        public native @Cast("bool") boolean intersects(@Const @ByRef Vector3 v);

        public native @ByVal Vector3 getCenter();

        public native @ByVal Vector3 getSize();

        public native @ByVal Vector3 getHalfSize();



        public native @Cast("bool") boolean contains(@Const @ByRef Vector3 v);



        public native double squaredDistance(@Const @ByRef Vector3 v);


        public native double distance(@Const @ByRef Vector3 v);



        public native @Cast("bool") boolean contains(@Const @ByRef AxisAlignedBox other);



        public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef AxisAlignedBox rhs);



        public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef AxisAlignedBox rhs);


        @MemberGetter public static native @Const @ByRef AxisAlignedBox BOX_NULL();
        @MemberGetter public static native @Const @ByRef AxisAlignedBox BOX_INFINITE();


    }




    @Namespace("Ogre::v1") @NoOffset public static class Billboard extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Billboard(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Billboard(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Billboard position(long position) {
            return (Billboard)super.position(position);
        }
    


        public native @ByRef Vector3 mPosition(); public native Billboard mPosition(Vector3 mPosition);

        public native @ByRef Vector3 mDirection(); public native Billboard mDirection(Vector3 mDirection);
        public native BillboardSet mParentSet(); public native Billboard mParentSet(BillboardSet mParentSet);
        public native @ByRef ColourValue mColour(); public native Billboard mColour(ColourValue mColour);
        public native @ByRef Radian mRotation(); public native Billboard mRotation(Radian mRotation);



        public Billboard() { super((Pointer)null); allocate(); }
        private native void allocate();



        public Billboard(@Const @ByRef Vector3 position, BillboardSet owner, @Const @ByRef(nullValue = "Ogre::ColourValue::White") ColourValue colour) { super((Pointer)null); allocate(position, owner, colour); }
        private native void allocate(@Const @ByRef Vector3 position, BillboardSet owner, @Const @ByRef(nullValue = "Ogre::ColourValue::White") ColourValue colour);
        public Billboard(@Const @ByRef Vector3 position, BillboardSet owner) { super((Pointer)null); allocate(position, owner); }
        private native void allocate(@Const @ByRef Vector3 position, BillboardSet owner);





        public native @Const @ByRef Radian getRotation();





        public native void setRotation(@Const @ByRef Radian rotation);






        public native void setPosition(@Const @ByRef Vector3 position);






        public native void setPosition(double x, double y, double z);






        public native @Const @ByRef Vector3 getPosition();
        public native void setDimensions(double width, double height);


        public native void resetDimensions();






        public native void setColour(@Const @ByRef ColourValue colour);



        public native @Const @ByRef ColourValue getColour();






        public native @Cast("bool") boolean hasOwnDimensions();


        public native double getOwnWidth();


        public native double getOwnHeight();



        public native void _notifyOwner(BillboardSet owner);
        public native @Cast("bool") boolean isUseTexcoordRect();
        public native void setTexcoordIndex(@Cast("Ogre::uint16") short texcoordIndex);






        public native @Cast("Ogre::uint16") short getTexcoordIndex();






        public native void setTexcoordRect(@Const @ByRef FloatRect texcoordRect);






        public native void setTexcoordRect(double u0, double v0, double u1, double v1);





        public native @Const @ByRef FloatRect getTexcoordRect();
    }






    @Namespace("Ogre") @NoOffset public static class Sphere extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Sphere(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Sphere(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Sphere position(long position) {
            return (Sphere)super.position(position);
        }
    

        public Sphere() { super((Pointer)null); allocate(); }
        private native void allocate();




        public Sphere(@Const @ByRef Vector3 center, double radius) { super((Pointer)null); allocate(center, radius); }
        private native void allocate(@Const @ByRef Vector3 center, double radius);


        public native double getRadius();


        public native void setRadius(double radius);


        public native @Const @ByRef Vector3 getCenter();


        public native void setCenter(@Const @ByRef Vector3 center);


        public native @Cast("bool") boolean intersects(@Const @ByRef Sphere s);

        public native @Cast("bool") boolean intersects(@Const @ByRef AxisAlignedBox box);

        public native @Cast("bool") boolean intersects(@Const @ByRef Plane plane);

        public native @Cast("bool") boolean intersects(@Const @ByRef Vector3 v);

        public native void merge(@Const @ByRef Sphere oth);


    }




    @Namespace("Ogre") @NoOffset public static class Vector2 extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Vector2(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Vector2(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Vector2 position(long position) {
            return (Vector2)super.position(position);
        }
    
        public native double x(); public native Vector2 x(double x);
        public native double y(); public native Vector2 y(double y);




        public Vector2() { super((Pointer)null); allocate(); }
        private native void allocate();

        public Vector2(double fX, double fY ) { super((Pointer)null); allocate(fX, fY); }
        private native void allocate(double fX, double fY );

        public Vector2( double scaler ) { super((Pointer)null); allocate(scaler); }
        private native void allocate( double scaler );

        public Vector2( @Const IntPointer afCoordinate ) { super((Pointer)null); allocate(afCoordinate); }
        private native void allocate( @Const IntPointer afCoordinate );
        public Vector2( @Const IntBuffer afCoordinate ) { super((Pointer)null); allocate(afCoordinate); }
        private native void allocate( @Const IntBuffer afCoordinate );
        public Vector2( @Const int[] afCoordinate ) { super((Pointer)null); allocate(afCoordinate); }
        private native void allocate( @Const int[] afCoordinate );



        public native void swap(@ByRef Vector2 other);

        public native @Name("operator []") double get( @Cast("const size_t") long i );


        public native double ptr();





        public native @ByRef @Name("operator =") Vector2 put( @Const @ByRef Vector2 rkVector );

        public native @ByRef @Name("operator =") Vector2 put( double fScalar);

        public native @Cast("bool") @Name("operator ==") boolean equals( @Const @ByRef Vector2 rkVector );

        public native @Cast("bool") @Name("operator !=") boolean notEquals( @Const @ByRef Vector2 rkVector );


        public native @ByVal @Name("operator +") Vector2 add( @Const @ByRef Vector2 rkVector );

        public native @ByVal @Name("operator -") Vector2 subtract( @Const @ByRef Vector2 rkVector );

        public native @ByVal @Name("operator *") Vector2 multiply( double fScalar );

        public native @ByVal @Name("operator *") Vector2 multiply( @Const @ByRef Vector2 rhs);

        public native @ByVal @Name("operator /") Vector2 divide( double fScalar );

        public native @ByVal @Name("operator /") Vector2 divide( @Const @ByRef Vector2 rhs);

        public native @Const @ByRef @Name("operator +") Vector2 add();

        public native @ByVal @Name("operator -") Vector2 subtract();


        

        

        

        

        

        


        public native @ByRef @Name("operator +=") Vector2 addPut( @Const @ByRef Vector2 rkVector );

        public native @ByRef @Name("operator +=") Vector2 addPut( double fScaler );

        public native @ByRef @Name("operator -=") Vector2 subtractPut( @Const @ByRef Vector2 rkVector );

        public native @ByRef @Name("operator -=") Vector2 subtractPut( double fScaler );

        public native @ByRef @Name("operator *=") Vector2 multiplyPut( double fScalar );

        public native @ByRef @Name("operator *=") Vector2 multiplyPut( @Const @ByRef Vector2 rkVector );

        public native @ByRef @Name("operator /=") Vector2 dividePut( double fScalar );

        public native @ByRef @Name("operator /=") Vector2 dividePut( @Const @ByRef Vector2 rkVector );
        public native double length();
        public native double squaredLength();
        public native double distance(@Const @ByRef Vector2 rhs);
        public native double squaredDistance(@Const @ByRef Vector2 rhs);
        public native double dotProduct(@Const @ByRef Vector2 vec);
        public native double normalise();




        public native @ByVal Vector2 midPoint( @Const @ByRef Vector2 vec );




        public native @Cast("bool") @Name("operator <") boolean lessThan( @Const @ByRef Vector2 rhs );




        public native @Cast("bool") @Name("operator >") boolean greaterThan( @Const @ByRef Vector2 rhs );
        public native void makeFloor( @Const @ByRef Vector2 cmp );
        public native void makeCeil( @Const @ByRef Vector2 cmp );
        public native @ByVal Vector2 perpendicular();




        public native double crossProduct( @Const @ByRef Vector2 rkVector );
        public native @ByVal Vector2 randomDeviant(@ByVal Radian angle);


        public native @Cast("bool") boolean isZeroLength();



        public native @ByVal Vector2 normalisedCopy();




        public native @ByVal Vector2 reflect(@Const @ByRef Vector2 normal);


        public native @Cast("bool") boolean isNaN();





        public native @ByVal Radian angleBetween(@Const @ByRef Vector2 other);






        public native @ByVal Radian angleTo(@Const @ByRef Vector2 other);


        @MemberGetter public static native @Const @ByRef Vector2 ZERO();
        @MemberGetter public static native @Const @ByRef Vector2 UNIT_X();
        @MemberGetter public static native @Const @ByRef Vector2 UNIT_Y();
        @MemberGetter public static native @Const @ByRef Vector2 NEGATIVE_UNIT_X();
        @MemberGetter public static native @Const @ByRef Vector2 NEGATIVE_UNIT_Y();
        @MemberGetter public static native @Const @ByRef Vector2 UNIT_SCALE();



        
    }



    @Namespace("Ogre") @NoOffset public static class AnimableValue extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public AnimableValue(Pointer p) { super(p); }
    

        /** enum Ogre::AnimableValue::ValueType */
        public static final int
            INT = 0,
            REAL = 1,
            VECTOR2 = 2,
            VECTOR3 = 3,
            VECTOR4 = 4,
            QUATERNION = 5,
            COLOUR = 6,
            RADIAN = 7,
            DEGREE = 8;


        public native @Cast("Ogre::AnimableValue::ValueType") int getType();


        public native void setCurrentStateAsBaseValue();


        public native void setValue(int arg0);

        public native void setValue(double arg0);

        public native void setValue(@Const @ByRef Vector2 arg0);

        public native void setValue(@Const @ByRef Vector3 arg0);

        public native void setValue(@Const @ByRef Vector4 arg0);

        public native void setValue(@Const @ByRef Quaternion arg0);

        public native void setValue(@Const @ByRef ColourValue arg0);

        public native void setValue(@Const @ByRef Radian arg0);

        public native void setValue(@Const @ByRef Degree arg0);

        public native void setValue(@Const @ByRef Any val);


        public native void resetToBaseValue();


        public native void applyDeltaValue(int arg0);

        public native void applyDeltaValue(double arg0);

        public native void applyDeltaValue(@Const @ByRef Vector2 arg0);

        public native void applyDeltaValue(@Const @ByRef Vector3 arg0);

        public native void applyDeltaValue(@Const @ByRef Vector4 arg0);

        public native void applyDeltaValue(@Const @ByRef Quaternion arg0);

        public native void applyDeltaValue(@Const @ByRef ColourValue arg0);

        public native void applyDeltaValue(@Const @ByRef Degree arg0);

        public native void applyDeltaValue(@Const @ByRef Radian arg0);

        public native void applyDeltaValue(@Const @ByRef Any val);


    }




    @Namespace("Ogre") @NoOffset public static class AnimableObject extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public AnimableObject(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public AnimableObject(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public AnimableObject position(long position) {
            return (AnimableObject)super.position(position);
        }
    
        public AnimableObject() { super((Pointer)null); allocate(); }
        private native void allocate();


        public native @Cast("const Ogre::StringVector*") @ByRef StringVectorRef getAnimableValueNames();







        public native @ByVal @Cast("Ogre::AnimableValuePtr*") RealControllerFunctionSPtr createAnimableValue(@Const @ByRef String valueName);



    }





    @Namespace("Ogre") public static native void MurmurHash3_x86_32( @Const Pointer key, int len, @Cast("uint32_t") int seed, Pointer out );

    @Namespace("Ogre") public static native void MurmurHash3_x86_128( @Const Pointer key, int len, @Cast("uint32_t") int seed, Pointer out );

    @Namespace("Ogre") public static native void MurmurHash3_x64_128( @Const Pointer key, int len, @Cast("uint32_t") int seed, Pointer out );

    @Namespace("Ogre") @NoOffset public static class IdString extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public IdString(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public IdString(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public IdString position(long position) {
            return (IdString)super.position(position);
        }
    
        @MemberGetter public static native @Cast("const uint32_t") int Seed();
        public static final int Seed = Seed();

        public native @Cast("Ogre::uint32") int mHash(); public native IdString mHash(int mHash);


        public native @Cast("char") byte mDebugString(int i); public native IdString mDebugString(int i, byte mDebugString);
        @MemberGetter public native @Cast("char*") BytePointer mDebugString();


        public IdString() { super((Pointer)null); allocate(); }
        private native void allocate();

        public IdString( @Cast("const char*") BytePointer string ) { super((Pointer)null); allocate(string); }
        private native void allocate( @Cast("const char*") BytePointer string );
        public IdString( String string ) { super((Pointer)null); allocate(string); }
        private native void allocate( String string );

        public IdString( @Cast("Ogre::uint32") int value ) { super((Pointer)null); allocate(value); }
        private native void allocate( @Cast("Ogre::uint32") int value );







        public native void OGRE_COPY_DEBUG_STRING( @Cast("const char*") BytePointer string );
        public native void OGRE_COPY_DEBUG_STRING( String string );

        public native void OGRE_COPY_DEBUG_STRING( @Cast("Ogre::uint32") int value );

        public native void OGRE_APPEND_DEBUG_STRING( @Cast("const char*") BytePointer string );
        public native void OGRE_APPEND_DEBUG_STRING( String string );






        public native @Name("operator +=") void addPut( @ByVal IdString idString );

        public native @ByVal @Name("operator +") IdString add( @ByVal IdString idString );

        public native @Cast("bool") @Name("operator <") boolean lessThan( @ByVal IdString idString );

        public native @Cast("bool") @Name("operator ==") boolean equals( @ByVal IdString idString );

        public native @Cast("bool") @Name("operator !=") boolean notEquals( @ByVal IdString idString );


        public native @ByVal String getFriendlyText();


        public native @ByVal String getReleaseText();
    }

    /** enum Ogre::ParameterType */
    public static final int
        PT_BOOL = 0,
        PT_REAL = 1,
        PT_INT = 2,
        PT_UNSIGNED_INT = 3,
        PT_SHORT = 4,
        PT_UNSIGNED_SHORT = 5,
        PT_LONG = 6,
        PT_UNSIGNED_LONG = 7,
        PT_STRING = 8,
        PT_VECTOR3 = 9,
        PT_MATRIX3 = 10,
        PT_MATRIX4 = 11,
        PT_QUATERNION = 12,
        PT_COLOURVALUE = 13;


    @Namespace("Ogre") @NoOffset public static class ParameterDef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ParameterDef(Pointer p) { super(p); }
    
        public native @ByRef String name(); public native ParameterDef name(String name);
        public native @ByRef String description(); public native ParameterDef description(String description);
        public native @Cast("Ogre::ParameterType") int paramType(); public native ParameterDef paramType(int paramType);
        public ParameterDef(@Const @ByRef String newName, @Const @ByRef String newDescription, @Cast("Ogre::ParameterType") int newType) { super((Pointer)null); allocate(newName, newDescription, newType); }
        private native void allocate(@Const @ByRef String newName, @Const @ByRef String newDescription, @Cast("Ogre::ParameterType") int newType);
    }


    @Namespace("Ogre") public static class ParamCommand extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ParamCommand(Pointer p) { super(p); }
    
        public native @ByVal String doGet(@Const Pointer target);
        public native void doSet(Pointer target, @Const @ByRef String val);
    }


    @Namespace("Ogre") @NoOffset public static class ParamDictionary extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ParamDictionary(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ParamDictionary(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ParamDictionary position(long position) {
            return (ParamDictionary)super.position(position);
        }
    
        public ParamDictionary() { super((Pointer)null); allocate(); }
        private native void allocate();






        public native void addParameter(@Const @ByRef ParameterDef paramDef, ParamCommand paramCmd);





        public native @Cast("const Ogre::ParameterList*") @ByRef ParameterDefVectorRef getParameters();



    }
    @Namespace("Ogre") @NoOffset public static class StringInterface extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public StringInterface(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public StringInterface(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public StringInterface position(long position) {
            return (StringInterface)super.position(position);
        }
    
        public StringInterface() { super((Pointer)null); allocate(); }
        private native void allocate();
        public native ParamDictionary getParamDictionary();






        public native @Cast("const Ogre::ParameterList*") @ByRef ParameterDefVectorRef getParameters();
        public native @Cast("bool") boolean setParameter(@Const @ByRef String name, @Const @ByRef String value);
        public native void setParameterList(@Cast("const Ogre::NameValuePairList*") @ByRef SStringMapRef paramList);
        public native @ByVal String getParameter(@Const @ByRef String name);
        public native void copyParametersTo(StringInterface dest);




        public static native void cleanupDictionary();

    }





    @Namespace("Ogre") @NoOffset public static class Resource extends StringInterface {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Resource(Pointer p) { super(p); }
        public Pointer asPointer() { return asPointer(this); }
        @Namespace public static native @Name("static_cast<ResourceAlloc*>") Pointer asPointer(Resource pointer);
    
   
        @Name("Ogre::Resource::Listener") public static class ResourceListener extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public ResourceListener(Pointer p) { super(p); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public ResourceListener(long size) { super((Pointer)null); allocateArray(size); }
            private native void allocateArray(long size);
            @Override public ResourceListener position(long position) {
                return (ResourceListener)super.position(position);
            }
        
            public ResourceListener() { super((Pointer)null); allocate(); }
            private native void allocate();
            public native void loadingComplete(Resource arg0);
            public native void preparingComplete(Resource arg0);


            public native void unloadingComplete(Resource arg0);
        }


        /** enum Ogre::Resource::LoadingState */
        public static final int

            LOADSTATE_UNLOADED = 0,

            LOADSTATE_LOADING = 1,

            LOADSTATE_LOADED = 2,

            LOADSTATE_UNLOADING = 3,

            LOADSTATE_PREPARED = 4,

            LOADSTATE_PREPARING = 5;
        public native void prepare(@Cast("bool") boolean backgroundThread/*=false*/);
        public native void prepare();
        public native void load(@Cast("bool") boolean backgroundThread/*=false*/);
        public native void load();






        public native void reload();



        public native @Cast("bool") boolean isReloadable();



        public native @Cast("bool") boolean isManuallyLoaded();



        public native void setManuallyLoaded(@Cast("bool") boolean isManual);





        public native void unload();



        public native @Cast("size_t") long getSize();



        public native void touch();



        public native @Const @ByRef String getName();

        public native @Cast("Ogre::ResourceHandle") long getHandle();



        public native @Cast("bool") boolean isPrepared();



        public native @Cast("bool") boolean isLoaded();



        public native void setToLoaded();




        public native @Cast("bool") boolean isLoading();



        public native @Cast("Ogre::Resource::LoadingState") int getLoadingState();
        public native @Cast("bool") boolean isBackgroundLoaded();
        public native void setBackgroundLoaded(@Cast("bool") boolean bl);
        public native void escalateLoading();




        public native void addListener(ResourceListener lis);




        public native void removeListener(ResourceListener lis);


        public native @Const @ByRef String getGroup();
        public native void changeGroupOwnership(@Const @ByRef String newGroup);


        public native ResourceManager getCreator();






        public native @Const @ByRef String getOrigin();

        public native void _notifyOrigin(@Const @ByRef String origin);
        public native @Cast("size_t") long getStateCount();






        public native void _dirtyState();
        public native void _fireLoadingComplete(@Cast("bool") boolean wasBackgroundLoaded);
        public native void _firePreparingComplete(@Cast("bool") boolean wasBackgroundLoaded);
        public native void _fireUnloadingComplete();


        public native @Cast("size_t") long calculateSize();

    }
    @Namespace("Ogre") public static class ManualResourceLoader extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ManualResourceLoader(Pointer p) { super(p); }
    







        public native void prepareResource(Resource resource);




        public native void loadResource(Resource resource);
    }




    @Namespace("Ogre") @NoOffset public static class Serializer extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Serializer(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Serializer(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Serializer position(long position) {
            return (Serializer)super.position(position);
        }
    
        public Serializer() { super((Pointer)null); allocate(); }
        private native void allocate();


        /** enum Ogre::Serializer::Endian */
        public static final int

            ENDIAN_NATIVE = 0,

            ENDIAN_BIG = 1,

            ENDIAN_LITTLE = 2;
    }




    /** enum Ogre::BaseConstantType */
    public static final int
        BCT_FLOAT = 1,
        BCT_INT = 2,
        BCT_DOUBLE = 3,
        BCT_UINT = 4,
        BCT_BOOL = 5,
        BCT_SAMPLER = 6,
        BCT_SUBROUTINE = 7,
        BCT_UNKNOWN = 99;






    /** enum Ogre::GpuConstantType */
    public static final int
        GCT_FLOAT1 = 1,
        GCT_FLOAT2 = 2,
        GCT_FLOAT3 = 3,
        GCT_FLOAT4 = 4,
        GCT_SAMPLER1D = 5,
        GCT_SAMPLER2D = 6,
        GCT_SAMPLER3D = 7,
        GCT_SAMPLERCUBE = 8,
        GCT_SAMPLERRECT = 9,
        GCT_SAMPLER1DSHADOW = 10,
        GCT_SAMPLER2DSHADOW = 11,
        GCT_SAMPLER2DARRAY = 12,
        GCT_MATRIX_2X2 = 13,
        GCT_MATRIX_2X3 = 14,
        GCT_MATRIX_2X4 = 15,
        GCT_MATRIX_3X2 = 16,
        GCT_MATRIX_3X3 = 17,
        GCT_MATRIX_3X4 = 18,
        GCT_MATRIX_4X2 = 19,
        GCT_MATRIX_4X3 = 20,
        GCT_MATRIX_4X4 = 21,
        GCT_INT1 = 22,
        GCT_INT2 = 23,
        GCT_INT3 = 24,
        GCT_INT4 = 25,
        GCT_SUBROUTINE = 26,
        GCT_DOUBLE1 = 27,
        GCT_DOUBLE2 = 28,
        GCT_DOUBLE3 = 29,
        GCT_DOUBLE4 = 30,
        GCT_MATRIX_DOUBLE_2X2 = 31,
        GCT_MATRIX_DOUBLE_2X3 = 32,
        GCT_MATRIX_DOUBLE_2X4 = 33,
        GCT_MATRIX_DOUBLE_3X2 = 34,
        GCT_MATRIX_DOUBLE_3X3 = 35,
        GCT_MATRIX_DOUBLE_3X4 = 36,
        GCT_MATRIX_DOUBLE_4X2 = 37,
        GCT_MATRIX_DOUBLE_4X3 = 38,
        GCT_MATRIX_DOUBLE_4X4 = 39,
        GCT_UINT1 = 40,
        GCT_UINT2 = 41,
        GCT_UINT3 = 42,
        GCT_UINT4 = 43,
        GCT_BOOL1 = 44,
        GCT_BOOL2 = 45,
        GCT_BOOL3 = 46,
        GCT_BOOL4 = 47,
        GCT_SAMPLER_WRAPPER1D = 48,
        GCT_SAMPLER_WRAPPER2D = 49,
        GCT_SAMPLER_WRAPPER3D = 50,
        GCT_SAMPLER_WRAPPERCUBE = 51,
        GCT_SAMPLER_STATE = 52,
        GCT_UNKNOWN = 99;




    /** enum Ogre::GpuParamVariability */
    public static final int

        GPV_GLOBAL = 1,

        GPV_PER_OBJECT = 2,

        GPV_LIGHTS = 4,

        GPV_PASS_ITERATION_NUMBER = 8,



        GPV_ALL =  0xFFFF;





    @Namespace("Ogre") @NoOffset public static class GpuConstantDefinition extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public GpuConstantDefinition(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public GpuConstantDefinition(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public GpuConstantDefinition position(long position) {
            return (GpuConstantDefinition)super.position(position);
        }
    

        public native @Cast("Ogre::GpuConstantType") int constType(); public native GpuConstantDefinition constType(int constType);

        public native @Cast("size_t") long physicalIndex(); public native GpuConstantDefinition physicalIndex(long physicalIndex);

        public native @Cast("size_t") long logicalIndex(); public native GpuConstantDefinition logicalIndex(long logicalIndex);


        public native @Cast("size_t") long elementSize(); public native GpuConstantDefinition elementSize(long elementSize);

        public native @Cast("size_t") long arraySize(); public native GpuConstantDefinition arraySize(long arraySize);

        public native @Cast("Ogre::uint16") short variability(); public native GpuConstantDefinition variability(short variability);







        public native @Cast("bool") boolean isFloat();

        public static native @Cast("bool") boolean isFloat(@Cast("Ogre::GpuConstantType") int c);

        public native @Cast("bool") boolean isDouble();

        public static native @Cast("bool") boolean isDouble(@Cast("Ogre::GpuConstantType") int c);

        public native @Cast("bool") boolean isInt();

        public static native @Cast("bool") boolean isInt(@Cast("Ogre::GpuConstantType") int c);

        public native @Cast("bool") boolean isUnsignedInt();

        public static native @Cast("bool") boolean isUnsignedInt(@Cast("Ogre::GpuConstantType") int c);

        public native @Cast("bool") boolean isBool();

        public static native @Cast("bool") boolean isBool(@Cast("Ogre::GpuConstantType") int c);

        public native @Cast("bool") boolean isSampler();

        public static native @Cast("bool") boolean isSampler(@Cast("Ogre::GpuConstantType") int c);

        public native @Cast("bool") boolean isSubroutine();

        public static native @Cast("bool") boolean isSubroutine(@Cast("Ogre::GpuConstantType") int c);

        public static native @Cast("Ogre::BaseConstantType") int getBaseType(@Cast("Ogre::GpuConstantType") int ctype);




        public static native @Cast("size_t") long getElementSize(@Cast("Ogre::GpuConstantType") int ctype, @Cast("bool") boolean padToMultiplesOf4);

    public GpuConstantDefinition() { super((Pointer)null); allocate(); }
    private native void allocate();
    }


    @Namespace("Ogre") @NoOffset public static class GpuNamedConstants extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public GpuNamedConstants(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public GpuNamedConstants(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public GpuNamedConstants position(long position) {
            return (GpuNamedConstants)super.position(position);
        }
    

        public native @Cast("size_t") long floatBufferSize(); public native GpuNamedConstants floatBufferSize(long floatBufferSize);

        public native @Cast("size_t") long doubleBufferSize(); public native GpuNamedConstants doubleBufferSize(long doubleBufferSize);

        public native @Cast("size_t") long intBufferSize(); public native GpuNamedConstants intBufferSize(long intBufferSize);

        public native @Cast("size_t") long uintBufferSize(); public native GpuNamedConstants uintBufferSize(long uintBufferSize);



        public native @ByRef @Cast("Ogre::GpuConstantDefinitionMap*") GpuConstantDefinitionMapRef map(); public native GpuNamedConstants map(GpuConstantDefinitionMapRef map);

    public GpuNamedConstants() { super((Pointer)null); allocate(); }
    private native void allocate();
        public native void generateConstantDefinitionArrayEntries(@Const @ByRef String paramName,
                                                            @Const @ByRef GpuConstantDefinition baseDef);


        public static native @Cast("bool") boolean getGenerateAllConstantDefinitionArrayEntries();







        public static native void setGenerateAllConstantDefinitionArrayEntries(@Cast("bool") boolean generateAll);




        public native void save(@Const @ByRef String filename);



        public native void load(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream);

        public native @Cast("size_t") long calculateSize();
    }


    @Namespace("Ogre") public static class GpuNamedConstantsSerializer extends Serializer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public GpuNamedConstantsSerializer(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public GpuNamedConstantsSerializer(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public GpuNamedConstantsSerializer position(long position) {
            return (GpuNamedConstantsSerializer)super.position(position);
        }
    
        public GpuNamedConstantsSerializer() { super((Pointer)null); allocate(); }
        private native void allocate();
        public native void exportNamedConstants(@Const GpuNamedConstants pConsts, @Const @ByRef String filename,
                                          @ByVal(nullValue = "Endian(ENDIAN_NATIVE)") Endian endianMode);
        public native void exportNamedConstants(@Const GpuNamedConstants pConsts, @Const @ByRef String filename);
        public native void exportNamedConstants(@Const GpuNamedConstants pConsts, @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr stream,
                                          @ByVal(nullValue = "Endian(ENDIAN_NATIVE)") Endian endianMode);
        public native void exportNamedConstants(@Const GpuNamedConstants pConsts, @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr stream);
        public native void importNamedConstants(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream, GpuNamedConstants pDest);
    }




    @Namespace("Ogre") @NoOffset public static class GpuLogicalIndexUse extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public GpuLogicalIndexUse(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public GpuLogicalIndexUse(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public GpuLogicalIndexUse position(long position) {
            return (GpuLogicalIndexUse)super.position(position);
        }
    

        public native @Cast("size_t") long physicalIndex(); public native GpuLogicalIndexUse physicalIndex(long physicalIndex);

        public native @Cast("size_t") long currentSize(); public native GpuLogicalIndexUse currentSize(long currentSize);

        public native @Cast("Ogre::uint16") short variability(); public native GpuLogicalIndexUse variability(short variability);

    public GpuLogicalIndexUse() { super((Pointer)null); allocate(); }
    private native void allocate();
    public GpuLogicalIndexUse(@Cast("size_t") long bufIdx, @Cast("size_t") long curSz, @Cast("Ogre::uint16") short v) { super((Pointer)null); allocate(bufIdx, curSz, v); }
    private native void allocate(@Cast("size_t") long bufIdx, @Cast("size_t") long curSz, @Cast("Ogre::uint16") short v);
    }

    @Namespace("Ogre") @NoOffset public static class GpuLogicalBufferStruct extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public GpuLogicalBufferStruct(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public GpuLogicalBufferStruct(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public GpuLogicalBufferStruct position(long position) {
            return (GpuLogicalBufferStruct)super.position(position);
        }
    
     


        public native @ByRef @Cast("Ogre::GpuLogicalIndexUseMap*") GpuLogicalIndexUseMapRef map(); public native GpuLogicalBufferStruct map(GpuLogicalIndexUseMapRef map);

        public native @Cast("size_t") long bufferSize(); public native GpuLogicalBufferStruct bufferSize(long bufferSize);
    public GpuLogicalBufferStruct() { super((Pointer)null); allocate(); }
    private native void allocate();
    }
    @Namespace("Ogre") @NoOffset public static class GpuSharedParameters extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public GpuSharedParameters(Pointer p) { super(p); }
    
        public GpuSharedParameters(@Const @ByRef String name) { super((Pointer)null); allocate(name); }
        private native void allocate(@Const @ByRef String name);


        public native @Const @ByRef String getName();
        public native void addConstantDefinition(@Const @ByRef String name, @Cast("Ogre::GpuConstantType") int constType, @Cast("size_t") long arraySize/*=1*/);
        public native void addConstantDefinition(@Const @ByRef String name, @Cast("Ogre::GpuConstantType") int constType);



        public native void removeConstantDefinition(@Const @ByRef String name);



        public native void removeAllConstantDefinitions();




        public native @Cast("unsigned long") long getVersion();




        public native @Cast("size_t") long calculateSize();




        public native @Cast("bool") boolean isDirty();







        public native void _markClean();
        public native void _markDirty();


        public native @Cast("size_t") long getFrameLastUpdated();




        public native @ByVal @Cast("Ogre::GpuConstantDefinitionIterator*") NumericTrackIteratorRef getConstantDefinitionIterator();



        public native @Const @ByRef GpuConstantDefinition getConstantDefinition(@Const @ByRef String name);



        public native @Const @ByRef GpuNamedConstants getConstantDefinitions();


        public native void setNamedConstant(@Const @ByRef String name, double val);

        public native void setNamedConstant(@Const @ByRef String name, int val);



        public native void setNamedConstant(@Const @ByRef String name, @Const @ByRef Vector4 vec);

        public native void setNamedConstant(@Const @ByRef String name, @Const @ByRef Vector3 vec);

        public native void setNamedConstant(@Const @ByRef String name, @Const @ByRef Vector2 vec);

        public native void setNamedConstant(@Const @ByRef String name, @Const @ByRef Matrix4 m);

        public native void setNamedConstant(@Const @ByRef String name, @Const Matrix4 m, @Cast("size_t") long numEntries);

        public native void setNamedConstant(@Const @ByRef String name, @Const FloatPointer val, @Cast("size_t") long count);
        public native void setNamedConstant(@Const @ByRef String name, @Const FloatBuffer val, @Cast("size_t") long count);
        public native void setNamedConstant(@Const @ByRef String name, @Const float[] val, @Cast("size_t") long count);

        public native void setNamedConstant(@Const @ByRef String name, @Const DoublePointer val, @Cast("size_t") long count);
        public native void setNamedConstant(@Const @ByRef String name, @Const DoubleBuffer val, @Cast("size_t") long count);
        public native void setNamedConstant(@Const @ByRef String name, @Const double[] val, @Cast("size_t") long count);

        public native void setNamedConstant(@Const @ByRef String name, @Const @ByRef ColourValue colour);

        public native void setNamedConstant(@Const @ByRef String name, @Const IntPointer val, @Cast("size_t") long count);
        public native void setNamedConstant(@Const @ByRef String name, @Const IntBuffer val, @Cast("size_t") long count);
        public native void setNamedConstant(@Const @ByRef String name, @Const int[] val, @Cast("size_t") long count);




        public native FloatPointer getFloatPointer(@Cast("size_t") long pos);

        public native DoublePointer getDoublePointer(@Cast("size_t") long pos);

        public native IntPointer getIntPointer(@Cast("size_t") long pos);

        public native @Cast("Ogre::uint*") IntPointer getUnsignedIntPointer(@Cast("size_t") long pos);






        public native @Cast("const Ogre::FloatConstantList*") @ByRef FloatVectorRef getFloatConstantList();

        public native @Cast("const Ogre::DoubleConstantList*") @ByRef DoubleVectorRef getDoubleConstantList();

        public native @Cast("const Ogre::IntConstantList*") @ByRef IntVectorRef getIntConstantList();

        public native @Cast("const Ogre::UnsignedIntConstantList*") @ByRef UintVectorRef getUnsignedIntConstantList();




        public native void _setRenderSystemData(@Const @ByRef Any data);

        public native @Const @ByRef Any _getRenderSystemData();

    }




    @Namespace("Ogre") @NoOffset public static class GpuSharedParametersUsage extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public GpuSharedParametersUsage(Pointer p) { super(p); }
    

        public GpuSharedParametersUsage(@ByVal @Cast("Ogre::GpuSharedParametersPtr*") RealControllerFunctionSPtr sharedParams,
                                         GpuProgramParameters params) { super((Pointer)null); allocate(sharedParams, params); }
        private native void allocate(@ByVal @Cast("Ogre::GpuSharedParametersPtr*") RealControllerFunctionSPtr sharedParams,
                                         GpuProgramParameters params);
        public native void _copySharedParamsToTargetParams();


        public native @Const @ByRef String getName();

        public native @ByVal @Cast("Ogre::GpuSharedParametersPtr*") RealControllerFunctionSPtr getSharedParams();
        public native GpuProgramParameters getTargetParams();


        public native void _setRenderSystemData(@Const @ByRef Any data);

        public native @Const @ByRef Any _getRenderSystemData();


    }
    @Namespace("Ogre") @NoOffset public static class GpuProgramParameters extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public GpuProgramParameters(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public GpuProgramParameters(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public GpuProgramParameters position(long position) {
            return (GpuProgramParameters)super.position(position);
        }
    



        /** enum Ogre::GpuProgramParameters::AutoConstantType */
        public static final int

            ACT_WORLD_MATRIX = 0,

            ACT_INVERSE_WORLD_MATRIX = 1,



            ACT_TRANSPOSE_WORLD_MATRIX = 2,

            ACT_INVERSE_TRANSPOSE_WORLD_MATRIX = 3,


            ACT_WORLD_MATRIX_ARRAY_3x4 = 4,

            ACT_WORLD_MATRIX_ARRAY = 5,

            ACT_WORLD_DUALQUATERNION_ARRAY_2x4 = 6,

            ACT_WORLD_SCALE_SHEAR_MATRIX_ARRAY_3x4 = 7,


            ACT_VIEW_MATRIX = 8,

            ACT_INVERSE_VIEW_MATRIX = 9,



            ACT_TRANSPOSE_VIEW_MATRIX = 10,



            ACT_INVERSE_TRANSPOSE_VIEW_MATRIX = 11,



            ACT_PROJECTION_MATRIX = 12,



            ACT_INVERSE_PROJECTION_MATRIX = 13,



            ACT_TRANSPOSE_PROJECTION_MATRIX = 14,



            ACT_INVERSE_TRANSPOSE_PROJECTION_MATRIX = 15,



            ACT_VIEWPROJ_MATRIX = 16,



            ACT_INVERSE_VIEWPROJ_MATRIX = 17,



            ACT_TRANSPOSE_VIEWPROJ_MATRIX = 18,



            ACT_INVERSE_TRANSPOSE_VIEWPROJ_MATRIX = 19,



            ACT_WORLDVIEW_MATRIX = 20,

            ACT_INVERSE_WORLDVIEW_MATRIX = 21,



            ACT_TRANSPOSE_WORLDVIEW_MATRIX = 22,

            ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX = 23,




            ACT_WORLDVIEWPROJ_MATRIX = 24,



            ACT_INVERSE_WORLDVIEWPROJ_MATRIX = 25,



            ACT_TRANSPOSE_WORLDVIEWPROJ_MATRIX = 26,



            ACT_INVERSE_TRANSPOSE_WORLDVIEWPROJ_MATRIX = 27,






            ACT_RENDER_TARGET_FLIPPING = 28,



            ACT_VERTEX_WINDING = 29,


            ACT_FOG_COLOUR = 30,

            ACT_FOG_PARAMS = 31,



            ACT_SURFACE_AMBIENT_COLOUR = 32,

            ACT_SURFACE_DIFFUSE_COLOUR = 33,

            ACT_SURFACE_SPECULAR_COLOUR = 34,

            ACT_SURFACE_EMISSIVE_COLOUR = 35,

            ACT_SURFACE_SHININESS = 36,

            ACT_SURFACE_ALPHA_REJECTION_VALUE = 37,



            ACT_LIGHT_COUNT = 38,



            ACT_AMBIENT_LIGHT_COLOUR = 39,


            ACT_LIGHT_DIFFUSE_COLOUR = 40,

            ACT_LIGHT_SPECULAR_COLOUR = 41,

            ACT_LIGHT_ATTENUATION = 42,





            ACT_SPOTLIGHT_PARAMS = 43,

            ACT_LIGHT_POSITION = 44,

            ACT_LIGHT_POSITION_OBJECT_SPACE = 45,

            ACT_LIGHT_POSITION_VIEW_SPACE = 46,

            ACT_LIGHT_DIRECTION = 47,

            ACT_LIGHT_DIRECTION_OBJECT_SPACE = 48,

            ACT_LIGHT_DIRECTION_VIEW_SPACE = 49,




            ACT_LIGHT_DISTANCE_OBJECT_SPACE = 50,

            ACT_LIGHT_POWER_SCALE = 51,

            ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED = 52,

            ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED = 53,

            ACT_LIGHT_DIFFUSE_COLOUR_ARRAY = 54,

            ACT_LIGHT_SPECULAR_COLOUR_ARRAY = 55,

            ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED_ARRAY = 56,

            ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED_ARRAY = 57,

            ACT_LIGHT_ATTENUATION_ARRAY = 58,

            ACT_LIGHT_POSITION_ARRAY = 59,

            ACT_LIGHT_POSITION_OBJECT_SPACE_ARRAY = 60,

            ACT_LIGHT_POSITION_VIEW_SPACE_ARRAY = 61,

            ACT_LIGHT_DIRECTION_ARRAY = 62,

            ACT_LIGHT_DIRECTION_OBJECT_SPACE_ARRAY = 63,

            ACT_LIGHT_DIRECTION_VIEW_SPACE_ARRAY = 64,




            ACT_LIGHT_DISTANCE_OBJECT_SPACE_ARRAY = 65,



            ACT_LIGHT_POWER_SCALE_ARRAY = 66,






            ACT_SPOTLIGHT_PARAMS_ARRAY = 67,





            ACT_DERIVED_AMBIENT_LIGHT_COLOUR = 68,




            ACT_DERIVED_SCENE_COLOUR = 69,






            ACT_DERIVED_LIGHT_DIFFUSE_COLOUR = 70,





            ACT_DERIVED_LIGHT_SPECULAR_COLOUR = 71,


            ACT_DERIVED_LIGHT_DIFFUSE_COLOUR_ARRAY = 72,

            ACT_DERIVED_LIGHT_SPECULAR_COLOUR_ARRAY = 73,

            ACT_LIGHT_CASTS_SHADOWS = 74,

            ACT_LIGHT_CASTS_SHADOWS_ARRAY = 75,





            ACT_SHADOW_EXTRUSION_DISTANCE = 76,

            ACT_CAMERA_POSITION = 77,

            ACT_CAMERA_POSITION_OBJECT_SPACE = 78,

            ACT_TEXTURE_VIEWPROJ_MATRIX = 79,

            ACT_TEXTURE_VIEWPROJ_MATRIX_ARRAY = 80,



            ACT_TEXTURE_WORLDVIEWPROJ_MATRIX = 81,

            ACT_TEXTURE_WORLDVIEWPROJ_MATRIX_ARRAY = 82,

            ACT_SPOTLIGHT_VIEWPROJ_MATRIX = 83,

            ACT_SPOTLIGHT_VIEWPROJ_MATRIX_ARRAY = 84,



            ACT_SPOTLIGHT_WORLDVIEWPROJ_MATRIX = 85,



            ACT_SPOTLIGHT_WORLDVIEWPROJ_MATRIX_ARRAY = 86,

            ACT_CUSTOM = 87,


            ACT_TIME = 88,



            ACT_TIME_0_X = 89,

            ACT_COSTIME_0_X = 90,

            ACT_SINTIME_0_X = 91,

            ACT_TANTIME_0_X = 92,



            ACT_TIME_0_X_PACKED = 93,




            ACT_TIME_0_1 = 94,

            ACT_COSTIME_0_1 = 95,

            ACT_SINTIME_0_1 = 96,

            ACT_TANTIME_0_1 = 97,



            ACT_TIME_0_1_PACKED = 98,




            ACT_TIME_0_2PI = 99,

            ACT_COSTIME_0_2PI = 100,

            ACT_SINTIME_0_2PI = 101,

            ACT_TANTIME_0_2PI = 102,



            ACT_TIME_0_2PI_PACKED = 103,

            ACT_FRAME_TIME = 104,

            ACT_FPS = 105,




            ACT_VIEWPORT_WIDTH = 106,



            ACT_VIEWPORT_HEIGHT = 107,



            ACT_INVERSE_VIEWPORT_WIDTH = 108,



            ACT_INVERSE_VIEWPORT_HEIGHT = 109,



            ACT_VIEWPORT_SIZE = 110,





            ACT_VIEW_DIRECTION = 111,



            ACT_VIEW_SIDE_VECTOR = 112,



            ACT_VIEW_UP_VECTOR = 113,



            ACT_FOV = 114,



            ACT_NEAR_CLIP_DISTANCE = 115,



            ACT_FAR_CLIP_DISTANCE = 116,




            ACT_PASS_NUMBER = 117,





            ACT_PASS_ITERATION_NUMBER = 118,





            ACT_ANIMATION_PARAMETRIC = 119,






            ACT_TEXEL_OFFSETS = 120,





            ACT_SCENE_DEPTH_RANGE = 121,






            ACT_SHADOW_SCENE_DEPTH_RANGE = 122,






            ACT_SHADOW_SCENE_DEPTH_RANGE_ARRAY = 123,




            ACT_SHADOW_COLOUR = 124,



            ACT_TEXTURE_SIZE = 125,



            ACT_INVERSE_TEXTURE_SIZE = 126,



            ACT_PACKED_TEXTURE_SIZE = 127,




            ACT_TEXTURE_MATRIX = 128,






            ACT_LOD_CAMERA_POSITION = 129,





            ACT_LOD_CAMERA_POSITION_OBJECT_SPACE = 130,

            ACT_LIGHT_CUSTOM = 131,




            ACT_PSSM_SPLITS = 132,

            ACT_UNKNOWN = 999;




        /** enum Ogre::GpuProgramParameters::ACDataType */
        public static final int

            ACDT_NONE = 0,

            ACDT_INT = 1,

            ACDT_REAL = 2;



        /** enum Ogre::GpuProgramParameters::ElementType */
        public static final int
            ET_INT = 0,

            ET_REAL = 1;




        @NoOffset public static class AutoConstantDefinition extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public AutoConstantDefinition(Pointer p) { super(p); }
        
            public native @Cast("Ogre::GpuProgramParameters::AutoConstantType") int acType(); public native AutoConstantDefinition acType(int acType);
            public native @ByRef String name(); public native AutoConstantDefinition name(String name);
            public native @Cast("size_t") long elementCount(); public native AutoConstantDefinition elementCount(long elementCount);

            public native @Cast("Ogre::GpuProgramParameters::ElementType") int elementType(); public native AutoConstantDefinition elementType(int elementType);

            public native @Cast("Ogre::GpuProgramParameters::ACDataType") int dataType(); public native AutoConstantDefinition dataType(int dataType);

        public AutoConstantDefinition(@Cast("Ogre::GpuProgramParameters::AutoConstantType") int _acType, @Const @ByRef String _name,
                                       @Cast("size_t") long _elementCount, @Cast("Ogre::GpuProgramParameters::ElementType") int _elementType,
                                       @Cast("Ogre::GpuProgramParameters::ACDataType") int _dataType) { super((Pointer)null); allocate(_acType, _name, _elementCount, _elementType, _dataType); }
        private native void allocate(@Cast("Ogre::GpuProgramParameters::AutoConstantType") int _acType, @Const @ByRef String _name,
                                       @Cast("size_t") long _elementCount, @Cast("Ogre::GpuProgramParameters::ElementType") int _elementType,
                                       @Cast("Ogre::GpuProgramParameters::ACDataType") int _dataType);
        }


        @NoOffset public static class AutoConstantEntry extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public AutoConstantEntry(Pointer p) { super(p); }
        

            public native @Cast("Ogre::GpuProgramParameters::AutoConstantType") int paramType(); public native AutoConstantEntry paramType(int paramType);

            public native @Cast("size_t") long physicalIndex(); public native AutoConstantEntry physicalIndex(long physicalIndex);



            public native @Cast("size_t") long elementCount(); public native AutoConstantEntry elementCount(long elementCount);
                public native @Cast("size_t") long data(); public native AutoConstantEntry data(long data);
                public native double fData(); public native AutoConstantEntry fData(double fData);

            public native @Cast("Ogre::uint16") short variability(); public native AutoConstantEntry variability(short variability);

        public AutoConstantEntry(@Cast("Ogre::GpuProgramParameters::AutoConstantType") int theType, @Cast("size_t") long theIndex, @Cast("size_t") long theData,
                                  @Cast("Ogre::uint16") short theVariability, @Cast("size_t") long theElemCount/*=4*/) { super((Pointer)null); allocate(theType, theIndex, theData, theVariability, theElemCount); }
        private native void allocate(@Cast("Ogre::GpuProgramParameters::AutoConstantType") int theType, @Cast("size_t") long theIndex, @Cast("size_t") long theData,
                                  @Cast("Ogre::uint16") short theVariability, @Cast("size_t") long theElemCount/*=4*/);
        public AutoConstantEntry(@Cast("Ogre::GpuProgramParameters::AutoConstantType") int theType, @Cast("size_t") long theIndex, @Cast("size_t") long theData,
                                  @Cast("Ogre::uint16") short theVariability) { super((Pointer)null); allocate(theType, theIndex, theData, theVariability); }
        private native void allocate(@Cast("Ogre::GpuProgramParameters::AutoConstantType") int theType, @Cast("size_t") long theIndex, @Cast("size_t") long theData,
                                  @Cast("Ogre::uint16") short theVariability);

        public AutoConstantEntry(@Cast("Ogre::GpuProgramParameters::AutoConstantType") int theType, @Cast("size_t") long theIndex, double theData,
                                  @Cast("Ogre::uint16") short theVariability, @Cast("size_t") long theElemCount/*=4*/) { super((Pointer)null); allocate(theType, theIndex, theData, theVariability, theElemCount); }
        private native void allocate(@Cast("Ogre::GpuProgramParameters::AutoConstantType") int theType, @Cast("size_t") long theIndex, double theData,
                                  @Cast("Ogre::uint16") short theVariability, @Cast("size_t") long theElemCount/*=4*/);
        public AutoConstantEntry(@Cast("Ogre::GpuProgramParameters::AutoConstantType") int theType, @Cast("size_t") long theIndex, double theData,
                                  @Cast("Ogre::uint16") short theVariability) { super((Pointer)null); allocate(theType, theIndex, theData, theVariability); }
        private native void allocate(@Cast("Ogre::GpuProgramParameters::AutoConstantType") int theType, @Cast("size_t") long theIndex, double theData,
                                  @Cast("Ogre::uint16") short theVariability);

        }
        public GpuProgramParameters() { super((Pointer)null); allocate(); }
        private native void allocate();


        public GpuProgramParameters(@Const @ByRef GpuProgramParameters oth) { super((Pointer)null); allocate(oth); }
        private native void allocate(@Const @ByRef GpuProgramParameters oth);

        public native @ByRef @Name("operator =") GpuProgramParameters put(@Const @ByRef GpuProgramParameters oth);


        public native void _setNamedConstants(@Cast("const Ogre::GpuNamedConstantsPtr*") @ByRef RealControllerFunctionSPtr constantmap);


        public native void _setLogicalIndexes(@Cast("const Ogre::GpuLogicalBufferStructPtr*") @ByRef RealControllerFunctionSPtr floatIndexMap, @Cast("const Ogre::GpuLogicalBufferStructPtr*") @ByRef RealControllerFunctionSPtr doubleIndexMap,
                                        @Cast("const Ogre::GpuLogicalBufferStructPtr*") @ByRef RealControllerFunctionSPtr intIndexMap, @Cast("const Ogre::GpuLogicalBufferStructPtr*") @ByRef RealControllerFunctionSPtr uintIndexMap,
                                        @Cast("const Ogre::GpuLogicalBufferStructPtr*") @ByRef RealControllerFunctionSPtr boolIndexMap);



        public native @Cast("bool") boolean hasNamedParameters();





        public native @Cast("bool") boolean hasLogicalIndexedParameters();






        public native void setConstant(@Cast("size_t") long index, @Const @ByRef Vector4 vec);







        public native void setConstant(@Cast("size_t") long index, double val);







        public native void setConstant(@Cast("size_t") long index, @Const @ByRef Vector3 vec);







        public native void setConstant(@Cast("size_t") long index, @Const @ByRef Vector2 vec);






        public native void setConstant(@Cast("size_t") long index, @Const @ByRef Matrix4 m);







        public native void setConstant(@Cast("size_t") long index, @Const Matrix4 m, @Cast("size_t") long numEntries);





        public native void setConstant(@Cast("size_t") long index, @Const @ByRef ColourValue colour);






        public native void setConstant(@Cast("size_t") long index, @Const FloatPointer val, @Cast("size_t") long count);
        public native void setConstant(@Cast("size_t") long index, @Const FloatBuffer val, @Cast("size_t") long count);
        public native void setConstant(@Cast("size_t") long index, @Const float[] val, @Cast("size_t") long count);






        public native void setConstant(@Cast("size_t") long index, @Const DoublePointer val, @Cast("size_t") long count);
        public native void setConstant(@Cast("size_t") long index, @Const DoubleBuffer val, @Cast("size_t") long count);
        public native void setConstant(@Cast("size_t") long index, @Const double[] val, @Cast("size_t") long count);
        public native void setConstant(@Cast("size_t") long index, @Const IntPointer val, @Cast("size_t") long count);
        public native void setConstant(@Cast("size_t") long index, @Const IntBuffer val, @Cast("size_t") long count);
        public native void setConstant(@Cast("size_t") long index, @Const int[] val, @Cast("size_t") long count);
        public native void setConstant(@Cast("size_t") long index, @Cast("const bool*") BoolPointer val, @Cast("size_t") long count);
        public native void setConstant(@Cast("size_t") long index, @Cast("const bool*") boolean[] val, @Cast("size_t") long count);







        public native void _writeRawConstants(@Cast("size_t") long physicalIndex, @Const FloatPointer val, @Cast("size_t") long count);
        public native void _writeRawConstants(@Cast("size_t") long physicalIndex, @Const FloatBuffer val, @Cast("size_t") long count);
        public native void _writeRawConstants(@Cast("size_t") long physicalIndex, @Const float[] val, @Cast("size_t") long count);






        public native void _writeRawConstants(@Cast("size_t") long physicalIndex, @Const DoublePointer val, @Cast("size_t") long count);
        public native void _writeRawConstants(@Cast("size_t") long physicalIndex, @Const DoubleBuffer val, @Cast("size_t") long count);
        public native void _writeRawConstants(@Cast("size_t") long physicalIndex, @Const double[] val, @Cast("size_t") long count);






        public native void _writeRawConstants(@Cast("size_t") long physicalIndex, @Const IntPointer val, @Cast("size_t") long count);
        public native void _writeRawConstants(@Cast("size_t") long physicalIndex, @Const IntBuffer val, @Cast("size_t") long count);
        public native void _writeRawConstants(@Cast("size_t") long physicalIndex, @Const int[] val, @Cast("size_t") long count);
        public native void _readRawConstants(@Cast("size_t") long physicalIndex, @Cast("size_t") long count, FloatPointer dest);
        public native void _readRawConstants(@Cast("size_t") long physicalIndex, @Cast("size_t") long count, FloatBuffer dest);
        public native void _readRawConstants(@Cast("size_t") long physicalIndex, @Cast("size_t") long count, float[] dest);






        public native void _readRawConstants(@Cast("size_t") long physicalIndex, @Cast("size_t") long count, IntPointer dest);
        public native void _readRawConstants(@Cast("size_t") long physicalIndex, @Cast("size_t") long count, IntBuffer dest);
        public native void _readRawConstants(@Cast("size_t") long physicalIndex, @Cast("size_t") long count, int[] dest);
        public native void _writeRawConstant(@Cast("size_t") long physicalIndex, @Const @ByRef Vector4 vec,
                                       @Cast("size_t") long count/*=4*/);
        public native void _writeRawConstant(@Cast("size_t") long physicalIndex, @Const @ByRef Vector4 vec);







        public native void _writeRawConstant(@Cast("size_t") long physicalIndex, double val);







        public native void _writeRawConstant(@Cast("size_t") long physicalIndex, double val, @Cast("size_t") long count);







        public native void _writeRawConstant(@Cast("size_t") long physicalIndex, int val);







        public native void _writeRawConstant(@Cast("size_t") long physicalIndex, @Cast("bool") boolean val);







        public native void _writeRawConstant(@Cast("size_t") long physicalIndex, @Const @ByRef Vector3 vec);







        public native void _writeRawConstant(@Cast("size_t") long physicalIndex, @Const @ByRef Vector2 vec);
        public native void _writeRawConstant(@Cast("size_t") long physicalIndex, @Const @ByRef Matrix4 m, @Cast("size_t") long elementCount);
        public native void _writeRawConstant(@Cast("size_t") long physicalIndex, @Const @ByRef ColourValue colour,
                                       @Cast("size_t") long count/*=4*/);
        public native void _writeRawConstant(@Cast("size_t") long physicalIndex, @Const @ByRef ColourValue colour);







        public native @ByVal @Cast("Ogre::GpuConstantDefinitionIterator*") NumericTrackIteratorRef getConstantDefinitionIterator();





        public native @Const @ByRef GpuConstantDefinition getConstantDefinition(@Const @ByRef String name);





        public native @Const @ByRef GpuNamedConstants getConstantDefinitions();






        public native @Cast("const Ogre::GpuLogicalBufferStructPtr*") @ByRef RealControllerFunctionSPtr getFloatLogicalBufferStruct();





        public native @Cast("const Ogre::GpuLogicalBufferStructPtr*") @ByRef RealControllerFunctionSPtr getDoubleLogicalBufferStruct();





        public native @Cast("const Ogre::GpuLogicalBufferStructPtr*") @ByRef RealControllerFunctionSPtr getIntLogicalBufferStruct();





        public native @Cast("const Ogre::GpuLogicalBufferStructPtr*") @ByRef RealControllerFunctionSPtr getUnsignedIntLogicalBufferStruct();





        public native @Cast("const Ogre::GpuLogicalBufferStructPtr*") @ByRef RealControllerFunctionSPtr getBoolLogicalBufferStruct();






        public native @Cast("size_t") long getFloatLogicalIndexForPhysicalIndex(@Cast("size_t") long physicalIndex);





        public native @Cast("size_t") long getDoubleLogicalIndexForPhysicalIndex(@Cast("size_t") long physicalIndex);





        public native @Cast("size_t") long getIntLogicalIndexForPhysicalIndex(@Cast("size_t") long physicalIndex);





        public native @Cast("size_t") long getUnsignedIntLogicalIndexForPhysicalIndex(@Cast("size_t") long physicalIndex);





        public native @Cast("size_t") long getBoolLogicalIndexForPhysicalIndex(@Cast("size_t") long physicalIndex);



        public native @Cast("const Ogre::FloatConstantList*") @ByRef FloatVectorRef getFloatConstantList();

        public native FloatPointer getFloatPointer(@Cast("size_t") long pos);

        public native @Cast("const Ogre::DoubleConstantList*") @ByRef DoubleVectorRef getDoubleConstantList();

        public native DoublePointer getDoublePointer(@Cast("size_t") long pos);

        public native @Cast("const Ogre::IntConstantList*") @ByRef IntVectorRef getIntConstantList();

        public native IntPointer getIntPointer(@Cast("size_t") long pos);

        public native @Cast("const Ogre::UnsignedIntConstantList*") @ByRef UintVectorRef getUnsignedIntConstantList();

        public native @Cast("Ogre::uint*") IntPointer getUnsignedIntPointer(@Cast("size_t") long pos);
        public native @Cast("const Ogre::GpuProgramParameters::AutoConstantList*") @ByRef AutoConstantEntryVectorRef getAutoConstantList();
        public native void setAutoConstant(@Cast("size_t") long index, @Cast("Ogre::GpuProgramParameters::AutoConstantType") int acType, @Cast("size_t") long extraInfo/*=0*/);
        public native void setAutoConstant(@Cast("size_t") long index, @Cast("Ogre::GpuProgramParameters::AutoConstantType") int acType);
        public native void setAutoConstantReal(@Cast("size_t") long index, @Cast("Ogre::GpuProgramParameters::AutoConstantType") int acType, double rData);
        public native void setAutoConstant(@Cast("size_t") long index, @Cast("Ogre::GpuProgramParameters::AutoConstantType") int acType, @Cast("Ogre::uint16") short extraInfo1, @Cast("Ogre::uint16") short extraInfo2);




        public native void _setRawAutoConstant(@Cast("size_t") long physicalIndex, @Cast("Ogre::GpuProgramParameters::AutoConstantType") int acType, @Cast("size_t") long extraInfo,
                                         @Cast("Ogre::uint16") short variability, @Cast("size_t") long elementSize/*=4*/);
        public native void _setRawAutoConstant(@Cast("size_t") long physicalIndex, @Cast("Ogre::GpuProgramParameters::AutoConstantType") int acType, @Cast("size_t") long extraInfo,
                                         @Cast("Ogre::uint16") short variability);



        public native void _setRawAutoConstantReal(@Cast("size_t") long physicalIndex, @Cast("Ogre::GpuProgramParameters::AutoConstantType") int acType, double rData,
                                             @Cast("Ogre::uint16") short variability, @Cast("size_t") long elementSize/*=4*/);
        public native void _setRawAutoConstantReal(@Cast("size_t") long physicalIndex, @Cast("Ogre::GpuProgramParameters::AutoConstantType") int acType, double rData,
                                             @Cast("Ogre::uint16") short variability);



        public native void clearAutoConstant(@Cast("size_t") long index);





        public native void setConstantFromTime(@Cast("size_t") long index, double factor);


        public native void clearAutoConstants();

        public native @ByVal @Cast("Ogre::GpuProgramParameters::AutoConstantIterator*") NodeTrackIteratorRef getAutoConstantIterator();

        public native @Cast("size_t") long getAutoConstantCount();




        public native AutoConstantEntry getAutoConstantEntry(@Cast("const size_t") long index);

        public native @Cast("bool") boolean hasAutoConstants();




        public native @Const AutoConstantEntry findFloatAutoConstantEntry(@Cast("size_t") long logicalIndex);




        public native @Const AutoConstantEntry findDoubleAutoConstantEntry(@Cast("size_t") long logicalIndex);




        public native @Const AutoConstantEntry findIntAutoConstantEntry(@Cast("size_t") long logicalIndex);




        public native @Const AutoConstantEntry findUnsignedIntAutoConstantEntry(@Cast("size_t") long logicalIndex);
        public native @Const AutoConstantEntry findAutoConstantEntry(@Const @ByRef String paramName);



        public native @Const AutoConstantEntry _findRawAutoConstantEntryFloat(@Cast("size_t") long physicalIndex);



        public native @Const AutoConstantEntry _findRawAutoConstantEntryDouble(@Cast("size_t") long physicalIndex);



        public native @Const AutoConstantEntry _findRawAutoConstantEntryInt(@Cast("size_t") long physicalIndex);



        public native @Const AutoConstantEntry _findRawAutoConstantEntryUnsignedInt(@Cast("size_t") long physicalIndex);



        public native @Const AutoConstantEntry _findRawAutoConstantEntryBool(@Cast("size_t") long physicalIndex);





        public native void _updateAutoParams(@Const AutoParamDataSource source, @Cast("Ogre::uint16") short variabilityMask);



        public native void setIgnoreMissingParams(@Cast("bool") boolean state);
        public native void setNamedConstant(@Const @ByRef String name, double val);
        public native void setNamedConstant(@Const @ByRef String name, int val);
        public native void setNamedConstant(@Const @ByRef String name, @Const @ByRef Vector4 vec);
        public native void setNamedConstant(@Const @ByRef String name, @Const @ByRef Vector3 vec);




        public native void setNamedConstant(@Const @ByRef String name, @Const @ByRef Vector2 vec);




        public native void setNamedConstant(@Const @ByRef String name, @Const @ByRef Matrix4 m);







        public native void setNamedConstant(@Const @ByRef String name, @Const Matrix4 m, @Cast("size_t") long numEntries);




        public native void setNamedConstant(@Const @ByRef String name, @Const @ByRef ColourValue colour);
        public native void setNamedConstant(@Const @ByRef String name, @Const FloatPointer val, @Cast("size_t") long count,
                                      @Cast("size_t") long multiple/*=4*/);
        public native void setNamedConstant(@Const @ByRef String name, @Const FloatPointer val, @Cast("size_t") long count);
        public native void setNamedConstant(@Const @ByRef String name, @Const FloatBuffer val, @Cast("size_t") long count,
                                      @Cast("size_t") long multiple/*=4*/);
        public native void setNamedConstant(@Const @ByRef String name, @Const FloatBuffer val, @Cast("size_t") long count);
        public native void setNamedConstant(@Const @ByRef String name, @Const float[] val, @Cast("size_t") long count,
                                      @Cast("size_t") long multiple/*=4*/);
        public native void setNamedConstant(@Const @ByRef String name, @Const float[] val, @Cast("size_t") long count);
        public native void setNamedConstant(@Const @ByRef String name, @Const DoublePointer val, @Cast("size_t") long count,
                                      @Cast("size_t") long multiple/*=4*/);
        public native void setNamedConstant(@Const @ByRef String name, @Const DoublePointer val, @Cast("size_t") long count);
        public native void setNamedConstant(@Const @ByRef String name, @Const DoubleBuffer val, @Cast("size_t") long count,
                                      @Cast("size_t") long multiple/*=4*/);
        public native void setNamedConstant(@Const @ByRef String name, @Const DoubleBuffer val, @Cast("size_t") long count);
        public native void setNamedConstant(@Const @ByRef String name, @Const double[] val, @Cast("size_t") long count,
                                      @Cast("size_t") long multiple/*=4*/);
        public native void setNamedConstant(@Const @ByRef String name, @Const double[] val, @Cast("size_t") long count);
        public native void setNamedConstant(@Const @ByRef String name, @Const IntPointer val, @Cast("size_t") long count,
                                      @Cast("size_t") long multiple/*=4*/);
        public native void setNamedConstant(@Const @ByRef String name, @Const IntPointer val, @Cast("size_t") long count);
        public native void setNamedConstant(@Const @ByRef String name, @Const IntBuffer val, @Cast("size_t") long count,
                                      @Cast("size_t") long multiple/*=4*/);
        public native void setNamedConstant(@Const @ByRef String name, @Const IntBuffer val, @Cast("size_t") long count);
        public native void setNamedConstant(@Const @ByRef String name, @Const int[] val, @Cast("size_t") long count,
                                      @Cast("size_t") long multiple/*=4*/);
        public native void setNamedConstant(@Const @ByRef String name, @Const int[] val, @Cast("size_t") long count);
        public native void setNamedAutoConstant(@Const @ByRef String name, @Cast("Ogre::GpuProgramParameters::AutoConstantType") int acType, @Cast("size_t") long extraInfo/*=0*/);
        public native void setNamedAutoConstant(@Const @ByRef String name, @Cast("Ogre::GpuProgramParameters::AutoConstantType") int acType);
        public native void setNamedAutoConstantReal(@Const @ByRef String name, @Cast("Ogre::GpuProgramParameters::AutoConstantType") int acType, double rData);
        public native void setNamedAutoConstant(@Const @ByRef String name, @Cast("Ogre::GpuProgramParameters::AutoConstantType") int acType, @Cast("Ogre::uint16") short extraInfo1, @Cast("Ogre::uint16") short extraInfo2);
        public native void setNamedConstantFromTime(@Const @ByRef String name, double factor);


        public native void clearNamedAutoConstant(@Const @ByRef String name);
        public native @Const GpuConstantDefinition _findNamedConstantDefinition(
                    @Const @ByRef String name, @Cast("bool") boolean throwExceptionIfMissing/*=false*/);
        public native @Const GpuConstantDefinition _findNamedConstantDefinition(
                    @Const @ByRef String name);






        public native @Cast("size_t") long _getFloatConstantPhysicalIndex(@Cast("size_t") long logicalIndex, @Cast("size_t") long requestedSize, @Cast("Ogre::uint16") short variability);






        public native @Cast("size_t") long _getDoubleConstantPhysicalIndex(@Cast("size_t") long logicalIndex, @Cast("size_t") long requestedSize, @Cast("Ogre::uint16") short variability);






        public native @Cast("size_t") long _getIntConstantPhysicalIndex(@Cast("size_t") long logicalIndex, @Cast("size_t") long requestedSize, @Cast("Ogre::uint16") short variability);






        public native @Cast("size_t") long _getUnsignedIntConstantPhysicalIndex(@Cast("size_t") long logicalIndex, @Cast("size_t") long requestedSize, @Cast("Ogre::uint16") short variability);
        public native void setTransposeMatrices(@Cast("bool") boolean val);

        public native @Cast("bool") boolean getTransposeMatrices();







        public native void copyConstantsFrom(@Const @ByRef GpuProgramParameters source);
        public native void copyMatchingNamedConstantsFrom(@Const @ByRef GpuProgramParameters source);




        public static native @Const AutoConstantDefinition getAutoConstantDefinition(@Const @ByRef String name);




        public static native @Const AutoConstantDefinition getAutoConstantDefinition(@Cast("const size_t") long idx);


        public static native @Cast("size_t") long getNumAutoConstantDefinitions();




        public native void incPassIterationNumber();

        public native @Cast("bool") boolean hasPassIterationNumber();

        public native @Cast("size_t") long getPassIterationNumberIndex();







        public native void addSharedParameters(@ByVal @Cast("Ogre::GpuSharedParametersPtr*") RealControllerFunctionSPtr sharedParams);
        public native void addSharedParameters(@Const @ByRef String sharedParamsName);


        public native @Cast("bool") boolean isUsingSharedParameters(@Const @ByRef String sharedParamsName);


        public native void removeSharedParameters(@Const @ByRef String sharedParamsName);


        public native void removeAllSharedParameters();


        public native @Cast("const Ogre::GpuProgramParameters::GpuSharedParamUsageList*") @ByRef GpuSharedParametersUsageVectorRef getSharedParameters();


        public native void _setRenderSystemData(@Const @ByRef Any data);

        public native @Const @ByRef Any _getRenderSystemData();
        public native void _copySharedParams();

        public native @Cast("size_t") long calculateSize();



        public native void setNamedSubroutine(@Const @ByRef String subroutineSlot, @Const @ByRef String subroutine);



        public native void setSubroutine(@Cast("size_t") long index, @Const @ByRef String subroutine);



        public native @Cast("const Ogre::GpuProgramParameters::SubroutineMap*") @ByRef StringUnorderedMapRef getSubroutineMap();
    }




    /** enum Ogre::GpuProgramType */
    public static final int
        GPT_VERTEX_PROGRAM = 0,
        GPT_FRAGMENT_PROGRAM = 1,
        GPT_GEOMETRY_PROGRAM = 2,
        GPT_HULL_PROGRAM = 3,
        GPT_DOMAIN_PROGRAM = 4,
        GPT_COMPUTE_PROGRAM = 5;
    @Namespace("Ogre") @NoOffset public static class GpuProgram extends Resource {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public GpuProgram(Pointer p) { super(p); }
    





    public native void setSourceFile(@Const @ByRef String filename);





    public native void setSource(@Const @ByRef String source);
    public native void setSource(@Const @ByRef String source, @Const @ByRef String debugFilename);


    public native @Const @ByRef String getSyntaxCode();


    public native void setSyntaxCode(@Const @ByRef String syntax);


    public native @Const @ByRef String getSourceFile();

    public native @Const @ByRef String getSource();

    public native void setType(@Cast("Ogre::GpuProgramType") int t);

    public native @Cast("Ogre::GpuProgramType") int getType();





    public native GpuProgram _getBindingDelegate();


    public native @Cast("bool") boolean isSupported();
    public native @ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr createParameters();







    public native void setSkeletalAnimationIncluded(@Cast("bool") boolean included);







    public native @Cast("bool") boolean isSkeletalAnimationIncluded();







    public native void setMorphAnimationIncluded(@Cast("bool") boolean included);
    public native void setPoseAnimationIncluded(short poseCount);







    public native @Cast("bool") boolean isMorphAnimationIncluded();







    public native @Cast("bool") boolean isPoseAnimationIncluded();



    public native short getNumberOfPosesIncluded();



    public native void setVertexTextureFetchRequired(@Cast("bool") boolean r);



    public native @Cast("bool") boolean isVertexTextureFetchRequired();




    public native void setAdjacencyInfoRequired(@Cast("bool") boolean r);



    public native @Cast("bool") boolean isAdjacencyInfoRequired();



    public native void setComputeGroupDimensions(@ByVal Vector3 dimensions);



    public native @ByVal Vector3 getComputeGroupDimensions();
    public native @ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr getDefaultParameters();



    public native @Cast("bool") boolean hasDefaultParameters();







    public native @Cast("bool") boolean getPassSurfaceAndLightStates();
    public native @Cast("bool") boolean getPassFogStates();







    public native @Cast("bool") boolean getPassTransformStates();




    public native @Const @ByRef String getLanguage();



    public native @Cast("bool") boolean hasCompileError();



    public native void resetCompileError();
    public native void setManualNamedConstants(@Const @ByRef GpuNamedConstants namedConstants);
    public native void setManualNamedConstantsFile(@Const @ByRef String paramDefFile);




    public native @Const @ByRef String getManualNamedConstantsFile();






    public native @Const @ByRef GpuNamedConstants getConstantDefinitions();


    public native @Cast("size_t") long calculateSize();

    }



    /** enum Ogre::LayerBlendType */
    public static final int
        LBT_COLOUR = 0,
        LBT_ALPHA = 1;
    /** enum Ogre::LayerBlendOperation */
    public static final int

        LBO_REPLACE = 0,

        LBO_ADD = 1,

        LBO_MODULATE = 2,

        LBO_ALPHA_BLEND = 3;







    /** enum Ogre::LayerBlendOperationEx */
    public static final int

        LBX_SOURCE1 = 0,

        LBX_SOURCE2 = 1,

        LBX_MODULATE = 2,

        LBX_MODULATE_X2 = 3,

        LBX_MODULATE_X4 = 4,

        LBX_ADD = 5,

        LBX_ADD_SIGNED = 6,

        LBX_ADD_SMOOTH = 7,

        LBX_SUBTRACT = 8,

        LBX_BLEND_DIFFUSE_ALPHA = 9,

        LBX_BLEND_TEXTURE_ALPHA = 10,

        LBX_BLEND_CURRENT_ALPHA = 11,

        LBX_BLEND_MANUAL = 12,

        LBX_DOTPRODUCT = 13,

        LBX_BLEND_DIFFUSE_COLOUR = 14;





    /** enum Ogre::LayerBlendSource */
    public static final int

        LBS_CURRENT = 0,

        LBS_TEXTURE = 1,

        LBS_DIFFUSE = 2,

        LBS_SPECULAR = 3,

        LBS_MANUAL = 4;
    @Namespace("Ogre") public static class LayerBlendModeEx extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public LayerBlendModeEx() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public LayerBlendModeEx(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public LayerBlendModeEx(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public LayerBlendModeEx position(long position) {
            return (LayerBlendModeEx)super.position(position);
        }
    

        public native @Cast("Ogre::LayerBlendType") int blendType(); public native LayerBlendModeEx blendType(int blendType);

        public native @Cast("Ogre::LayerBlendOperationEx") int operation(); public native LayerBlendModeEx operation(int operation);

        public native @Cast("Ogre::LayerBlendSource") int source1(); public native LayerBlendModeEx source1(int source1);

        public native @Cast("Ogre::LayerBlendSource") int source2(); public native LayerBlendModeEx source2(int source2);


        public native @ByRef ColourValue colourArg1(); public native LayerBlendModeEx colourArg1(ColourValue colourArg1);

        public native @ByRef ColourValue colourArg2(); public native LayerBlendModeEx colourArg2(ColourValue colourArg2);

        public native double alphaArg1(); public native LayerBlendModeEx alphaArg1(double alphaArg1);

        public native double alphaArg2(); public native LayerBlendModeEx alphaArg2(double alphaArg2);

        public native double factor(); public native LayerBlendModeEx factor(double factor);

        public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef LayerBlendModeEx rhs);

        public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef LayerBlendModeEx rhs);



    }
    /** enum Ogre::SceneBlendType */
    public static final int

        SBT_TRANSPARENT_ALPHA = 0,

        SBT_TRANSPARENT_COLOUR = 1,

        SBT_ADD = 2,

        SBT_MODULATE = 3,

        SBT_REPLACE = 4;





    /** enum Ogre::SceneBlendFactor */
    public static final int
        SBF_ONE = 0,
        SBF_ZERO = 1,
        SBF_DEST_COLOUR = 2,
        SBF_SOURCE_COLOUR = 3,
        SBF_ONE_MINUS_DEST_COLOUR = 4,
        SBF_ONE_MINUS_SOURCE_COLOUR = 5,
        SBF_DEST_ALPHA = 6,
        SBF_SOURCE_ALPHA = 7,
        SBF_ONE_MINUS_DEST_ALPHA = 8,
        SBF_ONE_MINUS_SOURCE_ALPHA = 9;





    /** enum Ogre::SceneBlendOperation */
    public static final int
        SBO_ADD = 0,
        SBO_SUBTRACT = 1,
        SBO_REVERSE_SUBTRACT = 2,
        SBO_MIN = 3,
        SBO_MAX = 4;




    @Namespace("Ogre") @NoOffset public static class Material extends Resource {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Material(Pointer p) { super(p); }
    



        public Material(ResourceManager creator, @Const @ByRef String name, @Cast("Ogre::ResourceHandle") long handle,
                    @Const @ByRef String group, @Cast("bool") boolean isManual/*=false*/, ManualResourceLoader loader/*=0*/) { super((Pointer)null); allocate(creator, name, handle, group, isManual, loader); }
        private native void allocate(ResourceManager creator, @Const @ByRef String name, @Cast("Ogre::ResourceHandle") long handle,
                    @Const @ByRef String group, @Cast("bool") boolean isManual/*=false*/, ManualResourceLoader loader/*=0*/);
        public Material(ResourceManager creator, @Const @ByRef String name, @Cast("Ogre::ResourceHandle") long handle,
                    @Const @ByRef String group) { super((Pointer)null); allocate(creator, name, handle, group); }
        private native void allocate(ResourceManager creator, @Const @ByRef String name, @Cast("Ogre::ResourceHandle") long handle,
                    @Const @ByRef String group);


        public native @ByRef @Name("operator =") Material put( @Const @ByRef Material rhs );




        public native @Cast("bool") boolean isTransparent();
        public native void setReceiveShadows(@Cast("bool") boolean enabled);

        public native @Cast("bool") boolean getReceiveShadows();
        public native void setTransparencyCastsShadows(@Cast("bool") boolean enabled);

        public native @Cast("bool") boolean getTransparencyCastsShadows();
        public native Technique createTechnique();

        public native Technique getTechnique(@Cast("unsigned short") short index);



        public native Technique getTechnique(@Const @ByRef String name);

        public native @Cast("unsigned short") short getNumTechniques();

        public native void removeTechnique(@Cast("unsigned short") short index);

        public native void removeAllTechniques();

        public native @ByVal @Cast("Ogre::Material::TechniqueIterator*") TechniquesVectorIteratorRef getTechniqueIterator();






        public native @ByVal @Cast("Ogre::Material::TechniqueIterator*") TechniquesVectorIteratorRef getSupportedTechniqueIterator();


        public native Technique getSupportedTechnique(@Cast("unsigned short") short index);

        public native @Cast("unsigned short") short getNumSupportedTechniques();

        public native @Const @ByRef String getUnsupportedTechniquesExplanation();






        public native @Cast("unsigned short") short getNumLodLevels(@Cast("unsigned short") short schemeIndex);





        public native @Cast("unsigned short") short getNumLodLevels(@Const @ByRef String schemeName);
        public native Technique getBestTechnique(@Cast("unsigned short") short lodIndex/*=0*/, @Const Renderable rend/*=0*/);
        public native Technique getBestTechnique();







        public native @ByVal @Cast("Ogre::MaterialPtr*") RealControllerFunctionSPtr clone(@Const @ByRef String newName, @Cast("bool") boolean changeGroup/*=false*/,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String newGroup);
        public native @ByVal @Cast("Ogre::MaterialPtr*") RealControllerFunctionSPtr clone(@Const @ByRef String newName);





        public native void copyDetailsTo(@Cast("Ogre::MaterialPtr*") @ByRef RealControllerFunctionSPtr mat);
        public native void compile(@Cast("bool") boolean autoManageTextureUnits/*=true*/);
        public native void compile();
        public native void setPointSize(double ps);
        public native void setAmbient(double red, double green, double blue);
        public native void setAmbient(@Const @ByRef ColourValue ambient);
        public native void setDiffuse(double red, double green, double blue, double alpha);
        public native void setDiffuse(@Const @ByRef ColourValue diffuse);
        public native void setSpecular(double red, double green, double blue, double alpha);
        public native void setSpecular(@Const @ByRef ColourValue specular);
        public native void setShininess(double val);
        public native void setSelfIllumination(double red, double green, double blue);
        public native void setSelfIllumination(@Const @ByRef ColourValue selfIllum);
        public native void setMacroblock( @Const @ByRef HlmsMacroblock macroblock );
        public native void setColourWriteEnabled(@Cast("bool") boolean enabled);
        public native void setShadingMode( @Cast("Ogre::ShadeOptions") int mode );
        public native void setFog(
                    @Cast("bool") boolean overrideScene,
                    @Cast("Ogre::FogMode") int mode/*=Ogre::FOG_NONE*/,
                    @Const @ByRef(nullValue = "Ogre::ColourValue::White") ColourValue colour,
                    double expDensity/*=0.001*/, double linearStart/*=0.0*/, double linearEnd/*=1.0*/ );
        public native void setFog(
                    @Cast("bool") boolean overrideScene );
        public native void setSamplerblock( @Const @ByRef HlmsSamplerblock samplerblock );
        public native void setBlendblock( @Const @ByRef HlmsBlendblock blendblock );


        public native void _notifyNeedsRecompile();
        public native void setLodLevels(@Cast("const Ogre::Material::LodValueArray*") @ByRef RealFastArrayRef lodValues);

        public native @Cast("const Ogre::Material::LodValueArray*") RealFastArrayRef _getLodValues();
        public native @ByVal @Cast("Ogre::Material::LodValueIterator*") NodeTrackIteratorRef getLodValueIterator();
        public native @ByVal @Cast("Ogre::Material::LodValueIterator*") NodeTrackIteratorRef getUserLodValueIterator();



        public native void touch();
        public native @Cast("bool") boolean applyTextureAliases(@Cast("const Ogre::AliasTextureNamePairList*") @ByRef SStringMapRef aliasList, @Cast("const bool") boolean apply/*=true*/);
        public native @Cast("bool") boolean applyTextureAliases(@Cast("const Ogre::AliasTextureNamePairList*") @ByRef SStringMapRef aliasList);




        public native @Cast("bool") boolean getCompilationRequired();


    }



    @Namespace("Ogre") @NoOffset public static class UserObjectBindings extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public UserObjectBindings(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public UserObjectBindings(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public UserObjectBindings position(long position) {
            return (UserObjectBindings)super.position(position);
        }
    

        public UserObjectBindings() { super((Pointer)null); allocate(); }
        private native void allocate();
        public native void setUserAny(@Const @ByRef Any anything);



        public native @Const @ByRef Any getUserAny();
        public native void setUserAny(@Const @ByRef String key, @Const @ByRef Any anything);






        public native @Const @ByRef Any getUserAny(@Const @ByRef String key);




        public native void eraseUserAny(@Const @ByRef String key);


        public native void clear();



        public static native @Const @ByRef Any getEmptyUserAny();

    }










    @Namespace("Ogre::v1") public static class VertexBoneAssignment extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public VertexBoneAssignment() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public VertexBoneAssignment(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public VertexBoneAssignment(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public VertexBoneAssignment position(long position) {
            return (VertexBoneAssignment)super.position(position);
        }
    
        public native @Cast("unsigned int") int vertexIndex(); public native VertexBoneAssignment vertexIndex(int vertexIndex);
        public native @Cast("unsigned short") short boneIndex(); public native VertexBoneAssignment boneIndex(short boneIndex);
        public native double weight(); public native VertexBoneAssignment weight(double weight);

    }
    

    @Namespace("Ogre") public static native @Cast("bool") @Name("operator <") boolean lessThan( @Const @ByRef VertexBoneAssignment _l, @Cast("Ogre::uint32") int _vertexIndex );

    @Namespace("Ogre") public static native @Cast("bool") @Name("operator <") boolean lessThan( @Cast("Ogre::uint32") int _vertexIndex, @Const @ByRef VertexBoneAssignment _r );





    @Name("Ogre::Mesh") @NoOffset public static class Mesh extends Resource {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Mesh(Pointer p) { super(p); }
        public AnimationContainer asAnimationContainer() { return asAnimationContainer(this); }
        @Namespace public static native @Name("static_cast<Ogre::v1::AnimationContainer*>") AnimationContainer asAnimationContainer(Mesh pointer);
    




        public Mesh(ResourceManager creator, @Const @ByRef String name, @Cast("Ogre::ResourceHandle") long handle,
                    @Const @ByRef String group, @Cast("bool") boolean isManual/*=false*/, ManualResourceLoader loader/*=0*/) { super((Pointer)null); allocate(creator, name, handle, group, isManual, loader); }
        private native void allocate(ResourceManager creator, @Const @ByRef String name, @Cast("Ogre::ResourceHandle") long handle,
                    @Const @ByRef String group, @Cast("bool") boolean isManual/*=false*/, ManualResourceLoader loader/*=0*/);
        public Mesh(ResourceManager creator, @Const @ByRef String name, @Cast("Ogre::ResourceHandle") long handle,
                    @Const @ByRef String group) { super((Pointer)null); allocate(creator, name, handle, group); }
        private native void allocate(ResourceManager creator, @Const @ByRef String name, @Cast("Ogre::ResourceHandle") long handle,
                    @Const @ByRef String group);
        public native SubMesh createSubMesh();



        public native SubMesh createSubMesh(@Const @ByRef String name);



        public native void nameSubMesh(@Const @ByRef String name, short index);



        public native void unnameSubMesh(@Const @ByRef String name);






        public native short _getSubMeshIndex(@Const @ByRef String name);



        public native @Cast("unsigned short") short getNumSubMeshes();



        public native SubMesh getSubMesh(@Cast("unsigned short") short index);



        public native SubMesh getSubMesh(@Const @ByRef String name);







        public native void destroySubMesh(@Cast("unsigned short") short index);







        public native void destroySubMesh(@Const @ByRef String name);

        public native @ByVal @Cast("Ogre::Mesh::SubMeshIterator*") TechniquesVectorIteratorRef getSubMeshIterator();


        public native void importV2( Mesh mesh );
        public native void arrangeEfficient( @Cast("bool") boolean halfPos, @Cast("bool") boolean halfTexCoords, @Cast("bool") boolean qTangents );




        public native void dearrangeToInefficient();
        public native VertexData sharedVertexData(int i); public native Mesh sharedVertexData(int i, VertexData sharedVertexData);
        @MemberGetter public native @Cast("VertexData**") PointerPointer sharedVertexData();
        public native @ByRef @Cast("Ogre::Mesh::IndexMap*") UshortFastArrayRef sharedBlendIndexToBoneIndexMap(); public native Mesh sharedBlendIndexToBoneIndexMap(UshortFastArrayRef sharedBlendIndexToBoneIndexMap);
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr clone(@Const @ByRef String newName, @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String newGroup);
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr clone(@Const @ByRef String newName);



        public native @Const @ByRef AxisAlignedBox getBounds();


        public native double getBoundingSphereRadius();


        public native double getBoneBoundingRadius();
        public native void _setBounds(@Const @ByRef AxisAlignedBox bounds, @Cast("bool") boolean pad/*=true*/);
        public native void _setBounds(@Const @ByRef AxisAlignedBox bounds);
        public native void _setBoundingSphereRadius(double radius);





        public native void _setBoneBoundingRadius(double radius);






        public native void _computeBoneBoundingRadius();
        public native void _updateBoundsFromVertexBuffers(@Cast("bool") boolean pad/*=false*/);
        public native void _updateBoundsFromVertexBuffers();







        public native void _calcBoundsFromVertexBuffer(VertexData vertexData, @ByRef AxisAlignedBox outAABB, double outRadius, @Cast("bool") boolean updateOnly/*=false*/);
        public native void _calcBoundsFromVertexBuffer(VertexData vertexData, @ByRef AxisAlignedBox outAABB, double outRadius);
        public native void setSkeletonName(@Const @ByRef String skelName);


        public native @Cast("bool") boolean hasSkeleton();



        public native @Cast("bool") boolean hasVertexAnimation();





        public native @Const @ByRef SkeletonPtr getOldSkeleton();
        public native @Cast("const Ogre::SkeletonDefPtr*") @ByRef RealControllerFunctionSPtr getSkeleton();


        public native @Const @ByRef String getSkeletonName();




        public native void _initAnimationState(AnimationStateSet animSet);





        public native void _refreshAnimationState(AnimationStateSet animSet);
        public native void addBoneAssignment(@Const @ByRef VertexBoneAssignment vertBoneAssign);






        public native void clearBoneAssignments();







        public native void _notifySkeleton(@ByRef SkeletonPtr pSkel);




        public native @ByVal @Cast("Ogre::Mesh::BoneAssignmentIterator*") AnimationStateMapIteratorRef getBoneAssignmentIterator();



        public native @Cast("const Ogre::Mesh::VertexBoneAssignmentList*") @ByRef VertexBoneAssignmentMultimapRef getBoneAssignments();

        public native void setLodStrategyName( @Const @ByRef String name );


        public native @Const @ByRef String getLodStrategyName();





        public native short getNumLodLevels();

        public native @Const @ByRef MeshLodUsage getLodLevel(short index);







        public native short getLodIndex(double value);






        public native @Cast("bool") boolean hasManualLodLevel();
        public native void updateManualLodLevel(short index, @Const @ByRef String meshName);


        public native void _setLodInfo(@Cast("unsigned short") short numLevels);

        public native void _setLodUsage(@Cast("unsigned short") short level, @Const @ByRef MeshLodUsage usage);

        public native void _setSubMeshLodFaceList( @Cast("unsigned short") short subIdx, @Cast("unsigned short") short level, IndexData facedata,
                                             @Cast("bool") boolean casterPass );

        public native @Cast("bool") boolean _isManualLodLevel(@Cast("unsigned short") short level);


        public native void removeLodLevels();
        public native void setVertexBufferPolicy(@ByVal Usage usage, @Cast("bool") boolean shadowBuffer/*=false*/);
        public native void setVertexBufferPolicy(@ByVal Usage usage);
        public native void setIndexBufferPolicy(@ByVal Usage usage, @Cast("bool") boolean shadowBuffer/*=false*/);
        public native void setIndexBufferPolicy(@ByVal Usage usage);

        public native @ByVal Usage getVertexBufferUsage();

        public native @ByVal Usage getIndexBufferUsage();

        public native @Cast("bool") boolean isVertexBufferShadowed();

        public native @Cast("bool") boolean isIndexBufferShadowed();
        public native @Cast("unsigned short") short _rationaliseBoneAssignments(@Cast("size_t") long vertexCount, @Cast("Ogre::Mesh::VertexBoneAssignmentList*") @ByRef VertexBoneAssignmentMultimapRef assignments);
        public native void _compileBoneAssignments();






        public native void _updateCompiledBoneAssignments();
        public native void mergeAdjacentTexcoords( @Cast("unsigned short") short finalTexCoordSet, @Cast("unsigned short") short texCoordSetToDestroy );


        public static native @Cast("bool") boolean msOptimizeForShadowMapping(); public static native void msOptimizeForShadowMapping(boolean msOptimizeForShadowMapping);

        public native void prepareForShadowMapping( @Cast("bool") boolean forceSameBuffers );



        public native @Cast("bool") boolean hasValidShadowMappingBuffers();



        public native @Cast("bool") boolean hasIndependentShadowMappingBuffers();
        public native void buildTangentVectors(@Cast("Ogre::VertexElementSemantic") int targetSemantic/*=Ogre::VES_TANGENT*/,
                    @Cast("unsigned short") short sourceTexCoordSet/*=0*/, @Cast("unsigned short") short index/*=0*/,
                    @Cast("bool") boolean splitMirrored/*=false*/, @Cast("bool") boolean splitRotated/*=false*/, @Cast("bool") boolean storeParityInW/*=false*/);
        public native void buildTangentVectors();
        public native @Cast("bool") boolean suggestTangentVectorBuildParams(@Cast("Ogre::VertexElementSemantic") int targetSemantic,
                    @Cast("unsigned short*") @ByRef ShortPointer outSourceCoordSet, @Cast("unsigned short*") @ByRef ShortPointer outIndex);
        public native @Cast("bool") boolean suggestTangentVectorBuildParams(@Cast("Ogre::VertexElementSemantic") int targetSemantic,
                    @Cast("unsigned short*") @ByRef ShortBuffer outSourceCoordSet, @Cast("unsigned short*") @ByRef ShortBuffer outIndex);
        public native @Cast("bool") boolean suggestTangentVectorBuildParams(@Cast("Ogre::VertexElementSemantic") int targetSemantic,
                    @Cast("unsigned short*") @ByRef short[] outSourceCoordSet, @Cast("unsigned short*") @ByRef short[] outIndex);




        public native void buildEdgeList();

        public native void freeEdgeList();
        public native void prepareForShadowVolume();
        public native EdgeData getEdgeList(@Cast("unsigned short") short lodIndex/*=0*/);
        public native EdgeData getEdgeList();



        public native @Cast("bool") boolean isPreparedForShadowVolumes();


        public native @Cast("bool") boolean isEdgeListBuilt();
        public static native void prepareMatricesForVertexBlend(@Cast("const Ogre::Matrix4**") PointerPointer blendMatrices,
                    @Const Matrix4 boneMatrices, @Cast("const Ogre::Mesh::IndexMap*") @ByRef UshortFastArrayRef indexMap);
        public static native void prepareMatricesForVertexBlend(@Const @ByPtrPtr Matrix4 blendMatrices,
                    @Const Matrix4 boneMatrices, @Cast("const Ogre::Mesh::IndexMap*") @ByRef UshortFastArrayRef indexMap);
        public static native void softwareVertexBlend(@Const VertexData sourceVertexData,
                    @Const VertexData targetVertexData,
                    @Cast("const Ogre::Matrix4*const*") PointerPointer blendMatrices, @Cast("size_t") long numMatrices,
                    @Cast("bool") boolean blendNormals);
        public static native void softwareVertexBlend(@Const VertexData sourceVertexData,
                    @Const VertexData targetVertexData,
                    @Const @ByPtrPtr Matrix4 blendMatrices, @Cast("size_t") long numMatrices,
                    @Cast("bool") boolean blendNormals);
        public static native void softwareVertexMorph(double t,
                    @Const @ByRef HardwareVertexBufferSharedPtr b1,
                    @Const @ByRef HardwareVertexBufferSharedPtr b2,
                    VertexData targetVertexData);
        public static native void softwareVertexPoseBlend(double weight,
                    @Cast("const map<size_t,Ogre::Vector3>::type*") @ByRef Vector3MapRef vertexOffsetMap,
                    @Cast("const map<size_t,Ogre::Vector3>::type*") @ByRef Vector3MapRef normalsMap,
                    VertexData targetVertexData);

        public native @Cast("const Ogre::Mesh::SubMeshNameMap*") @ByRef SUshortUnorderedMapRef getSubMeshNameMap();
        public native void setAutoBuildEdgeLists(@Cast("bool") boolean autobuild);




        public native @Cast("bool") boolean getAutoBuildEdgeLists();



        public native @ByVal VertexAnimationType getSharedVertexDataAnimationType();


        public native @Cast("bool") boolean getSharedVertexDataAnimationIncludesNormals();







        public native Animation createAnimation(@Const @ByRef String name, double length);





        public native Animation getAnimation(@Const @ByRef String name);






        public native Animation _getAnimationImpl(@Const @ByRef String name);


        public native @Cast("bool") boolean hasAnimation(@Const @ByRef String name);


        public native void removeAnimation(@Const @ByRef String name);


        public native @Cast("unsigned short") short getNumAnimations();



        public native Animation getAnimation(@Cast("unsigned short") short index);


        public native void removeAllAnimations();





        public native VertexData getVertexDataByTrackHandle(@Cast("unsigned short") short handle);
        public native void updateMaterialForAllSubMeshes();





        public native void _determineAnimationTypes();

        public native @Cast("bool") boolean _getAnimationTypesDirty();
        public native Pose createPose(short target, @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String name);
        public native Pose createPose(short target);

        public native @Cast("size_t") long getPoseCount();

        public native Pose getPose(short index);

        public native Pose getPose(@Const @ByRef String name);




        public native void removePose(short index);




        public native void removePose(@Const @ByRef String name);

        public native void removeAllPoses();


        public native @ByVal @Cast("Ogre::Mesh::PoseIterator*") TechniquesVectorIteratorRef getPoseIterator();

        public native @Const @ByRef PoseList getPoseList();

        public native @Cast("const Ogre::Mesh::LodValueArray*") RealFastArrayRef _getLodValueArray();

        public native void createAzdoBuffers();

    }


    @Namespace("Ogre::v1") @NoOffset public static class MeshLodUsage extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MeshLodUsage(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MeshLodUsage(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public MeshLodUsage position(long position) {
            return (MeshLodUsage)super.position(position);
        }
    




        public native double userValue(); public native MeshLodUsage userValue(double userValue);






        public native double value(); public native MeshLodUsage value(double value);



        public native @ByRef String manualName(); public native MeshLodUsage manualName(String manualName);

        public native @ByRef @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr manualMesh(); public native MeshLodUsage manualMesh(RealControllerFunctionSPtr manualMesh);

        public native EdgeData edgeData(); public native MeshLodUsage edgeData(EdgeData edgeData);

        public MeshLodUsage() { super((Pointer)null); allocate(); }
        private native void allocate();
    }






            
        
    @Namespace("Ogre") @NoOffset public static class LodStrategy extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public LodStrategy(Pointer p) { super(p); }
    


        public native double getBaseValue();


        public native double transformBias(double factor);

        public native void lodUpdateImpl( @Cast("const size_t") long numNodes, @ByVal ObjectData t,
                                            @Const Camera camera, double bias );


        public static native void lodSet( @ByRef ObjectData t, double lodValues );
        public native double transformUserValue(double userValue);


        public native double getValue(@Const MovableObject movableObject, @Const Camera camera);


        public static native short getIndex(double value, @Const @ByRef MeshLodUsageList meshLodUsageList);


        public static native short getIndex(double value, @Cast("const Ogre::Material::LodValueArray*") @ByRef RealFastArrayRef materialLodValueArray);


        public static native void sort(@ByRef MeshLodUsageList meshLodUsageList);


        public static native @Cast("bool") boolean isSorted(@Const @ByRef LodValueArray values);


        public static native void assertSorted(@Const @ByRef LodValueArray values);


        public native @Const @ByRef String getName();
    }




    @Namespace("Ogre") @NoOffset public static class Renderable extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Renderable(Pointer p) { super(p); }
    


        public native void setMaterialName( @Const @ByRef String name, @Const @ByRef String groupName );


        public native void setMaterial( @Cast("const Ogre::MaterialPtr*") @ByRef RealControllerFunctionSPtr material );




        public native @ByVal @Cast("Ogre::MaterialPtr*") RealControllerFunctionSPtr getMaterial();



        public native void getRenderOperation(@ByRef RenderOperation op, @Cast("bool") boolean casterPass);
        public native @Cast("bool") boolean preRender(SceneManager sm, RenderSystem rsys);



        public native void postRender(SceneManager sm, RenderSystem rsys);
        public native void getWorldTransforms(Matrix4 xform);
        public native @Cast("unsigned short") short getNumWorldTransforms();

        public native @Cast("bool") boolean hasSkeletonAnimation();
        public native @Cast("bool") boolean getUseIdentityWorldMatrix();
        public native @Cast("bool") boolean getUseIdentityViewProjMatrixIsDynamic();
        public native void setUseIdentityProjection(@Cast("bool") boolean useIdentityProjection);
        public native @Cast("bool") boolean getUseIdentityProjection();
        public native void setUseIdentityView(@Cast("bool") boolean useIdentityView);
        public native @Cast("bool") boolean getUseIdentityView();





        public native @Cast("const Ogre::LightList*") @ByRef HashedVector getLights();







        public native @Cast("bool") boolean getCastsShadows();
        public native void setCustomParameter(@Cast("size_t") long index, @Const @ByRef Vector4 value);





        public native void removeCustomParameter(@Cast("size_t") long index);





        public native @Cast("bool") boolean hasCustomParameter(@Cast("size_t") long index);





        public native @Const @ByRef Vector4 getCustomParameter(@Cast("size_t") long index);
        public native void _updateCustomGpuParameter(
                    @Const @ByRef GpuProgramParameters.AutoConstantEntry constantEntry,
                    GpuProgramParameters params);






        public native void setPolygonModeOverrideable(@Cast("bool") boolean override);




        public native @Cast("bool") boolean getPolygonModeOverrideable();
        public native void setUserAny(@Const @ByRef Any anything);




        public native @Const @ByRef Any getUserAny();





        public native @ByRef UserObjectBindings getUserObjectBindings();

        public native @Cast("const Ogre::VertexArrayObjectArray*") @ByRef RealFastArrayRef getVaos( @Cast("Ogre::VertexPass") int vertexPass );

        public native @Cast("Ogre::uint32") int getHlmsHash();
        public native @Cast("Ogre::uint32") int getHlmsCasterHash();
        public native HlmsDatablock getDatablock();




        public native void setDatablockOrMaterialName( @ByVal String materialName, @ByVal String groupName );





        public native void setDatablock( @ByVal IdString datablockName );


        public native void setDatablock( HlmsDatablock datablock );


        public native void _setHlmsHashes( @Cast("Ogre::uint32") int hash, @Cast("Ogre::uint32") int casterHash );

        public native @Cast("Ogre::uint8") byte getCurrentMaterialLod();

        
        public native void setRenderQueueSubGroup( @Cast("Ogre::uint8") byte subGroup );
        public native @Cast("Ogre::uint8") byte getRenderQueueSubGroup(); public native @Cast("Ogre::uint32") int mHlmsGlobalIndex(); public native Renderable mHlmsGlobalIndex(int mHlmsGlobalIndex);
    }

    @Namespace("Ogre") @NoOffset public static class RenderableAnimated extends Renderable {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderableAnimated(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public RenderableAnimated(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public RenderableAnimated position(long position) {
            return (RenderableAnimated)super.position(position);
        }
    
        public RenderableAnimated() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native @Cast("const Ogre::RenderableAnimated::IndexMap*") UshortFastArrayRef getBlendIndexToBoneIndexMap();
    }










    @Namespace("Ogre") public static class Id extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public Id() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Id(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Id(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public Id position(long position) {
            return (Id)super.position(position);
        }
    
    }

    @Namespace("Ogre") @NoOffset public static class IdObject extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public IdObject(Pointer p) { super(p); }
    





        public IdObject( @Cast("Ogre::IdType") int id ) { super((Pointer)null); allocate(id); }
        private native void allocate( @Cast("Ogre::IdType") int id );


        public native @Cast("Ogre::IdType") int getId();

        public native @Cast("bool") @Name("operator ()") boolean apply( @Const IdObject left, @Const IdObject right );
    }

    @Namespace("Ogre") public static class ArrayRadian extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public ArrayRadian() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ArrayRadian(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ArrayRadian(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public ArrayRadian position(long position) {
            return (ArrayRadian)super.position(position);
        }
    
        public native @ByRef @Name("operator =") ArrayRadian put( @Const @ByRef ArrayRadian r );

        public native @Const @ByRef @Name("operator +") ArrayRadian add();
        public native @ByVal @Name("operator +") ArrayRadian add( @Const @ByRef ArrayRadian r );

        public native @ByRef @Name("operator +=") ArrayRadian addPut( @Const @ByRef ArrayRadian r );

        public native @ByVal @Name("operator -") ArrayRadian subtract();
        public native @ByVal @Name("operator -") ArrayRadian subtract( @Const @ByRef ArrayRadian r );

        public native @ByRef @Name("operator -=") ArrayRadian subtractPut( @Const @ByRef ArrayRadian r );
        public native @ByVal @Name("operator *") ArrayRadian multiply( @Const @ByRef ArrayRadian f );
    }

    @Namespace("Ogre") public static class MathlibSSE2 extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public MathlibSSE2() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MathlibSSE2(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MathlibSSE2(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public MathlibSSE2 position(long position) {
            return (MathlibSSE2)super.position(position);
        }
    
        public static native @ByVal __m128d CmovRobust( @ByVal __m128d arg1, @ByVal __m128d arg2, @ByVal __m128d mask );
        public static native @ByVal ArrayInt CmovRobust( @ByVal ArrayInt arg1, @ByVal ArrayInt arg2, @ByVal ArrayMaskI mask );
        public static native @ByVal ArrayInt And( @ByVal ArrayInt a, @ByVal ArrayInt b );

        public static native @ByVal ArrayInt SetAll( @Cast("Ogre::uint32") int val );
    }






    

    






    







    

    






    







    

    

    

    
    
    
    
    
    


    

    



    @Namespace("Ogre") @NoOffset public static class ArrayVector3 extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ArrayVector3(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ArrayVector3(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ArrayVector3 position(long position) {
            return (ArrayVector3)super.position(position);
        }
    

        public ArrayVector3() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native void getAsVector3( @ByRef Vector3 out, @Cast("size_t") long index );



        public native @ByVal Vector3 getAsVector3( @Cast("size_t") long index );

        public native void setFromVector3( @Const @ByRef Vector3 v, @Cast("size_t") long index );


        public native void setAll( @Const @ByRef Vector3 v );
        public native @ByRef @Name("operator =") ArrayVector3 put( double fScalar );


        public native @Const @ByRef @Name("operator +") ArrayVector3 add();
        public native @ByVal @Name("operator -") ArrayVector3 subtract();

        
        
        

        
        

        
        
        

        
        

        
        
        

        
        

        
        
        

        
        

        public native @Name("operator +=") void addPut( @Const @ByRef ArrayVector3 a );
        public native @Name("operator +=") void addPut( double fScalar );

        public native @Name("operator -=") void subtractPut( @Const @ByRef ArrayVector3 a );
        public native @Name("operator -=") void subtractPut( double fScalar );

        public native @Name("operator *=") void multiplyPut( @Const @ByRef ArrayVector3 a );
        public native @Name("operator *=") void multiplyPut( double fScalar );

        public native @Name("operator /=") void dividePut( @Const @ByRef ArrayVector3 a );
        public native @Name("operator /=") void dividePut( double fScalar );



        public native void normalise( );


        public native @ByVal ArrayVector3 crossProduct( @Const @ByRef ArrayVector3 rkVector );


        public native @ByVal ArrayVector3 midPoint( @Const @ByRef ArrayVector3 vec );


        public native void makeFloor( @Const @ByRef ArrayVector3 cmp );


        public native void makeCeil( @Const @ByRef ArrayVector3 cmp );
        public native void setToSign();


        public native @ByVal ArrayVector3 perpendicular( );


        public native @ByVal ArrayVector3 normalisedCopy( );


        public native @ByVal ArrayVector3 reflect( @Const @ByRef ArrayVector3 normal );
        public native void inverseLeaveZeroes( );






        public native int isNaN( );


        public native @ByVal ArrayVector3 primaryAxis( );
        public native @ByVal Vector3 collapseMin( );
        public native @ByVal Vector3 collapseMax( );
        public native void loadFromAoS( double src );

        @MemberGetter public static native @Const @ByRef ArrayVector3 ZERO();
        @MemberGetter public static native @Const @ByRef ArrayVector3 UNIT_X();
        @MemberGetter public static native @Const @ByRef ArrayVector3 UNIT_Y();
        @MemberGetter public static native @Const @ByRef ArrayVector3 UNIT_Z();
        @MemberGetter public static native @Const @ByRef ArrayVector3 NEGATIVE_UNIT_X();
        @MemberGetter public static native @Const @ByRef ArrayVector3 NEGATIVE_UNIT_Y();
        @MemberGetter public static native @Const @ByRef ArrayVector3 NEGATIVE_UNIT_Z();
        @MemberGetter public static native @Const @ByRef ArrayVector3 UNIT_SCALE();
    }





    

    



    @Namespace("Ogre") public static native @ByVal @Name("operator +") ArrayVector3 add( @Const @ByRef ArrayVector3 lhs, @Const @ByRef ArrayVector3 rhs );
    @Namespace("Ogre") public static native @ByVal @Name("operator +") ArrayVector3 add( double fScalar, @Const @ByRef ArrayVector3 rhs );
    @Namespace("Ogre") public static native @ByVal @Name("operator +") ArrayVector3 add( @Const @ByRef ArrayVector3 lhs, double fScalar );


    @Namespace("Ogre") public static native @ByVal @Name("operator -") ArrayVector3 subtract( @Const @ByRef ArrayVector3 lhs, @Const @ByRef ArrayVector3 rhs );
    @Namespace("Ogre") public static native @ByVal @Name("operator -") ArrayVector3 subtract( double fScalar, @Const @ByRef ArrayVector3 rhs );
    @Namespace("Ogre") public static native @ByVal @Name("operator -") ArrayVector3 subtract( @Const @ByRef ArrayVector3 lhs, double fScalar );


    @Namespace("Ogre") public static native @ByVal @Name("operator *") ArrayVector3 multiply( @Const @ByRef ArrayVector3 lhs, @Const @ByRef ArrayVector3 rhs );
    @Namespace("Ogre") public static native @ByVal @Name("operator *") ArrayVector3 multiply( double fScalar, @Const @ByRef ArrayVector3 rhs );
    @Namespace("Ogre") public static native @ByVal @Name("operator *") ArrayVector3 multiply( @Const @ByRef ArrayVector3 lhs, double fScalar );


    @Namespace("Ogre") public static native @ByVal @Name("operator /") ArrayVector3 divide( @Const @ByRef ArrayVector3 lhs, @Const @ByRef ArrayVector3 rhs );
    @Namespace("Ogre") public static native @ByVal @Name("operator /") ArrayVector3 divide( double fScalar, @Const @ByRef ArrayVector3 rhs );
    @Namespace("Ogre") public static native @ByVal @Name("operator /") ArrayVector3 divide( @Const @ByRef ArrayVector3 lhs, double fScalar );

    



    
    
    


    
    
    


    
    
    


    
    
    



    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    @Namespace("Ogre") @NoOffset public static class ArrayQuaternion extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ArrayQuaternion(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ArrayQuaternion(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ArrayQuaternion position(long position) {
            return (ArrayQuaternion)super.position(position);
        }
    

        public ArrayQuaternion() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native void getAsQuaternion( @ByRef Quaternion out, @Cast("size_t") long index );



        public native @ByVal Quaternion getAsQuaternion( @Cast("size_t") long index );

        public native void setFromQuaternion( @Const @ByRef Quaternion v, @Cast("size_t") long index );

        public native void setAll( @Const @ByRef Quaternion v );


        public native void FromAngleAxis( @Const @ByRef ArrayRadian rfAngle, @Const @ByRef ArrayVector3 rkAxis );


        public native void ToAngleAxis( @ByRef ArrayRadian rfAngle, @ByRef ArrayVector3 rkAxis );

        

        
        
        
        
        public native @Name("operator +=") void addPut( @Const @ByRef ArrayQuaternion a );
        public native @Name("operator -=") void subtractPut( @Const @ByRef ArrayQuaternion a );


        public native @ByVal ArrayVector3 xAxis( );

        public native @ByVal ArrayVector3 yAxis( );

        public native @ByVal ArrayVector3 zAxis( );



        public native void normalise( );

        public native @ByVal ArrayQuaternion Inverse( );
        public native @ByVal ArrayQuaternion UnitInverse( );
        public native @ByVal ArrayQuaternion Exp( );
        public native @ByVal ArrayQuaternion Log( );


        public native @ByVal @Name("operator *") ArrayVector3 multiply( @Const @ByRef ArrayVector3 v );
        public static native void mul( @Const @ByRef ArrayQuaternion inQ, @ByRef ArrayVector3 inOutVec );

        @MemberGetter public static native @Const @ByRef ArrayQuaternion ZERO();
        @MemberGetter public static native @Const @ByRef ArrayQuaternion IDENTITY();
    }




    @Namespace("Ogre") public static native @ByVal @Name("operator +") ArrayQuaternion add( @Const @ByRef ArrayQuaternion lhs, @Const @ByRef ArrayQuaternion rhs );


    @Namespace("Ogre") public static native @ByVal @Name("operator -") ArrayQuaternion subtract( @Const @ByRef ArrayQuaternion lhs, @Const @ByRef ArrayQuaternion rhs );



    


    


    






    @Namespace("Ogre") public static native @ByVal @Name("operator *") ArrayQuaternion multiply( @Const @ByRef ArrayQuaternion lhs, @Const @ByRef ArrayQuaternion rhs );

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    @Namespace("Ogre") @NoOffset public static class ArrayMatrix4 extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ArrayMatrix4(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ArrayMatrix4(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ArrayMatrix4 position(long position) {
            return (ArrayMatrix4)super.position(position);
        }
    

        public ArrayMatrix4() { super((Pointer)null); allocate(); }
        private native void allocate();
        public ArrayMatrix4( @Const @ByRef ArrayMatrix4 copy ) { super((Pointer)null); allocate(copy); }
        private native void allocate( @Const @ByRef ArrayMatrix4 copy );

        public native void getAsMatrix4( @ByRef Matrix4 out, @Cast("size_t") long index );



        public native @ByVal Matrix4 getAsMatrix4( @Cast("size_t") long index );

        public native void setFromMatrix4( @Const @ByRef Matrix4 m, @Cast("size_t") long index );


        public native void setAll( @Const @ByRef Matrix4 m );

        public static native @ByVal ArrayMatrix4 createAllFromMatrix4( @Const @ByRef Matrix4 m );






        public native @ByRef @Name("operator =") ArrayMatrix4 put( @Const @ByRef ArrayMatrix4 rkMatrix );


        

        public native @ByVal @Name("operator *") ArrayVector3 multiply( @Const @ByRef ArrayVector3 rhs );



        public native @Name("operator *=") void multiplyPut( @Const @ByRef ArrayMatrix4 rhs );
        public native void fromQuaternion( @Const @ByRef ArrayQuaternion q );


        public native void makeTransform( @Const @ByRef ArrayVector3 position, @Const @ByRef ArrayVector3 scale,
                                            @Const @ByRef ArrayQuaternion orientation );





        public native void storeToAoS( Matrix4 dst );





        public native void loadFromAoS( @Const Matrix4 src );
        public native void loadFromAoS( @Const SimpleMatrix4 src );


        public native @Cast("bool") boolean isAffine();

        @MemberGetter public static native @Const @ByRef ArrayMatrix4 IDENTITY();
    }





    @Namespace("Ogre") public static class SimpleMatrix4 extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public SimpleMatrix4() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public SimpleMatrix4(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SimpleMatrix4(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public SimpleMatrix4 position(long position) {
            return (SimpleMatrix4)super.position(position);
        }
    


        public native void load( @Const @ByRef Matrix4 src );
    }






    @Namespace("Ogre") public static native @ByVal @Name("operator *") ArrayMatrix4 multiply( @Const @ByRef ArrayMatrix4 lhs, @Const @ByRef ArrayMatrix4 rhs );

    

    

    

    

    

    

    

    


    public static class CleanupRoutines extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    CleanupRoutines(Pointer p) { super(p); }
        protected CleanupRoutines() { allocate(); }
        private native void allocate();
        public native void call( @Cast("char*") BytePointer dstPtr, @Cast("size_t") long indexDst, @Cast("char*") BytePointer srcPtr, @Cast("size_t") long indexSrc,
                                         @Cast("size_t") long numSlots, @Cast("size_t") long numFreeSlots, @Cast("size_t") long elementsMemSize );
    }
    @Namespace("Ogre") @NoOffset public static class ArrayMemoryManager extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ArrayMemoryManager(Pointer p) { super(p); }
    
        /** enum Ogre::ArrayMemoryManager::ManagerType */
        public static final int
            NodeType = 0,
            ObjectDataType = 1,
            BoneType = 2,



            UserDefinedType0 = 3,
            UserDefinedType1 = 4,
            UserDefinedType2 = 5,
            UserDefinedType3 = 6,
            UserDefinedType4 = 7,
            UserDefinedType5 = 8,
            UserDefinedType6 = 9,

            NumStructTypes = 10;
        public static class RebaseListener extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public RebaseListener(Pointer p) { super(p); }
        
            public native void buildDiffList( @Cast("Ogre::ArrayMemoryManager::ManagerType") int managerType, @Cast("Ogre::uint16") short level,
                                                    @Cast("const Ogre::MemoryPoolVec*") @ByRef CharPtrVectorRef basePtrs, @Cast("Ogre::ArrayMemoryManager::PtrdiffVec*") @ByRef CharPtrVectorRef outDiffsList );
            public native void applyRebase( @Cast("Ogre::ArrayMemoryManager::ManagerType") int managerType, @Cast("Ogre::uint16") short level,
                                                    @Cast("const Ogre::MemoryPoolVec*") @ByRef CharPtrVectorRef newBasePtrs,
                                                    @Cast("const Ogre::ArrayMemoryManager::PtrdiffVec*") @ByRef CharPtrVectorRef diffsList );
            public native void performCleanup( @Cast("Ogre::ArrayMemoryManager::ManagerType") int managerType, @Cast("Ogre::uint16") short level,
                                                     @Cast("const Ogre::MemoryPoolVec*") @ByRef CharPtrVectorRef basePtrs,
                                                     @Cast("size_t const*") SizeTPointer elementsMemSizes, @Cast("size_t") long startInstance,
                                                     @Cast("size_t") long diffInstances );
        }
        @MemberGetter public static native @Cast("const size_t") long MAX_MEMORY_SLOTS();
        public static final long MAX_MEMORY_SLOTS = MAX_MEMORY_SLOTS();
        public ArrayMemoryManager( @Cast("Ogre::ArrayMemoryManager::ManagerType") int managerType, @Cast("size_t const*") SizeTPointer elementsMemSize,
                                    @Const({false, true}) CleanupRoutines cleanupRoutines, @Cast("size_t") long numElementsSize,
                                    @Cast("Ogre::uint16") short depthLevel, @Cast("size_t") long hintMaxNodes,
                                    @Cast("size_t") long cleanupThreshold/*=100*/, @Cast("size_t") long maxHardLimit/*=Ogre::ArrayMemoryManager::MAX_MEMORY_SLOTS*/,
                                    RebaseListener rebaseListener/*=0*/ ) { super((Pointer)null); allocate(managerType, elementsMemSize, cleanupRoutines, numElementsSize, depthLevel, hintMaxNodes, cleanupThreshold, maxHardLimit, rebaseListener); }
        private native void allocate( @Cast("Ogre::ArrayMemoryManager::ManagerType") int managerType, @Cast("size_t const*") SizeTPointer elementsMemSize,
                                    @Const({false, true}) CleanupRoutines cleanupRoutines, @Cast("size_t") long numElementsSize,
                                    @Cast("Ogre::uint16") short depthLevel, @Cast("size_t") long hintMaxNodes,
                                    @Cast("size_t") long cleanupThreshold/*=100*/, @Cast("size_t") long maxHardLimit/*=Ogre::ArrayMemoryManager::MAX_MEMORY_SLOTS*/,
                                    RebaseListener rebaseListener/*=0*/ );
        public ArrayMemoryManager( @Cast("Ogre::ArrayMemoryManager::ManagerType") int managerType, @Cast("size_t const*") SizeTPointer elementsMemSize,
                                    @Const({false, true}) CleanupRoutines cleanupRoutines, @Cast("size_t") long numElementsSize,
                                    @Cast("Ogre::uint16") short depthLevel, @Cast("size_t") long hintMaxNodes ) { super((Pointer)null); allocate(managerType, elementsMemSize, cleanupRoutines, numElementsSize, depthLevel, hintMaxNodes); }
        private native void allocate( @Cast("Ogre::ArrayMemoryManager::ManagerType") int managerType, @Cast("size_t const*") SizeTPointer elementsMemSize,
                                    @Const({false, true}) CleanupRoutines cleanupRoutines, @Cast("size_t") long numElementsSize,
                                    @Cast("Ogre::uint16") short depthLevel, @Cast("size_t") long hintMaxNodes );
        public native void initialize();







        public native void destroy();


        public native @Cast("size_t") long getFreeMemory();

        public native @Cast("size_t") long getUsedMemory();

        public native @Cast("size_t") long getWastedMemory();

        public native @Cast("size_t") long getAllMemory();
    }
    @Namespace("Ogre") @NoOffset public static class NodeArrayMemoryManager extends ArrayMemoryManager {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public NodeArrayMemoryManager(Pointer p) { super(p); }
    
        /** enum Ogre::NodeArrayMemoryManager::MemoryTypes */
        public static final int
            Parent = 0,
            Owner = 1,
            Position = 2,
            Orientation = 3,
            Scale = 4,
            DerivedPosition = 5,
            DerivedOrientation = 6,
            DerivedScale = 7,
            WorldMat = 8,
            InheritOrientation = 9,
            InheritScale = 10,
            NumMemoryTypes = 11;

        @MemberGetter public static native @Cast("const size_t") long ElementsMemSize(int i);
        @MemberGetter public static native @Cast("const size_t*") SizeTPointer ElementsMemSize();
        @MemberGetter public static native CleanupRoutines NodeCleanupRoutines(int i);
        @MemberGetter public static native @Const CleanupRoutines NodeCleanupRoutines();


        public NodeArrayMemoryManager( @Cast("Ogre::uint16") short depthLevel, @Cast("size_t") long hintMaxNodes, Node dummyNode,
                                        @Cast("size_t") long cleanupThreshold/*=100*/, @Cast("size_t") long maxHardLimit/*=MAX_MEMORY_SLOTS*/,
                                        RebaseListener rebaseListener/*=0*/ ) { super((Pointer)null); allocate(depthLevel, hintMaxNodes, dummyNode, cleanupThreshold, maxHardLimit, rebaseListener); }
        private native void allocate( @Cast("Ogre::uint16") short depthLevel, @Cast("size_t") long hintMaxNodes, Node dummyNode,
                                        @Cast("size_t") long cleanupThreshold/*=100*/, @Cast("size_t") long maxHardLimit/*=MAX_MEMORY_SLOTS*/,
                                        RebaseListener rebaseListener/*=0*/ );
        public NodeArrayMemoryManager( @Cast("Ogre::uint16") short depthLevel, @Cast("size_t") long hintMaxNodes, Node dummyNode ) { super((Pointer)null); allocate(depthLevel, hintMaxNodes, dummyNode); }
        private native void allocate( @Cast("Ogre::uint16") short depthLevel, @Cast("size_t") long hintMaxNodes, Node dummyNode );
        public native void createNewNode( @ByRef Transform outTransform );







        public native void destroyNode( @ByRef Transform inOutTransform );
        public native @Cast("size_t") long getFirstNode( @ByRef Transform outTransform );
    }
    @Namespace("Ogre") @NoOffset public static class ObjectDataArrayMemoryManager extends ArrayMemoryManager {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ObjectDataArrayMemoryManager(Pointer p) { super(p); }
    
        /** enum Ogre::ObjectDataArrayMemoryManager::MemoryTypes */
        public static final int
            Parent = 0,
            Owner = 1,
            LocalAabb = 2,
            WorldAabb = 3,
            LocalRadius = 4,
            WorldRadius = 5,
            DistanceToCamera = 6,
            UpperDistance = 7,
            VisibilityFlags = 8,
            QueryFlags = 9,
            LightMask = 10,
            NumMemoryTypes = 11;

        @MemberGetter public static native @Cast("const size_t") long ElementsMemSize(int i);
        @MemberGetter public static native @Cast("const size_t*") SizeTPointer ElementsMemSize();
        @MemberGetter public static native CleanupRoutines ObjCleanupRoutines(int i);
        @MemberGetter public static native @Const CleanupRoutines ObjCleanupRoutines();


        public ObjectDataArrayMemoryManager( @Cast("Ogre::uint16") short depthLevel, @Cast("size_t") long hintMaxNodes, Node dummyNode,
                                                MovableObject dummyObject, @Cast("size_t") long cleanupThreshold/*=100*/,
                                                @Cast("size_t") long maxHardLimit/*=MAX_MEMORY_SLOTS*/,
                                                RebaseListener rebaseListener/*=0*/ ) { super((Pointer)null); allocate(depthLevel, hintMaxNodes, dummyNode, dummyObject, cleanupThreshold, maxHardLimit, rebaseListener); }
        private native void allocate( @Cast("Ogre::uint16") short depthLevel, @Cast("size_t") long hintMaxNodes, Node dummyNode,
                                                MovableObject dummyObject, @Cast("size_t") long cleanupThreshold/*=100*/,
                                                @Cast("size_t") long maxHardLimit/*=MAX_MEMORY_SLOTS*/,
                                                RebaseListener rebaseListener/*=0*/ );
        public ObjectDataArrayMemoryManager( @Cast("Ogre::uint16") short depthLevel, @Cast("size_t") long hintMaxNodes, Node dummyNode,
                                                MovableObject dummyObject ) { super((Pointer)null); allocate(depthLevel, hintMaxNodes, dummyNode, dummyObject); }
        private native void allocate( @Cast("Ogre::uint16") short depthLevel, @Cast("size_t") long hintMaxNodes, Node dummyNode,
                                                MovableObject dummyObject );


        public native void createNewNode( @ByRef ObjectData outData );


        public native void destroyNode( @ByRef ObjectData inOutData );


        public native @Cast("size_t") long getFirstNode( @ByRef ObjectData outData );
    }

    @Namespace("Ogre") public static native void cleanerFlat( @Cast("char*") BytePointer dstPtr, @Cast("size_t") long indexDst, @Cast("char*") BytePointer srcPtr, @Cast("size_t") long indexSrc,
                                 @Cast("size_t") long numSlots, @Cast("size_t") long numFreeSlots, @Cast("size_t") long elementsMemSize );
    @Namespace("Ogre") public static native void cleanerFlat( @Cast("char*") ByteBuffer dstPtr, @Cast("size_t") long indexDst, @Cast("char*") ByteBuffer srcPtr, @Cast("size_t") long indexSrc,
                                 @Cast("size_t") long numSlots, @Cast("size_t") long numFreeSlots, @Cast("size_t") long elementsMemSize );
    @Namespace("Ogre") public static native void cleanerFlat( @Cast("char*") byte[] dstPtr, @Cast("size_t") long indexDst, @Cast("char*") byte[] srcPtr, @Cast("size_t") long indexSrc,
                                 @Cast("size_t") long numSlots, @Cast("size_t") long numFreeSlots, @Cast("size_t") long elementsMemSize );
    @Namespace("Ogre") public static native void cleanerArrayVector3( @Cast("char*") BytePointer dstPtr, @Cast("size_t") long indexDst, @Cast("char*") BytePointer srcPtr, @Cast("size_t") long indexSrc,
                                         @Cast("size_t") long numSlots, @Cast("size_t") long numFreeSlots, @Cast("size_t") long elementsMemSize );
    @Namespace("Ogre") public static native void cleanerArrayVector3( @Cast("char*") ByteBuffer dstPtr, @Cast("size_t") long indexDst, @Cast("char*") ByteBuffer srcPtr, @Cast("size_t") long indexSrc,
                                         @Cast("size_t") long numSlots, @Cast("size_t") long numFreeSlots, @Cast("size_t") long elementsMemSize );
    @Namespace("Ogre") public static native void cleanerArrayVector3( @Cast("char*") byte[] dstPtr, @Cast("size_t") long indexDst, @Cast("char*") byte[] srcPtr, @Cast("size_t") long indexSrc,
                                         @Cast("size_t") long numSlots, @Cast("size_t") long numFreeSlots, @Cast("size_t") long elementsMemSize );
    @Namespace("Ogre") public static native void cleanerArrayQuaternion( @Cast("char*") BytePointer dstPtr, @Cast("size_t") long indexDst, @Cast("char*") BytePointer srcPtr, @Cast("size_t") long indexSrc,
                                            @Cast("size_t") long numSlots, @Cast("size_t") long numFreeSlots, @Cast("size_t") long elementsMemSize );
    @Namespace("Ogre") public static native void cleanerArrayQuaternion( @Cast("char*") ByteBuffer dstPtr, @Cast("size_t") long indexDst, @Cast("char*") ByteBuffer srcPtr, @Cast("size_t") long indexSrc,
                                            @Cast("size_t") long numSlots, @Cast("size_t") long numFreeSlots, @Cast("size_t") long elementsMemSize );
    @Namespace("Ogre") public static native void cleanerArrayQuaternion( @Cast("char*") byte[] dstPtr, @Cast("size_t") long indexDst, @Cast("char*") byte[] srcPtr, @Cast("size_t") long indexSrc,
                                            @Cast("size_t") long numSlots, @Cast("size_t") long numFreeSlots, @Cast("size_t") long elementsMemSize );
    @Namespace("Ogre") public static native void cleanerArrayAabb( @Cast("char*") BytePointer dstPtr, @Cast("size_t") long indexDst, @Cast("char*") BytePointer srcPtr, @Cast("size_t") long indexSrc,
                                        @Cast("size_t") long numSlots, @Cast("size_t") long numFreeSlots, @Cast("size_t") long elementsMemSize );
    @Namespace("Ogre") public static native void cleanerArrayAabb( @Cast("char*") ByteBuffer dstPtr, @Cast("size_t") long indexDst, @Cast("char*") ByteBuffer srcPtr, @Cast("size_t") long indexSrc,
                                        @Cast("size_t") long numSlots, @Cast("size_t") long numFreeSlots, @Cast("size_t") long elementsMemSize );
    @Namespace("Ogre") public static native void cleanerArrayAabb( @Cast("char*") byte[] dstPtr, @Cast("size_t") long indexDst, @Cast("char*") byte[] srcPtr, @Cast("size_t") long indexSrc,
                                        @Cast("size_t") long numSlots, @Cast("size_t") long numFreeSlots, @Cast("size_t") long elementsMemSize );





    @Namespace("Ogre") @NoOffset public static class Transform extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Transform(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Transform(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Transform position(long position) {
            return (Transform)super.position(position);
        }
    

        public native @Cast("unsigned char") byte mIndex(); public native Transform mIndex(byte mIndex);


        public native Node mParents(int i); public native Transform mParents(int i, Node mParents);
        @MemberGetter public native @Cast("Ogre::Node**") PointerPointer mParents();


        public native Node mOwner(int i); public native Transform mOwner(int i, Node mOwner);
        @MemberGetter public native @Cast("Ogre::Node**") PointerPointer mOwner();


        public native ArrayVector3 mPosition(); public native Transform mPosition(ArrayVector3 mPosition);


        public native ArrayQuaternion mOrientation(); public native Transform mOrientation(ArrayQuaternion mOrientation);


        public native ArrayVector3 mScale(); public native Transform mScale(ArrayVector3 mScale);


        public native ArrayVector3 mDerivedPosition(); public native Transform mDerivedPosition(ArrayVector3 mDerivedPosition);


        public native ArrayQuaternion mDerivedOrientation(); public native Transform mDerivedOrientation(ArrayQuaternion mDerivedOrientation);


        public native ArrayVector3 mDerivedScale(); public native Transform mDerivedScale(ArrayVector3 mDerivedScale);


        public native Matrix4 mDerivedTransform(); public native Transform mDerivedTransform(Matrix4 mDerivedTransform);



        public native @Cast("bool*") BoolPointer mInheritOrientation(); public native Transform mInheritOrientation(BoolPointer mInheritOrientation);



        public native @Cast("bool*") BoolPointer mInheritScale(); public native Transform mInheritScale(BoolPointer mInheritScale);

        public Transform() { super((Pointer)null); allocate(); }
        private native void allocate();
        public native void copy( @Const @ByRef Transform inCopy );
        public native void rebasePtrs( @Cast("const Ogre::MemoryPoolVec*") @ByRef CharPtrVectorRef newBasePtrs, @Cast("const ptrdiff_t") long diff );




        public native void advancePack();

        public native void advancePack( @Cast("size_t") long numAdvance );
    }

    @Namespace("Ogre") @NoOffset public static class Node extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Node(Pointer p) { super(p); }
        public IdObject asIdObject() { return asIdObject(this); }
        @Namespace public static native @Name("static_cast<Ogre::IdObject*>") IdObject asIdObject(Node pointer);
    


        /** enum Ogre::Node::TransformSpace */
        public static final int

            TS_LOCAL = 0,

            TS_PARENT = 1,

            TS_WORLD = 2;



        @Name("Ogre::Node::Listener") public static class NodeListener extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public NodeListener(Pointer p) { super(p); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public NodeListener(long size) { super((Pointer)null); allocateArray(size); }
            private native void allocateArray(long size);
            @Override public NodeListener position(long position) {
                return (NodeListener)super.position(position);
            }
        
            public NodeListener() { super((Pointer)null); allocate(); }
            private native void allocate();







            public native void nodeUpdated(@Const Node arg0);

            public native void nodeDestroyed(@Const Node arg0);

            public native void nodeAttached(@Const Node arg0);

            public native void nodeDetached(@Const Node arg0);
        }






        public native @Cast("size_t") long mGlobalIndex(); public native Node mGlobalIndex(long mGlobalIndex);

        public native @Cast("size_t") long mParentIndex(); public native Node mParentIndex(long mParentIndex);


        public native void setName( @Const @ByRef String name );


        public native @Const @ByRef String getName();


        public native Node getParent();






        public native void migrateTo( NodeMemoryManager nodeMemoryManager );


        public native @Cast("bool") boolean isStatic();
        public native @Cast("bool") boolean setStatic( @Cast("bool") boolean bStatic );


        public native @Cast("Ogre::uint16") short getDepthLevel();


        public native @ByRef Transform _getTransform();



        public native void _notifyStaticDirty();





                   public native @ByVal Quaternion getOrientation();
                   public native void setOrientation( @ByVal Quaternion q );
                   public native void setOrientation( double w, double x, double y, double z);
                   public native void resetOrientation();





                   public native void setPosition( @Const @ByRef Vector3 pos );





                   public native void setPosition(double x, double y, double z);





                   public native @ByVal Vector3 getPosition();
                   public native void setScale(@Const @ByRef Vector3 scale);
                   public native void setScale(double x, double y, double z);





                   public native @ByVal Vector3 getScale();
                   public native void setInheritOrientation(@Cast("bool") boolean inherit);
                   public native @Cast("bool") boolean getInheritOrientation();
                   public native void setInheritScale(@Cast("bool") boolean inherit);





                   public native @Cast("bool") boolean getInheritScale();
                   public native void scale(@Const @ByRef Vector3 scale);
                   public native void scale(double x, double y, double z);
                   public native void translate(@Const @ByRef Vector3 d, @Cast("Ogre::Node::TransformSpace") int relativeTo/*=Ogre::Node::TS_PARENT*/);
                   public native void translate(@Const @ByRef Vector3 d);
                   public native void translate(double x, double y, double z, @Cast("Ogre::Node::TransformSpace") int relativeTo/*=Ogre::Node::TS_PARENT*/);
                   public native void translate(double x, double y, double z);
                   public native void translate(@Const @ByRef Matrix3 axes, @Const @ByRef Vector3 move, @Cast("Ogre::Node::TransformSpace") int relativeTo/*=Ogre::Node::TS_PARENT*/);
                   public native void translate(@Const @ByRef Matrix3 axes, @Const @ByRef Vector3 move);
                   public native void translate(@Const @ByRef Matrix3 axes, double x, double y, double z, @Cast("Ogre::Node::TransformSpace") int relativeTo/*=Ogre::Node::TS_PARENT*/);
                   public native void translate(@Const @ByRef Matrix3 axes, double x, double y, double z);



                   public native void roll(@Const @ByRef Radian angle, @Cast("Ogre::Node::TransformSpace") int relativeTo/*=Ogre::Node::TS_LOCAL*/);
                   public native void roll(@Const @ByRef Radian angle);



                   public native void pitch(@Const @ByRef Radian angle, @Cast("Ogre::Node::TransformSpace") int relativeTo/*=Ogre::Node::TS_LOCAL*/);
                   public native void pitch(@Const @ByRef Radian angle);



                   public native void yaw(@Const @ByRef Radian angle, @Cast("Ogre::Node::TransformSpace") int relativeTo/*=Ogre::Node::TS_LOCAL*/);
                   public native void yaw(@Const @ByRef Radian angle);



                   public native void rotate(@Const @ByRef Vector3 axis, @Const @ByRef Radian angle, @Cast("Ogre::Node::TransformSpace") int relativeTo/*=Ogre::Node::TS_LOCAL*/);
                   public native void rotate(@Const @ByRef Vector3 axis, @Const @ByRef Radian angle);



                   public native void rotate(@Const @ByRef Quaternion q, @Cast("Ogre::Node::TransformSpace") int relativeTo/*=Ogre::Node::TS_LOCAL*/);
                   public native void rotate(@Const @ByRef Quaternion q);



                   public native @ByVal Matrix3 getLocalAxes();







        public native Node createChild(
                    @Cast("Ogre::SceneMemoryMgrTypes") int sceneType/*=Ogre::SCENE_DYNAMIC*/,
                    @Const @ByRef(nullValue = "Ogre::Vector3::ZERO") Vector3 translate,
                    @Const @ByRef(nullValue = "Ogre::Quaternion::IDENTITY") Quaternion rotate );
        public native Node createChild( );





        public native void addChild(Node child);



        public native @Cast("size_t") long numChildren();


        public native Node getChild( @Cast("size_t") long index );
        public native @ByVal @Cast("Ogre::Node::NodeVecIterator*") TechniquesVectorIteratorRef getChildIterator();
        public native void removeChild( Node child );




        public native void removeAllChildren();





                   public native void _setDerivedPosition(@Const @ByRef Vector3 pos);






                   public native void _setDerivedOrientation(@Const @ByRef Quaternion q);
                   public native @ByVal Quaternion _getDerivedOrientation();
                   public native @ByVal Quaternion _getDerivedOrientationUpdated();
                   public native @ByVal Vector3 _getDerivedPosition();
                   public native @ByVal Vector3 _getDerivedPositionUpdated();
                   public native @ByVal Vector3 _getDerivedScale();
                   public native @ByVal Vector3 _getDerivedScaleUpdated();
                   public native @Const @ByRef Matrix4 _getFullTransform();


                   public native @Const @ByRef Matrix4 _getFullTransformUpdated();






        public native void setListener(NodeListener listener);



        public native NodeListener getListener();





        public static native void updateAllTransforms( @Cast("const size_t") long numNodes, @ByVal Transform t );


                   public native @ByVal Vector3 convertWorldToLocalPosition( @Const @ByRef Vector3 worldPos );



                   public native @ByVal Vector3 convertLocalToWorldPosition( @Const @ByRef Vector3 localPos );


                   public native @ByVal Quaternion convertWorldToLocalOrientation( @Const @ByRef Quaternion worldOrientation );



                   public native @ByVal Quaternion convertLocalToWorldOrientation( @Const @ByRef Quaternion localOrientation );


        public native double getSquaredViewDepth(@Const Camera cam);
        public native void setUserAny(@Const @ByRef Any anything);




        public native @Const @ByRef Any getUserAny();





        public native @ByRef UserObjectBindings getUserObjectBindings();






        public native void _setNullNodeMemoryManager();




        public native void _callMemoryChangeListeners();

        public native NodeMemoryManager getDefaultNodeMemoryManager( @Cast("Ogre::SceneMemoryMgrTypes") int sceneType );


        public native void _setCachedTransformOutOfDate();
        public native @Cast("bool") boolean isCachedTransformOutOfDate();

    }




    @Namespace("Ogre") @NoOffset public static class SceneNode extends Node {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SceneNode(Pointer p) { super(p); }
    

        public SceneNode( @Cast("Ogre::IdType") int id, SceneManager creator, NodeMemoryManager nodeMemoryManager,
                            SceneNode parent ) { super((Pointer)null); allocate(id, creator, nodeMemoryManager, parent); }
        private native void allocate( @Cast("Ogre::IdType") int id, SceneManager creator, NodeMemoryManager nodeMemoryManager,
                            SceneNode parent );




        public SceneNode( @Const @ByRef Transform transformPtrs ) { super((Pointer)null); allocate(transformPtrs); }
        private native void allocate( @Const @ByRef Transform transformPtrs );


        public native @Cast("bool") boolean setStatic( @Cast("bool") boolean bStatic );


        public native void _notifyStaticDirty();






                   public native void attachObject(MovableObject obj);



        public native @Cast("size_t") long numAttachedObjects();





        public native MovableObject getAttachedObject( @Cast("size_t") long index );





        public native MovableObject getAttachedObject( @Const @ByRef String name );





                   public native void detachObject(MovableObject obj);



        public native void detachAllObjects();



                   public native void _attachBone( SkeletonInstance skeletonInstance, Bone bone );



                   public native void _detachBone( SkeletonInstance skeletonInstance, Bone bone );



                   public native void _detachAllBones( SkeletonInstance skeletonInstance );


        public native void detachAllBones();


        public native void _callMemoryChangeListeners();
        public native @ByVal @Cast("Ogre::SceneNode::ObjectIterator*") TechniquesVectorIteratorRef getAttachedObjectIterator();






        public native SceneManager getCreator();
        public native void removeAndDestroyChild( SceneNode sceneNode );







        public native void removeAndDestroyAllChildren();







        public native SceneNode createChildSceneNode(
                        @Cast("Ogre::SceneMemoryMgrTypes") int sceneType/*=Ogre::SCENE_DYNAMIC*/,
                        @Const @ByRef(nullValue = "Ogre::Vector3::ZERO") Vector3 translate,
                        @Const @ByRef(nullValue = "Ogre::Quaternion::IDENTITY") Quaternion rotate );
        public native SceneNode createChildSceneNode( );

        public native void setListener( Listener listener );
        public native void setFixedYawAxis( @Cast("bool") boolean useFixed, @Const @ByRef(nullValue = "Ogre::Vector3::UNIT_Y") Vector3 fixedAxis );
        public native void setFixedYawAxis( @Cast("bool") boolean useFixed );

        public native @Cast("bool") boolean isYawFixed();



        public native void yaw(@Const @ByRef Radian angle, @ByVal(nullValue = "TransformSpace(TS_LOCAL)") TransformSpace relativeTo);
        public native void yaw(@Const @ByRef Radian angle);
        public native void setDirection(double x, double y, double z,
                    @ByVal(nullValue = "TransformSpace(TS_LOCAL)") TransformSpace relativeTo,
                    @Const @ByRef(nullValue = "Ogre::Vector3::NEGATIVE_UNIT_Z") Vector3 localDirectionVector);
        public native void setDirection(double x, double y, double z);
        public native void setDirection(@Const @ByRef Vector3 vec, @ByVal(nullValue = "TransformSpace(TS_LOCAL)") TransformSpace relativeTo,
                    @Const @ByRef(nullValue = "Ogre::Vector3::NEGATIVE_UNIT_Z") Vector3 localDirectionVector);
        public native void setDirection(@Const @ByRef Vector3 vec);






        public native void lookAt( @Const @ByRef Vector3 targetPoint, @ByVal TransformSpace relativeTo,
                    @Const @ByRef(nullValue = "Ogre::Vector3::NEGATIVE_UNIT_Z") Vector3 localDirectionVector);
        public native void lookAt( @Const @ByRef Vector3 targetPoint, @ByVal TransformSpace relativeTo);
        public native void setAutoTracking(@Cast("bool") boolean enabled, SceneNode target/*=0*/,
                    @Const @ByRef(nullValue = "Ogre::Vector3::NEGATIVE_UNIT_Z") Vector3 localDirectionVector,
                    @Const @ByRef(nullValue = "Ogre::Vector3::ZERO") Vector3 offset);
        public native void setAutoTracking(@Cast("bool") boolean enabled);


        public native SceneNode getParentSceneNode();
        public native void setVisible(@Cast("bool") boolean visible, @Cast("bool") boolean cascade/*=true*/);
        public native void setVisible(@Cast("bool") boolean visible);







        public native void flipVisibility(@Cast("bool") boolean cascade/*=true*/);
        public native void flipVisibility();




        public native NodeMemoryManager getDefaultNodeMemoryManager( @Cast("Ogre::SceneMemoryMgrTypes") int sceneType );


        public native void _setCachedTransformOutOfDate();

    }





    @Namespace("Ogre") @NoOffset public static class Aabb extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Aabb(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Aabb(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Aabb position(long position) {
            return (Aabb)super.position(position);
        }
    
        public native @ByRef Vector3 mCenter(); public native Aabb mCenter(Vector3 mCenter);
        public native @ByRef Vector3 mHalfSize(); public native Aabb mHalfSize(Vector3 mHalfSize);

        public Aabb() { super((Pointer)null); allocate(); }
        private native void allocate();





        public Aabb( @Const @ByRef Vector3 center, @Const @ByRef Vector3 halfSize ) { super((Pointer)null); allocate(center, halfSize); }
        private native void allocate( @Const @ByRef Vector3 center, @Const @ByRef Vector3 halfSize );


        public native void setExtents( @Const @ByRef Vector3 min, @Const @ByRef Vector3 max );


        public static native @ByVal Aabb newFromExtents( @Const @ByRef Vector3 min, @Const @ByRef Vector3 max );


        public native @ByVal Vector3 getMinimum();


        public native @ByVal Vector3 getMaximum();


        public native @ByVal Vector3 getSize();




        public native void merge( @Const @ByRef Aabb rhs );


        public native void merge( @Const @ByRef Vector3 points );
        public native void transformAffine( @Const @ByRef Matrix4 matrix );


        public native @Cast("bool") boolean intersects( @Const @ByRef Aabb b2 );


        public native @ByVal Aabb intersection( @Const @ByRef Aabb b2 );


        public native double volume();


        public native @Cast("bool") boolean contains( @Const @ByRef Aabb other );


        public native @Cast("bool") boolean contains( @Const @ByRef Vector3 v );


        public native double distance( @Const @ByRef Vector3 v );


        public native double getRadius();


        public native double getRadiusOrigin();

        public native @Cast("bool") @Name("operator ==") boolean equals( @Const @ByRef Aabb _r );
        public native @Cast("bool") @Name("operator !=") boolean notEquals( @Const @ByRef Aabb _r );

        @MemberGetter public static native @Const @ByRef Aabb BOX_INFINITE();
        @MemberGetter public static native @Const @ByRef Aabb BOX_NULL();


        @MemberGetter public static native @Const @ByRef Aabb BOX_ZERO();
    }




    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    @Namespace("Ogre") @NoOffset public static class ArrayAabb extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ArrayAabb(Pointer p) { super(p); }
    
        public native @ByRef ArrayVector3 mCenter(); public native ArrayAabb mCenter(ArrayVector3 mCenter);
        public native @ByRef ArrayVector3 mHalfSize(); public native ArrayAabb mHalfSize(ArrayVector3 mHalfSize);

        public ArrayAabb( @Const @ByRef ArrayVector3 center, @Const @ByRef ArrayVector3 halfSize ) { super((Pointer)null); allocate(center, halfSize); }
        private native void allocate( @Const @ByRef ArrayVector3 center, @Const @ByRef ArrayVector3 halfSize );

        public native void getAsAabb( @ByRef Aabb out, @Cast("size_t") long index );



        public native @ByVal Aabb getAsAabb( @Cast("size_t") long index );

        public native void setFromAabb( @Const @ByRef Aabb aabb, @Cast("size_t") long index );

        public native void setAll( @Const @ByRef Aabb aabb );


        public native @ByVal ArrayVector3 getMinimum();


        public native @ByVal ArrayVector3 getMaximum();




        public native void merge( @Const @ByRef ArrayAabb rhs );


        public native void merge( @Const @ByRef ArrayVector3 points );
        public native void transformAffine( @Const @ByRef ArrayMatrix4 matrix );


        public native @ByVal ArrayAabb intersection( @Const @ByRef ArrayAabb b2 );

        @MemberGetter public static native @Const @ByRef ArrayAabb BOX_INFINITE();


        @MemberGetter public static native @Const @ByRef ArrayAabb BOX_ZERO();
    }





    

    

    

    

    

    

    

    

    

    



    @Namespace("Ogre") @NoOffset public static class ObjectData extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ObjectData(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ObjectData(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ObjectData position(long position) {
            return (ObjectData)super.position(position);
        }
    

        public native @Cast("unsigned char") byte mIndex(); public native ObjectData mIndex(byte mIndex);


        public native Node mParents(int i); public native ObjectData mParents(int i, Node mParents);
        @MemberGetter public native @Cast("Ogre::Node**") PointerPointer mParents();


        public native MovableObject mOwner(int i); public native ObjectData mOwner(int i, MovableObject mOwner);
        @MemberGetter public native @Cast("Ogre::MovableObject**") PointerPointer mOwner();






        public native ArrayAabb mLocalAabb(); public native ObjectData mLocalAabb(ArrayAabb mLocalAabb);


        public native ArrayAabb mWorldAabb(); public native ObjectData mWorldAabb(ArrayAabb mWorldAabb);







        public native double mLocalRadius(); public native ObjectData mLocalRadius(double mLocalRadius);






        public native double mWorldRadius(); public native ObjectData mWorldRadius(double mWorldRadius);





        public native @Cast("Ogre::RealAsUint*") IntPointer mDistanceToCamera(); public native ObjectData mDistanceToCamera(IntPointer mDistanceToCamera);


        public native double mUpperDistance(); public native ObjectData mUpperDistance(double mUpperDistance);


        public native @Cast("Ogre::uint32*") IntPointer mVisibilityFlags(); public native ObjectData mVisibilityFlags(IntPointer mVisibilityFlags);


        public native @Cast("Ogre::uint32*") IntPointer mQueryFlags(); public native ObjectData mQueryFlags(IntPointer mQueryFlags);
        public native @Cast("Ogre::uint32*") IntPointer mLightMask(); public native ObjectData mLightMask(IntPointer mLightMask);

        public ObjectData() { super((Pointer)null); allocate(); }
        private native void allocate();


        public native void copy( @Const @ByRef ObjectData inCopy );




        public native void advancePack();

        public native void advancePack( @Cast("size_t") long numAdvance );




        public native void advanceBoundsPack();




        public native void advanceFrustumPack();




        public native void advanceDirtyInstanceMgr();




        public native void advanceCullLightPack();




        public native void advanceLightPack();

        public native void advanceLodPack();
    }

        @Namespace("Ogre::VisibilityFlags") @MemberGetter public static native @Cast("const Ogre::uint32") int LAYER_SHADOW_CASTER();
        @Namespace("Ogre::VisibilityFlags") @MemberGetter public static native @Cast("const Ogre::uint32") int LAYER_VISIBILITY();
        @Namespace("Ogre::VisibilityFlags") @MemberGetter public static native @Cast("const Ogre::uint32") int RESERVED_VISIBILITY_FLAGS();
    










    @Namespace("Ogre") @NoOffset public static class MovableObject extends AnimableObject {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MovableObject(Pointer p) { super(p); }
        public Pointer asPointer() { return asPointer(this); }
        @Namespace public static native @Name("static_cast<MovableAlloc*>") Pointer asPointer(MovableObject pointer);
        public IdObject asIdObject() { return asIdObject(this); }
        @Namespace public static native @Name("static_cast<Ogre::IdObject*>") IdObject asIdObject(MovableObject pointer);
    
        @MemberGetter public static native @ByRef @Cast("const Ogre::FastArray<Ogre::Real>*") RealFastArrayRef c_DefaultLodMesh();



        public static class Listener extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Listener(Pointer p) { super(p); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public Listener(long size) { super((Pointer)null); allocateArray(size); }
            private native void allocateArray(long size);
            @Override public Listener position(long position) {
                return (Listener)super.position(position);
            }
        
            public Listener() { super((Pointer)null); allocate(); }
            private native void allocate();

            public native void objectDestroyed(MovableObject arg0);

            public native void objectAttached(MovableObject arg0);

            public native void objectDetached(MovableObject arg0);
        }

        public native @ByRef @Cast("Ogre::RenderableArray*") RealFastArrayRef mRenderables(); public native MovableObject mRenderables(RealFastArrayRef mRenderables);






        public native @Cast("size_t") long mGlobalIndex(); public native MovableObject mGlobalIndex(long mGlobalIndex);

        public native @Cast("size_t") long mParentIndex(); public native MovableObject mParentIndex(long mParentIndex);


        public native void _notifyManager(SceneManager man);

        public native SceneManager _getManager();


        public native void setName( @Const @ByRef String name );


        public native @Const @ByRef String getName();


        public native @Const @ByRef String getMovableType();


        public native Node getParentNode();

        public native SceneNode getParentSceneNode();



        public native void _notifyAttached( Node parent );


        public native @Cast("bool") boolean isAttached();


        public native void detachFromParent();


        public native void _notifyParentNodeMemoryChanged();

        public native @Cast("unsigned char") byte getCurrentMeshLod();


        public native @Cast("bool") boolean isStatic();
        public native @Cast("bool") boolean setStatic( @Cast("bool") boolean bStatic );



        public native void _notifyStaticDirty();






        public native void _updateRenderQueue(RenderQueue queue, Camera camera, @Const Camera lodCamera);





        public static native void updateAllBounds( @Cast("const size_t") long numNodes, @ByVal ObjectData t );
        public static native void cullFrustum( @Cast("const size_t") long numNodes, @ByVal ObjectData t, @Const Camera frustum,
                                         @Cast("Ogre::uint32") int sceneVisibilityFlags, @Cast("Ogre::MovableObject::MovableObjectArray*") @ByRef RealFastArrayRef outCulledObjects,
                                         @Const Camera lodCamera );


        public native void instanceBatchCullFrustumThreaded( @Const Frustum frustum, @Const Camera lodCamera,
                                                                @Cast("Ogre::uint32") int combinedVisibilityFlags );
        public static native void cullLights( @Cast("const size_t") long numNodes, @ByVal ObjectData t, @ByRef LightListInfo outGlobalLightList,
                                        @Cast("const Ogre::FrustumVec*") @ByRef FrustumPtrVectorRef frustums, @Cast("const Ogre::FrustumVec*") @ByRef FrustumPtrVectorRef cubemapFrustums );
        public static native void buildLightList( @Cast("const size_t") long numNodes, @ByVal ObjectData t,
                                            @Const @ByRef LightListInfo globalLightList );

        public static native void calculateCastersBox( @Cast("const size_t") long numNodes, @ByVal ObjectData t,
                                                 @Cast("Ogre::uint32") int sceneVisibilityFlags, AxisAlignedBox outBox );

        
        
        public native void setVisible( @Cast("bool") boolean visible );





        public native @Cast("bool") boolean getVisible();





        public native @Cast("bool") boolean isVisible();







        public native void setRenderingDistance(double dist);


        public native double getRenderingDistance();






        public native void setRenderingMinPixelSize(double pixelSize);




        public native double getRenderingMinPixelSize();





        public native @ByRef UserObjectBindings getUserObjectBindings();
        public native void setRenderQueueGroup(@Cast("Ogre::uint8") byte queueID);


        public native @Cast("Ogre::uint8") byte getRenderQueueGroup();


        public native @ByRef ObjectData _getObjectData();


        public native @Const @ByRef Matrix4 _getParentNodeFullTransform();





        public native @ByVal Aabb getLocalAabb();





        public native void setLocalAabb(@Const @ByVal Aabb box);







        public native @ByVal Aabb getWorldAabb();
        public native @ByVal Aabb getWorldAabbUpdated();







        public native float getWorldRadius();
        public native float getWorldRadiusUpdated();
        public native void setQueryFlags(@Cast("Ogre::uint32") int flags);



        public native void addQueryFlags(@Cast("Ogre::uint32") int flags);



        public native void removeQueryFlags(@Cast("Ogre::uint32") int flags);


        public native @Cast("Ogre::uint32") int getQueryFlags();



        public static native void setDefaultQueryFlags(@Cast("Ogre::uint32") int flags);



        public static native @Cast("Ogre::uint32") int getDefaultQueryFlags();


        public native @Cast("Ogre::RealAsUint") int getCachedDistanceToCamera();


        public native double getCachedDistanceToCameraAsReal();
        public native void setVisibilityFlags(@Cast("Ogre::uint32") int flags);



        public native void addVisibilityFlags(@Cast("Ogre::uint32") int flags);



        public native void removeVisibilityFlags(@Cast("Ogre::uint32") int flags);




        public native @Cast("Ogre::uint32") int getVisibilityFlags();



        public static native void setDefaultVisibilityFlags(@Cast("Ogre::uint32") int flags);



        public static native @Cast("Ogre::uint32") int getDefaultVisibilityFlags();






        public native void setListener(Listener listener);



        public native Listener getListener();






        public native @Cast("const Ogre::LightList*") @ByRef HashedVector queryLights();





        public native @Cast("Ogre::uint32") int getLightMask();






        public native void setLightMask(@Cast("Ogre::uint32") int lightMask);







        public native @Cast("Ogre::LightList*") HashedVector _getLightList();
        public native void setCastShadows( @Cast("bool") boolean enabled );

        public native @Cast("bool") boolean getCastShadows();

        public native SkeletonInstance getSkeletonInstance();


        public native void _setCachedAabbOutOfDate();
        public native @Cast("bool") boolean isCachedAabbOutOfDate();


    }






    @Namespace("Ogre") public static class MovableObjectFactory extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MovableObjectFactory(Pointer p) { super(p); }
    

        public native @Const @ByRef String getType();







        public native MovableObject createInstance( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager,
                                                SceneManager manager, @Cast("const Ogre::NameValuePairList*") SStringMapRef params/*=0*/);
        public native MovableObject createInstance( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager,
                                                SceneManager manager);

        public native void destroyInstance(MovableObject obj);
    }

    @Namespace("Ogre") @NoOffset public static class NullEntity extends MovableObject {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public NullEntity(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public NullEntity(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public NullEntity position(long position) {
            return (NullEntity)super.position(position);
        }
    
        public NullEntity() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native @Const @ByRef String getMovableType();
        public native void _updateRenderQueue(RenderQueue queue, Camera camera, @Const Camera lodCamera,
                                                @Cast("Ogre::RealAsUint") int depth);
    }





    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    @Namespace("Ogre") public static class ResourceGroupListener extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ResourceGroupListener(Pointer p) { super(p); }
    
        public native void resourceGroupScriptingStarted(@Const @ByRef String groupName, @Cast("size_t") long scriptCount);







        public native void scriptParseStarted(@Const @ByRef String scriptName, @Cast("bool*") @ByRef BoolPointer skipThisScript);
        public native void scriptParseStarted(@Const @ByRef String scriptName, @Cast("bool*") @ByRef boolean[] skipThisScript);



        public native void scriptParseEnded(@Const @ByRef String scriptName, @Cast("bool") boolean skipped);

        public native void resourceGroupScriptingEnded(@Const @ByRef String groupName);






        public native void resourceGroupPrepareStarted(@Const @ByRef String groupName, @Cast("size_t") long resourceCount);




        public native void resourcePrepareStarted(@Cast("const Ogre::ResourcePtr*") @ByRef RealControllerFunctionSPtr resource);



        public native void resourcePrepareEnded();





        public native void worldGeometryPrepareStageStarted(@Const @ByRef String description);





        public native void worldGeometryPrepareStageEnded();

        public native void resourceGroupPrepareEnded(@Const @ByRef String groupName);






        public native void resourceGroupLoadStarted(@Const @ByRef String groupName, @Cast("size_t") long resourceCount);



        public native void resourceLoadStarted(@Cast("const Ogre::ResourcePtr*") @ByRef RealControllerFunctionSPtr resource);


        public native void resourceLoadEnded();





        public native void worldGeometryStageStarted(@Const @ByRef String description);




        public native void worldGeometryStageEnded();

        public native void resourceGroupLoadEnded(@Const @ByRef String groupName);



        public native void resourceCreated(@Cast("const Ogre::ResourcePtr*") @ByRef RealControllerFunctionSPtr resource);



        public native void resourceRemove(@Cast("const Ogre::ResourcePtr*") @ByRef RealControllerFunctionSPtr resource);
    }






    @Namespace("Ogre") public static class ResourceLoadingListener extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ResourceLoadingListener(Pointer p) { super(p); }
    


        public native @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr resourceLoading(@Const @ByRef String name, @Const @ByRef String group, Resource resource);






        public native void resourceStreamOpened(@Const @ByRef String name, @Const @ByRef String group, Resource resource, @Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr dataStream);



        public native @Cast("bool") boolean resourceCollision(Resource resource, ResourceManager resourceManager);
    }
    @Namespace("Ogre") @NoOffset public static class ResourceGroupManager extends ResourceGroupManagerSgtRef {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ResourceGroupManager(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ResourceGroupManager(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ResourceGroupManager position(long position) {
            return (ResourceGroupManager)super.position(position);
        }
        public Pointer asPointer() { return asPointer(this); }
        @Namespace public static native @Name("static_cast<ResourceAlloc*>") Pointer asPointer(ResourceGroupManager pointer);
    
   

        public static native @ByRef String DEFAULT_RESOURCE_GROUP_NAME(); public static native void DEFAULT_RESOURCE_GROUP_NAME(String DEFAULT_RESOURCE_GROUP_NAME);

        public static native @ByRef String INTERNAL_RESOURCE_GROUP_NAME(); public static native void INTERNAL_RESOURCE_GROUP_NAME(String INTERNAL_RESOURCE_GROUP_NAME);

        public static native @ByRef String AUTODETECT_RESOURCE_GROUP_NAME(); public static native void AUTODETECT_RESOURCE_GROUP_NAME(String AUTODETECT_RESOURCE_GROUP_NAME);

        public static native @Cast("size_t") long RESOURCE_SYSTEM_NUM_REFERENCE_COUNTS(); public static native void RESOURCE_SYSTEM_NUM_REFERENCE_COUNTS(long RESOURCE_SYSTEM_NUM_REFERENCE_COUNTS);

        public static class ResourceDeclaration extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public ResourceDeclaration() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public ResourceDeclaration(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public ResourceDeclaration(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public ResourceDeclaration position(long position) {
                return (ResourceDeclaration)super.position(position);
            }
        
            public native @ByRef String resourceName(); public native ResourceDeclaration resourceName(String resourceName);
            public native @ByRef String resourceType(); public native ResourceDeclaration resourceType(String resourceType);
            public native ManualResourceLoader loader(); public native ResourceDeclaration loader(ManualResourceLoader loader);
            public native @ByRef @Cast("Ogre::NameValuePairList*") SStringMapRef parameters(); public native ResourceDeclaration parameters(SStringMapRef parameters);
        }

        public static class ResourceLocation extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public ResourceLocation() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public ResourceLocation(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public ResourceLocation(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public ResourceLocation position(long position) {
                return (ResourceLocation)super.position(position);
            }
        

            public native Archive archive(); public native ResourceLocation archive(Archive archive);

            public native @Cast("bool") boolean recursive(); public native ResourceLocation recursive(boolean recursive);
        }
        public ResourceGroupManager() { super((Pointer)null); allocate(); }
        private native void allocate();
        public native void createResourceGroup(@Const @ByRef String name, @Cast("const bool") boolean inGlobalPool/*=true*/);
        public native void createResourceGroup(@Const @ByRef String name);
        public native void initialiseResourceGroup(@Const @ByRef String name);




        public native void initialiseAllResourceGroups();
        public native void prepareResourceGroup(@Const @ByRef String name, @Cast("bool") boolean prepareMainResources/*=true*/,
                    @Cast("bool") boolean prepareWorldGeom/*=true*/);
        public native void prepareResourceGroup(@Const @ByRef String name);
        public native void loadResourceGroup(@Const @ByRef String name, @Cast("bool") boolean loadMainResources/*=true*/,
                    @Cast("bool") boolean loadWorldGeom/*=true*/);
        public native void loadResourceGroup(@Const @ByRef String name);
        public native void unloadResourceGroup(@Const @ByRef String name, @Cast("bool") boolean reloadableOnly/*=true*/);
        public native void unloadResourceGroup(@Const @ByRef String name);
        public native void unloadUnreferencedResourcesInGroup(@Const @ByRef String name,
                    @Cast("bool") boolean reloadableOnly/*=true*/);
        public native void unloadUnreferencedResourcesInGroup(@Const @ByRef String name);
        public native void clearResourceGroup(@Const @ByRef String name);






        public native void destroyResourceGroup(@Const @ByRef String name);
        public native @Cast("bool") boolean isResourceGroupInitialised(@Const @ByRef String name);
        public native @Cast("bool") boolean isResourceGroupLoaded(@Const @ByRef String name);




        public native @Cast("bool") boolean resourceGroupExists(@Const @ByRef String name);
        public native void addResourceLocation(@Const @ByRef String name, @Const @ByRef String locType,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String resGroup, @Cast("bool") boolean recursive/*=false*/, @Cast("bool") boolean readOnly/*=true*/);
        public native void addResourceLocation(@Const @ByRef String name, @Const @ByRef String locType);

        public native void removeResourceLocation(@Const @ByRef String name,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String resGroup);
        public native void removeResourceLocation(@Const @ByRef String name);

        public native @Cast("bool") boolean resourceLocationExists(@Const @ByRef String name,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String resGroup);
        public native @Cast("bool") boolean resourceLocationExists(@Const @ByRef String name);
        public native void declareResource(@Const @ByRef String name, @Const @ByRef String resourceType,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName,
                    @Cast("const Ogre::NameValuePairList*") @ByRef(nullValue = "Ogre::NameValuePairList()") SStringMapRef loadParameters);
        public native void declareResource(@Const @ByRef String name, @Const @ByRef String resourceType);
        public native void declareResource(@Const @ByRef String name, @Const @ByRef String resourceType,
                    @Const @ByRef String groupName, ManualResourceLoader loader,
                    @Cast("const Ogre::NameValuePairList*") @ByRef(nullValue = "Ogre::NameValuePairList()") SStringMapRef loadParameters);
        public native void declareResource(@Const @ByRef String name, @Const @ByRef String resourceType,
                    @Const @ByRef String groupName, ManualResourceLoader loader);
        public native void undeclareResource(@Const @ByRef String name, @Const @ByRef String groupName);
        public native @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr openResource(@Const @ByRef String resourceName,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName,
                    @Cast("bool") boolean searchGroupsIfNotFound/*=true*/, Resource resourceBeingLoaded/*=0*/);
        public native @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr openResource(@Const @ByRef String resourceName);
        public native @ByVal @Cast("Ogre::DataStreamListPtr*") RealControllerFunctionSPtr openResources(@Const @ByRef String pattern,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName);
        public native @ByVal @Cast("Ogre::DataStreamListPtr*") RealControllerFunctionSPtr openResources(@Const @ByRef String pattern);
        public native @ByVal @Cast("Ogre::StringVectorPtr*") RealControllerFunctionSPtr listResourceNames(@Const @ByRef String groupName, @Cast("bool") boolean dirs/*=false*/);
        public native @ByVal @Cast("Ogre::StringVectorPtr*") RealControllerFunctionSPtr listResourceNames(@Const @ByRef String groupName);







        public native @ByVal FileInfoListPtr listResourceFileInfo(@Const @ByRef String groupName, @Cast("bool") boolean dirs/*=false*/);
        public native @ByVal FileInfoListPtr listResourceFileInfo(@Const @ByRef String groupName);
        public native @ByVal @Cast("Ogre::StringVectorPtr*") RealControllerFunctionSPtr findResourceNames(@Const @ByRef String groupName, @Const @ByRef String pattern,
                    @Cast("bool") boolean dirs/*=false*/);
        public native @ByVal @Cast("Ogre::StringVectorPtr*") RealControllerFunctionSPtr findResourceNames(@Const @ByRef String groupName, @Const @ByRef String pattern);





        public native @Cast("bool") boolean resourceExists(@Const @ByRef String group, @Const @ByRef String filename);




        public native @Cast("bool") boolean resourceExistsInAnyGroup(@Const @ByRef String filename);







        public native @Const @ByRef String findGroupContainingResource(@Const @ByRef String filename);
        public native @ByVal FileInfoListPtr findResourceFileInfo(@Const @ByRef String group, @Const @ByRef String pattern,
                    @Cast("bool") boolean dirs/*=false*/);
        public native @ByVal FileInfoListPtr findResourceFileInfo(@Const @ByRef String group, @Const @ByRef String pattern);


        public native @ByVal @Cast("time_t*") Pointer resourceModifiedTime(@Const @ByRef String group, @Const @ByRef String filename);




        public native @ByVal @Cast("Ogre::StringVectorPtr*") RealControllerFunctionSPtr listResourceLocations(@Const @ByRef String groupName);







        public native @ByVal @Cast("Ogre::StringVectorPtr*") RealControllerFunctionSPtr findResourceLocation(@Const @ByRef String groupName, @Const @ByRef String pattern);
        public native @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr createResource(@Const @ByRef String filename, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName,
                    @Cast("bool") boolean overwrite/*=false*/, @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String locationPattern);
        public native @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr createResource(@Const @ByRef String filename);
        public native void deleteResource(@Const @ByRef String filename, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String locationPattern);
        public native void deleteResource(@Const @ByRef String filename);
        public native void deleteMatchingResources(@Const @ByRef String filePattern, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String locationPattern);
        public native void deleteMatchingResources(@Const @ByRef String filePattern);




        public native void addResourceGroupListener(ResourceGroupListener l);

        public native void removeResourceGroupListener(ResourceGroupListener l);







        public native void setWorldResourceGroupName(@Const @ByRef String groupName);


        public native @Const @ByRef String getWorldResourceGroupName();
        public native void linkWorldGeometryToResourceGroup(@Const @ByRef String group,
                    @Const @ByRef String worldGeometry, SceneManager sceneManager);





        public native void unlinkWorldGeometryFromResourceGroup(@Const @ByRef String group);
        public native @Cast("bool") boolean isResourceGroupInGlobalPool(@Const @ByRef String name);


        public native void shutdownAll();
        public native void _registerResourceManager(@Const @ByRef String resourceType, ResourceManager rm);







        public native void _unregisterResourceManager(@Const @ByRef String resourceType);



        public native @ByVal @Cast("Ogre::ResourceGroupManager::ResourceManagerIterator*") AnimationStateMapIteratorRef getResourceManagerIterator();





        public native void _registerScriptLoader(ScriptLoader su);




        public native void _unregisterScriptLoader(ScriptLoader su);




        public native ScriptLoader _findScriptLoader(@Const @ByRef String pattern);




        public native ResourceManager _getResourceManager(@Const @ByRef String resourceType);




        public native void _notifyResourceCreated(@Cast("Ogre::ResourcePtr*") @ByRef RealControllerFunctionSPtr res);




        public native void _notifyResourceRemoved(@Cast("Ogre::ResourcePtr*") @ByRef RealControllerFunctionSPtr res);



        public native void _notifyResourceGroupChanged(@Const @ByRef String oldGroup, Resource res);





        public native void _notifyAllResourcesRemoved(ResourceManager manager);
        public native void _notifyWorldGeometryStageStarted(@Const @ByRef String description);







        public native void _notifyWorldGeometryStageEnded();






        public native @ByVal @Cast("Ogre::StringVector*") StringVectorRef getResourceGroups();






        public native @ByVal @Cast("Ogre::ResourceGroupManager::ResourceDeclarationList*") ResourceDeclarationListRef getResourceDeclarationList(@Const @ByRef String groupName);





        public native @Cast("const Ogre::ResourceGroupManager::LocationList*") @ByRef ResourceLocationPtrListRef getResourceLocationList(@Const @ByRef String groupName);


        public native void setLoadingListener(ResourceLoadingListener listener);

        public native ResourceLoadingListener getLoadingListener();
        public static native @ByRef ResourceGroupManager getSingleton();
        public static native ResourceGroupManager getSingletonPtr();

    }



    @Namespace("Ogre::v1") @NoOffset public static class BillboardChain extends MovableObject {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public BillboardChain(Pointer p) { super(p); }
        public Renderable asRenderable() { return asRenderable(this); }
        @Namespace public static native @Name("static_cast<Ogre::Renderable*>") Renderable asRenderable(BillboardChain pointer);
    



        @NoOffset public static class Element extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Element(Pointer p) { super(p); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public Element(long size) { super((Pointer)null); allocateArray(size); }
            private native void allocateArray(long size);
            @Override public Element position(long position) {
                return (Element)super.position(position);
            }
        

            public Element() { super((Pointer)null); allocate(); }
            private native void allocate();

            public Element(@Const @ByRef Vector3 position,
                            double width,
                            double texCoord,
                            @Const @ByRef ColourValue colour,
                            @Const @ByRef Quaternion orientation) { super((Pointer)null); allocate(position, width, texCoord, colour, orientation); }
            private native void allocate(@Const @ByRef Vector3 position,
                            double width,
                            double texCoord,
                            @Const @ByRef ColourValue colour,
                            @Const @ByRef Quaternion orientation);

            public native @ByRef @Name("position") Vector3 _position(); public native Element _position(Vector3 _position);
            public native double width(); public native Element width(double width);

            public native double texCoord(); public native Element texCoord(double texCoord);
            public native @ByRef ColourValue colour(); public native Element colour(ColourValue colour);


            public native @ByRef Quaternion orientation(); public native Element orientation(Quaternion orientation);
        }
        public BillboardChain( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager,
                                @Cast("size_t") long maxElements/*=20*/, @Cast("size_t") long numberOfChains/*=1*/,
                                @Cast("bool") boolean useTextureCoords/*=true*/, @Cast("bool") boolean useColours/*=true*/,
                                @Cast("bool") boolean dynamic/*=true*/ ) { super((Pointer)null); allocate(id, objectMemoryManager, manager, maxElements, numberOfChains, useTextureCoords, useColours, dynamic); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager,
                                @Cast("size_t") long maxElements/*=20*/, @Cast("size_t") long numberOfChains/*=1*/,
                                @Cast("bool") boolean useTextureCoords/*=true*/, @Cast("bool") boolean useColours/*=true*/,
                                @Cast("bool") boolean dynamic/*=true*/ );
        public BillboardChain( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager ) { super((Pointer)null); allocate(id, objectMemoryManager, manager); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager );



        public native void setMaxChainElements(@Cast("size_t") long maxElements);


        public native @Cast("size_t") long getMaxChainElements();



        public native void setNumberOfChains(@Cast("size_t") long numChains);



        public native @Cast("size_t") long getNumberOfChains();







        public native void setUseTextureCoords(@Cast("bool") boolean use);



        public native @Cast("bool") boolean getUseTextureCoords();




        /** enum Ogre::v1::BillboardChain::TexCoordDirection */
        public static final int

            TCD_U = 0,

            TCD_V = 1;




        public native void setTextureCoordDirection(@Cast("Ogre::v1::BillboardChain::TexCoordDirection") int dir);



        public native @Cast("Ogre::v1::BillboardChain::TexCoordDirection") int getTextureCoordDirection();






        public native void setOtherTextureCoordRange(double start, double end);



        public native double getOtherTextureCoordRange();







        public native void setUseVertexColours(@Cast("bool") boolean use);



        public native @Cast("bool") boolean getUseVertexColours();




        public native void setDynamic(@Cast("bool") boolean dyn);




        public native @Cast("bool") boolean getDynamic();
        public native void addChainElement(@Cast("size_t") long chainIndex,
                    @Const @ByRef Element billboardChainElement);



        public native void removeChainElement(@Cast("size_t") long chainIndex);






        public native void updateChainElement(@Cast("size_t") long chainIndex, @Cast("size_t") long elementIndex,
                    @Const @ByRef Element billboardChainElement);





        public native @Const @ByRef Element getChainElement(@Cast("size_t") long chainIndex, @Cast("size_t") long elementIndex);


        public native @Cast("size_t") long getNumChainElements(@Cast("size_t") long chainIndex);


        public native void clearChain(@Cast("size_t") long chainIndex);

        public native void clearAllChains();
        public native void setFaceCamera( @Cast("bool") boolean faceCamera, @Const @ByRef(nullValue = "Ogre::Vector3::UNIT_X") Vector3 normalVector );
        public native void setFaceCamera( @Cast("bool") boolean faceCamera );



        public native double getSquaredViewDepth(@Const Camera cam);
        public native @Const @ByRef AxisAlignedBox getBoundingBox();
        public native @Const @ByRef String getMovableType();
        public native void _updateRenderQueue(RenderQueue arg0, Camera camera, @Const Camera lodCamera);
        public native void getRenderOperation(@ByRef RenderOperation arg0, @Cast("bool") boolean casterPass);
        public native @Cast("bool") boolean preRender(SceneManager sm, RenderSystem rsys);
        public native void getWorldTransforms(Matrix4 arg0);
        public native @Cast("const Ogre::LightList*") @ByRef HashedVector getLights();
    }



    @Namespace("Ogre::v1") @NoOffset public static class BillboardChainFactory extends MovableObjectFactory {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public BillboardChainFactory(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public BillboardChainFactory(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public BillboardChainFactory position(long position) {
            return (BillboardChainFactory)super.position(position);
        }
    
        public BillboardChainFactory() { super((Pointer)null); allocate(); }
        private native void allocate();

        public static native @ByRef String FACTORY_TYPE_NAME(); public static native void FACTORY_TYPE_NAME(String FACTORY_TYPE_NAME);

        public native @Const @ByRef String getType();
        public native void destroyInstance( MovableObject obj);

    }











    @Namespace("Ogre") @NoOffset public static class QueuedRenderable extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public QueuedRenderable(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public QueuedRenderable(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public QueuedRenderable position(long position) {
            return (QueuedRenderable)super.position(position);
        }
    
        public native @Cast("Ogre::uint64") long hash(); public native QueuedRenderable hash(long hash);
        public native Renderable renderable(); public native QueuedRenderable renderable(Renderable renderable);
        public native @Const({false, true}) MovableObject movableObject(); public native QueuedRenderable movableObject(MovableObject movableObject);

        public QueuedRenderable() { super((Pointer)null); allocate(); }
        private native void allocate();
        public QueuedRenderable( @Cast("Ogre::uint64") long _hash, Renderable _renderable,
                                  @Const MovableObject _movableObject ) { super((Pointer)null); allocate(_hash, _renderable, _movableObject); }
        private native void allocate( @Cast("Ogre::uint64") long _hash, Renderable _renderable,
                                  @Const MovableObject _movableObject );

        public native @Cast("bool") @Name("operator <") boolean lessThan( @Const @ByRef QueuedRenderable _r );
    }
    @Namespace("Ogre") @NoOffset public static class RenderQueue extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderQueue(Pointer p) { super(p); }
    
        /** enum Ogre::RenderQueue::Modes */
        public static final int




            V1_LEGACY = 0,
            V1_FAST = 1,






            FAST = 2;
        public RenderQueue( HlmsManager hlmsManager, SceneManager sceneManager, VaoManager vaoManager ) { super((Pointer)null); allocate(hlmsManager, sceneManager, vaoManager); }
        private native void allocate( HlmsManager hlmsManager, SceneManager sceneManager, VaoManager vaoManager );


        public native void clear();







        public native void clearState();


        public native void addRenderableV1( @Cast("Ogre::uint8") byte renderQueueId, @Cast("bool") boolean casterPass, Renderable pRend,
                                      @Const MovableObject pMovableObject );
        public native void addRenderableV2( @Cast("size_t") long threadIdx, @Cast("Ogre::uint8") byte renderQueueId, @Cast("bool") boolean casterPass,
                                      Renderable pRend, @Const MovableObject pMovableObject );

        public native void render( RenderSystem rs, @Cast("Ogre::uint8") byte firstRq, @Cast("Ogre::uint8") byte lastRq,
                             @Cast("bool") boolean casterPass, @Cast("bool") boolean dualParaboloid );


        public native void renderSingleObject( Renderable pRend, @Const MovableObject pMovableObject,
                                         RenderSystem rs, @Cast("bool") boolean casterPass, @Cast("bool") boolean dualParaboloid );


        public native void frameEnded();







        public native void setRenderQueueMode( @Cast("Ogre::uint8") byte rqId, @Cast("Ogre::RenderQueue::Modes") int newMode );
        public native @Cast("Ogre::RenderQueue::Modes") int getRenderQueueMode( @Cast("Ogre::uint8") byte rqId );
        public native void setSortRenderQueue( @Cast("Ogre::uint8") byte rqId, @Cast("bool") boolean bSort );
        public native @Cast("bool") boolean getSortRenderQueue( @Cast("Ogre::uint8") byte rqId );
    }



    @Namespace("Ogre") public static class RqBits extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public RqBits() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public RqBits(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RqBits(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public RqBits position(long position) {
            return (RqBits)super.position(position);
        }
    
        @MemberGetter public static native int SubRqIdBits();
        public static final int SubRqIdBits = SubRqIdBits();
        @MemberGetter public static native int TransparencyBits();
        public static final int TransparencyBits = TransparencyBits();
        @MemberGetter public static native int MacroblockBits();
        public static final int MacroblockBits = MacroblockBits();
        @MemberGetter public static native int ShaderBits();
        public static final int ShaderBits = ShaderBits();
        @MemberGetter public static native int MeshBits();
        public static final int MeshBits = MeshBits();
        @MemberGetter public static native int TextureBits();
        public static final int TextureBits = TextureBits();
        @MemberGetter public static native int DepthBits();
        public static final int DepthBits = DepthBits();

        @MemberGetter public static native int SubRqIdShift();
        public static final int SubRqIdShift = SubRqIdShift();
        @MemberGetter public static native int TransparencyShift();
        public static final int TransparencyShift = TransparencyShift();
        @MemberGetter public static native int MacroblockShift();
        public static final int MacroblockShift = MacroblockShift();
        @MemberGetter public static native int ShaderShift();
        public static final int ShaderShift = ShaderShift();
        @MemberGetter public static native int MeshShift();
        public static final int MeshShift = MeshShift();
        @MemberGetter public static native int TextureShift();
        public static final int TextureShift = TextureShift();
        @MemberGetter public static native int DepthShift();
        public static final int DepthShift = DepthShift();

        @MemberGetter public static native int DepthShiftTransp();
        public static final int DepthShiftTransp = DepthShiftTransp();
        @MemberGetter public static native int MacroblockShiftTransp();
        public static final int MacroblockShiftTransp = MacroblockShiftTransp();
        @MemberGetter public static native int ShaderShiftTransp();
        public static final int ShaderShiftTransp = ShaderShiftTransp();
        @MemberGetter public static native int MeshShiftTransp();
        public static final int MeshShiftTransp = MeshShiftTransp();
        @MemberGetter public static native int TextureShiftTransp();
        public static final int TextureShiftTransp = TextureShiftTransp();
    }





    /** enum Ogre::v1::BillboardOrigin */
    public static final int
        BBO_TOP_LEFT = 0,
        BBO_TOP_CENTER = 1,
        BBO_TOP_RIGHT = 2,
        BBO_CENTER_LEFT = 3,
        BBO_CENTER = 4,
        BBO_CENTER_RIGHT = 5,
        BBO_BOTTOM_LEFT = 6,
        BBO_BOTTOM_CENTER = 7,
        BBO_BOTTOM_RIGHT = 8;

    /** enum Ogre::v1::BillboardRotationType */
    public static final int

        BBR_VERTEX = 0,

        BBR_TEXCOORD = 1;

    /** enum Ogre::v1::BillboardType */
    public static final int

        BBT_POINT = 0,

        BBT_ORIENTED_COMMON = 1,

        BBT_ORIENTED_SELF = 2,

        BBT_PERPENDICULAR_COMMON = 3,

        BBT_PERPENDICULAR_SELF = 4;
    @Namespace("Ogre::v1") @NoOffset public static class BillboardSet extends MovableObject {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public BillboardSet(Pointer p) { super(p); }
        public Renderable asRenderable() { return asRenderable(this); }
        @Namespace public static native @Name("static_cast<Ogre::Renderable*>") Renderable asRenderable(BillboardSet pointer);
    
        public BillboardSet( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager,
                              @Cast("unsigned int") int poolSize/*=20*/, @Cast("bool") boolean externalDataSource/*=false*/,
                              @Cast("Ogre::uint8") byte renderQueueId/*=0*/ ) { super((Pointer)null); allocate(id, objectMemoryManager, manager, poolSize, externalDataSource, renderQueueId); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager,
                              @Cast("unsigned int") int poolSize/*=20*/, @Cast("bool") boolean externalDataSource/*=false*/,
                              @Cast("Ogre::uint8") byte renderQueueId/*=0*/ );
        public BillboardSet( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager ) { super((Pointer)null); allocate(id, objectMemoryManager, manager); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager );
        public native Billboard createBillboard(
                    @Const @ByRef Vector3 position,
                    @Const @ByRef(nullValue = "Ogre::ColourValue::White") ColourValue colour );
        public native Billboard createBillboard(
                    @Const @ByRef Vector3 position );
        public native Billboard createBillboard(
                    double x, double y, double z,
                    @Const @ByRef(nullValue = "Ogre::ColourValue::White") ColourValue colour );
        public native Billboard createBillboard(
                    double x, double y, double z );



        public native int getNumBillboards();
        public native void setAutoextend(@Cast("bool") boolean autoextend);





        public native @Cast("bool") boolean getAutoextend();




        public native void setSortingEnabled(@Cast("bool") boolean sortenable);





        public native @Cast("bool") boolean getSortingEnabled();
        public native void setPoolSize(@Cast("size_t") long size);







        public native @Cast("unsigned int") int getPoolSize();




        public native void clear();
        public native Billboard getBillboard(@Cast("unsigned int") int index);





        public native void removeBillboard(@Cast("unsigned int") int index);





        public native void removeBillboard(Billboard pBill);
        public native void setBillboardOrigin(@Cast("Ogre::v1::BillboardOrigin") int origin);





        public native @Cast("Ogre::v1::BillboardOrigin") int getBillboardOrigin();
        public native void setBillboardRotationType(@Cast("Ogre::v1::BillboardRotationType") int rotationType);





        public native @Cast("Ogre::v1::BillboardRotationType") int getBillboardRotationType();
        public native void setDefaultDimensions(double width, double height);


        public native void setDefaultWidth(double width);

        public native double getDefaultWidth();

        public native void setDefaultHeight(double height);

        public native double getDefaultHeight();


        public native @Cast("bool") boolean getUseIdentityWorldMatrix();





        public native void _notifyCurrentCamera( @Const Camera cam );






        public native void beginBillboards(@Cast("size_t") long numBillboards/*=0*/);
        public native void beginBillboards();

        public native void injectBillboard(@Const @ByRef Billboard bb, @Const Camera camera);

        public native void endBillboards();





        public native void setBounds(@Const @ByRef Aabb aabb, double radius);





        public native void _updateRenderQueue(RenderQueue queue, Camera camera, @Const Camera lodCamera);


        public native void _updateRenderQueueImpl(RenderQueue queue, Camera camera, @Const Camera lodCamera);





        public native void getRenderOperation(@ByRef RenderOperation op, @Cast("bool") boolean casterPass);





        public native void getWorldTransforms(Matrix4 xform);



        public native void _notifyBillboardResized();



        public native void _notifyBillboardRotated();


        public native @Cast("bool") boolean getCullIndividually();
        public native void setCullIndividually(@Cast("bool") boolean cullIndividual);
        public native void setBillboardType(@Cast("Ogre::v1::BillboardType") int bbt);


        public native @Cast("Ogre::v1::BillboardType") int getBillboardType();
        public native void setCommonDirection(@Const @ByRef Vector3 vec);


        public native @Const @ByRef Vector3 getCommonDirection();
        public native void setCommonUpVector(@Const @ByRef Vector3 vec);


        public native @Const @ByRef Vector3 getCommonUpVector();
        public native void setUseAccurateFacing(@Cast("bool") boolean acc);




        public native @Cast("bool") boolean getUseAccurateFacing();


        public native @Const @ByRef String getMovableType();


        public native double getSquaredViewDepth(@Const Camera cam);


        public native void _updateBounds();

        public native @Cast("const Ogre::LightList*") @ByRef HashedVector getLights();


        public native void _sortBillboards();


        public native @Cast("Ogre::SortMode") int _getSortMode();






        public native void setBillboardsInWorldSpace(@Cast("bool") boolean ws);



        public native @Cast("bool") boolean getBillboardsInWorldSpace();
        public native void setTextureCoords( @Cast("Ogre::Ogre::FloatRect const*") FloatRectRef coords, @Cast("Ogre::uint16") short numCoords );
        public native void setTextureStacksAndSlices( @Cast("Ogre::uchar") byte stacks, @Cast("Ogre::uchar") byte slices );







        public native @Cast("Ogre::Ogre::FloatRect const*") FloatRectRef getTextureCoords( @Cast("Ogre::uint16*") ShortPointer oNumCoords );
        public native @Cast("Ogre::Ogre::FloatRect const*") FloatRectRef getTextureCoords( @Cast("Ogre::uint16*") ShortBuffer oNumCoords );
        public native @Cast("Ogre::Ogre::FloatRect const*") FloatRectRef getTextureCoords( @Cast("Ogre::uint16*") short[] oNumCoords );
        public native void setPointRenderingEnabled(@Cast("bool") boolean enabled);


        public native @Cast("bool") boolean isPointRenderingEnabled();
        public native void setAutoUpdate(@Cast("bool") boolean autoUpdate);


        public native @Cast("bool") boolean getAutoUpdate();





        public native void notifyBillboardDataChanged();

        public native void setMaterial( @Cast("const Ogre::MaterialPtr*") @ByRef RealControllerFunctionSPtr material );
        public native void setDatablock( HlmsDatablock datablock );

    }


    @Namespace("Ogre::v1") @NoOffset public static class BillboardSetFactory extends MovableObjectFactory {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public BillboardSetFactory(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public BillboardSetFactory(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public BillboardSetFactory position(long position) {
            return (BillboardSetFactory)super.position(position);
        }
    
        public BillboardSetFactory() { super((Pointer)null); allocate(); }
        private native void allocate();

        public static native @ByRef String FACTORY_TYPE_NAME(); public static native void FACTORY_TYPE_NAME(String FACTORY_TYPE_NAME);

        public native @Const @ByRef String getType();
        public native void destroyInstance( MovableObject obj);

    }




    @Namespace("Ogre::v1") @NoOffset public static class OldNode extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public OldNode(Pointer p) { super(p); }
    


        /** enum Ogre::v1::OldNode::TransformSpace */
        public static final int

            TS_LOCAL = 0,

            TS_PARENT = 1,

            TS_WORLD = 2;



        public static class Listener extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Listener(Pointer p) { super(p); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public Listener(long size) { super((Pointer)null); allocateArray(size); }
            private native void allocateArray(long size);
            @Override public Listener position(long position) {
                return (Listener)super.position(position);
            }
        
            public Listener() { super((Pointer)null); allocate(); }
            private native void allocate();







            public native void OldNodeUpdated(@Const OldNode arg0);

            public native void OldNodeDestroyed(@Const OldNode arg0);

            public native void OldNodeAttached(@Const OldNode arg0);

            public native void OldNodeDetached(@Const OldNode arg0);
        }


        public native @Const @ByRef String getName();



        public native OldNode getParent();



        public native @Const @ByRef Quaternion getOrientation();
        public native void setOrientation( @Const @ByRef Quaternion q );
        public native void setOrientation( double w, double x, double y, double z);
        public native void resetOrientation();



        public native void setPosition(@Const @ByRef Vector3 pos);



        public native void setPosition(double x, double y, double z);



        public native @Const @ByRef Vector3 getPosition();
        public native void setScale(@Const @ByRef Vector3 scale);
        public native void setScale(double x, double y, double z);



        public native @Const @ByRef Vector3 getScale();
        public native void setInheritOrientation(@Cast("bool") boolean inherit);
        public native @Cast("bool") boolean getInheritOrientation();
        public native void setInheritScale(@Cast("bool") boolean inherit);





        public native @Cast("bool") boolean getInheritScale();
        public native void scale(@Const @ByRef Vector3 scale);
        public native void scale(double x, double y, double z);
        public native void translate(@Const @ByRef Vector3 d, @Cast("Ogre::v1::OldNode::TransformSpace") int relativeTo/*=Ogre::v1::OldNode::TS_PARENT*/);
        public native void translate(@Const @ByRef Vector3 d);
        public native void translate(double x, double y, double z, @Cast("Ogre::v1::OldNode::TransformSpace") int relativeTo/*=Ogre::v1::OldNode::TS_PARENT*/);
        public native void translate(double x, double y, double z);
        public native void translate(@Const @ByRef Matrix3 axes, @Const @ByRef Vector3 move, @Cast("Ogre::v1::OldNode::TransformSpace") int relativeTo/*=Ogre::v1::OldNode::TS_PARENT*/);
        public native void translate(@Const @ByRef Matrix3 axes, @Const @ByRef Vector3 move);
        public native void translate(@Const @ByRef Matrix3 axes, double x, double y, double z, @Cast("Ogre::v1::OldNode::TransformSpace") int relativeTo/*=Ogre::v1::OldNode::TS_PARENT*/);
        public native void translate(@Const @ByRef Matrix3 axes, double x, double y, double z);



        public native void roll(@Const @ByRef Radian angle, @Cast("Ogre::v1::OldNode::TransformSpace") int relativeTo/*=Ogre::v1::OldNode::TS_LOCAL*/);
        public native void roll(@Const @ByRef Radian angle);



        public native void pitch(@Const @ByRef Radian angle, @Cast("Ogre::v1::OldNode::TransformSpace") int relativeTo/*=Ogre::v1::OldNode::TS_LOCAL*/);
        public native void pitch(@Const @ByRef Radian angle);



        public native void yaw(@Const @ByRef Radian angle, @Cast("Ogre::v1::OldNode::TransformSpace") int relativeTo/*=Ogre::v1::OldNode::TS_LOCAL*/);
        public native void yaw(@Const @ByRef Radian angle);



        public native void rotate(@Const @ByRef Vector3 axis, @Const @ByRef Radian angle, @Cast("Ogre::v1::OldNode::TransformSpace") int relativeTo/*=Ogre::v1::OldNode::TS_LOCAL*/);
        public native void rotate(@Const @ByRef Vector3 axis, @Const @ByRef Radian angle);



        public native void rotate(@Const @ByRef Quaternion q, @Cast("Ogre::v1::OldNode::TransformSpace") int relativeTo/*=Ogre::v1::OldNode::TS_LOCAL*/);
        public native void rotate(@Const @ByRef Quaternion q);



        public native @ByVal Matrix3 getLocalAxes();







        public native OldNode createChild(
                    @Const @ByRef(nullValue = "Ogre::Vector3::ZERO") Vector3 translate,
                    @Const @ByRef(nullValue = "Ogre::Quaternion::IDENTITY") Quaternion rotate );
        public native OldNode createChild( );
        public native OldNode createChild(@Const @ByRef String name, @Const @ByRef(nullValue = "Ogre::Vector3::ZERO") Vector3 translate, @Const @ByRef(nullValue = "Ogre::Quaternion::IDENTITY") Quaternion rotate);
        public native OldNode createChild(@Const @ByRef String name);





        public native void addChild(OldNode child);



        public native @Cast("unsigned short") short numChildren();





        public native OldNode getChild(@Cast("unsigned short") short index);



        public native OldNode getChild(@Const @ByRef String name);
        public native @ByVal @Cast("Ogre::v1::OldNode::ChildOldNodeIterator*") AnimationStateMapIteratorRef getChildIterator();
        public native OldNode removeChild(@Cast("unsigned short") short index);







        public native OldNode removeChild(OldNode child);






        public native OldNode removeChild(@Const @ByRef String name);



        public native void removeAllChildren();





        public native void _setDerivedPosition(@Const @ByRef Vector3 pos);






        public native void _setDerivedOrientation(@Const @ByRef Quaternion q);



        public native @Const @ByRef Quaternion _getDerivedOrientation();



        public native @Const @ByRef Vector3 _getDerivedPosition();



        public native @Const @ByRef Vector3 _getDerivedScale();
        public native @Const @ByRef Matrix4 _getFullTransform();
        public native void _update(@Cast("bool") boolean updateChildren, @Cast("bool") boolean parentHasChanged);






        public native void setListener(Listener listener);



        public native Listener getListener();
        public native void setInitialState();


        public native void resetToInitialState();





        public native @Const @ByRef Vector3 getInitialPosition();


        public native @ByVal Vector3 convertWorldToLocalPosition( @Const @ByRef Vector3 worldPos );



        public native @ByVal Vector3 convertLocalToWorldPosition( @Const @ByRef Vector3 localPos );


        public native @ByVal Quaternion convertWorldToLocalOrientation( @Const @ByRef Quaternion worldOrientation );



        public native @ByVal Quaternion convertLocalToWorldOrientation( @Const @ByRef Quaternion localOrientation );


        public native @Const @ByRef Quaternion getInitialOrientation();


        public native @Const @ByRef Vector3 getInitialScale();


        public native double getSquaredViewDepth(@Const Camera cam);
        public native void needUpdate(@Cast("bool") boolean forceParentUpdate/*=false*/);
        public native void needUpdate();




        public native void requestUpdate(OldNode child, @Cast("bool") boolean forceParentUpdate/*=false*/);
        public native void requestUpdate(OldNode child);

        public native void cancelUpdate(OldNode child);
        public static native void queueNeedUpdate(OldNode n);

        public static native void processQueuedUpdates();
        public native void setUserAny(@Const @ByRef Any anything);




        public native @Const @ByRef Any getUserAny();





        public native @ByRef UserObjectBindings getUserObjectBindings();

    }





    @Namespace("Ogre::v1") @NoOffset public static class OldBone extends OldNode {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public OldBone(Pointer p) { super(p); }
    

        public OldBone(@Cast("unsigned short") short handle, Skeleton creator) { super((Pointer)null); allocate(handle, creator); }
        private native void allocate(@Cast("unsigned short") short handle, Skeleton creator);

        public OldBone(@Const @ByRef String name, @Cast("unsigned short") short handle, Skeleton creator) { super((Pointer)null); allocate(name, handle, creator); }
        private native void allocate(@Const @ByRef String name, @Cast("unsigned short") short handle, Skeleton creator);
        public native OldBone createChild(@Cast("unsigned short") short handle,
                    @Const @ByRef(nullValue = "Ogre::Vector3::ZERO") Vector3 translate, @Const @ByRef(nullValue = "Ogre::Quaternion::IDENTITY") Quaternion rotate);
        public native OldBone createChild(@Cast("unsigned short") short handle);



        public native @Cast("unsigned short") short getHandle();




        public native void setBindingPose();







        public native void reset();
        public native void setManuallyControlled(@Cast("bool") boolean manuallyControlled);


        public native @Cast("bool") boolean isManuallyControlled();






        public native void _getOffsetTransform(@ByRef Matrix4 m);


        public native @Const @ByRef Vector3 _getBindingPoseInverseScale();

        public native @Const @ByRef Vector3 _getBindingPoseInversePosition();

        public native @Const @ByRef Quaternion _getBindingPoseInverseOrientation();


        public native void needUpdate(@Cast("bool") boolean forceParentUpdate/*=false*/);
        public native void needUpdate();
    }






    @Namespace("Ogre::v1") @NoOffset public static class HardwareIndexBuffer extends HardwareBuffer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareIndexBuffer(Pointer p) { super(p); }
    
            /** enum Ogre::v1::HardwareIndexBuffer::IndexType */
            public static final int
                IT_16BIT = 0,
                IT_32BIT = 1;

            public HardwareIndexBuffer(HardwareBufferManagerBase mgr, @Cast("Ogre::v1::HardwareIndexBuffer::IndexType") int idxType, @Cast("size_t") long numIndexes, @Cast("Ogre::v1::HardwareBuffer::Usage") int usage,
                            @Cast("bool") boolean useSystemMemory, @Cast("bool") boolean useShadowBuffer) { super((Pointer)null); allocate(mgr, idxType, numIndexes, usage, useSystemMemory, useShadowBuffer); }
            private native void allocate(HardwareBufferManagerBase mgr, @Cast("Ogre::v1::HardwareIndexBuffer::IndexType") int idxType, @Cast("size_t") long numIndexes, @Cast("Ogre::v1::HardwareBuffer::Usage") int usage,
                            @Cast("bool") boolean useSystemMemory, @Cast("bool") boolean useShadowBuffer);

            public native HardwareBufferManagerBase getManager();

            public native @Cast("Ogre::v1::HardwareIndexBuffer::IndexType") int getType();

            public native @Cast("size_t") long getNumIndexes();

            public native @Cast("size_t") long getIndexSize();


    }



    @Namespace("Ogre::v1") public static class HardwareIndexBufferSharedPtr extends HardwareIndexBufferSPtr {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareIndexBufferSharedPtr(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public HardwareIndexBufferSharedPtr(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public HardwareIndexBufferSharedPtr position(long position) {
            return (HardwareIndexBufferSharedPtr)super.position(position);
        }
    
        public HardwareIndexBufferSharedPtr() { super((Pointer)null); allocate(); }
        private native void allocate();
        public HardwareIndexBufferSharedPtr(HardwareIndexBuffer buf) { super((Pointer)null); allocate(buf); }
        private native void allocate(HardwareIndexBuffer buf);
    }








    @Namespace("Ogre::v1") @NoOffset public static class VertexData extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public VertexData(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public VertexData(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public VertexData position(long position) {
            return (VertexData)super.position(position);
        }
    






        public VertexData(HardwareBufferManagerBase mgr/*=0*/) { super((Pointer)null); allocate(mgr); }
        private native void allocate(HardwareBufferManagerBase mgr/*=0*/);
        public VertexData() { super((Pointer)null); allocate(); }
        private native void allocate();
        public VertexData(VertexDeclaration dcl, VertexBufferBinding bind) { super((Pointer)null); allocate(dcl, bind); }
        private native void allocate(VertexDeclaration dcl, VertexBufferBinding bind);




        public native VertexDeclaration vertexDeclaration(); public native VertexData vertexDeclaration(VertexDeclaration vertexDeclaration);



        public native VertexBufferBinding vertexBufferBinding(); public native VertexData vertexBufferBinding(VertexBufferBinding vertexBufferBinding);

        public native @Cast("bool") boolean mDeleteDclBinding(); public native VertexData mDeleteDclBinding(boolean mDeleteDclBinding);

        public native @Cast("size_t") long vertexStart(); public native VertexData vertexStart(long vertexStart);

        public native @Cast("size_t") long vertexCount(); public native VertexData vertexCount(long vertexCount);



        public static class HardwareAnimationData extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public HardwareAnimationData() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public HardwareAnimationData(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public HardwareAnimationData(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public HardwareAnimationData position(long position) {
                return (HardwareAnimationData)super.position(position);
            }
        
            public native @Cast("unsigned short") short targetBufferIndex(); public native HardwareAnimationData targetBufferIndex(short targetBufferIndex);
            public native double parametric(); public native HardwareAnimationData parametric(double parametric);
        }

        public native @ByRef @Cast("Ogre::v1::VertexData::HardwareAnimationDataList*") HardwareAnimationDataVectorRef hwAnimationDataList(); public native VertexData hwAnimationDataList(HardwareAnimationDataVectorRef hwAnimationDataList);

        public native @Cast("size_t") long hwAnimDataItemsUsed(); public native VertexData hwAnimDataItemsUsed(long hwAnimDataItemsUsed);






        public native VertexData clone(@Cast("bool") boolean copyData/*=true*/, HardwareBufferManagerBase mgr/*=0*/);
        public native VertexData clone();
        public native void prepareForShadowVolume();
        public native @ByRef HardwareVertexBufferSharedPtr hardwareShadowVolWBuffer(); public native VertexData hardwareShadowVolWBuffer(HardwareVertexBufferSharedPtr hardwareShadowVolWBuffer);
        public native void reorganiseBuffers(VertexDeclaration newDeclaration, @Cast("const Ogre::v1::BufferUsageList*") @ByRef HardwareBufferUsageVectorRef bufferUsage,
                    HardwareBufferManagerBase mgr/*=0*/);
        public native void reorganiseBuffers(VertexDeclaration newDeclaration, @Cast("const Ogre::v1::BufferUsageList*") @ByRef HardwareBufferUsageVectorRef bufferUsage);
        public native void reorganiseBuffers(VertexDeclaration newDeclaration, HardwareBufferManagerBase mgr/*=0*/);
        public native void reorganiseBuffers(VertexDeclaration newDeclaration);
        public native void closeGapsInBindings();
        public native void removeUnusedBuffers();
        public native void convertPackedColour(@Cast("Ogre::VertexElementType") int srcType, @Cast("Ogre::VertexElementType") int destType);
        public native short allocateHardwareAnimationElements(short count, @Cast("bool") boolean animateNormals);


        public native HardwareBufferManagerBase _getHardwareBufferManager();

    }


    @Namespace("Ogre::v1") @NoOffset public static class IndexData extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public IndexData(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public IndexData(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public IndexData position(long position) {
            return (IndexData)super.position(position);
        }
    
        public IndexData() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native @ByRef HardwareIndexBufferSharedPtr indexBuffer(); public native IndexData indexBuffer(HardwareIndexBufferSharedPtr indexBuffer);


        public native @Cast("size_t") long indexStart(); public native IndexData indexStart(long indexStart);


        public native @Cast("size_t") long indexCount(); public native IndexData indexCount(long indexCount);






        public native IndexData clone(@Cast("bool") boolean copyData/*=true*/, HardwareBufferManagerBase mgr/*=0*/);
        public native IndexData clone();
        public native void optimiseVertexCacheTriList();

    }






    @Namespace("Ogre::v1") @NoOffset public static class VertexCacheProfiler extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public VertexCacheProfiler(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public VertexCacheProfiler(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public VertexCacheProfiler position(long position) {
            return (VertexCacheProfiler)super.position(position);
        }
    
            public VertexCacheProfiler(@Cast("unsigned int") int cachesize/*=16*/) { super((Pointer)null); allocate(cachesize); }
            private native void allocate(@Cast("unsigned int") int cachesize/*=16*/);
            public VertexCacheProfiler() { super((Pointer)null); allocate(); }
            private native void allocate();

            public native void profile(@Const @ByRef HardwareIndexBufferSharedPtr indexBuffer);
            public native void reset();
            public native void flush();

            public native @Cast("unsigned int") int getHits();
            public native @Cast("unsigned int") int getMisses();
            public native @Cast("unsigned int") int getSize();
    }




    /** enum Ogre::OrientationMode */
    public static final int
        OR_DEGREE_0 = 0,
        OR_DEGREE_90 = 1,
        OR_DEGREE_180 = 2,
        OR_DEGREE_270 = 3,

        OR_PORTRAIT =  OR_DEGREE_0,
        OR_LANDSCAPERIGHT =  OR_DEGREE_90,
        OR_LANDSCAPELEFT =  OR_DEGREE_270;



    /** enum Ogre::ProjectionType */
    public static final int
        PT_ORTHOGRAPHIC = 0,
        PT_PERSPECTIVE = 1;



    /** enum Ogre::FrustumPlane */
    public static final int
        FRUSTUM_PLANE_NEAR = 0,
        FRUSTUM_PLANE_FAR = 1,
        FRUSTUM_PLANE_LEFT = 2,
        FRUSTUM_PLANE_RIGHT = 3,
        FRUSTUM_PLANE_TOP = 4,
        FRUSTUM_PLANE_BOTTOM = 5;





    @Namespace("Ogre") @NoOffset public static class Frustum extends MovableObject {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Frustum(Pointer p) { super(p); }
        public Renderable asRenderable() { return asRenderable(this); }
        @Namespace public static native @Name("static_cast<Ogre::Renderable*>") Renderable asRenderable(Frustum pointer);
    


        public Frustum( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager ) { super((Pointer)null); allocate(id, objectMemoryManager); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager );
        public native void setFOVy(@Const @ByRef Radian fovy);



        public native @Const @ByRef Radian getFOVy();
        public native void setNearClipDistance(double nearDist);



        public native double getNearClipDistance();
        public native void setFarClipDistance(double farDist);



        public native double getFarClipDistance();
        public native void setAspectRatio(double ratio);



        public native double getAspectRatio();
        public native void setFrustumOffset(@Const @ByRef Vector2 offset);
        public native void setFrustumOffset(double horizontal/*=0.0*/, double vertical/*=0.0*/);
        public native void setFrustumOffset();



        public native @Const @ByRef Vector2 getFrustumOffset();





        public native void setFocalLength(double focalLength/*=1.0*/);
        public native void setFocalLength();



        public native double getFocalLength();





        public native void setFrustumExtents(double left, double right, double top, double bottom);

        public native void resetFrustumExtents();

        public native void getFrustumExtents(double outleft, double outright, double outtop, double outbottom);
        public native @Const @ByRef Matrix4 getProjectionMatrixRS();
        public native @Const @ByRef Matrix4 getProjectionMatrixWithRSDepth();
        public native @Const @ByRef Matrix4 getProjectionMatrix();



        public native @Const @ByRef Matrix4 getViewMatrix();





        public native void calcViewMatrixRelative(@Const @ByRef Vector3 relPos, @ByRef Matrix4 matToUpdate);
        public native void setCustomViewMatrix(@Cast("bool") boolean enable,
                    @Const @ByRef(nullValue = "Ogre::Matrix4::IDENTITY") Matrix4 viewMatrix);
        public native void setCustomViewMatrix(@Cast("bool") boolean enable);

        public native @Cast("bool") boolean isCustomViewMatrixEnabled();
        public native void setCustomProjectionMatrix(@Cast("bool") boolean enable,
                    @Const @ByRef(nullValue = "Ogre::Matrix4::IDENTITY") Matrix4 projectionMatrix);
        public native void setCustomProjectionMatrix(@Cast("bool") boolean enable);

        public native @Cast("bool") boolean isCustomProjectionMatrixEnabled();





        public native @Const Plane getFrustumPlanes();


        public native @Const Plane _getCachedFrustumPlanes();





        public native @Const @ByRef Plane getFrustumPlane( @Cast("unsigned short") short plane );
        public native @Cast("bool") boolean isVisible(@Const @ByRef AxisAlignedBox bound, @Cast("Ogre::FrustumPlane*") IntPointer culledBy/*=0*/);
        public native @Cast("bool") boolean isVisible(@Const @ByRef AxisAlignedBox bound);
        public native @Cast("bool") boolean isVisible(@Const @ByRef AxisAlignedBox bound, @Cast("Ogre::FrustumPlane*") IntBuffer culledBy/*=0*/);
        public native @Cast("bool") boolean isVisible(@Const @ByRef AxisAlignedBox bound, @Cast("Ogre::FrustumPlane*") int[] culledBy/*=0*/);
        public native @Cast("bool") boolean isVisible(@Const @ByRef Sphere bound, @Cast("Ogre::FrustumPlane*") IntPointer culledBy/*=0*/);
        public native @Cast("bool") boolean isVisible(@Const @ByRef Sphere bound);
        public native @Cast("bool") boolean isVisible(@Const @ByRef Sphere bound, @Cast("Ogre::FrustumPlane*") IntBuffer culledBy/*=0*/);
        public native @Cast("bool") boolean isVisible(@Const @ByRef Sphere bound, @Cast("Ogre::FrustumPlane*") int[] culledBy/*=0*/);
        public native @Cast("bool") boolean isVisible(@Const @ByRef Vector3 vert, @Cast("Ogre::FrustumPlane*") IntPointer culledBy/*=0*/);
        public native @Cast("bool") boolean isVisible(@Const @ByRef Vector3 vert);
        public native @Cast("bool") boolean isVisible(@Const @ByRef Vector3 vert, @Cast("Ogre::FrustumPlane*") IntBuffer culledBy/*=0*/);
        public native @Cast("bool") boolean isVisible(@Const @ByRef Vector3 vert, @Cast("Ogre::FrustumPlane*") int[] culledBy/*=0*/);


        public native @Const @ByRef AxisAlignedBox getBoundingBox();


        public native @Const @ByRef String getMovableType();


        public native void getRenderOperation(@ByRef RenderOperation op, @Cast("bool") boolean casterPass);


        public native void getWorldTransforms(Matrix4 xform);


        public native double getSquaredViewDepth(@Const Camera cam);


        public native @Cast("const Ogre::LightList*") @ByRef HashedVector getLights();

        public native void getCustomWorldSpaceCorners(
                            ArrayVector3 outCorners,
                            double customFarPlane );







        public native @Const Vector3 getWorldSpaceCorners();



        public native void setProjectionType(@Cast("Ogre::ProjectionType") int pt);



        public native @Cast("Ogre::ProjectionType") int getProjectionType();
        public native void setOrthoWindow(double w, double h);





        public native void setOrthoWindowHeight(double h);





        public native void setOrthoWindowWidth(double w);


        public native double getOrthoWindowHeight();



        public native double getOrthoWindowWidth();






        public native void enableReflection(@Const @ByRef Plane p);
        public native void enableReflection(@Const MovablePlane p);


        public native void disableReflection();


        public native @Cast("bool") boolean isReflected();

        public native @Const @ByRef Matrix4 getReflectionMatrix();

        public native @Const @ByRef Plane getReflectionPlane();
        public native @Cast("bool") boolean projectSphere(@Const @ByRef Sphere sphere,
                    double left, double top, double right, double bottom);
        public native void enableCustomNearClipPlane(@Const MovablePlane plane);
        public native void enableCustomNearClipPlane(@Const @ByRef Plane plane);

        public native void disableCustomNearClipPlane();

        public native @Cast("bool") boolean isCustomNearClipPlaneEnabled();


        @MemberGetter public static native double INFINITE_FAR_PLANE_ADJUST();
        public static final double INFINITE_FAR_PLANE_ADJUST = INFINITE_FAR_PLANE_ADJUST();


        public native @Const @ByRef Vector3 getPositionForViewUpdate();

        public native @Const @ByRef Quaternion getOrientationForViewUpdate();



        public native @ByVal PlaneBoundedVolume getPlaneBoundedVolume();





        public native void setOrientationMode(@Cast("Ogre::OrientationMode") int orientationMode);






        public native @Cast("Ogre::OrientationMode") int getOrientationMode();

    }





    @Namespace("Ogre") @NoOffset public static class Camera extends Frustum {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Camera(Pointer p) { super(p); }
    


        public static class Listener extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Listener(Pointer p) { super(p); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public Listener(long size) { super((Pointer)null); allocateArray(size); }
            private native void allocateArray(long size);
            @Override public Listener position(long position) {
                return (Listener)super.position(position);
            }
        
            public Listener() { super((Pointer)null); allocate(); }
            private native void allocate();


            public native void cameraPreRenderScene(Camera cam);


            public native void cameraPostRenderScene(Camera cam);


            public native void cameraDestroyed(Camera cam);

        }


        public Camera( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager sm ) { super((Pointer)null); allocate(id, objectMemoryManager, sm); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager sm );


        public native void addListener(Listener l);

        public native void removeListener(Listener l);



        public native SceneManager getSceneManager();



        public native void setPosition(double x, double y, double z);



        public native void setPosition(@Const @ByRef Vector3 vec);



        public native @Const @ByRef Vector3 getPosition();



        public native void move(@Const @ByRef Vector3 vec);



        public native void moveRelative(@Const @ByRef Vector3 vec);






        public native void setDirection(double x, double y, double z);



        public native void setDirection(@Const @ByRef Vector3 vec);



        public native @ByVal Vector3 getDirection();



        public native @ByVal Vector3 getUp();



        public native @ByVal Vector3 getRight();
        public native void lookAt( @Const @ByRef Vector3 targetPoint );
        public native void lookAt(double x, double y, double z);



        public native void roll(@Const @ByRef Radian angle);



        public native void yaw(@Const @ByRef Radian angle);



        public native void pitch(@Const @ByRef Radian angle);



        public native void rotate(@Const @ByRef Vector3 axis, @Const @ByRef Radian angle);



        public native void rotate(@Const @ByRef Quaternion q);
        public native void setFixedYawAxis( @Cast("bool") boolean useFixed, @Const @ByRef(nullValue = "Ogre::Vector3::UNIT_Y") Vector3 fixedAxis );
        public native void setFixedYawAxis( @Cast("bool") boolean useFixed );




        public native @Const @ByRef Quaternion getOrientation();



        public native void setOrientation(@Const @ByRef Quaternion q);
        public native void _cullScenePhase01(@Const Camera lodCamera, Viewport vp, @Cast("Ogre::uint8") byte firstRq, @Cast("Ogre::uint8") byte lastRq );

        public native void _renderScenePhase02(@Const Camera lodCamera, Viewport vp, @Cast("Ogre::uint8") byte firstRq, @Cast("Ogre::uint8") byte lastRq,
                                         @Cast("bool") boolean includeOverlays);



                    



        public native void _notifyRenderedFaces(@Cast("unsigned int") int numfaces);



        public native void _notifyRenderedBatches(@Cast("unsigned int") int numbatches);



        public native @Cast("unsigned int") int _getNumRenderedFaces();



        public native @Cast("unsigned int") int _getNumRenderedBatches();



        public native @Const @ByRef Quaternion getDerivedOrientation();


        public native @Const @ByRef Vector3 getDerivedPosition();


        public native @ByVal Vector3 getDerivedDirection();


        public native @ByVal Vector3 getDerivedUp();


        public native @ByVal Vector3 getDerivedRight();


        public native @Const @ByRef Vector3 _getCachedDerivedPosition();



        public native @Const @ByRef Quaternion getRealOrientation();


        public native @Const @ByRef Vector3 getRealPosition();


        public native @ByVal Vector3 getRealDirection();


        public native @ByVal Vector3 getRealUp();


        public native @ByVal Vector3 getRealRight();


        public native void getWorldTransforms(Matrix4 mat);


        public native @Const @ByRef String getMovableType();
        public native void setAutoTracking(@Cast("bool") boolean enabled, SceneNode target/*=0*/,
                    @Const @ByRef(nullValue = "Ogre::Vector3::ZERO") Vector3 offset);
        public native void setAutoTracking(@Cast("bool") boolean enabled);
        public native void setLodBias(double factor/*=1.0*/);
        public native void setLodBias();





        public native double getLodBias();
        public native void setLodCamera(@Const Camera lodCam);







        public native @Const Camera getLodCamera();






        public native @ByVal Ray getCameraToViewportRay(double screenx, double screeny);





        public native void getCameraToViewportRay(double screenx, double screeny, Ray outRay);
        public native @ByVal PlaneBoundedVolume getCameraToViewportBoxVolume(double screenLeft,
                    double screenTop, double screenRight, double screenBottom, @Cast("bool") boolean includeFarPlane/*=false*/);
        public native @ByVal PlaneBoundedVolume getCameraToViewportBoxVolume(double screenLeft,
                    double screenTop, double screenRight, double screenBottom);
        public native void getCameraToViewportBoxVolume(double screenLeft,
                    double screenTop, double screenRight, double screenBottom,
                    PlaneBoundedVolume outVolume, @Cast("bool") boolean includeFarPlane/*=false*/);
        public native void getCameraToViewportBoxVolume(double screenLeft,
                    double screenTop, double screenRight, double screenBottom,
                    PlaneBoundedVolume outVolume);


        public native double _getLodBiasInverse();



        public native void _autoTrack();
        public native void setWindow(double left, double top, double right, double bottom);

        public native void resetWindow();

        public native @Cast("bool") boolean isWindowSet();

        public native @Cast("const vector<Ogre::Plane>::type*") @ByRef PlaneVectorRef getWindowPlanes();


        public native SceneNode getAutoTrackTarget();

        public native @Const @ByRef Vector3 getAutoTrackOffset();






        public native Viewport getLastViewport();

        public native void _notifyViewport(Viewport viewport);
        public native void setAutoAspectRatio(@Cast("bool") boolean autoratio);



        public native @Cast("bool") boolean getAutoAspectRatio();
        public native void setCullingFrustum(Frustum frustum);

        public native Frustum getCullingFrustum();





        public native void forwardIntersect(@Const @ByRef Plane worldPlane, @Cast("vector<Ogre::Vector4>::type*") Vector4VectorRef intersect3d);


        public native @Cast("bool") boolean isVisible(@Const @ByRef AxisAlignedBox bound, @Cast("Ogre::FrustumPlane*") IntPointer culledBy/*=0*/);
        public native @Cast("bool") boolean isVisible(@Const @ByRef AxisAlignedBox bound);
        public native @Cast("bool") boolean isVisible(@Const @ByRef AxisAlignedBox bound, @Cast("Ogre::FrustumPlane*") IntBuffer culledBy/*=0*/);
        public native @Cast("bool") boolean isVisible(@Const @ByRef AxisAlignedBox bound, @Cast("Ogre::FrustumPlane*") int[] culledBy/*=0*/);

        public native @Cast("bool") boolean isVisible(@Const @ByRef Sphere bound, @Cast("Ogre::FrustumPlane*") IntPointer culledBy/*=0*/);
        public native @Cast("bool") boolean isVisible(@Const @ByRef Sphere bound);
        public native @Cast("bool") boolean isVisible(@Const @ByRef Sphere bound, @Cast("Ogre::FrustumPlane*") IntBuffer culledBy/*=0*/);
        public native @Cast("bool") boolean isVisible(@Const @ByRef Sphere bound, @Cast("Ogre::FrustumPlane*") int[] culledBy/*=0*/);

        public native @Cast("bool") boolean isVisible(@Const @ByRef Vector3 vert, @Cast("Ogre::FrustumPlane*") IntPointer culledBy/*=0*/);
        public native @Cast("bool") boolean isVisible(@Const @ByRef Vector3 vert);
        public native @Cast("bool") boolean isVisible(@Const @ByRef Vector3 vert, @Cast("Ogre::FrustumPlane*") IntBuffer culledBy/*=0*/);
        public native @Cast("bool") boolean isVisible(@Const @ByRef Vector3 vert, @Cast("Ogre::FrustumPlane*") int[] culledBy/*=0*/);

        public native @Const Vector3 getWorldSpaceCorners();

        public native @Const @ByRef Plane getFrustumPlane( @Cast("unsigned short") short plane );

        public native @Cast("bool") boolean projectSphere(@Const @ByRef Sphere sphere,
                    double left, double top, double right, double bottom);

        public native double getNearClipDistance();

        public native double getFarClipDistance();

        public native @Const @ByRef Matrix4 getViewMatrix();
        public native @Const @ByRef Matrix4 getViewMatrix(@Cast("bool") boolean ownFrustumOnly);





        public native void setUseRenderingDistance(@Cast("bool") boolean use);



        public native @Cast("bool") boolean getUseRenderingDistance();







        public native void synchroniseBaseSettingsWith(@Const Camera cam);


        public native @Const @ByRef Vector3 getPositionForViewUpdate();

        public native @Const @ByRef Quaternion getOrientationForViewUpdate();





        public native void setUseMinPixelSize(@Cast("bool") boolean enable);



        public native @Cast("bool") boolean getUseMinPixelSize();
        public native double getPixelDisplayRatio();





        public native void _resetRenderedRqs( @Cast("size_t") long numRqs );
        public native void _setRenderedRqs( @Cast("size_t") long rqStart, @Cast("size_t") long rqEnd );


        public native @Cast("bool") boolean isRenderedRq( @Cast("size_t") long rqId );

    }




    @Namespace("Ogre") @NoOffset public static class ConfigFile extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ConfigFile(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ConfigFile(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ConfigFile position(long position) {
            return (ConfigFile)super.position(position);
        }
    

        public ConfigFile() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native void load(@Const @ByRef String filename, @Const @ByRef(nullValue = "Ogre::String(\"\t:=\")") String separators, @Cast("bool") boolean trimWhitespace/*=true*/);
        public native void load(@Const @ByRef String filename);

        public native void load(@Const @ByRef String filename, @Const @ByRef String resourceGroup, @Const @ByRef(nullValue = "Ogre::String(\"\t:=\")") String separators, @Cast("bool") boolean trimWhitespace/*=true*/);
        public native void load(@Const @ByRef String filename, @Const @ByRef String resourceGroup);

        public native void load(@Cast("const Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream, @Const @ByRef(nullValue = "Ogre::String(\"\t:=\")") String separators, @Cast("bool") boolean trimWhitespace/*=true*/);
        public native void load(@Cast("const Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream);

        public native void loadDirect(@Const @ByRef String filename, @Const @ByRef(nullValue = "Ogre::String(\"\t:=\")") String separators, @Cast("bool") boolean trimWhitespace/*=true*/);
        public native void loadDirect(@Const @ByRef String filename);

        public native void loadFromResourceSystem(@Const @ByRef String filename, @Const @ByRef String resourceGroup, @Const @ByRef(nullValue = "Ogre::String(\"\t:=\")") String separators, @Cast("bool") boolean trimWhitespace/*=true*/);
        public native void loadFromResourceSystem(@Const @ByRef String filename, @Const @ByRef String resourceGroup);






        public native @ByVal String getSetting(@Const @ByRef String key, @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String section, @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String defaultValue);
        public native @ByVal String getSetting(@Const @ByRef String key);

        public native @ByVal @Cast("Ogre::StringVector*") StringVectorRef getMultiSetting(@Const @ByRef String key, @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String section);
        public native @ByVal @Cast("Ogre::StringVector*") StringVectorRef getMultiSetting(@Const @ByRef String key);

        public native @ByVal @Cast("Ogre::ConfigFile::SectionIterator*") SettingsBySectionIteratorRef getSectionIterator();

        public native @ByVal @Cast("Ogre::ConfigFile::SettingsIterator*") SettingsMultiMapIteratorRef getSettingsIterator(@Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String section);
        public native @ByVal @Cast("Ogre::ConfigFile::SettingsIterator*") SettingsMultiMapIteratorRef getSettingsIterator();




        public native void clear();
    }











    /** enum Ogre::PixelFormat */
    public static final int

        PF_UNKNOWN = 0,

        PF_L8 = 1,
        PF_BYTE_L =  PF_L8,

        PF_L16 = 2,
        PF_SHORT_L =  PF_L16,

        PF_A8 = 3,
        PF_BYTE_A =  PF_A8,

        PF_A4L4 = 4,

        PF_BYTE_LA = 5,

        PF_R5G6B5 = 6,

        PF_B5G6R5 = 7,

        PF_R3G3B2 = 31,

        PF_A4R4G4B4 = 8,

        PF_A1R5G5B5 = 9,

        PF_R8G8B8 = 10,

        PF_B8G8R8 = 11,

        PF_A8R8G8B8 = 12,

        PF_A8B8G8R8 = 13,

        PF_B8G8R8A8 = 14,

        PF_R8G8B8A8 = 28,


        PF_X8R8G8B8 = 26,


        PF_X8B8G8R8 = 27,
        PF_BYTE_RGB =  PF_B8G8R8,

        PF_BYTE_BGR =  PF_R8G8B8,

        PF_BYTE_BGRA =  PF_A8R8G8B8,

        PF_BYTE_RGBA =  PF_A8B8G8R8,


        PF_A2R10G10B10 = 15,

        PF_A2B10G10R10 = 16,

        PF_DXT1 = 17,

        PF_DXT2 = 18,

        PF_DXT3 = 19,

        PF_DXT4 = 20,

        PF_DXT5 = 21,

        PF_FLOAT16_R = 32,

        PF_FLOAT16_RGB = 22,

        PF_FLOAT16_RGBA = 23,

        PF_FLOAT32_R = 33,

        PF_FLOAT32_RGB = 24,

        PF_FLOAT32_RGBA = 25,

        PF_FLOAT16_GR = 35,

        PF_FLOAT32_GR = 36,

        PF_DEPTH_DEPRECATED = 29,

        PF_SHORT_RGBA = 30,

        PF_SHORT_GR = 34,

        PF_SHORT_RGB = 37,

        PF_PVRTC_RGB2 = 38,

        PF_PVRTC_RGBA2 = 39,

        PF_PVRTC_RGB4 = 40,

        PF_PVRTC_RGBA4 = 41,

        PF_PVRTC2_2BPP = 42,

        PF_PVRTC2_4BPP = 43,

        PF_R11G11B10_FLOAT = 44,

        PF_R8_UINT = 45,

        PF_R8G8_UINT = 46,

        PF_R8G8B8_UINT = 47,

        PF_R8G8B8A8_UINT = 48,

        PF_R16_UINT = 49,

        PF_R16G16_UINT = 50,

        PF_R16G16B16_UINT = 51,

        PF_R16G16B16A16_UINT = 52,

        PF_R32_UINT = 53,

        PF_R32G32_UINT = 54,

        PF_R32G32B32_UINT = 55,

        PF_R32G32B32A32_UINT = 56,

        PF_R8_SINT = 57,

        PF_R8G8_SINT = 58,

        PF_R8G8B8_SINT = 59,

        PF_R8G8B8A8_SINT = 60,

        PF_R16_SINT = 61,

        PF_R16G16_SINT = 62,

        PF_R16G16B16_SINT = 63,

        PF_R16G16B16A16_SINT = 64,

        PF_R32_SINT = 65,

        PF_R32G32_SINT = 66,

        PF_R32G32B32_SINT = 67,

        PF_R32G32B32A32_SINT = 68,

        PF_R9G9B9E5_SHAREDEXP = 69,

        PF_BC4_UNORM = 70,

        PF_BC4_SNORM = 71,

        PF_BC5_UNORM = 72,

        PF_BC5_SNORM = 73,

        PF_BC6H_UF16 = 74,

        PF_BC6H_SF16 = 75,

        PF_BC7_UNORM = 76,

        PF_BC7_UNORM_SRGB = 77,

        PF_R8 = 78,

        PF_RG8 = 79,

        PF_R8_SNORM = 80,

        PF_R8G8_SNORM = 81,

        PF_R8G8B8_SNORM = 82,

        PF_R8G8B8A8_SNORM = 83,

        PF_R16_SNORM = 84,

        PF_R16G16_SNORM = 85,

        PF_R16G16B16_SNORM = 86,

        PF_R16G16B16A16_SNORM = 87,

        PF_ETC1_RGB8 = 88,

        PF_ETC2_RGB8 = 89,

        PF_ETC2_RGBA8 = 90,

        PF_ETC2_RGB8A1 = 91,

        PF_ATC_RGB = 92,

        PF_ATC_RGBA_EXPLICIT_ALPHA = 93,

        PF_ATC_RGBA_INTERPOLATED_ALPHA = 94,
        PF_D24_UNORM_S8_UINT = 95,

        PF_D24_UNORM_X8 = 96,

        PF_X24_S8_UINT = 97,

        PF_D24_UNORM = 98,

        PF_D16_UNORM = 99,

        PF_D32_FLOAT = 100,

        PF_D32_FLOAT_X24_S8_UINT = 101,

        PF_D32_FLOAT_X24_X8 = 102,

        PF_X32_X24_S8_UINT = 103,




        PF_NULL = 104,


        PF_COUNT = 105;




    /** enum Ogre::PixelFormatFlags */
    public static final int

        PFF_HASALPHA =  0x00000001,


        PFF_COMPRESSED =  0x00000002,

        PFF_FLOAT =  0x00000004,

        PFF_DEPTH =  0x00000008,


        PFF_NATIVEENDIAN =  0x00000010,


        PFF_LUMINANCE =  0x00000020,

        PFF_INTEGER =  0x00000040,

        PFF_SIGNED =  0x00000080;


    /** enum Ogre::PixelComponentType */
    public static final int
        PCT_BYTE = 0,
        PCT_SHORT = 1,
        PCT_FLOAT16 = 2,
        PCT_FLOAT32 = 3,
        PCT_SINT = 4,
        PCT_UINT = 5,
        PCT_COUNT = 6;




    @Namespace("Ogre") public static class PixelUtil extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public PixelUtil() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public PixelUtil(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public PixelUtil(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public PixelUtil position(long position) {
            return (PixelUtil)super.position(position);
        }
    






        public static native @Cast("size_t") long getNumElemBytes( @Cast("Ogre::PixelFormat") int format );







        public static native @Cast("size_t") long getNumElemBits( @Cast("Ogre::PixelFormat") int format );






        public static native @Cast("Ogre::uint8") byte getMaxMipmapCount( @Cast("Ogre::uint32") int maxResolution );
        public static native @Cast("Ogre::uint8") byte getMaxMipmapCount( @Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height );
        public static native @Cast("Ogre::uint8") byte getMaxMipmapCount( @Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height, @Cast("Ogre::uint32") int depth );
        public static native @Cast("size_t") long getMemorySize(@Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height, @Cast("Ogre::uint32") int depth, @Cast("Ogre::PixelFormat") int format);
        public static native @Cast("Ogre::uint32") int getCompressedBlockWidth( @Cast("Ogre::PixelFormat") int format, @Cast("bool") boolean apiStrict/*=true*/ );
        public static native @Cast("Ogre::uint32") int getCompressedBlockWidth( @Cast("Ogre::PixelFormat") int format );


        public static native @Cast("Ogre::uint32") int getCompressedBlockHeight( @Cast("Ogre::PixelFormat") int format, @Cast("bool") boolean apiStrict/*=true*/ );
        public static native @Cast("Ogre::uint32") int getCompressedBlockHeight( @Cast("Ogre::PixelFormat") int format );
        public static native @Cast("unsigned int") int getFlags( @Cast("Ogre::PixelFormat") int format );


        public static native @Cast("bool") boolean hasAlpha(@Cast("Ogre::PixelFormat") int format);

        public static native @Cast("bool") boolean isFloatingPoint(@Cast("Ogre::PixelFormat") int format);

        public static native @Cast("bool") boolean isInteger(@Cast("Ogre::PixelFormat") int format);

        public static native @Cast("bool") boolean isSigned(@Cast("Ogre::PixelFormat") int format);

        public static native @Cast("bool") boolean isCompressed(@Cast("Ogre::PixelFormat") int format);

        public static native @Cast("bool") boolean isDepth(@Cast("Ogre::PixelFormat") int format);

        public static native @Cast("bool") boolean isNativeEndian(@Cast("Ogre::PixelFormat") int format);

        public static native @Cast("bool") boolean isLuminance(@Cast("Ogre::PixelFormat") int format);
        public static native @Cast("bool") boolean isValidExtent(@Cast("size_t") long width, @Cast("size_t") long height, @Cast("size_t") long depth, @Cast("Ogre::PixelFormat") int format);




        public static native void getBitDepths(@Cast("Ogre::PixelFormat") int format, IntPointer rgba);
        public static native void getBitDepths(@Cast("Ogre::PixelFormat") int format, IntBuffer rgba);
        public static native void getBitDepths(@Cast("Ogre::PixelFormat") int format, int[] rgba);




        public static native void getBitMasks(@Cast("Ogre::PixelFormat") int format, @Cast("Ogre::uint64*") LongPointer rgba);
        public static native void getBitMasks(@Cast("Ogre::PixelFormat") int format, @Cast("Ogre::uint64*") LongBuffer rgba);
        public static native void getBitMasks(@Cast("Ogre::PixelFormat") int format, @Cast("Ogre::uint64*") long[] rgba);




        public static native void getBitShifts(@Cast("Ogre::PixelFormat") int format, @Cast("unsigned char*") BytePointer rgba);
        public static native void getBitShifts(@Cast("Ogre::PixelFormat") int format, @Cast("unsigned char*") ByteBuffer rgba);
        public static native void getBitShifts(@Cast("Ogre::PixelFormat") int format, @Cast("unsigned char*") byte[] rgba);



        public static native @ByVal String getFormatName(@Cast("Ogre::PixelFormat") int srcformat);
        public static native @Cast("bool") boolean isAccessible(@Cast("Ogre::PixelFormat") int srcformat);





        public static native @Cast("Ogre::PixelComponentType") int getComponentType(@Cast("Ogre::PixelFormat") int fmt);




        public static native @Cast("size_t") long getComponentCount(@Cast("Ogre::PixelFormat") int fmt);
        public static native @Cast("Ogre::PixelFormat") int getFormatFromName(@Const @ByRef String name, @Cast("bool") boolean accessibleOnly/*=false*/, @Cast("bool") boolean caseSensitive/*=false*/);
        public static native @Cast("Ogre::PixelFormat") int getFormatFromName(@Const @ByRef String name);
        public static native @ByVal String getBNFExpressionOfPixelFormats(@Cast("bool") boolean accessibleOnly/*=false*/);
        public static native @ByVal String getBNFExpressionOfPixelFormats();
        public static native @Cast("Ogre::PixelFormat") int getFormatForBitDepths(@Cast("Ogre::PixelFormat") int fmt, short integerBits, short floatBits);






        public static native void packColour(@Const @ByRef ColourValue colour, @Cast("const Ogre::PixelFormat") int pf, Pointer dest);







        public static native void packColour(@Cast("const Ogre::uint8") byte r, @Cast("const Ogre::uint8") byte g, @Cast("const Ogre::uint8") byte b, @Cast("const Ogre::uint8") byte a, @Cast("const Ogre::PixelFormat") int pf, Pointer dest);







        public static native void packColour(float r, float g, float b, float a, @Cast("const Ogre::PixelFormat") int pf, Pointer dest);






        public static native void unpackColour(ColourValue colour, @Cast("Ogre::PixelFormat") int pf, @Const Pointer src);
        public static native void unpackColour(@Cast("Ogre::uint8*") BytePointer r, @Cast("Ogre::uint8*") BytePointer g, @Cast("Ogre::uint8*") BytePointer b, @Cast("Ogre::uint8*") BytePointer a, @Cast("Ogre::PixelFormat") int pf, @Const Pointer src);
        public static native void unpackColour(@Cast("Ogre::uint8*") ByteBuffer r, @Cast("Ogre::uint8*") ByteBuffer g, @Cast("Ogre::uint8*") ByteBuffer b, @Cast("Ogre::uint8*") ByteBuffer a, @Cast("Ogre::PixelFormat") int pf, @Const Pointer src);
        public static native void unpackColour(@Cast("Ogre::uint8*") byte[] r, @Cast("Ogre::uint8*") byte[] g, @Cast("Ogre::uint8*") byte[] b, @Cast("Ogre::uint8*") byte[] a, @Cast("Ogre::PixelFormat") int pf, @Const Pointer src);
        public static native void unpackColour(FloatPointer r, FloatPointer g, FloatPointer b, FloatPointer a, @Cast("Ogre::PixelFormat") int pf, @Const Pointer src);
        public static native void unpackColour(FloatBuffer r, FloatBuffer g, FloatBuffer b, FloatBuffer a, @Cast("Ogre::PixelFormat") int pf, @Const Pointer src);
        public static native void unpackColour(float[] r, float[] g, float[] b, float[] a, @Cast("Ogre::PixelFormat") int pf, @Const Pointer src);
        public static native void bulkPixelConversion(Pointer src, @Cast("Ogre::PixelFormat") int srcFormat, Pointer dst, @Cast("Ogre::PixelFormat") int dstFormat, @Cast("unsigned int") int count);
        public static native void bulkPixelConversion(@Const @ByRef PixelBox src, @Const @ByRef PixelBox dst);







        public static native void convertForNormalMapping(@Const @ByRef PixelBox src, @Const @ByRef PixelBox dst);
        public static native void bulkCompressedSubregion( @Const @ByRef PixelBox src, @Const @ByRef PixelBox dst,
                                                     @Const @ByRef Box dstRegion );





        public static native void bulkPixelVerticalFlip(@Const @ByRef PixelBox box);
    }











    /** enum Ogre::ImageFlags */
    public static final int
        IF_COMPRESSED =  0x00000001,
        IF_CUBEMAP =  0x00000002,
        IF_3D_TEXTURE =  0x00000004;
    @Namespace("Ogre") @NoOffset public static class Image extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Image(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Image(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Image position(long position) {
            return (Image)super.position(position);
        }
    


        public Image() { super((Pointer)null); allocate(); }
        private native void allocate();


        public Image( @Const @ByRef Image img ) { super((Pointer)null); allocate(img); }
        private native void allocate( @Const @ByRef Image img );



        public native @ByRef @Name("operator =") Image put( @Const @ByRef Image img );
        public native @ByRef Image flipAroundY();
        public native @ByRef Image flipAroundX();
        public native @ByRef Image loadDynamicImage( @Cast("Ogre::uchar*") BytePointer data, @Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height,
                                    @Cast("Ogre::uint32") int depth,
                                     @Cast("Ogre::PixelFormat") int format, @Cast("bool") boolean autoDelete/*=false*/,
                                     @Cast("size_t") long numFaces/*=1*/, @Cast("Ogre::uint8") byte numMipMaps/*=0*/);
        public native @ByRef Image loadDynamicImage( @Cast("Ogre::uchar*") BytePointer data, @Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height,
                                    @Cast("Ogre::uint32") int depth,
                                     @Cast("Ogre::PixelFormat") int format);
        public native @ByRef Image loadDynamicImage( @Cast("Ogre::uchar*") ByteBuffer data, @Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height,
                                    @Cast("Ogre::uint32") int depth,
                                     @Cast("Ogre::PixelFormat") int format, @Cast("bool") boolean autoDelete/*=false*/,
                                     @Cast("size_t") long numFaces/*=1*/, @Cast("Ogre::uint8") byte numMipMaps/*=0*/);
        public native @ByRef Image loadDynamicImage( @Cast("Ogre::uchar*") ByteBuffer data, @Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height,
                                    @Cast("Ogre::uint32") int depth,
                                     @Cast("Ogre::PixelFormat") int format);
        public native @ByRef Image loadDynamicImage( @Cast("Ogre::uchar*") byte[] data, @Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height,
                                    @Cast("Ogre::uint32") int depth,
                                     @Cast("Ogre::PixelFormat") int format, @Cast("bool") boolean autoDelete/*=false*/,
                                     @Cast("size_t") long numFaces/*=1*/, @Cast("Ogre::uint8") byte numMipMaps/*=0*/);
        public native @ByRef Image loadDynamicImage( @Cast("Ogre::uchar*") byte[] data, @Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height,
                                    @Cast("Ogre::uint32") int depth,
                                     @Cast("Ogre::PixelFormat") int format);
        public native @ByRef Image loadDynamicImage( @Cast("Ogre::uchar*") BytePointer data, @Cast("Ogre::uint32") int width,
                                         @Cast("Ogre::uint32") int height, @Cast("Ogre::PixelFormat") int format);
        public native @ByRef Image loadDynamicImage( @Cast("Ogre::uchar*") ByteBuffer data, @Cast("Ogre::uint32") int width,
                                         @Cast("Ogre::uint32") int height, @Cast("Ogre::PixelFormat") int format);
        public native @ByRef Image loadDynamicImage( @Cast("Ogre::uchar*") byte[] data, @Cast("Ogre::uint32") int width,
                                         @Cast("Ogre::uint32") int height, @Cast("Ogre::PixelFormat") int format);
        public native @ByRef Image loadRawData(
                    @Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream,
                    @Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height, @Cast("Ogre::uint32") int depth,
                    @Cast("Ogre::PixelFormat") int format,
                    @Cast("size_t") long numFaces/*=1*/, @Cast("size_t") long numMipMaps/*=0*/);
        public native @ByRef Image loadRawData(
                    @Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream,
                    @Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height, @Cast("Ogre::uint32") int depth,
                    @Cast("Ogre::PixelFormat") int format);
        public native @ByRef Image loadRawData(
                    @Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream,
                    @Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height,
                    @Cast("Ogre::PixelFormat") int format );
        public native @ByRef Image load( @Const @ByRef String filename, @Const @ByRef String groupName );
        public native @ByRef Image load(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream, @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String type );
        public native @ByRef Image load(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream );
        public native @ByRef Image loadTwoImagesAsRGBA(@Const @ByRef String rgbFilename, @Const @ByRef String alphaFilename,
                    @Const @ByRef String groupName, @Cast("Ogre::PixelFormat") int format/*=Ogre::PF_BYTE_RGBA*/);
        public native @ByRef Image loadTwoImagesAsRGBA(@Const @ByRef String rgbFilename, @Const @ByRef String alphaFilename,
                    @Const @ByRef String groupName);
        public native @ByRef Image loadTwoImagesAsRGBA(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr rgbStream, @Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr alphaStream, @Cast("Ogre::PixelFormat") int format/*=Ogre::PF_BYTE_RGBA*/,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String rgbType, @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String alphaType);
        public native @ByRef Image loadTwoImagesAsRGBA(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr rgbStream, @Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr alphaStream);
        public native @ByRef Image combineTwoImagesAsRGBA(@Const @ByRef Image rgb, @Const @ByRef Image alpha, @Cast("Ogre::PixelFormat") int format/*=Ogre::PF_BYTE_RGBA*/);
        public native @ByRef Image combineTwoImagesAsRGBA(@Const @ByRef Image rgb, @Const @ByRef Image alpha);
        public native void save(@Const @ByRef String filename);





        public native @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr encode(@Const @ByRef String formatextension);







        public native @Cast("Ogre::uchar*") BytePointer getData();



        public native @Cast("size_t") long getSize();



        public native @Cast("Ogre::uint8") byte getNumMipmaps();



        public native @Cast("bool") boolean hasFlag(@Cast("const Ogre::ImageFlags") int imgFlag);



        public native @Cast("Ogre::uint32") int getWidth();



        public native @Cast("Ogre::uint32") int getHeight();



        public native @Cast("Ogre::uint32") int getDepth();




        public native @Cast("size_t") long getNumFaces();



        public native @Cast("size_t") long getRowSpan();



        public native @Cast("Ogre::PixelFormat") int getFormat();



        public native @Cast("Ogre::uchar") byte getBPP();



        public native @Cast("bool") boolean getHasAlpha();






        public static native void applyGamma( @Cast("Ogre::uchar*") BytePointer buffer, double gamma, @Cast("size_t") long size, @Cast("Ogre::uchar") byte bpp );
        public static native void applyGamma( @Cast("Ogre::uchar*") ByteBuffer buffer, double gamma, @Cast("size_t") long size, @Cast("Ogre::uchar") byte bpp );
        public static native void applyGamma( @Cast("Ogre::uchar*") byte[] buffer, double gamma, @Cast("size_t") long size, @Cast("Ogre::uchar") byte bpp );






        public native @ByVal ColourValue getColourAt(@Cast("size_t") long x, @Cast("size_t") long y, @Cast("size_t") long z);






        public native void setColourAt(@Const({false, true}) @ByRef ColourValue cv, @Cast("size_t") long x, @Cast("size_t") long y, @Cast("size_t") long z);




        public native @ByVal PixelBox getPixelBox(@Cast("size_t") long face/*=0*/, @Cast("size_t") long mipmap/*=0*/);
        public native @ByVal PixelBox getPixelBox();


        public native void freeMemory();

        /** enum Ogre::Image::Filter */
        public static final int
            FILTER_NEAREST = 0,
            FILTER_LINEAR = 1,
            FILTER_BILINEAR = 2,
            FILTER_BOX = 3,
            FILTER_TRIANGLE = 4,
            FILTER_BICUBIC = 5,
            FILTER_GAUSSIAN = 6;







        public static native void scale(@Const @ByRef PixelBox src, @Const @ByRef PixelBox dst, @Cast("Ogre::Image::Filter") int filter/*=Ogre::Image::FILTER_BILINEAR*/);
        public static native void scale(@Const @ByRef PixelBox src, @Const @ByRef PixelBox dst);


        public native void resize(short width, short height, @Cast("Ogre::Image::Filter") int filter/*=Ogre::Image::FILTER_BILINEAR*/);
        public native void resize(short width, short height);
        public native @Cast("bool") boolean generateMipmaps( @Cast("bool") boolean gammaCorrected, @Cast("Ogre::Image::Filter") int filter/*=Ogre::Image::FILTER_BILINEAR*/ );
        public native @Cast("bool") boolean generateMipmaps( @Cast("bool") boolean gammaCorrected );


        public static native @Cast("size_t") long calculateSize(@Cast("size_t") long mipmaps, @Cast("size_t") long faces, @Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height, @Cast("Ogre::uint32") int depth, @Cast("Ogre::PixelFormat") int format);


        public static native @ByVal String getFileExtFromMagic(@ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr stream);
    }





    /** enum Ogre::TextureUsage */
    public static final int

        TU_STATIC =HBU_STATIC,
        TU_DYNAMIC =HBU_DYNAMIC,
        TU_WRITE_ONLY =HBU_WRITE_ONLY,
        TU_STATIC_WRITE_ONLY =HBU_STATIC_WRITE_ONLY,
        TU_DYNAMIC_WRITE_ONLY =HBU_DYNAMIC_WRITE_ONLY,
        TU_DYNAMIC_WRITE_ONLY_DISCARDABLE =HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE,

        TU_AUTOMIPMAP =  0x10,


        TU_RENDERTARGET =  0x20,



        TU_UAV =  0x40,


        TU_NOT_TEXTURE =  0x80,


        TU_UAV_NOT_TEXTURE =  TU_UAV|TU_NOT_TEXTURE,



        TU_AUTOMIPMAP_AUTO =  0x100,


        TU_DEFAULT =  TU_AUTOMIPMAP | TU_STATIC_WRITE_ONLY;



    /** enum Ogre::TextureType */
    public static final int

        TEX_TYPE_1D = 1,

        TEX_TYPE_2D = 2,

        TEX_TYPE_3D = 3,

        TEX_TYPE_CUBE_MAP = 4,

        TEX_TYPE_2D_ARRAY = 5,

        TEX_TYPE_2D_RECT = 6;



    /** enum Ogre::TextureMipmap */
    public static final int

        MIP_UNLIMITED =  0x7FFFFFFF,

        MIP_DEFAULT = -1;
    @Namespace("Ogre") @NoOffset public static class Texture extends Resource {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Texture(Pointer p) { super(p); }
    



        public native void setTextureType(@Cast("Ogre::TextureType") int ttype );



        public native @Cast("Ogre::TextureType") int getTextureType();

        public native @Cast("bool") boolean isTextureTypeArray();



        public native @Cast("Ogre::uint8") byte getNumMipmaps();





        public native void setNumMipmaps(@Cast("Ogre::uint8") byte num);





        public native @Cast("bool") boolean getMipmapsHardwareGenerated();



        public native float getGamma();
        public native void setGamma(float g);
        public native void setHardwareGammaEnabled(@Cast("bool") boolean enabled);




        public native @Cast("bool") boolean isHardwareGammaEnabled();
        public native void setFSAA(@Cast("Ogre::uint") int fsaa, @Const @ByRef String fsaaHint, @Cast("bool") boolean explicitResolve);




        public native @Cast("Ogre::uint") int getFSAA();



        public native @Const @ByRef String getFSAAHint();



        public native @Cast("Ogre::uint32") int getHeight();



        public native @Cast("Ogre::uint32") int getWidth();



        public native @Cast("Ogre::uint32") int getDepth();



        public native @Cast("Ogre::uint32") int getSrcHeight();



        public native @Cast("Ogre::uint32") int getSrcWidth();



        public native @Cast("Ogre::uint32") int getSrcDepth();



        public native void setHeight(@Cast("Ogre::uint32") int h);



        public native void setWidth(@Cast("Ogre::uint32") int w);




        public native void setDepth(@Cast("Ogre::uint32") int d);



        public native int getUsage();
        public native void setUsage(int u);
        public native void createInternalResources();



        public native void freeInternalResources();



        public native void _autogenerateMipmaps();



        public native void copyToTexture( @Cast("Ogre::TexturePtr*") @ByRef RealControllerFunctionSPtr target );







        public native void loadImage( @Const @ByRef Image img );
        public native void loadRawData( @Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream,
                    short uWidth, short uHeight, @Cast("Ogre::PixelFormat") int eFormat);






        public native void _loadImages( @Cast("const Ogre::ConstImagePtrList*") @ByRef ImagePtrVectorRef images );


        public native @Cast("Ogre::PixelFormat") int getFormat();


        public native @Cast("Ogre::PixelFormat") int getDesiredFormat();




        public native @Cast("Ogre::PixelFormat") int getSrcFormat();


        public native void setFormat(@Cast("Ogre::PixelFormat") int pf);


        public native @Cast("bool") boolean hasAlpha();






        public native void setDesiredIntegerBitDepth(short bits);



        public native short getDesiredIntegerBitDepth();






        public native void setDesiredFloatBitDepth(short bits);



        public native short getDesiredFloatBitDepth();



        public native void setDesiredBitDepths(short integerBits, short floatBits);



        public native void setTreatLuminanceAsAlpha(@Cast("bool") boolean asAlpha);



        public native @Cast("bool") boolean getTreatLuminanceAsAlpha();




        public native @Cast("size_t") long getNumFaces();
        public native @ByVal HardwarePixelBufferSharedPtr getBuffer(@Cast("size_t") long face/*=0*/, @Cast("size_t") long mipmap/*=0*/);
        public native @ByVal HardwarePixelBufferSharedPtr getBuffer();






        public native void convertToImage(@ByRef Image destImage, @Cast("bool") boolean includeMipMaps/*=false*/);
        public native void convertToImage(@ByRef Image destImage);






        public native void getCustomAttribute(@Const @ByRef String name, Pointer pData);

    }




    @Namespace("Ogre") @NoOffset public static class TextureUnitState extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public TextureUnitState(Pointer p) { super(p); }
    





        /** enum Ogre::TextureUnitState::TextureEffectType */
        public static final int

            ET_ENVIRONMENT_MAP = 0,

            ET_PROJECTIVE_TEXTURE = 1,

            ET_UVSCROLL = 2,

            ET_USCROLL = 3,

            ET_VSCROLL = 4,

            ET_ROTATE = 5,

            ET_TRANSFORM = 6;






        /** enum Ogre::TextureUnitState::EnvMapType */
        public static final int

            ENV_PLANAR = 0,

            ENV_CURVED = 1,

            ENV_REFLECTION = 2,

            ENV_NORMAL = 3;






        /** enum Ogre::TextureUnitState::TextureTransformType */
        public static final int
            TT_TRANSLATE_U = 0,
            TT_TRANSLATE_V = 1,
            TT_SCALE_U = 2,
            TT_SCALE_V = 3,
            TT_ROTATE = 4;



        /** enum Ogre::TextureUnitState::TextureCubeFace */
        public static final int
            CUBE_FRONT = 0,
            CUBE_BACK = 1,
            CUBE_LEFT = 2,
            CUBE_RIGHT = 3,
            CUBE_UP = 4,
            CUBE_DOWN = 5;



        public static class TextureEffect extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public TextureEffect() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public TextureEffect(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public TextureEffect(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public TextureEffect position(long position) {
                return (TextureEffect)super.position(position);
            }
        
            public native @Cast("Ogre::TextureUnitState::TextureEffectType") int type(); public native TextureEffect type(int type);
            public native int subtype(); public native TextureEffect subtype(int subtype);
            public native double arg1(); public native TextureEffect arg1(double arg1);
            public native double arg2(); public native TextureEffect arg2(double arg2);
            public native @Cast("Ogre::WaveformType") int waveType(); public native TextureEffect waveType(int waveType);
            public native double base(); public native TextureEffect base(double base);
            public native double frequency(); public native TextureEffect frequency(double frequency);
            public native double phase(); public native TextureEffect phase(double phase);
            public native double amplitude(); public native TextureEffect amplitude(double amplitude);
            public native @Cast("Ogre::Controller<Ogre::Real>*") RealControllerRef controller(); public native TextureEffect controller(RealControllerRef controller);
            @MemberGetter public native @Const Frustum frustum();
        }



        public TextureUnitState(Pass parent) { super((Pointer)null); allocate(parent); }
        private native void allocate(Pass parent);

        public TextureUnitState(Pass parent, @Const @ByRef TextureUnitState oth ) { super((Pointer)null); allocate(parent, oth); }
        private native void allocate(Pass parent, @Const @ByRef TextureUnitState oth );

        public native @ByRef @Name("operator =") TextureUnitState put( @Const @ByRef TextureUnitState oth );







        public TextureUnitState( Pass parent, @Const @ByRef String texName, @Cast("unsigned int") int texCoordSet/*=0*/) { super((Pointer)null); allocate(parent, texName, texCoordSet); }
        private native void allocate( Pass parent, @Const @ByRef String texName, @Cast("unsigned int") int texCoordSet/*=0*/);
        public TextureUnitState( Pass parent, @Const @ByRef String texName) { super((Pointer)null); allocate(parent, texName); }
        private native void allocate( Pass parent, @Const @ByRef String texName);
        public native @Const @ByRef String getTextureName();






        public native void setTextureName( @Const @ByRef String name, @Cast("Ogre::TextureType") int ttype/*=Ogre::TEX_TYPE_2D*/);
        public native void setTextureName( @Const @ByRef String name);






        public native void setTexture( @Cast("const Ogre::TexturePtr*") @ByRef RealControllerFunctionSPtr texPtr);
        public native void setCubicTextureName( @Const @ByRef String name, @Cast("bool") boolean forUVW/*=false*/ );
        public native void setCubicTextureName( @Const @ByRef String name );
        public native void setCubicTexture( @Cast("const Ogre::TexturePtr*const") RealControllerFunctionSPtr texPtrs, @Cast("bool") boolean forUVW/*=false*/ );
        public native void setCubicTexture( @Cast("const Ogre::TexturePtr*const") RealControllerFunctionSPtr texPtrs );
        public native void setAnimatedTextureName( @Const @ByRef String name, @Cast("unsigned int") int numFrames, double duration/*=0*/ );
        public native void setAnimatedTextureName( @Const @ByRef String name, @Cast("unsigned int") int numFrames );



        public native @ByVal @Cast("std::pair<size_t,size_t>*") SizetPairRef getTextureDimensions( @Cast("unsigned int") int frame/*=0*/ );
        public native @ByVal @Cast("std::pair<size_t,size_t>*") SizetPairRef getTextureDimensions( );
        public native void setCurrentFrame( @Cast("unsigned int") int frameNumber );





        public native @Cast("unsigned int") int getCurrentFrame();






        public native @Const @ByRef String getFrameTextureName(@Cast("unsigned int") int frameNumber);
        public native void setFrameTextureName(@Const @ByRef String name, @Cast("unsigned int") int frameNumber);







        public native void addFrameTextureName(@Const @ByRef String name);
        public native void deleteFrameTextureName(@Cast("const size_t") long frameNumber);




        public native @Cast("unsigned int") int getNumFrames();



        /** enum Ogre::TextureUnitState::BindingType */
        public static final int

            BT_FRAGMENT = 0,



            BT_VERTEX = 1,

            BT_GEOMETRY = 2,

            BT_TESSELLATION_HULL = 3,

            BT_TESSELLATION_DOMAIN = 4,

            BT_COMPUTE = 5;


        /** enum Ogre::TextureUnitState::ContentType */
        public static final int

            CONTENT_NAMED = 0,

            CONTENT_SHADOW = 1,

            CONTENT_COMPOSITOR = 2;
        public native void setBindingType(@Cast("Ogre::TextureUnitState::BindingType") int bt);



        public native @Cast("Ogre::TextureUnitState::BindingType") int getBindingType();






        public native void setContentType(@Cast("Ogre::TextureUnitState::ContentType") int ct);

        public native @Cast("Ogre::TextureUnitState::ContentType") int getContentType();







        public native @Cast("bool") boolean isCubic();





        public native @Cast("bool") boolean is3D();





        public native @Cast("Ogre::TextureType") int getTextureType();



        public native void setDesiredFormat(@Cast("Ogre::PixelFormat") int desiredFormat);



        public native @Cast("Ogre::PixelFormat") int getDesiredFormat();



        public native void setNumMipmaps(int numMipmaps);



        public native int getNumMipmaps();



        public native void setIsAlpha(@Cast("bool") boolean isAlpha);



        public native @Cast("bool") boolean getIsAlpha();


        public native double getGamma();

        public native void setGamma(double gamma);


        public native void setHardwareGammaEnabled(@Cast("bool") boolean enabled);

        public native @Cast("bool") boolean isHardwareGammaEnabled();





        public native @Cast("unsigned int") int getTextureCoordSet();
        public native void setTextureCoordSet(@Cast("unsigned int") int set);
        public native void setTextureTransform(@Const @ByRef Matrix4 xform);
        public native @Const @ByRef Matrix4 getTextureTransform();
        public native void setTextureScroll(double u, double v);





        public native void setTextureUScroll(double value);

        public native double getTextureUScroll();





        public native void setTextureVScroll(double value);

        public native double getTextureVScroll();





        public native void setTextureUScale(double value);

        public native double getTextureUScale();





        public native void setTextureVScale(double value);

        public native double getTextureVScale();
        public native void setTextureScale(double uScale, double vScale);
        public native void setTextureRotate(@Const @ByRef Radian angle);

        public native @Const @ByRef Radian getTextureRotate();
        public native void setColourOperationEx(
                    @Cast("Ogre::LayerBlendOperationEx") int op,
                    @Cast("Ogre::LayerBlendSource") int source1/*=Ogre::LBS_TEXTURE*/,
                    @Cast("Ogre::LayerBlendSource") int source2/*=Ogre::LBS_CURRENT*/,
        
                    @Const @ByRef(nullValue = "Ogre::ColourValue::White") ColourValue arg1,
                    @Const @ByRef(nullValue = "Ogre::ColourValue::White") ColourValue arg2,
        
                    double manualBlend/*=0.0*/);
        public native void setColourOperationEx(
                    @Cast("Ogre::LayerBlendOperationEx") int op);
        public native void setColourOperation( @Cast("const Ogre::LayerBlendOperation") int op);
        public native void setColourOpMultipassFallback( @Cast("const Ogre::SceneBlendFactor") int sourceFactor, @Cast("const Ogre::SceneBlendFactor") int destFactor);



        public native @Const @ByRef LayerBlendModeEx getColourBlendMode();



        public native @Const @ByRef LayerBlendModeEx getAlphaBlendMode();



        public native @Cast("Ogre::SceneBlendFactor") int getColourBlendFallbackSrc();



        public native @Cast("Ogre::SceneBlendFactor") int getColourBlendFallbackDest();
        public native void setAlphaOperation(@Cast("Ogre::LayerBlendOperationEx") int op,
                    @Cast("Ogre::LayerBlendSource") int source1/*=Ogre::LBS_TEXTURE*/,
                    @Cast("Ogre::LayerBlendSource") int source2/*=Ogre::LBS_CURRENT*/,
                    double arg1/*=1.0*/,
                    double arg2/*=1.0*/,
                    double manualBlend/*=0.0*/);
        public native void setAlphaOperation(@Cast("Ogre::LayerBlendOperationEx") int op);
        public native void addEffect(@ByRef TextureEffect effect);
        public native void setEnvironmentMap(@Cast("bool") boolean enable, @Cast("Ogre::TextureUnitState::EnvMapType") int envMapType/*=Ogre::TextureUnitState::ENV_CURVED*/);
        public native void setEnvironmentMap(@Cast("bool") boolean enable);
        public native void setScrollAnimation(double uSpeed, double vSpeed);
        public native void setRotateAnimation(double speed);
        public native void setTransformAnimation( @Cast("const Ogre::TextureUnitState::TextureTransformType") int ttype,
                    @Cast("const Ogre::WaveformType") int waveType, double base/*=0*/, double frequency/*=1*/, double phase/*=0*/, double amplitude/*=1*/ );
        public native void setTransformAnimation( @Cast("const Ogre::TextureUnitState::TextureTransformType") int ttype,
                    @Cast("const Ogre::WaveformType") int waveType );
        public native void setProjectiveTexturing(@Cast("bool") boolean enabled, @Const Frustum projectionSettings/*=0*/);
        public native void setProjectiveTexturing(@Cast("bool") boolean enabled);



        public native void removeAllEffects();






        public native void removeEffect( @Cast("const Ogre::TextureUnitState::TextureEffectType") int type );






        public native @Cast("bool") boolean isBlank();



        public native void setBlank();



        public native @Cast("bool") boolean isTextureLoadFailing();



        public native void retryTextureLoad();


        public native void setSamplerblock( @Const @ByRef HlmsSamplerblock samplerblock );




        public native @Const HlmsSamplerblock getSamplerblock();


        public native @Cast("const Ogre::TextureUnitState::EffectMap*") @ByRef TextureEffectMultiMap getEffects();

        public native double getAnimationDuration();
        public native void setCompositorReference(@Const @ByRef String textureName, @Cast("size_t") long mrtIndex/*=0*/);
        public native void setCompositorReference(@Const @ByRef String textureName);


        public native @ByVal IdString getReferencedTextureName();

        public native @Cast("size_t") long getReferencedMRTIndex();


        public native Pass getParent();


        public native void _prepare();

        public native void _unprepare();

        public native void _load();

        public native void _unload();

        public native @Cast("bool") boolean hasViewRelativeTextureCoordinateGeneration();


        public native @Cast("bool") boolean isLoaded();






        public native void setName(@Const @ByRef String name);

        public native @Const @ByRef String getName();





        public native void setTextureNameAlias(@Const @ByRef String name);


        public native @Const @ByRef String getTextureNameAlias();
        public native @Cast("bool") boolean applyTextureAliases(@Cast("const Ogre::AliasTextureNamePairList*") @ByRef SStringMapRef aliasList, @Cast("const bool") boolean apply/*=true*/);
        public native @Cast("bool") boolean applyTextureAliases(@Cast("const Ogre::AliasTextureNamePairList*") @ByRef SStringMapRef aliasList);


        public native void _notifyParent(Pass parent);


        public native @Cast("const Ogre::TexturePtr*") @ByRef RealControllerFunctionSPtr _getTexturePtr();

        public native @Cast("const Ogre::TexturePtr*") @ByRef RealControllerFunctionSPtr _getTexturePtr(@Cast("size_t") long frame);


        public native void _setTexturePtr(@Cast("const Ogre::TexturePtr*") @ByRef RealControllerFunctionSPtr texptr);

        public native void _setTexturePtr(@Cast("const Ogre::TexturePtr*") @ByRef RealControllerFunctionSPtr texptr, @Cast("size_t") long frame);

        public native @Cast("size_t") long calculateSize();




        public native @Cast("Ogre::Controller<Ogre::Real>*") RealControllerRef _getAnimController();


    }












    @Namespace("Ogre") @NoOffset public static class ControllerManager extends ControllerManagerSgtRef {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ControllerManager(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ControllerManager(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ControllerManager position(long position) {
            return (ControllerManager)super.position(position);
        }
        public Pointer asPointer() { return asPointer(this); }
        @Namespace public static native @Name("static_cast<ControllerAlloc*>") Pointer asPointer(ControllerManager pointer);
    
        public ControllerManager() { super((Pointer)null); allocate(); }
        private native void allocate();



        public native @Cast("Ogre::Controller<Ogre::Real>*") RealControllerRef createController(@Cast("const Ogre::ControllerValueRealPtr*") @ByRef RealControllerFunctionSPtr src,
                    @Cast("const Ogre::ControllerValueRealPtr*") @ByRef RealControllerFunctionSPtr dest, @Cast("const Ogre::ControllerFunctionRealPtr*") @ByRef RealControllerFunctionSPtr func);



        public native @Cast("Ogre::Controller<Ogre::Real>*") RealControllerRef createFrameTimePassthroughController(
                    @Cast("const Ogre::ControllerValueRealPtr*") @ByRef RealControllerFunctionSPtr dest);



        public native void clearControllers();



        public native void updateAllControllers();
        public native @Cast("const Ogre::ControllerValueRealPtr*") @ByRef RealControllerFunctionSPtr getFrameTimeSource();


        public native @Cast("const Ogre::ControllerFunctionRealPtr*") @ByRef RealControllerFunctionSPtr getPassthroughControllerFunction();
        public native @Cast("Ogre::Controller<Ogre::Real>*") RealControllerRef createTextureAnimator(TextureUnitState layer, double sequenceTime);
        public native @Cast("Ogre::Controller<Ogre::Real>*") RealControllerRef createTextureUVScroller(TextureUnitState layer, double speed);
        public native @Cast("Ogre::Controller<Ogre::Real>*") RealControllerRef createTextureUScroller(TextureUnitState layer, double uSpeed);
        public native @Cast("Ogre::Controller<Ogre::Real>*") RealControllerRef createTextureVScroller(TextureUnitState layer, double vSpeed);
        public native @Cast("Ogre::Controller<Ogre::Real>*") RealControllerRef createTextureRotater(TextureUnitState layer, double speed);
        public native @Cast("Ogre::Controller<Ogre::Real>*") RealControllerRef createTextureWaveTransformer(TextureUnitState layer, @Cast("Ogre::TextureUnitState::TextureTransformType") int ttype,
                    @Cast("Ogre::WaveformType") int waveType, double base/*=0*/, double frequency/*=1*/, double phase/*=0*/, double amplitude/*=1*/);
        public native @Cast("Ogre::Controller<Ogre::Real>*") RealControllerRef createTextureWaveTransformer(TextureUnitState layer, @Cast("Ogre::TextureUnitState::TextureTransformType") int ttype,
                    @Cast("Ogre::WaveformType") int waveType);
        public native @Cast("Ogre::Controller<Ogre::Real>*") RealControllerRef createGpuProgramTimerParam(@ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr params, @Cast("size_t") long paramIndex,
                    double timeFactor/*=1.0f*/);
        public native @Cast("Ogre::Controller<Ogre::Real>*") RealControllerRef createGpuProgramTimerParam(@ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr params, @Cast("size_t") long paramIndex);



        public native void destroyController(@Cast("Ogre::Controller<Ogre::Real>*") RealControllerRef controller);





        public native double getTimeFactor();
        public native void setTimeFactor(double tf);





        public native double getFrameDelay();
        public native void setFrameDelay(double fd);





        public native double getElapsedTime();
        public native void setElapsedTime(double elapsedTime);
        public static native @ByRef ControllerManager getSingleton();
        public static native ControllerManager getSingletonPtr();
    }





    @Namespace("Ogre::v1") @NoOffset public static class HardwareCounterBuffer extends HardwareBuffer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareCounterBuffer(Pointer p) { super(p); }
    

            public HardwareCounterBuffer(HardwareBufferManagerBase mgr, @Cast("size_t") long sizeBytes,
                                        @Cast("Ogre::v1::HardwareBuffer::Usage") int usage, @Cast("bool") boolean useShadowBuffer/*=false*/, @Const @ByRef(nullValue = "Ogre::String(\"\")") String name) { super((Pointer)null); allocate(mgr, sizeBytes, usage, useShadowBuffer, name); }
            private native void allocate(HardwareBufferManagerBase mgr, @Cast("size_t") long sizeBytes,
                                        @Cast("Ogre::v1::HardwareBuffer::Usage") int usage, @Cast("bool") boolean useShadowBuffer/*=false*/, @Const @ByRef(nullValue = "Ogre::String(\"\")") String name);
            public HardwareCounterBuffer(HardwareBufferManagerBase mgr, @Cast("size_t") long sizeBytes,
                                        @Cast("Ogre::v1::HardwareBuffer::Usage") int usage) { super((Pointer)null); allocate(mgr, sizeBytes, usage); }
            private native void allocate(HardwareBufferManagerBase mgr, @Cast("size_t") long sizeBytes,
                                        @Cast("Ogre::v1::HardwareBuffer::Usage") int usage);

            public native HardwareBufferManagerBase getManager();

            public native @Const @ByRef String getName();

    }


    @Namespace("Ogre::v1") public static class HardwareCounterBufferSharedPtr extends HardwareCounterBufferSPtr {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareCounterBufferSharedPtr(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public HardwareCounterBufferSharedPtr(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public HardwareCounterBufferSharedPtr position(long position) {
            return (HardwareCounterBufferSharedPtr)super.position(position);
        }
    
        public HardwareCounterBufferSharedPtr() { super((Pointer)null); allocate(); }
        private native void allocate();
        public HardwareCounterBufferSharedPtr(HardwareCounterBuffer buf) { super((Pointer)null); allocate(buf); }
        private native void allocate(HardwareCounterBuffer buf);
    }



    @Namespace("Ogre::v1") @NoOffset public static class HardwareUniformBuffer extends HardwareBuffer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareUniformBuffer(Pointer p) { super(p); }
    

            public HardwareUniformBuffer(HardwareBufferManagerBase mgr, @Cast("size_t") long sizeBytes,
                                        @Cast("Ogre::v1::HardwareBuffer::Usage") int usage, @Cast("bool") boolean useShadowBuffer/*=false*/, @Const @ByRef(nullValue = "Ogre::String(\"\")") String name) { super((Pointer)null); allocate(mgr, sizeBytes, usage, useShadowBuffer, name); }
            private native void allocate(HardwareBufferManagerBase mgr, @Cast("size_t") long sizeBytes,
                                        @Cast("Ogre::v1::HardwareBuffer::Usage") int usage, @Cast("bool") boolean useShadowBuffer/*=false*/, @Const @ByRef(nullValue = "Ogre::String(\"\")") String name);
            public HardwareUniformBuffer(HardwareBufferManagerBase mgr, @Cast("size_t") long sizeBytes,
                                        @Cast("Ogre::v1::HardwareBuffer::Usage") int usage) { super((Pointer)null); allocate(mgr, sizeBytes, usage); }
            private native void allocate(HardwareBufferManagerBase mgr, @Cast("size_t") long sizeBytes,
                                        @Cast("Ogre::v1::HardwareBuffer::Usage") int usage);

            public native HardwareBufferManagerBase getManager();

            public native @Const @ByRef String getName();

    }


    @Namespace("Ogre::v1") public static class HardwareUniformBufferSharedPtr extends HardwareUniformBufferSPtr {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareUniformBufferSharedPtr(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public HardwareUniformBufferSharedPtr(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public HardwareUniformBufferSharedPtr position(long position) {
            return (HardwareUniformBufferSharedPtr)super.position(position);
        }
    
        public HardwareUniformBufferSharedPtr() { super((Pointer)null); allocate(); }
        private native void allocate();
        public HardwareUniformBufferSharedPtr(HardwareUniformBuffer buf) { super((Pointer)null); allocate(buf); }
        private native void allocate(HardwareUniformBuffer buf);
    }



    @Namespace("Ogre::v1") public static class HardwareBufferLicensee extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareBufferLicensee(Pointer p) { super(p); }
    



        public native void licenseExpired(HardwareBuffer buffer);
    }


    @Name("Ogre::TempBlendedBufferInfo") @NoOffset public static class TempBlendedBufferInfo extends HardwareBufferLicensee {
        static { Loader.load(); }
        /** Default native constructor. */
        public TempBlendedBufferInfo() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public TempBlendedBufferInfo(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public TempBlendedBufferInfo(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public TempBlendedBufferInfo position(long position) {
            return (TempBlendedBufferInfo)super.position(position);
        }
        public Pointer asPointer() { return asPointer(this); }
        @Namespace public static native @Name("static_cast<BufferAlloc*>") Pointer asPointer(TempBlendedBufferInfo pointer);
    

        public native void extractFrom(@Const VertexData sourceData);

        public native void checkoutTempCopies(@Cast("bool") boolean positions/*=true*/, @Cast("bool") boolean normals/*=true*/);
        public native void checkoutTempCopies();

        public native void bindTempCopies(VertexData targetData, @Cast("bool") boolean suppressHardwareUpload);

        public native void licenseExpired(HardwareBuffer buffer);

        public native @Cast("bool") boolean buffersCheckedOut(@Cast("bool") boolean positions/*=true*/, @Cast("bool") boolean normals/*=true*/);
        public native @Cast("bool") boolean buffersCheckedOut();
    }
    @Namespace("Ogre::v1") @NoOffset public static class HardwareBufferManagerBase extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareBufferManagerBase(Pointer p) { super(p); }
    

        /** enum Ogre::v1::HardwareBufferManagerBase::BufferLicenseType */
        public static final int

            BLT_MANUAL_RELEASE = 0,

            BLT_AUTOMATIC_RELEASE = 1;
        public native @ByVal HardwareVertexBufferSharedPtr createVertexBuffer(@Cast("size_t") long vertexSize, @Cast("size_t") long numVerts, @Cast("Ogre::v1::HardwareBuffer::Usage") int usage,
                    @Cast("bool") boolean useShadowBuffer/*=false*/);
        public native @ByVal HardwareVertexBufferSharedPtr createVertexBuffer(@Cast("size_t") long vertexSize, @Cast("size_t") long numVerts, @Cast("Ogre::v1::HardwareBuffer::Usage") int usage);
        public native @ByVal HardwareIndexBufferSharedPtr createIndexBuffer(@Cast("Ogre::v1::HardwareIndexBuffer::IndexType") int itype, @Cast("size_t") long numIndexes,
                    @Cast("Ogre::v1::HardwareBuffer::Usage") int usage, @Cast("bool") boolean useShadowBuffer/*=false*/);
        public native @ByVal HardwareIndexBufferSharedPtr createIndexBuffer(@Cast("Ogre::v1::HardwareIndexBuffer::IndexType") int itype, @Cast("size_t") long numIndexes,
                    @Cast("Ogre::v1::HardwareBuffer::Usage") int usage);





        public native @ByVal @Cast("Ogre::v1::RenderToVertexBufferSharedPtr*") RealControllerFunctionSPtr createRenderToVertexBuffer();






        public native @ByVal HardwareUniformBufferSharedPtr createUniformBuffer(@Cast("size_t") long sizeBytes,
                                            @Cast("Ogre::v1::HardwareBuffer::Usage") int usage/*=Ogre::v1::HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE*/,
                                            @Cast("bool") boolean useShadowBuffer/*=false*/, @Const @ByRef(nullValue = "Ogre::String(\"\")") String name);
        public native @ByVal HardwareUniformBufferSharedPtr createUniformBuffer(@Cast("size_t") long sizeBytes);





        public native @ByVal HardwareCounterBufferSharedPtr createCounterBuffer(@Cast("size_t") long sizeBytes,
                                                                           @Cast("Ogre::v1::HardwareBuffer::Usage") int usage/*=Ogre::v1::HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE*/,
                                                                           @Cast("bool") boolean useShadowBuffer/*=false*/, @Const @ByRef(nullValue = "Ogre::String(\"\")") String name);
        public native @ByVal HardwareCounterBufferSharedPtr createCounterBuffer(@Cast("size_t") long sizeBytes);


        public native VertexDeclaration createVertexDeclaration();

        public native void destroyVertexDeclaration(VertexDeclaration decl);


        public native VertexBufferBinding createVertexBufferBinding();

        public native void destroyVertexBufferBinding(VertexBufferBinding binding);






        public native void registerVertexBufferSourceAndCopy(
                    @Const @ByRef HardwareVertexBufferSharedPtr sourceBuffer,
                    @Const @ByRef HardwareVertexBufferSharedPtr copy);
        public native @ByVal HardwareVertexBufferSharedPtr allocateVertexBufferCopy(
                    @Const @ByRef HardwareVertexBufferSharedPtr sourceBuffer,
                    @Cast("Ogre::v1::HardwareBufferManagerBase::BufferLicenseType") int licenseType,
                    HardwareBufferLicensee licensee,
                    @Cast("bool") boolean copyData/*=false*/);
        public native @ByVal HardwareVertexBufferSharedPtr allocateVertexBufferCopy(
                    @Const @ByRef HardwareVertexBufferSharedPtr sourceBuffer,
                    @Cast("Ogre::v1::HardwareBufferManagerBase::BufferLicenseType") int licenseType,
                    HardwareBufferLicensee licensee);
        public native void releaseVertexBufferCopy(
                    @Const @ByRef HardwareVertexBufferSharedPtr bufferCopy);
        public native void touchVertexBufferCopy(@Const @ByRef HardwareVertexBufferSharedPtr bufferCopy);
        public native void _freeUnusedBufferCopies();
        public native void _releaseBufferCopies(@Cast("bool") boolean forceFreeUnused/*=false*/);
        public native void _releaseBufferCopies();
        public native void _forceReleaseBufferCopies(@Const @ByRef HardwareVertexBufferSharedPtr sourceBuffer);
        public native void _forceReleaseBufferCopies(HardwareVertexBuffer sourceBuffer);


        public native void _notifyVertexBufferDestroyed(HardwareVertexBuffer buf);

        public native void _notifyIndexBufferDestroyed(HardwareIndexBuffer buf);

        public native void _notifyUniformBufferDestroyed(HardwareUniformBuffer buf);

        public native void _notifyCounterBufferDestroyed(HardwareCounterBuffer buf);
    }


    @Namespace("Ogre::v1") @NoOffset public static class HardwareBufferManager extends HardwareBufferManagerBase {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareBufferManager(Pointer p) { super(p); }
        public HardwareBufferManagerSgtRef asHardwareBufferManagerSgtRef() { return asHardwareBufferManagerSgtRef(this); }
        @Namespace public static native @Name("static_cast<Ogre::Singleton<HardwareBufferManager>*>") HardwareBufferManagerSgtRef asHardwareBufferManagerSgtRef(HardwareBufferManager pointer);
    
        public HardwareBufferManager(HardwareBufferManagerBase imp) { super((Pointer)null); allocate(imp); }
        private native void allocate(HardwareBufferManagerBase imp);


        public native @ByVal HardwareVertexBufferSharedPtr createVertexBuffer(@Cast("size_t") long vertexSize, @Cast("size_t") long numVerts, @Cast("Ogre::v1::HardwareBuffer::Usage") int usage,
                    @Cast("bool") boolean useShadowBuffer/*=false*/);
        public native @ByVal HardwareVertexBufferSharedPtr createVertexBuffer(@Cast("size_t") long vertexSize, @Cast("size_t") long numVerts, @Cast("Ogre::v1::HardwareBuffer::Usage") int usage);

        public native @ByVal HardwareIndexBufferSharedPtr createIndexBuffer(@Cast("Ogre::v1::HardwareIndexBuffer::IndexType") int itype, @Cast("size_t") long numIndexes,
                    @Cast("Ogre::v1::HardwareBuffer::Usage") int usage, @Cast("bool") boolean useShadowBuffer/*=false*/);
        public native @ByVal HardwareIndexBufferSharedPtr createIndexBuffer(@Cast("Ogre::v1::HardwareIndexBuffer::IndexType") int itype, @Cast("size_t") long numIndexes,
                    @Cast("Ogre::v1::HardwareBuffer::Usage") int usage);


        public native @ByVal @Cast("Ogre::v1::RenderToVertexBufferSharedPtr*") RealControllerFunctionSPtr createRenderToVertexBuffer();


        public native @ByVal HardwareUniformBufferSharedPtr createUniformBuffer(@Cast("size_t") long sizeBytes, @Cast("Ogre::v1::HardwareBuffer::Usage") int usage, @Cast("bool") boolean useShadowBuffer, @Const @ByRef(nullValue = "Ogre::String(\"\")") String name);
        public native @ByVal HardwareUniformBufferSharedPtr createUniformBuffer(@Cast("size_t") long sizeBytes, @Cast("Ogre::v1::HardwareBuffer::Usage") int usage, @Cast("bool") boolean useShadowBuffer);


        public native @ByVal HardwareCounterBufferSharedPtr createCounterBuffer(@Cast("size_t") long sizeBytes, @Cast("Ogre::v1::HardwareBuffer::Usage") int usage, @Cast("bool") boolean useShadowBuffer, @Const @ByRef(nullValue = "Ogre::String(\"\")") String name);
        public native @ByVal HardwareCounterBufferSharedPtr createCounterBuffer(@Cast("size_t") long sizeBytes, @Cast("Ogre::v1::HardwareBuffer::Usage") int usage, @Cast("bool") boolean useShadowBuffer);


        public native VertexDeclaration createVertexDeclaration();

        public native void destroyVertexDeclaration(VertexDeclaration decl);


        public native VertexBufferBinding createVertexBufferBinding();

        public native void destroyVertexBufferBinding(VertexBufferBinding binding);

        public native void registerVertexBufferSourceAndCopy(
                    @Const @ByRef HardwareVertexBufferSharedPtr sourceBuffer,
                    @Const @ByRef HardwareVertexBufferSharedPtr copy);

        public native @ByVal HardwareVertexBufferSharedPtr allocateVertexBufferCopy(
                    @Const @ByRef HardwareVertexBufferSharedPtr sourceBuffer,
                    @ByVal BufferLicenseType licenseType,
                    HardwareBufferLicensee licensee,
                    @Cast("bool") boolean copyData/*=false*/);
        public native @ByVal HardwareVertexBufferSharedPtr allocateVertexBufferCopy(
                    @Const @ByRef HardwareVertexBufferSharedPtr sourceBuffer,
                    @ByVal BufferLicenseType licenseType,
                    HardwareBufferLicensee licensee);

        public native void releaseVertexBufferCopy(
                    @Const @ByRef HardwareVertexBufferSharedPtr bufferCopy);


        public native void touchVertexBufferCopy(
                    @Const @ByRef HardwareVertexBufferSharedPtr bufferCopy);


        public native void _freeUnusedBufferCopies();

        public native void _releaseBufferCopies(@Cast("bool") boolean forceFreeUnused/*=false*/);
        public native void _releaseBufferCopies();

        public native void _forceReleaseBufferCopies(
                    @Const @ByRef HardwareVertexBufferSharedPtr sourceBuffer);

        public native void _forceReleaseBufferCopies(HardwareVertexBuffer sourceBuffer);

        public native void _notifyVertexBufferDestroyed(HardwareVertexBuffer buf);

        public native void _notifyIndexBufferDestroyed(HardwareIndexBuffer buf);

        public native void _notifyUniformBufferDestroyed(HardwareUniformBuffer buf);

        public native void _notifyConterBufferDestroyed(HardwareCounterBuffer buf);
        public static native @ByRef HardwareBufferManager getSingleton();
        public static native HardwareBufferManager getSingletonPtr();

    }





    @Namespace("Ogre::v1") @NoOffset public static class SubEntity extends Renderable {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SubEntity(Pointer p) { super(p); }
        public Pointer asPointer() { return asPointer(this); }
        @Namespace public static native @Name("static_cast<SubEntityAlloc*>") Pointer asPointer(SubEntity pointer);
    






        public native void setMaterial( @Cast("const Ogre::MaterialPtr*") @ByRef RealControllerFunctionSPtr material );

        public native void setDatablock( HlmsDatablock datablock );



        public native SubMesh getSubMesh();


        public native Entity getParent();



        public native void getRenderOperation(@ByRef RenderOperation op, @Cast("bool") boolean casterPass);





        public native void setIndexDataStartIndex(@Cast("size_t") long start_index);




        public native @Cast("size_t") long getIndexDataStartIndex();





        public native void setIndexDataEndIndex(@Cast("size_t") long end_index);



        public native @Cast("size_t") long getIndexDataEndIndex();



        public native void resetIndexDataStartEndIndex();



        public native void getWorldTransforms(Matrix4 xform);


        public native @Cast("unsigned short") short getNumWorldTransforms();

        public native double getSquaredViewDepth(@Const Camera cam);

        public native @Cast("const Ogre::LightList*") @ByRef HashedVector getLights();

        public native @Cast("bool") boolean getCastsShadows();
        public native VertexData _getSkelAnimVertexData();
        public native VertexData _getSoftwareVertexAnimVertexData();




        public native VertexData _getHardwareVertexAnimVertexData();



        public native TempBlendedBufferInfo _getSkelAnimTempBufferInfo();



        public native TempBlendedBufferInfo _getVertexAnimTempBufferInfo();

        public native VertexData getVertexDataForBinding( @Cast("bool") boolean casterPass );



        public native void _markBuffersUnusedForAnimation();


        public native void _markBuffersUsedForAnimation();

        public native @Cast("bool") boolean _getBuffersMarkedForAnimation();



        public native void _restoreBuffersForUnusedAnimation(@Cast("bool") boolean hardwareAnimation);


        public native void _updateCustomGpuParameter(
                    @Const @ByRef GpuProgramParameters.AutoConstantEntry constantEntry,
                    GpuProgramParameters params);
    }





    @Namespace("Ogre::v1") @NoOffset public static class Entity extends MovableObject {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Entity(Pointer p) { super(p); }
        public ResourceListener asResourceListener() { return asResourceListener(this); }
        @Namespace public static native @Name("static_cast<Ogre::Resource::Listener*>") ResourceListener asResourceListener(Entity pointer);
    



        public native @Cast("const Ogre::MeshPtr*") @ByRef RealControllerFunctionSPtr getMesh();



        public native SubEntity getSubEntity(@Cast("size_t") long index);





        public native SubEntity getSubEntity( @Const @ByRef String name );



        public native @Cast("size_t") long getNumSubEntities();


        public native void setDatablock( HlmsDatablock datablock );


        public native void setDatablock( @ByVal IdString datablockName );
        public native Entity clone();
        public native void setDatablockOrMaterialName( @Const @ByRef String name,
                                                 @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME)") String groupName );
        public native void setDatablockOrMaterialName( @Const @ByRef String name );
        public native void setMaterialName( @Const @ByRef String name, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME)") String groupName );
        public native void setMaterialName( @Const @ByRef String name );
        public native void setMaterial(@Cast("const Ogre::MaterialPtr*") @ByRef RealControllerFunctionSPtr material);
        public native void setRenderQueueSubGroup( @Cast("Ogre::uint8") byte subGroup );


        public native void setRenderQueueGroup(@Cast("Ogre::uint8") byte queueID);



        public native void _updateRenderQueue(RenderQueue queue, Camera camera, @Const Camera lodCamera);


        public native @Const @ByRef String getMovableType();







        public native AnimationState getAnimationState(@Const @ByRef String name);

        public native @Cast("bool") boolean hasAnimationState(@Const @ByRef String name);
        public native AnimationStateSet getAllAnimationStates();



        public native void setDisplaySkeleton(@Cast("bool") boolean display);



        public native @Cast("bool") boolean getDisplaySkeleton();






        public native Entity getManualLodLevel(@Cast("size_t") long index);






        public native @Cast("size_t") long getNumManualLodLevels();




        public native void setPolygonModeOverrideable(@Cast("bool") boolean PolygonModeOverrideable);
        public native TagPoint attachObjectToBone(@Const @ByRef String boneName,
                    MovableObject pMovable,
                    @Const @ByRef(nullValue = "Ogre::Quaternion::IDENTITY") Quaternion offsetOrientation,
                    @Const @ByRef(nullValue = "Ogre::Vector3::ZERO") Vector3 offsetPosition);
        public native TagPoint attachObjectToBone(@Const @ByRef String boneName,
                    MovableObject pMovable);






        public native MovableObject detachObjectFromBone(@Const @ByRef String movableName);







        public native void detachObjectFromBone(MovableObject obj);


        public native void detachAllObjectsFromBone();
        public native EdgeData getEdgeList();

        public native @Cast("bool") boolean hasEdgeList();


        public native @Const Matrix4 _getBoneMatrices();

        public native @Cast("unsigned short") short _getNumBoneMatrices();

        public native @Cast("bool") boolean hasSkeleton();

        public native OldSkeletonInstance getSkeleton();
        public native @Cast("bool") boolean isHardwareAnimationEnabled();


        public native void _notifyAttached( Node parent );







        public native int getSoftwareAnimationRequests();
        public native int getSoftwareAnimationNormalsRequests();
        public native void addSoftwareAnimationRequest(@Cast("bool") boolean normalsAlso);
        public native void removeSoftwareAnimationRequest(@Cast("bool") boolean normalsAlso);





        public native void shareSkeletonInstanceWith(Entity entity);



        public native @Cast("bool") boolean hasVertexAnimation();




        public native void stopSharingSkeletonInstance();




        public native @Cast("bool") boolean sharesSkeletonInstance();




        public native @Cast("const Ogre::v1::Entity::EntitySet*") EntityPtrSetRef getSkeletonInstanceSharingSet();
        public native void refreshAvailableAnimationState();
        public native void _updateAnimation();






        public native @Cast("bool") boolean _isAnimated();



        public native @Cast("bool") boolean _isSkeletonAnimated();
        public native VertexData _getSkelAnimVertexData();
        public native VertexData _getSoftwareVertexAnimVertexData();




        public native VertexData _getHardwareVertexAnimVertexData();



        public native TempBlendedBufferInfo _getSkelAnimTempBufferInfo();



        public native TempBlendedBufferInfo _getVertexAnimTempBufferInfo();

        public native @Cast("Ogre::uint32") int getTypeFlags();

        public native VertexData getVertexDataForBinding( @Cast("bool") boolean casterPass );


        /** enum Ogre::v1::Entity::VertexDataBindChoice */
        public static final int
            BIND_ORIGINAL = 0,
            BIND_SOFTWARE_SKELETAL = 1,
            BIND_SOFTWARE_MORPH = 2,
            BIND_HARDWARE_MORPH = 3;

        public native @Cast("Ogre::v1::Entity::VertexDataBindChoice") int chooseVertexDataForBinding(@Cast("bool") boolean hasVertexAnim);


        public native @Cast("bool") boolean _getBuffersMarkedForAnimation();


        public native void _markBuffersUsedForAnimation();
        public native @Cast("bool") boolean isInitialised();
        public native void _initialise(@Cast("bool") boolean forceReinitialise/*=false*/);
        public native void _initialise();

        public native void _deinitialise();




        public native void setSkipAnimationStateUpdate(@Cast("bool") boolean skip);




        public native @Cast("bool") boolean getSkipAnimationStateUpdate();





        public native void setAlwaysUpdateMainSkeleton(@Cast("bool") boolean update);





        public native @Cast("bool") boolean getAlwaysUpdateMainSkeleton();
        public native void setUpdateBoundingBoxFromSkeleton(@Cast("bool") boolean update);





        public native @Cast("bool") boolean getUpdateBoundingBoxFromSkeleton();


    }


    @Namespace("Ogre::v1") @NoOffset public static class EntityFactory extends MovableObjectFactory {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public EntityFactory(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public EntityFactory(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public EntityFactory position(long position) {
            return (EntityFactory)super.position(position);
        }
    
        public EntityFactory() { super((Pointer)null); allocate(); }
        private native void allocate();

        public static native @ByRef String FACTORY_TYPE_NAME(); public static native void FACTORY_TYPE_NAME(String FACTORY_TYPE_NAME);

        public native @Const @ByRef String getType();
        public native void destroyInstance( MovableObject obj);

    }





    @Namespace("Ogre") public static class FrameEvent extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public FrameEvent() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public FrameEvent(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public FrameEvent(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public FrameEvent position(long position) {
            return (FrameEvent)super.position(position);
        }
    







        public native double timeSinceLastEvent(); public native FrameEvent timeSinceLastEvent(double timeSinceLastEvent);






        public native double timeSinceLastFrame(); public native FrameEvent timeSinceLastFrame(double timeSinceLastFrame);
    }
    @Namespace("Ogre") public static class FrameListener extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public FrameListener() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public FrameListener(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public FrameListener(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public FrameListener position(long position) {
            return (FrameListener)super.position(position);
        }
    







        public native @Cast("bool") boolean frameStarted(@Const @ByRef FrameEvent evt);
        public native @Cast("bool") boolean frameRenderingQueued(@Const @ByRef FrameEvent evt);
        public native @Cast("bool") boolean frameEnded(@Const @ByRef FrameEvent evt);

    }



    @Namespace("Ogre") public static class ScriptLoader extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ScriptLoader(Pointer p) { super(p); }
    
        public native @Cast("const Ogre::StringVector*") @ByRef StringVectorRef getScriptPatterns();






        public native void parseScript(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream, @Const @ByRef String groupName);
        public native double getLoadingOrder();

    }








    @Name("Ogre::Pool<Ogre::ResourcePtr>") @NoOffset public static class ResourcePtrPoolRef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ResourcePtrPoolRef(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ResourcePtrPoolRef(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ResourcePtrPoolRef position(long position) {
            return (ResourcePtrPoolRef)super.position(position);
        }
    
        public ResourcePtrPoolRef() { super((Pointer)null); allocate(); }
        private native void allocate();




        public native @ByVal @Cast("std::pair<bool,Ogre::ResourcePtr>*") ResourcePtrPairRef removeItem();



        public native void addItem(@Cast("const Ogre::ResourcePtr*") @ByRef RealControllerFunctionSPtr i);

        public native void clear();
    }
    @Namespace("Ogre") @NoOffset public static class ResourceManager extends ScriptLoader {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ResourceManager(Pointer p) { super(p); }
        public Pointer asPointer() { return asPointer(this); }
        @Namespace public static native @Name("static_cast<ResourceAlloc*>") Pointer asPointer(ResourceManager pointer);
    
        public native @ByVal @Cast("Ogre::ResourcePtr*") RealControllerFunctionSPtr createResource(@Const @ByRef String name, @Const @ByRef String group,
                    @Cast("bool") boolean isManual/*=false*/, ManualResourceLoader loader/*=0*/,
                    @Cast("const Ogre::NameValuePairList*") SStringMapRef createParams/*=0*/);
        public native @ByVal @Cast("Ogre::ResourcePtr*") RealControllerFunctionSPtr createResource(@Const @ByRef String name, @Const @ByRef String group);
        public native @ByVal @Cast("Ogre::ResourceManager::ResourceCreateOrRetrieveResult*") RealPairRef createOrRetrieve(@Const @ByRef String name,
                    @Const @ByRef String group, @Cast("bool") boolean isManual/*=false*/,
                    ManualResourceLoader loader/*=0*/,
                    @Cast("const Ogre::NameValuePairList*") SStringMapRef createParams/*=0*/);
        public native @ByVal @Cast("Ogre::ResourceManager::ResourceCreateOrRetrieveResult*") RealPairRef createOrRetrieve(@Const @ByRef String name,
                    @Const @ByRef String group);
        public native void setMemoryBudget(@Cast("size_t") long bytes);



        public native @Cast("size_t") long getMemoryBudget();


        public native @Cast("size_t") long getMemoryUsage();







        public native void unload(@Const @ByRef String name);







        public native void unload(@Cast("Ogre::ResourceHandle") long handle);
        public native void unloadAll(@Cast("bool") boolean reloadableOnly/*=true*/);
        public native void unloadAll();
        public native void reloadAll(@Cast("bool") boolean reloadableOnly/*=true*/);
        public native void reloadAll();
        public native void unloadUnreferencedResources(@Cast("bool") boolean reloadableOnly/*=true*/);
        public native void unloadUnreferencedResources();
        public native void reloadUnreferencedResources(@Cast("bool") boolean reloadableOnly/*=true*/);
        public native void reloadUnreferencedResources();
        public native void remove(@Cast("Ogre::ResourcePtr*") @ByRef RealControllerFunctionSPtr r);
        public native void remove(@Const @ByRef String name);
        public native void remove(@Cast("Ogre::ResourceHandle") long handle);
        public native void removeAll();
        public native void removeUnreferencedResources(@Cast("bool") boolean reloadableOnly/*=true*/);
        public native void removeUnreferencedResources();



        public native @ByVal @Cast("Ogre::ResourcePtr*") RealControllerFunctionSPtr getResourceByName(@Const @ByRef String name, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME)") String groupName);
        public native @ByVal @Cast("Ogre::ResourcePtr*") RealControllerFunctionSPtr getResourceByName(@Const @ByRef String name);


        public native @ByVal @Cast("Ogre::ResourcePtr*") RealControllerFunctionSPtr getByHandle(@Cast("Ogre::ResourceHandle") long handle);


        public native @Cast("bool") boolean resourceExists(@Const @ByRef String name);

        public native @Cast("bool") boolean resourceExists(@Cast("Ogre::ResourceHandle") long handle);




        public native void _notifyResourceTouched(Resource res);




        public native void _notifyResourceLoaded(Resource res);




        public native void _notifyResourceUnloaded(Resource res);
        public native @ByVal @Cast("Ogre::ResourcePtr*") RealControllerFunctionSPtr prepare(@Const @ByRef String name,
                    @Const @ByRef String group, @Cast("bool") boolean isManual/*=false*/,
                    ManualResourceLoader loader/*=0*/, @Cast("const Ogre::NameValuePairList*") SStringMapRef loadParams/*=0*/,
                    @Cast("bool") boolean backgroundThread/*=false*/);
        public native @ByVal @Cast("Ogre::ResourcePtr*") RealControllerFunctionSPtr prepare(@Const @ByRef String name,
                    @Const @ByRef String group);
        public native @ByVal @Cast("Ogre::ResourcePtr*") RealControllerFunctionSPtr load(@Const @ByRef String name,
                    @Const @ByRef String group, @Cast("bool") boolean isManual/*=false*/,
                    ManualResourceLoader loader/*=0*/, @Cast("const Ogre::NameValuePairList*") SStringMapRef loadParams/*=0*/,
                    @Cast("bool") boolean backgroundThread/*=false*/);
        public native @ByVal @Cast("Ogre::ResourcePtr*") RealControllerFunctionSPtr load(@Const @ByRef String name,
                    @Const @ByRef String group);
        public native @Cast("const Ogre::StringVector*") @ByRef StringVectorRef getScriptPatterns();
        public native void parseScript(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream, @Const @ByRef String groupName);







        public native double getLoadingOrder();


        public native @Const @ByRef String getResourceType();


        public native void setVerbose(@Cast("bool") boolean v);


        public native @Cast("bool") boolean getVerbose();







        @NoOffset public static class ResourcePool extends ResourcePtrPoolRef {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public ResourcePool(Pointer p) { super(p); }
            public Pointer asPointer() { return asPointer(this); }
            @Namespace public static native @Name("static_cast<ResourceAlloc*>") Pointer asPointer(ResourceManager.ResourcePool pointer);
        
            public ResourcePool(@Const @ByRef String name) { super((Pointer)null); allocate(name); }
            private native void allocate(@Const @ByRef String name);

            public native @Const @ByRef String getName();
            public native void clear();
        }


        public native ResourcePool getResourcePool(@Const @ByRef String name);

        public native void destroyResourcePool(ResourcePool pool);

        public native void destroyResourcePool(@Const @ByRef String name);

        public native void destroyAllResourcePools();




        public native @ByVal @Cast("Ogre::ResourceManager::ResourceMapIterator*") AnimationStateMapIteratorRef getResourceIterator();
    }





    @Namespace("Ogre") @NoOffset public static class GpuProgramManager extends ResourceManager {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public GpuProgramManager(Pointer p) { super(p); }
        public GpuProgramManagerSgtRef asGpuProgramManagerSgtRef() { return asGpuProgramManagerSgtRef(this); }
        @Namespace public static native @Name("static_cast<Ogre::Singleton<Ogre::GpuProgramManager>*>") GpuProgramManagerSgtRef asGpuProgramManagerSgtRef(GpuProgramManager pointer);
    

        public static class Hash extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public Hash() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public Hash(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Hash(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public Hash position(long position) {
                return (Hash)super.position(position);
            }
        
            public native @Cast("Ogre::uint64") long hashVal(int i); public native Hash hashVal(int i, long hashVal);
            @MemberGetter public native @Cast("Ogre::uint64*") LongPointer hashVal();

            public native @Cast("bool") @Name("operator <") boolean lessThan( @Const @ByRef Hash _r );
        }



        public native @ByVal @Cast("Ogre::GpuProgramPtr*") RealControllerFunctionSPtr getByName(@Const @ByRef String name, @Cast("bool") boolean preferHighLevelPrograms/*=true*/);
        public native @ByVal @Cast("Ogre::GpuProgramPtr*") RealControllerFunctionSPtr getByName(@Const @ByRef String name);
        public native @ByVal @Cast("Ogre::GpuProgramPtr*") RealControllerFunctionSPtr load(@Const @ByRef String name, @Const @ByRef String groupName,
                    @Const @ByRef String filename, @Cast("Ogre::GpuProgramType") int gptype,
                    @Const @ByRef String syntaxCode);
        public native @ByVal @Cast("Ogre::GpuProgramPtr*") RealControllerFunctionSPtr loadFromString(@Const @ByRef String name, @Const @ByRef String groupName,
                    @Const @ByRef String code, @Cast("Ogre::GpuProgramType") int gptype,
                    @Const @ByRef String syntaxCode);


        public native @Cast("const Ogre::GpuProgramManager::SyntaxCodes*") @ByRef StringSetRef getSupportedSyntax();



        public native @Cast("bool") boolean isSyntaxSupported(@Const @ByRef String syntaxCode);






        public native @ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr createParameters();
        public native @ByVal @Cast("Ogre::GpuProgramPtr*") RealControllerFunctionSPtr createProgram(@Const @ByRef String name,
                    @Const @ByRef String groupName, @Const @ByRef String filename,
                    @Cast("Ogre::GpuProgramType") int gptype, @Const @ByRef String syntaxCode);
        public native @ByVal @Cast("Ogre::GpuProgramPtr*") RealControllerFunctionSPtr createProgramFromString(@Const @ByRef String name,
                    @Const @ByRef String groupName, @Const @ByRef String code,
                    @Cast("Ogre::GpuProgramType") int gptype, @Const @ByRef String syntaxCode);




        public native @ByVal @Cast("Ogre::ResourcePtr*") RealControllerFunctionSPtr create(@Const @ByRef String name, @Const @ByRef String group,
                    @Cast("Ogre::GpuProgramType") int gptype, @Const @ByRef String syntaxCode, @Cast("bool") boolean isManual/*=false*/,
                    ManualResourceLoader loader/*=0*/);
        public native @ByVal @Cast("Ogre::ResourcePtr*") RealControllerFunctionSPtr create(@Const @ByRef String name, @Const @ByRef String group,
                    @Cast("Ogre::GpuProgramType") int gptype, @Const @ByRef String syntaxCode);






        public native @ByVal @Cast("Ogre::ResourcePtr*") RealControllerFunctionSPtr getResourceByName(@Const @ByRef String name, @Cast("bool") boolean preferHighLevelPrograms/*=true*/);
        public native @ByVal @Cast("Ogre::ResourcePtr*") RealControllerFunctionSPtr getResourceByName(@Const @ByRef String name);







        public native @ByVal @Cast("Ogre::GpuSharedParametersPtr*") RealControllerFunctionSPtr createSharedParameters(@Const @ByRef String name);




        public native @ByVal @Cast("Ogre::GpuSharedParametersPtr*") RealControllerFunctionSPtr getSharedParameters(@Const @ByRef String name);



        public native @Cast("const Ogre::GpuProgramManager::SharedParametersMap*") @ByRef GpuSharedParametersPtrMapRef getAvailableSharedParameters();



        public native @Cast("bool") boolean getSaveMicrocodesToCache();


        public native void setSaveMicrocodesToCache( @Cast("const bool") boolean val );



        public native @Cast("bool") boolean isCacheDirty();

        public native @Cast("bool") boolean canGetCompiledShaderBuffer();



        public native @Cast("bool") boolean isMicrocodeAvailableInCache( @Const @ByRef String source );



        public native @Cast("const Ogre::GpuProgramManager::Microcode*") @ByRef RealControllerFunctionSPtr getMicrocodeFromCache( @Const @ByRef String source );




        public native @ByVal @Cast("Ogre::GpuProgramManager::Microcode*") RealControllerFunctionSPtr createMicrocode( @Cast("const Ogre::uint32") int size );




        public native void addMicrocodeToCache( @Const @ByRef String source, @Cast("const Ogre::GpuProgramManager::Microcode*") @ByRef RealControllerFunctionSPtr microcode );




        public native void removeMicrocodeFromCache( @Const @ByRef String source );




        public native void saveMicrocodeCache( @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr stream );



        public native void loadMicrocodeCache( @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr stream );


        public native void clearMicrocodeCache();
        public static native @ByRef GpuProgramManager getSingleton();
        public static native GpuProgramManager getSingletonPtr();



    }











    @Namespace("Ogre") @NoOffset public static class PixelBox extends Box {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public PixelBox(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public PixelBox(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public PixelBox position(long position) {
            return (PixelBox)super.position(position);
        }
        public Pointer asPointer() { return asPointer(this); }
        @Namespace public static native @Name("static_cast<ImageAlloc*>") Pointer asPointer(PixelBox pointer);
    

        public PixelBox() { super((Pointer)null); allocate(); }
        private native void allocate();







        public PixelBox(@Const @ByRef Box extents, @Cast("Ogre::PixelFormat") int pixelFormat, Pointer pixelData/*=0*/) { super((Pointer)null); allocate(extents, pixelFormat, pixelData); }
        private native void allocate(@Const @ByRef Box extents, @Cast("Ogre::PixelFormat") int pixelFormat, Pointer pixelData/*=0*/);
        public PixelBox(@Const @ByRef Box extents, @Cast("Ogre::PixelFormat") int pixelFormat) { super((Pointer)null); allocate(extents, pixelFormat); }
        private native void allocate(@Const @ByRef Box extents, @Cast("Ogre::PixelFormat") int pixelFormat);
        public PixelBox(@Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height, @Cast("Ogre::uint32") int depth, @Cast("Ogre::PixelFormat") int pixelFormat, Pointer pixelData/*=0*/) { super((Pointer)null); allocate(width, height, depth, pixelFormat, pixelData); }
        private native void allocate(@Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height, @Cast("Ogre::uint32") int depth, @Cast("Ogre::PixelFormat") int pixelFormat, Pointer pixelData/*=0*/);
        public PixelBox(@Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height, @Cast("Ogre::uint32") int depth, @Cast("Ogre::PixelFormat") int pixelFormat) { super((Pointer)null); allocate(width, height, depth, pixelFormat); }
        private native void allocate(@Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height, @Cast("Ogre::uint32") int depth, @Cast("Ogre::PixelFormat") int pixelFormat);


        public native Pointer data(); public native PixelBox data(Pointer data);

        public native @Cast("Ogre::PixelFormat") int format(); public native PixelBox format(int format);






        public native @Cast("size_t") long rowPitch(); public native PixelBox rowPitch(long rowPitch);







        public native @Cast("size_t") long slicePitch(); public native PixelBox slicePitch(long slicePitch);


        public native @Cast("size_t") long rowPitchAlwaysBytes();

        public native @Cast("size_t") long slicePitchAlwaysBytes();




        public native void setConsecutive();







        public native @Cast("size_t") long getRowSkip();







        public native @Cast("size_t") long getSliceSkip();


        public native @Cast("size_t") long getSliceSkipAlwaysBytes();




        public native @Cast("bool") boolean isConsecutive();




        public native @Cast("size_t") long getConsecutiveSize();
        public native @ByVal PixelBox getSubVolume(@Const @ByRef Box def);




        public native Pointer getTopLeftFrontPixelPtr();






        public native @ByVal ColourValue getColourAt(@Cast("size_t") long x, @Cast("size_t") long y, @Cast("size_t") long z);






        public native void setColourAt(@Const({false, true}) @ByRef ColourValue cv, @Cast("size_t") long x, @Cast("size_t") long y, @Cast("size_t") long z);
    }





    @Namespace("Ogre::v1") @NoOffset public static class HardwarePixelBuffer extends HardwareBuffer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwarePixelBuffer(Pointer p) { super(p); }
    







        public native @Const @ByRef PixelBox lock(@Const @ByRef Box lockBox, @ByVal LockOptions options);

        public native Pointer lock(@Cast("size_t") long offset, @Cast("size_t") long length, @ByVal LockOptions options, @ByVal(nullValue = "UploadOptions(HBU_DEFAULT)") UploadOptions uploadOpt);
        public native Pointer lock(@Cast("size_t") long offset, @Cast("size_t") long length, @ByVal LockOptions options);





        public native @Const @ByRef PixelBox getCurrentLock();


        public native void readData(@Cast("size_t") long offset, @Cast("size_t") long length, Pointer pDest);

        public native void writeData(@Cast("size_t") long offset, @Cast("size_t") long length, @Const Pointer pSource,
                        @Cast("bool") boolean discardWholeBuffer/*=false*/);
        public native void writeData(@Cast("size_t") long offset, @Cast("size_t") long length, @Const Pointer pSource);
        public native void blit(@Const @ByRef HardwarePixelBufferSharedPtr src, @Const @ByRef Box srcBox, @Const @ByRef Box dstBox);






        public native void blit(@Const @ByRef HardwarePixelBufferSharedPtr src);
        public native void blitFromMemory(@Const @ByRef PixelBox src, @Const @ByRef Box dstBox);






        public native void blitFromMemory(@Const @ByRef PixelBox src);
        public native void blitToMemory(@Const @ByRef Box srcBox, @Const @ByRef PixelBox dst);






        public native void blitToMemory(@Const @ByRef PixelBox dst);
        public native @Cast("Ogre::RenderTexture*") RenderTexture getRenderTarget(@Cast("size_t") long slice/*=0*/);
        public native @Cast("Ogre::RenderTexture*") RenderTexture getRenderTarget();


        public native @Cast("Ogre::uint32") int getWidth();

        public native @Cast("Ogre::uint32") int getHeight();

        public native @Cast("Ogre::uint32") int getDepth();

        public native @Cast("Ogre::PixelFormat") int getFormat();
    }


    @Namespace("Ogre::v1") public static class HardwarePixelBufferSharedPtr extends HardwarePixelBufferSPtr {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwarePixelBufferSharedPtr(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public HardwarePixelBufferSharedPtr(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public HardwarePixelBufferSharedPtr position(long position) {
            return (HardwarePixelBufferSharedPtr)super.position(position);
        }
    
        public HardwarePixelBufferSharedPtr() { super((Pointer)null); allocate(); }
        private native void allocate();
        public HardwarePixelBufferSharedPtr(HardwarePixelBuffer buf) { super((Pointer)null); allocate(buf); }
        private native void allocate(HardwarePixelBuffer buf);


    }





    @Namespace("Ogre") @NoOffset public static class HardwareOcclusionQuery extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HardwareOcclusionQuery(Pointer p) { super(p); }
    
    public native void beginOcclusionQuery();




    public native void endOcclusionQuery();
    public native @Cast("bool") boolean pullOcclusionQuery(@Cast("unsigned int*") IntPointer NumOfFragments);
    public native @Cast("bool") boolean pullOcclusionQuery(@Cast("unsigned int*") IntBuffer NumOfFragments);
    public native @Cast("bool") boolean pullOcclusionQuery(@Cast("unsigned int*") int[] NumOfFragments);






    public native @Cast("unsigned int") int getLastQuerysPixelcount();





     public native @Cast("bool") boolean isStillOutstanding();
}




    @Namespace("Ogre") @NoOffset public static class HighLevelGpuProgram extends GpuProgram {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HighLevelGpuProgram(Pointer p) { super(p); }
    
        public native @ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr createParameters();

        public native GpuProgram _getBindingDelegate();





        public native @Const @ByRef GpuNamedConstants getConstantDefinitions();

        public native @Cast("size_t") long calculateSize();




    }




    @Namespace("Ogre") public static class HighLevelGpuProgramFactory extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HighLevelGpuProgramFactory(Pointer p) { super(p); }
    

        public native @Const @ByRef String getLanguage();
        public native HighLevelGpuProgram create(ResourceManager creator,
                    @Const @ByRef String name, @Cast("Ogre::ResourceHandle") long handle,
                    @Const @ByRef String group, @Cast("bool") boolean isManual, ManualResourceLoader loader);
        public native void destroy(HighLevelGpuProgram prog);
    }
    @Namespace("Ogre") @NoOffset public static class HighLevelGpuProgramManager extends ResourceManager {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public HighLevelGpuProgramManager(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public HighLevelGpuProgramManager(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public HighLevelGpuProgramManager position(long position) {
            return (HighLevelGpuProgramManager)super.position(position);
        }
        public HighLevelGpuProgramManagerSgtRef asHighLevelGpuProgramManagerSgtRef() { return asHighLevelGpuProgramManagerSgtRef(this); }
        @Namespace public static native @Name("static_cast<Ogre::Singleton<Ogre::HighLevelGpuProgramManager>*>") HighLevelGpuProgramManagerSgtRef asHighLevelGpuProgramManagerSgtRef(HighLevelGpuProgramManager pointer);
    
        public HighLevelGpuProgramManager() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native void addFactory(HighLevelGpuProgramFactory factory);

        public native void removeFactory(HighLevelGpuProgramFactory factory);


        public native @Cast("bool") boolean isLanguageSupported(@Const @ByRef String lang);



        public native @ByVal @Cast("Ogre::HighLevelGpuProgramPtr*") RealControllerFunctionSPtr getByName(@Const @ByRef String name, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME)") String groupName);
        public native @ByVal @Cast("Ogre::HighLevelGpuProgramPtr*") RealControllerFunctionSPtr getByName(@Const @ByRef String name);
        public native @ByVal @Cast("Ogre::HighLevelGpuProgramPtr*") RealControllerFunctionSPtr createProgram(
                    @Const @ByRef String name, @Const @ByRef String groupName,
                    @Const @ByRef String language, @Cast("Ogre::GpuProgramType") int gptype);
        public static native @ByRef HighLevelGpuProgramManager getSingleton();
        public static native HighLevelGpuProgramManager getSingletonPtr();


    }











    @Namespace("Ogre::v1") @NoOffset public static class RenderOperation extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderOperation(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public RenderOperation(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public RenderOperation position(long position) {
            return (RenderOperation)super.position(position);
        }
    

        /** enum Ogre::v1::RenderOperation::OperationType */
        public static final int

            OT_POINT_LIST = 1,

            OT_LINE_LIST = 2,

            OT_LINE_STRIP = 3,

            OT_TRIANGLE_LIST = 4,

            OT_TRIANGLE_STRIP = 5,

            OT_TRIANGLE_FAN = 6,

            OT_PATCH_1_CONTROL_POINT = 7,
            OT_PATCH_2_CONTROL_POINT = 8,
            OT_PATCH_3_CONTROL_POINT = 9,
            OT_PATCH_4_CONTROL_POINT = 10,
            OT_PATCH_5_CONTROL_POINT = 11,
            OT_PATCH_6_CONTROL_POINT = 12,
            OT_PATCH_7_CONTROL_POINT = 13,
            OT_PATCH_8_CONTROL_POINT = 14,
            OT_PATCH_9_CONTROL_POINT = 15,
            OT_PATCH_10_CONTROL_POINT = 16,
            OT_PATCH_11_CONTROL_POINT = 17,
            OT_PATCH_12_CONTROL_POINT = 18,
            OT_PATCH_13_CONTROL_POINT = 19,
            OT_PATCH_14_CONTROL_POINT = 20,
            OT_PATCH_15_CONTROL_POINT = 21,
            OT_PATCH_16_CONTROL_POINT = 22,
            OT_PATCH_17_CONTROL_POINT = 23,
            OT_PATCH_18_CONTROL_POINT = 24,
            OT_PATCH_19_CONTROL_POINT = 25,
            OT_PATCH_20_CONTROL_POINT = 26,
            OT_PATCH_21_CONTROL_POINT = 27,
            OT_PATCH_22_CONTROL_POINT = 28,
            OT_PATCH_23_CONTROL_POINT = 29,
            OT_PATCH_24_CONTROL_POINT = 30,
            OT_PATCH_25_CONTROL_POINT = 31,
            OT_PATCH_26_CONTROL_POINT = 32,
            OT_PATCH_27_CONTROL_POINT = 33,
            OT_PATCH_28_CONTROL_POINT = 34,
            OT_PATCH_29_CONTROL_POINT = 35,
            OT_PATCH_30_CONTROL_POINT = 36,
            OT_PATCH_31_CONTROL_POINT = 37,
            OT_PATCH_32_CONTROL_POINT = 38;

        public static native @ByRef @Cast("Ogre::AtomicScalar<Ogre::uint32>*") UInt32AtomicScalarRef MeshIndexId(); public static native void MeshIndexId(UInt32AtomicScalarRef MeshIndexId);
        public native @Cast("Ogre::uint32") int meshIndex(); public native RenderOperation meshIndex(int meshIndex);


        public native VertexData vertexData(); public native RenderOperation vertexData(VertexData vertexData);


        public native @Cast("Ogre::v1::RenderOperation::OperationType") int operationType(); public native RenderOperation operationType(int operationType);





        public native @Cast("bool") boolean useIndexes(); public native RenderOperation useIndexes(boolean useIndexes);


        public native IndexData indexData(); public native RenderOperation indexData(IndexData indexData);
        public native @Cast("size_t") long numberOfInstances(); public native RenderOperation numberOfInstances(long numberOfInstances);


        public native @Cast("bool") boolean renderToVertexBuffer(); public native RenderOperation renderToVertexBuffer(boolean renderToVertexBuffer);



        public native @Cast("bool") boolean useGlobalInstancingVertexBufferIsAvailable(); public native RenderOperation useGlobalInstancingVertexBufferIsAvailable(boolean useGlobalInstancingVertexBufferIsAvailable);

    public RenderOperation() { super((Pointer)null); allocate(); }
    private native void allocate();


    }




    /** enum Ogre::SceneMemoryMgrTypes */
    ;
    @Namespace("Ogre") @NoOffset public static class ObjectMemoryManager extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ObjectMemoryManager(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ObjectMemoryManager(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ObjectMemoryManager position(long position) {
            return (ObjectMemoryManager)super.position(position);
        }
    
        public ObjectMemoryManager() { super((Pointer)null); allocate(); }
        private native void allocate();


        public native void _setTwin( @Cast("Ogre::SceneMemoryMgrTypes") int memoryManagerType, ObjectMemoryManager twinMemoryManager );


        public native ObjectMemoryManager getTwin();
        public native @Cast("Ogre::SceneMemoryMgrTypes") int getMemoryManagerType();







        public native void objectCreated( @ByRef ObjectData outObjectData, @Cast("size_t") long renderQueue );
        public native void objectMoved( @ByRef ObjectData inOutObjectData, @Cast("size_t") long oldRenderQueue, @Cast("size_t") long newRenderQueue );







        public native void objectDestroyed( @ByRef ObjectData outObjectData, @Cast("size_t") long renderQueue );
        public native void migrateTo( @ByRef ObjectData inOutTransform, @Cast("size_t") long renderQueue,
                                ObjectMemoryManager dstObjectMemoryManager );






        public native @Cast("size_t") long getNumRenderQueues();

        public native @Cast("size_t") long _getTotalRenderQueues();
        public native @Cast("size_t") long getTotalNumObjects();


        public native SceneNode _getDummyNode();
        public native @Cast("size_t") long getFirstObjectData( @ByRef ObjectData outObjectData, @Cast("size_t") long renderQueue );


        public native void buildDiffList( @Cast("Ogre::ArrayMemoryManager::ManagerType") int managerType, @Cast("Ogre::uint16") short level,
                                            @Cast("const Ogre::MemoryPoolVec*") @ByRef CharPtrVectorRef basePtrs,
                                            @Cast("Ogre::ArrayMemoryManager::PtrdiffVec*") @ByRef CharPtrVectorRef outDiffsList );
        public native void applyRebase( @Cast("Ogre::ArrayMemoryManager::ManagerType") int managerType, @Cast("Ogre::uint16") short level,
                                            @Cast("const Ogre::MemoryPoolVec*") @ByRef CharPtrVectorRef newBasePtrs,
                                            @Cast("const Ogre::ArrayMemoryManager::PtrdiffVec*") @ByRef CharPtrVectorRef diffsList );
        public native void performCleanup( @Cast("Ogre::ArrayMemoryManager::ManagerType") int managerType, @Cast("Ogre::uint16") short level,
                                             @Cast("const Ogre::MemoryPoolVec*") @ByRef CharPtrVectorRef basePtrs, @Cast("size_t const*") SizeTPointer elementsMemSizes,
                                             @Cast("size_t") long startInstance, @Cast("size_t") long diffInstances );
    }




    @Name("Ogre::InstanceBatch") @NoOffset public static class InstanceBatch extends Renderable {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public InstanceBatch(Pointer p) { super(p); }
        public MovableObject asMovableObject() { return asMovableObject(this); }
        @Namespace public static native @Name("static_cast<Ogre::MovableObject*>") MovableObject asMovableObject(InstanceBatch pointer);
    

        /** enum Ogre::InstanceBatch::SkeletalAnimationMode */
        public static final int
            SKELETONS_NOT_SUPPORTED = 0,
            SKELETONS_SUPPORTED = 1,
            SKELETONS_LUT = 2;

        public native @Cast("Ogre::MeshPtr*") @ByRef RealControllerFunctionSPtr _getMeshRef();



        public native void _setInstancesPerBatch( @Cast("size_t") long instancesPerBatch );

        public native @Cast("const Ogre::Mesh::IndexMap*") UshortFastArrayRef _getIndexToBoneMap();







        public native @Cast("Ogre::InstanceBatch::SkeletalAnimationMode") int _supportsSkeletalAnimation();



        public native void _updateAnimations();







        public native void _updateEntitiesBoundsThread( @Cast("size_t") long threadIdx );


        public native void _updateBounds();
        public native @Cast("size_t") long calculateMaxNumInstances( @Const SubMesh baseSubMesh, @Cast("Ogre::uint16") short flags );
        public native @ByVal RenderOperation build( @Const SubMesh baseSubMesh );
        public native void buildFrom( @Const SubMesh baseSubMesh, @Const @ByRef RenderOperation renderOperation );

        public native @Const @ByRef MeshPtr _getMeshReference();




        public native @Cast("bool") boolean isBatchFull();



        public native @Cast("bool") boolean isBatchUnused();




        public native void getInstancedEntitiesInUse( @Cast("Ogre::InstanceBatch::InstancedEntityVec*") @ByRef InstancedEntityPtrVectorRef outEntities, @Cast("Ogre::InstanceBatch::CustomParamsVec*") @ByRef Vector4VectorRef outParams );



        public native void _addAnimatedInstance( InstancedEntity instancedEntity );





        public native void _removeAnimatedInstance( @Const InstancedEntity instancedEntity );
        public native void _defragmentBatch( @Cast("bool") boolean optimizeCulling, @Cast("Ogre::InstanceBatch::InstancedEntityVec*") @ByRef InstancedEntityPtrVectorRef usedEntities,
                                        @Cast("Ogre::InstanceBatch::CustomParamsVec*") @ByRef Vector4VectorRef usedParams );






        public native void _defragmentBatchDiscard();
        public native @Cast("bool") boolean setStatic( @Cast("bool") boolean bStatic );




        public native void _notifyStaticDirty();







        public native InstancedEntity createInstancedEntity();







        public native void removeInstancedEntity( InstancedEntity instancedEntity );





        public native @Cast("bool") boolean useBoneWorldMatrices();



        public native void _markTransformSharingDirty();


        public native void _setCustomParam( InstancedEntity instancedEntity, @Cast("unsigned char") byte idx, @Const @ByRef Vector4 newParam );


        public native @Const @ByRef Vector4 _getCustomParam( InstancedEntity instancedEntity, @Cast("unsigned char") byte idx );



        public native void getRenderOperation( @ByRef RenderOperation op, @Cast("bool") boolean casterPass );


        public native double getSquaredViewDepth( @Const Camera cam );

        public native @Cast("const Ogre::LightList*") @ByRef HashedVector getLights( );


        public native @Const @ByRef String getMovableType();
    }


    @Namespace("Ogre") @NoOffset public static class DualQuaternion extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public DualQuaternion(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public DualQuaternion(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public DualQuaternion position(long position) {
            return (DualQuaternion)super.position(position);
        }
    

        public DualQuaternion() { super((Pointer)null); allocate(); }
        private native void allocate();


        public DualQuaternion(double fW, double fX, double fY, double fZ,
                        double fdW, double fdX, double fdY, double fdZ) { super((Pointer)null); allocate(fW, fX, fY, fZ, fdW, fdX, fdY, fdZ); }
        private native void allocate(double fW, double fX, double fY, double fZ,
                        double fdW, double fdX, double fdY, double fdZ);


        public DualQuaternion(@Const @ByRef Matrix4 rot) { super((Pointer)null); allocate(rot); }
        private native void allocate(@Const @ByRef Matrix4 rot);


        public DualQuaternion(@Const @ByRef Quaternion q, @Const @ByRef Vector3 trans) { super((Pointer)null); allocate(q, trans); }
        private native void allocate(@Const @ByRef Quaternion q, @Const @ByRef Vector3 trans);


        public DualQuaternion(double valptr) { super((Pointer)null); allocate(valptr); }
        private native void allocate(double valptr);


        public native @Name("operator []") double get( @Cast("const size_t") long i );

        public native @ByRef @Name("operator =") DualQuaternion put(@Const @ByRef DualQuaternion rkQ);

        public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef DualQuaternion rhs);

        public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef DualQuaternion rhs);


        public native double ptr();


        public native void swap(@ByRef DualQuaternion other);


        public native @Cast("bool") boolean isNaN();


        public native void fromRotationTranslation(@Const @ByRef Quaternion q, @Const @ByRef Vector3 trans);


        public native void toRotationTranslation(@ByRef Quaternion q, @ByRef Vector3 translation);


        public native void fromTransformationMatrix(@Const @ByRef Matrix4 kTrans);


        public native void toTransformationMatrix(@ByRef Matrix4 kTrans);

        public native double w(); public native DualQuaternion w(double w);
        public native double x(); public native DualQuaternion x(double x);
        public native double y(); public native DualQuaternion y(double y);
        public native double z(); public native DualQuaternion z(double z);
        public native double dw(); public native DualQuaternion dw(double dw);
        public native double dx(); public native DualQuaternion dx(double dx);
        public native double dy(); public native DualQuaternion dy(double dy);
        public native double dz(); public native DualQuaternion dz(double dz);





        
    }





    @Namespace("Ogre") public static class KfTransform extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public KfTransform() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public KfTransform(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public KfTransform(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public KfTransform position(long position) {
            return (KfTransform)super.position(position);
        }
    
        public native @ByRef ArrayVector3 mPosition(); public native KfTransform mPosition(ArrayVector3 mPosition);
        public native @ByRef ArrayQuaternion mOrientation(); public native KfTransform mOrientation(ArrayQuaternion mOrientation);
        public native @ByRef ArrayVector3 mScale(); public native KfTransform mScale(ArrayVector3 mScale);
    }

    @Namespace("Ogre") @Opaque public static class KfTransformArrayMemoryManager extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public KfTransformArrayMemoryManager() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public KfTransformArrayMemoryManager(Pointer p) { super(p); }
    }

    @Namespace("Ogre") public static class KeyFrameRig extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public KeyFrameRig() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public KeyFrameRig(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public KeyFrameRig(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public KeyFrameRig position(long position) {
            return (KeyFrameRig)super.position(position);
        }
    
        public native double mFrame(); public native KeyFrameRig mFrame(double mFrame);
        public native double mInvNextFrameDistance(); public native KeyFrameRig mInvNextFrameDistance(double mInvNextFrameDistance);


        public native KfTransform mBoneTransform(); public native KeyFrameRig mBoneTransform(KfTransform mBoneTransform);
    }

    @Namespace("Ogre") @NoOffset public static class SkeletonTrack extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SkeletonTrack(Pointer p) { super(p); }
    
        public SkeletonTrack( @Cast("Ogre::uint32") int boneBlockIdx, KfTransformArrayMemoryManager kfTransformMemoryManager ) { super((Pointer)null); allocate(boneBlockIdx, kfTransformMemoryManager); }
        private native void allocate( @Cast("Ogre::uint32") int boneBlockIdx, KfTransformArrayMemoryManager kfTransformMemoryManager );

        public native void setNumKeyFrame( @Cast("size_t") long numKeyFrames );

        public native void addKeyFrame( double timestamp, double frameRate );
        public native void setKeyFrameTransform( double frame, @Cast("Ogre::uint32") int slot, @Const @ByRef Vector3 vPos,
                                            @Const @ByRef Quaternion qRot, @Const @ByVal Vector3 vScale );

        public native @Cast("Ogre::uint32") int getBoneBlockIdx();
        public native @Cast("size_t") long getUsedSlots();
        public native void _setMaxUsedSlot( @Cast("Ogre::uint32") int slot );

        public native @Cast("const Ogre::KeyFrameRigVec*") @ByRef KeyFrameRigVectorRef getKeyFrames();
        public native @Cast("Ogre::KeyFrameRigVec*") @ByRef KeyFrameRigVectorRef _getKeyFrames();

        public native void getKeyFrameRigAt( @ByRef const_iterator inOutPrevFrame,
                                                @ByRef const_iterator outNextFrame,
                                                double frame );





        public native void _bakeUnusedSlots();
    }

    @Name("Ogre::RawSimdUniquePtr<Ogre::ArrayReal,Ogre::MEMCATEGORY_ANIMATION>") @NoOffset public static class MemArrayRealRawSimdUniquePtr extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MemArrayRealRawSimdUniquePtr(Pointer p) { super(p); }
    
        public MemArrayRealRawSimdUniquePtr() { super((Pointer)null); allocate(); }
        private native void allocate();

        public MemArrayRealRawSimdUniquePtr( @Cast("size_t") long numElements ) { super((Pointer)null); allocate(numElements); }
        private native void allocate( @Cast("size_t") long numElements );

        public MemArrayRealRawSimdUniquePtr( @Cast("const Ogre::RawSimdUniquePtr<Ogre::ArrayReal,Ogre::MEMCATEGORY_ANIMATION>*") @ByRef MemArrayRealRawSimdUniquePtr copy ) { super((Pointer)null); allocate(copy); }
        private native void allocate( @Cast("const Ogre::RawSimdUniquePtr<Ogre::ArrayReal,Ogre::MEMCATEGORY_ANIMATION>*") @ByRef MemArrayRealRawSimdUniquePtr copy );

        public native void swap( @Cast("Ogre::RawSimdUniquePtr<Ogre::ArrayReal,Ogre::MEMCATEGORY_ANIMATION>*") @ByRef MemArrayRealRawSimdUniquePtr copy );

        public native @Name("operator =") void put( @Cast("const Ogre::RawSimdUniquePtr<Ogre::ArrayReal,Ogre::MEMCATEGORY_ANIMATION>*") @ByRef MemArrayRealRawSimdUniquePtr copy );

        public native ArrayReal get();
        public native @Cast("size_t") long size();
    }

    @Namespace("Ogre") @Opaque public static class SkeletonAnimationDef extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public SkeletonAnimationDef() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SkeletonAnimationDef(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @NoOffset public static class SkeletonAnimation extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SkeletonAnimation(Pointer p) { super(p); }
    
        public native double mFrameRate(); public native SkeletonAnimation mFrameRate(double mFrameRate);
        public native double mWeight(); public native SkeletonAnimation mWeight(double mWeight);
        public native @Cast("Ogre::FastArray<size_t> const*") SizeFastArrayRef mSlotStarts(); public native SkeletonAnimation mSlotStarts(SizeFastArrayRef mSlotStarts);
        public native @Cast("bool") boolean mLoop(); public native SkeletonAnimation mLoop(boolean mLoop);
        public native @Cast("bool") boolean mEnabled(); public native SkeletonAnimation mEnabled(boolean mEnabled);
        public native SkeletonInstance mOwner(); public native SkeletonAnimation mOwner(SkeletonInstance mOwner);
        public SkeletonAnimation( @Const SkeletonAnimationDef definition, @Cast("const Ogre::FastArray<size_t>*") SizeFastArrayRef slotStarts,
                                    SkeletonInstance owner ) { super((Pointer)null); allocate(definition, slotStarts, owner); }
        private native void allocate( @Const SkeletonAnimationDef definition, @Cast("const Ogre::FastArray<size_t>*") SizeFastArrayRef slotStarts,
                                    SkeletonInstance owner );




        public native void _initialize();





        public native void addTime( double time );





        public native void addFrame( double frames );





        public native void setTime( double time );





        public native void setFrame( double frame );


        public native double getCurrentTime();


        public native double getCurrentFrame();


        public native double getNumFrames();


        public native double getDuration();

        public native @ByVal IdString getName();






        public native void setLoop( @Cast("bool") boolean bLoop );



        public native @Cast("bool") boolean getLoop();
        public native void setBoneWeight( @ByVal IdString boneName, double weight );
        public native double getBoneWeight( @ByVal IdString boneName );
        public native double getBoneWeightPtr( @ByVal IdString boneName );


        public native void setEnabled( @Cast("bool") boolean bEnable );
        public native @Cast("bool") boolean getEnabled();

        public native void _applyAnimation( @Cast("const Ogre::TransformArray*") @ByRef RealFastArrayRef boneTransforms );

        public native void _swapBoneWeightsUniquePtr( @Cast("Ogre::RawSimdUniquePtr<ArrayReal,Ogre::MEMCATEGORY_ANIMATION>*") @ByRef MemArrayRealRawSimdUniquePtr inOutBoneWeights );

        public native @Const SkeletonAnimationDef getDefinition();
    }




    @Namespace("Ogre") @NoOffset public static class ArrayMatrixAf4x3 extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ArrayMatrixAf4x3(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ArrayMatrixAf4x3(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ArrayMatrixAf4x3 position(long position) {
            return (ArrayMatrixAf4x3)super.position(position);
        }
    

        public ArrayMatrixAf4x3() { super((Pointer)null); allocate(); }
        private native void allocate();
        public ArrayMatrixAf4x3( @Const @ByRef ArrayMatrixAf4x3 copy ) { super((Pointer)null); allocate(copy); }
        private native void allocate( @Const @ByRef ArrayMatrixAf4x3 copy );


        public native void setAll( @Const @ByRef Matrix4 m );

        public static native @ByVal ArrayMatrixAf4x3 createAllFromMatrix4( @Const @ByRef Matrix4 m );


        

        public native @ByVal @Name("operator *") ArrayVector3 multiply( @Const @ByRef ArrayVector3 rhs );



        public native @Name("operator *=") void multiplyPut( @Const @ByRef ArrayMatrixAf4x3 rhs );
        public native void fromQuaternion( @Const @ByRef ArrayQuaternion q );


        public native void makeTransform( @Const @ByRef ArrayVector3 position, @Const @ByRef ArrayVector3 scale,
                                            @Const @ByRef ArrayQuaternion orientation );


        public native void decomposition( @ByRef ArrayVector3 position, @ByRef ArrayVector3 scale,
                                           @ByRef ArrayQuaternion orientation );





        public native void setToInverse();




        public native void setToInverseDegeneratesAsIdentity();





        public native void streamToAoS( Matrix4 dst );
        public native void storeToAoS( SimpleMatrixAf4x3 src );
        public native void streamToAoS( SimpleMatrixAf4x3 src );





        public native void loadFromAoS( @Const Matrix4 src );
        public native void loadFromAoS( @Cast("const Ogre::Matrix4**") PointerPointer src );
        public native void loadFromAoS( @Const SimpleMatrixAf4x3 src );

        @MemberGetter public static native @Const @ByRef ArrayMatrixAf4x3 IDENTITY();
    }





    @Namespace("Ogre") @NoOffset public static class SimpleMatrixAf4x3 extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SimpleMatrixAf4x3(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public SimpleMatrixAf4x3(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public SimpleMatrixAf4x3 position(long position) {
            return (SimpleMatrixAf4x3)super.position(position);
        }
    

        public SimpleMatrixAf4x3() { super((Pointer)null); allocate(); }
        private native void allocate();


        public native void load( @Const @ByRef Matrix4 src );


        public native void store( Matrix4 dst );


        public native void store4x3( Matrix4 dst );


        public native void store4x3( FloatPointer dst );
        public native void store4x3( FloatBuffer dst );
        public native void store4x3( float[] dst );


        public native void streamTo4x3( FloatPointer dst );
        public native void streamTo4x3( FloatBuffer dst );
        public native void streamTo4x3( float[] dst );

        @MemberGetter public static native @Const @ByRef SimpleMatrixAf4x3 IDENTITY();
    }






    @Namespace("Ogre") public static native @ByVal @Name("operator *") ArrayMatrixAf4x3 multiply( @Const @ByRef ArrayMatrixAf4x3 lhs, @Const @ByRef ArrayMatrixAf4x3 rhs );

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    



    @Namespace("Ogre") @NoOffset public static class BoneTransform extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public BoneTransform(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public BoneTransform(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public BoneTransform position(long position) {
            return (BoneTransform)super.position(position);
        }
    

        public native @Cast("unsigned char") byte mIndex(); public native BoneTransform mIndex(byte mIndex);


        public native Bone mOwner(int i); public native BoneTransform mOwner(int i, Bone mOwner);
        @MemberGetter public native @Cast("Ogre::Bone**") PointerPointer mOwner();


        public native ArrayVector3 mPosition(); public native BoneTransform mPosition(ArrayVector3 mPosition);


        public native ArrayQuaternion mOrientation(); public native BoneTransform mOrientation(ArrayQuaternion mOrientation);


        public native ArrayVector3 mScale(); public native BoneTransform mScale(ArrayVector3 mScale);


        public native @Const({false, true}) SimpleMatrixAf4x3 mParentNodeTransform(int i); public native BoneTransform mParentNodeTransform(int i, SimpleMatrixAf4x3 mParentNodeTransform);
        @MemberGetter public native @Cast("Ogre::SimpleMatrixAf4x3 const**") PointerPointer mParentNodeTransform();


        public native @Const({false, true}) SimpleMatrixAf4x3 mParentTransform(int i); public native BoneTransform mParentTransform(int i, SimpleMatrixAf4x3 mParentTransform);
        @MemberGetter public native @Cast("Ogre::SimpleMatrixAf4x3 const**") PointerPointer mParentTransform();



        public native SimpleMatrixAf4x3 mDerivedTransform(); public native BoneTransform mDerivedTransform(SimpleMatrixAf4x3 mDerivedTransform);



        public native SimpleMatrixAf4x3 mFinalTransform(); public native BoneTransform mFinalTransform(SimpleMatrixAf4x3 mFinalTransform);



        public native @Cast("bool*") BoolPointer mInheritOrientation(); public native BoneTransform mInheritOrientation(BoolPointer mInheritOrientation);



        public native @Cast("bool*") BoolPointer mInheritScale(); public native BoneTransform mInheritScale(BoolPointer mInheritScale);

        public BoneTransform() { super((Pointer)null); allocate(); }
        private native void allocate();
        public native void copy( @Const @ByRef BoneTransform inCopy );




        public native void advancePack();

        public native void advancePack( @Cast("size_t") long numAdvance );
    }

    @Namespace("Ogre") @NoOffset public static class Bone extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Bone(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Bone(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Bone position(long position) {
            return (Bone)super.position(position);
        }
        public IdObject asIdObject() { return asIdObject(this); }
        @Namespace public static native @Name("static_cast<Ogre::IdObject*>") IdObject asIdObject(Bone pointer);
    






        public native @Cast("size_t") long mGlobalIndex(); public native Bone mGlobalIndex(long mGlobalIndex);

        public native @Cast("size_t") long mParentIndex(); public native Bone mParentIndex(long mParentIndex);

        public Bone() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native void _initialize( @Cast("Ogre::IdType") int id, BoneMemoryManager boneMemoryManager,
                                    Bone parent, @Const({false, true}) ArrayMatrixAf4x3 reverseBind );
        public native void _deinitialize( @Cast("bool") boolean debugCheckLifoOrder/*=true*/ );
        public native void _deinitialize( );


        public native @Cast("Ogre::uint16") short getDepthLevel();


        public native @ByRef BoneTransform _getTransform();


        public native void _memoryRebased();

        public native void _setReverseBindPtr( @Const ArrayMatrixAf4x3 ptr );


        public native void setName( @Const @ByRef String name );


        public native @Const @ByRef String getName();


        public native Bone getParent();


        public native @Cast("size_t") long getNumChildren();


        public native Bone getChild(@Cast("size_t") long index);






        public native @Cast("const Ogre::BoneVec*") @ByRef BonePtrVectorRef getChildren();


        public native void addTagPoint( TagPoint tagPoint );

        public native void removeTagPoint( TagPoint tagPoint );
        public native void _setNodeParent( Node nodeParent );





        public native void setOrientation( @ByVal Quaternion q );





        public native @ByVal Quaternion getOrientation();





        public native void setPosition( @Const @ByRef Vector3 pos );





        public native @ByVal Vector3 getPosition();





        public native void setScale( @Const @ByRef Vector3 pos );





        public native @ByVal Vector3 getScale();
        public native void setInheritOrientation(@Cast("bool") boolean inherit);





        public native @Cast("bool") boolean getInheritOrientation();







        public native void setInheritScale(@Cast("bool") boolean inherit);





        public native @Cast("bool") boolean getInheritScale();
        public native @ByVal Matrix4 _getDerivedTransform();
        public native @Const @ByRef SimpleMatrixAf4x3 _getLocalSpaceTransform();
        public native @Const @ByRef SimpleMatrixAf4x3 _getFullTransform();


        public native @Const @ByRef SimpleMatrixAf4x3 _getFullTransformUpdated();
        public static native void updateAllTransforms( @Cast("const size_t") long numNodes, @ByVal BoneTransform t,
                                                 @Const({false, true}) ArrayMatrixAf4x3 reverseBind,
                                                 @Cast("size_t") long numBinds );


        public native void _setCachedTransformOutOfDate();
        public native @Cast("bool") boolean isCachedTransformOutOfDate();

    }






    

    

    

    

    

    

    @Namespace("Ogre") @NoOffset public static class SkeletonInstance extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SkeletonInstance(Pointer p) { super(p); }
    
        public SkeletonInstance( @Const SkeletonDef skeletonDef, BoneMemoryManager boneMemoryManager ) { super((Pointer)null); allocate(skeletonDef, boneMemoryManager); }
        private native void allocate( @Const SkeletonDef skeletonDef, BoneMemoryManager boneMemoryManager );

        public native @Const SkeletonDef getDefinition();

        public native void update();


        public native void resetToPose();
        public native void setManualBone( Bone bone, @Cast("bool") boolean isManual );





        public native @Cast("bool") boolean isManualBone( Bone bone );







        public native void setSceneNodeAsParentOfBone( Bone bone, SceneNode nodeParent );


        public native @Const @ByRef SimpleMatrixAf4x3 _getBoneFullTransform( @Cast("size_t") long index );


        public native Bone getBone( @ByVal IdString boneName );


        public native Bone getBone( @Cast("size_t") long index );


        public native @Cast("size_t") long getNumBones();

        public native @Cast("bool") boolean hasAnimation( @ByVal IdString name );

        public native SkeletonAnimation getAnimation( @ByVal IdString name );


        public native @Cast("const Ogre::SkeletonAnimationVec*") @ByRef SkeletonAnimationVectorRef getAnimations();





        public native void addAnimationsFromSkeleton( @Const @ByRef String skelName, @Const @ByRef String groupName );


        public native void _enableAnimation( SkeletonAnimation animation );


        public native void _disableAnimation( SkeletonAnimation animation );







        public native void setParentNode( Node parentNode );


        public native Node getParentNode();

        public native void getTransforms( SimpleMatrixAf4x3 outTransform,
                                    @Cast("const Ogre::FastArray<unsigned short>*") @ByRef UshortFastArrayRef usedBones );




        public native void _updateBoneStartTransforms();

        public native @Cast("const Ogre::TransformArray*") @ByRef RealFastArrayRef _getTransformArray();

        public native @Const Pointer _getMemoryBlock();
        public native @Const Pointer _getMemoryUniqueOffset();

        public native void _incrementRefCount();
        public native void _decrementRefCount();
        public native @Cast("Ogre::uint16") short _getRefCount();
    }

    @Namespace("Ogre") public static native @Cast("bool") boolean OrderSkeletonInstanceByMemory( @Const SkeletonInstance _left,
                                                    @Const SkeletonInstance _right );




    @Name("Ogre::InstancedEntity") @NoOffset public static class InstancedEntity extends MovableObject {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public InstancedEntity(Pointer p) { super(p); }
    
        public InstancedEntity( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, InstanceBatch batchOwner,
                                 @Cast("Ogre::uint32") int instanceID,
        
        
        
                                 InstancedEntity sharedTransformEntity/*=NULL*/ ) { super((Pointer)null); allocate(id, objectMemoryManager, batchOwner, instanceID, sharedTransformEntity); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, InstanceBatch batchOwner,
                                 @Cast("Ogre::uint32") int instanceID,
        
        
        
                                 InstancedEntity sharedTransformEntity/*=NULL*/ );
        public InstancedEntity( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, InstanceBatch batchOwner,
                                 @Cast("Ogre::uint32") int instanceID ) { super((Pointer)null); allocate(id, objectMemoryManager, batchOwner, instanceID); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, InstanceBatch batchOwner,
                                 @Cast("Ogre::uint32") int instanceID );
        public native @Cast("bool") boolean shareTransformWith( InstancedEntity slave );
        public native void stopSharingTransform();

        public native InstanceBatch _getOwner();

        public native @Const @ByRef String getMovableType();

        public native @Const @ByRef AxisAlignedBox getBoundingBox();



        public native double getSquaredViewDepth( @Const Camera cam );


        public native void _notifyStaticDirty();


        public native void _notifyAttached( Node parent );






        public native void _updateRenderQueue( RenderQueue queue, Camera camera, @Const Camera lodCamera );


        public native @Cast("bool") boolean hasSkeleton();



        public native OldSkeletonInstance getSkeleton();






        public native AnimationState getAnimationState(@Const @ByRef String name);

        public native AnimationStateSet getAllAnimationStates();






        public native @Cast("bool") boolean _updateAnimation();



        public native void setTransformLookupNumber(@Cast("Ogre::uint16") short num);


        public native @Cast("bool") boolean isInUse();


        public native @Cast("bool") boolean isInScene();
        public native void setCustomParam( @Cast("unsigned char") byte idx, @Const @ByRef Vector4 newParam );
        public native @Const @ByRef Vector4 getCustomParam( @Cast("unsigned char") byte idx );
    }



    


    

    

    


    @Name("Ogre::InstanceManager") @NoOffset public static class InstanceManager extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public InstanceManager(Pointer p) { super(p); }
    
        /** enum Ogre::InstanceManager::InstancingTechnique */
        public static final int
            ShaderBased = 0,
            TextureVTF = 1,
            HWInstancingBasic = 2,
            HWInstancingVTF = 3,
            InstancingTechniquesCount = 4;


        /** enum Ogre::InstanceManager::BatchSettingId */
        public static final int

            CAST_SHADOWS = 0,

            SHOW_BOUNDINGBOX = 1,

            NUM_SETTINGS = 2;
        public InstanceManager( @ByVal IdString customName, SceneManager sceneManager,
                                 @Const @ByRef String meshName, @Const @ByRef String groupName,
                                 @Cast("Ogre::InstanceManager::InstancingTechnique") int instancingTechnique, @Cast("Ogre::uint16") short instancingFlags,
                                 @Cast("size_t") long instancesPerBatch, @Cast("unsigned short") short subMeshIdx, @Cast("bool") boolean useBoneMatrixLookup/*=false*/) { super((Pointer)null); allocate(customName, sceneManager, meshName, groupName, instancingTechnique, instancingFlags, instancesPerBatch, subMeshIdx, useBoneMatrixLookup); }
        private native void allocate( @ByVal IdString customName, SceneManager sceneManager,
                                 @Const @ByRef String meshName, @Const @ByRef String groupName,
                                 @Cast("Ogre::InstanceManager::InstancingTechnique") int instancingTechnique, @Cast("Ogre::uint16") short instancingFlags,
                                 @Cast("size_t") long instancesPerBatch, @Cast("unsigned short") short subMeshIdx, @Cast("bool") boolean useBoneMatrixLookup/*=false*/);
        public InstanceManager( @ByVal IdString customName, SceneManager sceneManager,
                                 @Const @ByRef String meshName, @Const @ByRef String groupName,
                                 @Cast("Ogre::InstanceManager::InstancingTechnique") int instancingTechnique, @Cast("Ogre::uint16") short instancingFlags,
                                 @Cast("size_t") long instancesPerBatch, @Cast("unsigned short") short subMeshIdx) { super((Pointer)null); allocate(customName, sceneManager, meshName, groupName, instancingTechnique, instancingFlags, instancesPerBatch, subMeshIdx); }
        private native void allocate( @ByVal IdString customName, SceneManager sceneManager,
                                 @Const @ByRef String meshName, @Const @ByRef String groupName,
                                 @Cast("Ogre::InstanceManager::InstancingTechnique") int instancingTechnique, @Cast("Ogre::uint16") short instancingFlags,
                                 @Cast("size_t") long instancesPerBatch, @Cast("unsigned short") short subMeshIdx);

        public native @Const @ByVal IdString getName();

        public native SceneManager getSceneManager();






        public native void setInstancesPerBatch( @Cast("size_t") long instancesPerBatch );
        public native void setMaxLookupTableInstances( @Cast("size_t") long maxLookupTableInstances );
        public native void setNumCustomParams( @Cast("unsigned char") byte numCustomParams );

        public native @Cast("unsigned char") byte getNumCustomParams();


        public native @Cast("Ogre::InstanceManager::InstancingTechnique") int getInstancingTechnique();
        public native @Cast("size_t") long getMaxOrBestNumInstancesPerBatch( @Const @ByRef String materialName, @Cast("size_t") long suggestedSize,
                                                         @Cast("Ogre::uint16") short flags );


        public native InstancedEntity createInstancedEntity( @Const @ByRef String materialName,
                                                        @Cast("Ogre::SceneMemoryMgrTypes") int sceneType/*=Ogre::SCENE_DYNAMIC*/ );
        public native InstancedEntity createInstancedEntity( @Const @ByRef String materialName );







        public native void cleanupEmptyBatches();
        public native void defragmentBatches( @Cast("bool") boolean optimizeCulling );
        public native void setSetting( @Cast("Ogre::InstanceManager::BatchSettingId") int id, @Cast("bool") boolean enabled, @ByVal(nullValue = "Ogre::IdString()") IdString materialName );
        public native void setSetting( @Cast("Ogre::InstanceManager::BatchSettingId") int id, @Cast("bool") boolean enabled );


        public native @Cast("bool") boolean getSetting( @Cast("Ogre::InstanceManager::BatchSettingId") int id, @ByVal IdString materialName );




        public native @Cast("bool") boolean hasSettings( @ByVal IdString materialName );


        public native void setBatchesAsStatic( @Cast("bool") boolean bStatic );






        public native void _addToDynamicBatchList( InstanceBatch dynamicBatch );






        public native void _removeFromDynamicBatchList( InstanceBatch batch );




        public native void _addDirtyStaticBatch( InstanceBatch dirtyBatch );



        public native void _updateAnimations();



        public native void _updateDirtyBatchesThread( @Cast("size_t") long threadIdx );


        public native void _updateDirtyBatches();


        public native @ByVal @Cast("Ogre::InstanceManager::InstanceBatchMapIterator*") NumericTrackIteratorRef getInstanceBatchMapIterator();







        public native @ByVal @Cast("Ogre::InstanceManager::InstanceBatchIterator*") NodeTrackIteratorRef getInstanceBatchIterator( @Const @ByRef String materialName,
                                                                @Cast("Ogre::SceneMemoryMgrTypes") int sceneType );
    }

    @Namespace("Ogre::v1") public static class InstanceManagerCmp extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public InstanceManagerCmp() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public InstanceManagerCmp(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public InstanceManagerCmp(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public InstanceManagerCmp position(long position) {
            return (InstanceManagerCmp)super.position(position);
        }
    
        public native @Cast("bool") @Name("operator ()") boolean apply( @Const InstanceManager a, @Const InstanceManager b );
        public native @Cast("bool") @Name("operator ()") boolean apply( @Const InstanceManager a, @ByVal IdString name );
        public native @Cast("bool") @Name("operator ()") boolean apply( @ByVal IdString name, @Const InstanceManager a );
    }



    @Namespace("Ogre::v1") @NoOffset public static class KeyFrame extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public KeyFrame(Pointer p) { super(p); }
    


        public KeyFrame(@Const AnimationTrack parent, double time) { super((Pointer)null); allocate(parent, time); }
        private native void allocate(@Const AnimationTrack parent, double time);


        public native double getTime();


        public native KeyFrame _clone(AnimationTrack newParent);
    }




    @Namespace("Ogre::v1") @NoOffset public static class NumericKeyFrame extends KeyFrame {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public NumericKeyFrame(Pointer p) { super(p); }
    

        public NumericKeyFrame(@Const AnimationTrack parent, double time) { super((Pointer)null); allocate(parent, time); }
        private native void allocate(@Const AnimationTrack parent, double time);


        public native @Const @ByRef AnyNumeric getValue();




        public native void setValue(@Const @ByRef AnyNumeric val);


        public native KeyFrame _clone(AnimationTrack newParent);
    }



    @Namespace("Ogre::v1") @NoOffset public static class TransformKeyFrame extends KeyFrame {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public TransformKeyFrame(Pointer p) { super(p); }
    

        public TransformKeyFrame(@Const AnimationTrack parent, double time) { super((Pointer)null); allocate(parent, time); }
        private native void allocate(@Const AnimationTrack parent, double time);






        public native void setTranslate(@Const @ByRef Vector3 trans);


        public native @Const @ByRef Vector3 getTranslate();






        public native void setScale(@Const @ByRef Vector3 scale);


        public native @Const @ByRef Vector3 getScale();





        public native void setRotation(@Const @ByRef Quaternion rot);


        public native @Const @ByRef Quaternion getRotation();


        public native KeyFrame _clone(AnimationTrack newParent);


    }






    @Namespace("Ogre::v1") @NoOffset public static class VertexMorphKeyFrame extends KeyFrame {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public VertexMorphKeyFrame(Pointer p) { super(p); }
    

        public VertexMorphKeyFrame(@Const AnimationTrack parent, double time) { super((Pointer)null); allocate(parent, time); }
        private native void allocate(@Const AnimationTrack parent, double time);







        public native void setVertexBuffer(@Const @ByRef HardwareVertexBufferSharedPtr buf);


        public native @Const @ByRef HardwareVertexBufferSharedPtr getVertexBuffer();


        public native KeyFrame _clone(AnimationTrack newParent);

    }





    @Namespace("Ogre::v1") @NoOffset public static class VertexPoseKeyFrame extends KeyFrame {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public VertexPoseKeyFrame(Pointer p) { super(p); }
    

        public VertexPoseKeyFrame(@Const AnimationTrack parent, double time) { super((Pointer)null); allocate(parent, time); }
        private native void allocate(@Const AnimationTrack parent, double time);





        @NoOffset public static class PoseRef extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public PoseRef(Pointer p) { super(p); }
        







            public native short poseIndex(); public native PoseRef poseIndex(short poseIndex);



            public native double influence(); public native PoseRef influence(double influence);

            public PoseRef(short p, double i) { super((Pointer)null); allocate(p, i); }
            private native void allocate(short p, double i);
        }




        public native void addPoseReference(short poseIndex, double influence);



        public native void updatePoseReference(short poseIndex, double influence);



        public native void removePoseReference(short poseIndex);

        public native void removeAllPoseReferences();



        public native @Cast("const Ogre::v1::VertexPoseKeyFrame::PoseRefList*") @ByRef PoseRefVectorRef getPoseReferences();


        public native @ByVal @Cast("Ogre::v1::VertexPoseKeyFrame::PoseRefIterator*") PoseRefListVectorIteratorRef getPoseReferenceIterator();


        public native KeyFrame _clone(AnimationTrack newParent);

        public native void _applyBaseKeyFrame(@Const VertexPoseKeyFrame base);

    }





    @Namespace("Ogre") @NoOffset public static class PlaneBoundedVolume extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public PlaneBoundedVolume(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public PlaneBoundedVolume(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public PlaneBoundedVolume position(long position) {
            return (PlaneBoundedVolume)super.position(position);
        }
    

        public native @ByRef @Cast("Ogre::PlaneList*") PlaneVectorRef planes(); public native PlaneBoundedVolume planes(PlaneVectorRef planes);
        public native @Cast("Ogre::Plane::Side") int outside(); public native PlaneBoundedVolume outside(int outside);

        public PlaneBoundedVolume() { super((Pointer)null); allocate(); }
        private native void allocate();

        public PlaneBoundedVolume(@Cast("Ogre::Plane::Side") int theOutside) { super((Pointer)null); allocate(theOutside); }
        private native void allocate(@Cast("Ogre::Plane::Side") int theOutside);




        public native @Cast("bool") boolean intersects(@Const @ByRef AxisAlignedBox box);



        public native @Cast("bool") boolean intersects(@Const @ByRef Sphere sphere);





        public native @ByVal @Cast("std::pair<bool,Ogre::Real>*") RealPairRef intersects(@Const @ByRef Ray ray);

    }





    @Namespace("Ogre") @NoOffset public static class Light extends MovableObject {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Light(Pointer p) { super(p); }
    

        public native double tempSquareDist(); public native Light tempSquareDist(double tempSquareDist);

        public native void _calcTempSquareDist(@Const @ByRef Vector3 worldPos);


        /** enum Ogre::Light::LightTypes */
        public static final int

            LT_DIRECTIONAL = 0,

            LT_POINT = 1,

            LT_SPOTLIGHT = 2,

            NUM_LIGHT_TYPES = 3;



        public Light( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager ) { super((Pointer)null); allocate(id, objectMemoryManager, manager); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager );



        public native void setType(@Cast("Ogre::Light::LightTypes") int type);


        public native void setRenderQueueGroup(@Cast("Ogre::uint8") byte queueID);



        public native @Cast("Ogre::Light::LightTypes") int getType();
        public native void setDiffuseColour(double red, double green, double blue);
        public native void setDiffuseColour(@Const @ByRef ColourValue colour);



        public native @Const @ByRef ColourValue getDiffuseColour();
        public native void setSpecularColour(double red, double green, double blue);
        public native void setSpecularColour(@Const @ByRef ColourValue colour);



        public native @Const @ByRef ColourValue getSpecularColour();
        public native void setAttenuationBasedOnRadius( double radius, double lumThreshold);
        public native void setAttenuation(double range, double constant, double linear, double quadratic);



        public native double getAttenuationRange();



        public native double getAttenuationConstant();



        public native double getAttenuationLinear();



        public native double getAttenuationQuadric();







        public native void setDirection(@Const @ByRef Vector3 vec);






        public native @ByVal Vector3 getDirection();
  public native void setAffectParentNode( @Cast("bool") boolean bAffect );

  public native @Cast("bool") boolean getAffectParentNode();
        public native void setSpotlightRange(@Const @ByRef Radian innerAngle, @Const @ByRef Radian outerAngle, double falloff/*=1.0*/);
        public native void setSpotlightRange(@Const @ByRef Radian innerAngle, @Const @ByRef Radian outerAngle);



        public native @Const @ByRef Radian getSpotlightInnerAngle();



        public native @Const @ByRef Radian getSpotlightOuterAngle();



        public native double getSpotlightFalloff();



        public native void setSpotlightInnerAngle(@Const @ByRef Radian val);



        public native void setSpotlightOuterAngle(@Const @ByRef Radian val);



        public native void setSpotlightFalloff(double val);







        public native void setSpotlightNearClipDistance(double nearClip);




        public native double getSpotlightNearClipDistance();
        public native void setPowerScale(double power);




        public native double getPowerScale();


        public native void _updateRenderQueue(RenderQueue queue, Camera camera, @Const Camera lodCamera);


        public native @Const @ByRef String getMovableType();


        public native @ByVal Vector3 getDerivedDirection();
        public native @ByVal Vector3 getDerivedDirectionUpdated();
        public native @ByVal Vector4 getAs4DVector();


        public native @Cast("Ogre::uint32") int getTypeFlags();


        public native @ByVal @Cast("Ogre::AnimableValuePtr*") RealControllerFunctionSPtr createAnimableValue(@Const @ByRef String valueName);
        public native void setShadowFarDistance(double distance);


        public native void resetShadowFarDistance();



        public native double getShadowFarDistance();
        public native double getShadowFarDistanceSquared();






        public native void setShadowNearClipDistance(double nearClip);







        public native double getShadowNearClipDistance();




        public native double _deriveShadowNearClipDistance(@Const Camera maincam);
        public native void setShadowFarClipDistance(double farClip);







        public native double getShadowFarClipDistance();




        public native double _deriveShadowFarClipDistance(@Const Camera maincam);
        public native void setCustomParameter(@Cast("Ogre::uint16") short index, @Const @ByRef Vector4 value);





        public native @Const @ByRef Vector4 getCustomParameter(@Cast("Ogre::uint16") short index);
        public native void _updateCustomGpuParameter(@Cast("Ogre::uint16") short paramIndex,
                    @Const @ByRef GpuProgramParameters.AutoConstantEntry constantEntry,
                    GpuProgramParameters params);






        public native @Cast("bool") boolean isInLightRange(@Const @ByRef Sphere sphere);






        public native @Cast("bool") boolean isInLightRange(@Const @ByRef AxisAlignedBox container);
    }


    @Namespace("Ogre") @NoOffset public static class LightFactory extends MovableObjectFactory {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public LightFactory(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public LightFactory(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public LightFactory position(long position) {
            return (LightFactory)super.position(position);
        }
    
        public LightFactory() { super((Pointer)null); allocate(); }
        private native void allocate();

        public static native @ByRef String FACTORY_TYPE_NAME(); public static native void FACTORY_TYPE_NAME(String FACTORY_TYPE_NAME);

        public native @Const @ByRef String getType();
        public native void destroyInstance(MovableObject obj);

    }




    

    

    

    

    

    /** enum Ogre::LoggingLevel */
    public static final int
        LL_LOW = 1,
        LL_NORMAL = 2,
        LL_BOREME = 3;



    /** enum Ogre::LogMessageLevel */
    public static final int
        LML_TRIVIAL = 1,
        LML_NORMAL = 2,
        LML_CRITICAL = 3;


    @Namespace("Ogre") public static class LogListener extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public LogListener(Pointer p) { super(p); }
    
        public native void messageLogged( @Const @ByRef String message, @Cast("Ogre::LogMessageLevel") int lml, @Cast("bool") boolean maskDebug, @Const @ByRef String logName, @Cast("bool*") @ByRef BoolPointer skipThisMessage );
        public native void messageLogged( @Const @ByRef String message, @Cast("Ogre::LogMessageLevel") int lml, @Cast("bool") boolean maskDebug, @Const @ByRef String logName, @Cast("bool*") @ByRef boolean[] skipThisMessage );
    }
    @Namespace("Ogre") @NoOffset public static class Log extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Log(Pointer p) { super(p); }
    

   




        public Log( @Const @ByRef String name, @Cast("bool") boolean debugOutput/*=true*/, @Cast("bool") boolean suppressFileOutput/*=false*/) { super((Pointer)null); allocate(name, debugOutput, suppressFileOutput); }
        private native void allocate( @Const @ByRef String name, @Cast("bool") boolean debugOutput/*=true*/, @Cast("bool") boolean suppressFileOutput/*=false*/);
        public Log( @Const @ByRef String name) { super((Pointer)null); allocate(name); }
        private native void allocate( @Const @ByRef String name);


        public native @Const @ByRef String getName();

        public native @Cast("bool") boolean isDebugOutputEnabled();

        public native @Cast("bool") boolean isFileOutputSuppressed();

        public native @Cast("bool") boolean isTimeStampEnabled();




        public native void logMessage( @Const @ByRef String message, @Cast("Ogre::LogMessageLevel") int lml/*=Ogre::LML_NORMAL*/, @Cast("bool") boolean maskDebug/*=false*/ );
        public native void logMessage( @Const @ByRef String message );


        public native @ByVal Stream stream(@Cast("Ogre::LogMessageLevel") int lml/*=Ogre::LML_NORMAL*/, @Cast("bool") boolean maskDebug/*=false*/);
        public native @ByVal Stream stream();





        public native void setDebugOutputEnabled(@Cast("bool") boolean debugOutput);




        public native void setLogDetail(@Cast("Ogre::LoggingLevel") int ll);




        public native void setTimeStampEnabled(@Cast("bool") boolean timeStamp);


        public native @Cast("Ogre::LoggingLevel") int getLogDetail();






        public native void addListener(LogListener listener);







        public native void removeListener(LogListener listener);
        @NoOffset public static class Stream extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Stream(Pointer p) { super(p); }
        


            public static class Flush extends Pointer {
                static { Loader.load(); }
                /** Default native constructor. */
                public Flush() { super((Pointer)null); allocate(); }
                /** Native array allocator. Access with {@link Pointer#position(long)}. */
                public Flush(long size) { super((Pointer)null); allocateArray(size); }
                /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
                public Flush(Pointer p) { super(p); }
                private native void allocate();
                private native void allocateArray(long size);
                @Override public Flush position(long position) {
                    return (Flush)super.position(position);
                }
            }

            public Stream(Log target, @Cast("Ogre::LogMessageLevel") int lml, @Cast("bool") boolean maskDebug) { super((Pointer)null); allocate(target, lml, maskDebug); }
            private native void allocate(Log target, @Cast("Ogre::LogMessageLevel") int lml, @Cast("bool") boolean maskDebug);

            public Stream(@Const @ByRef Stream rhs) { super((Pointer)null); allocate(rhs); }
            private native void allocate(@Const @ByRef Stream rhs);

            public native @ByRef @Name("operator <<") Stream shiftLeft(@Const @ByRef Flush v);


        }







    }



    @Namespace("Ogre") @NoOffset public static class LogManager extends LogManagerSgtRef {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public LogManager(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public LogManager(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public LogManager position(long position) {
            return (LogManager)super.position(position);
        }
        public Pointer asPointer() { return asPointer(this); }
        @Namespace public static native @Name("static_cast<LogAlloc*>") Pointer asPointer(LogManager pointer);
    
   

        public LogManager() { super((Pointer)null); allocate(); }
        private native void allocate();
        public native Log createLog( @Const @ByRef String name, @Cast("bool") boolean defaultLog/*=false*/, @Cast("bool") boolean debuggerOutput/*=true*/,
                    @Cast("bool") boolean suppressFileOutput/*=false*/);
        public native Log createLog( @Const @ByRef String name);



        public native Log getLog( @Const @ByRef String name);



        public native Log getDefaultLog();


        public native void destroyLog(@Const @ByRef String name);

        public native void destroyLog(Log log);




        public native Log setDefaultLog(Log newLog);



        public native void logMessage( @Const @ByRef String message, @Cast("Ogre::LogMessageLevel") int lml/*=Ogre::LML_NORMAL*/,
                    @Cast("bool") boolean maskDebug/*=false*/);
        public native void logMessage( @Const @ByRef String message);



        public native void logMessage( @Cast("Ogre::LogMessageLevel") int lml, @Const @ByRef String message,
                    @Cast("bool") boolean maskDebug/*=false*/);
        public native void logMessage( @Cast("Ogre::LogMessageLevel") int lml, @Const @ByRef String message);


        public native @ByVal Log.Stream stream(@Cast("Ogre::LogMessageLevel") int lml/*=Ogre::LML_NORMAL*/,
                    @Cast("bool") boolean maskDebug/*=false*/);
        public native @ByVal Log.Stream stream();



        public native void setLogDetail(@Cast("Ogre::LoggingLevel") int ll);
        public static native @ByRef LogManager getSingleton();
        public static native LogManager getSingletonPtr();

    }





    @Name("Ogre::ManualObject") @NoOffset public static class ManualObject extends MovableObject {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ManualObject(Pointer p) { super(p); }
    
        public ManualObject( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager ) { super((Pointer)null); allocate(id, objectMemoryManager, manager); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager );
        public native void clear();
        public native void estimateVertexCount(@Cast("size_t") long vcount);
        public native void estimateIndexCount(@Cast("size_t") long icount);
        public native void begin(@Const @ByRef String materialName,
                    @ByVal(nullValue = "RenderOperation::OperationType(RenderOperation::OT_TRIANGLE_LIST)") OperationType opType, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName);
        public native void begin(@Const @ByRef String materialName);




        public native void setDynamic(@Cast("bool") boolean dyn);

        public native @Cast("bool") boolean getDynamic();
        public native void beginUpdate(@Cast("size_t") long sectionIndex);







        public native @Name("position") void _position(@Const @ByRef Vector3 pos);

        public native @Name("position") void _position(double x, double y, double z);






        public native void normal(@Const @ByRef Vector3 norm);

        public native void normal(double x, double y, double z);
        public native void tangent(@Const @ByRef Vector3 tan);

        public native void tangent(double x, double y, double z);
        public native void textureCoord(double u);

        public native void textureCoord(double u, double v);

        public native void textureCoord(double u, double v, double w);

        public native void textureCoord(double x, double y, double z, double w);

        public native void textureCoord(@Const @ByRef Vector2 uv);

        public native void textureCoord(@Const @ByRef Vector3 uvw);

        public native void textureCoord(@Const @ByRef Vector4 xyzw);



        public native void colour(@Const @ByRef ColourValue col);



        public native void colour(double r, double g, double b, double a/*=1.0f*/);
        public native void colour(double r, double g, double b);
        public native void index(@Cast("Ogre::uint32") int idx);
        public native void triangle(@Cast("Ogre::uint32") int i1, @Cast("Ogre::uint32") int i2, @Cast("Ogre::uint32") int i3);
        public native void quad(@Cast("Ogre::uint32") int i1, @Cast("Ogre::uint32") int i2, @Cast("Ogre::uint32") int i3, @Cast("Ogre::uint32") int i4);


        public native @Cast("size_t") long getCurrentVertexCount();


        public native @Cast("size_t") long getCurrentIndexCount();





        public native ManualObjectSection end();
        public native void setMaterialName(@Cast("size_t") long subIndex, @Const @ByRef String name, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String group);
        public native void setMaterialName(@Cast("size_t") long subIndex, @Const @ByRef String name);
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr convertToMesh(@Const @ByRef String meshName,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName,
                    @Cast("bool") boolean buildShadowMapBuffers/*=true*/ );
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr convertToMesh(@Const @ByRef String meshName );
        public native void setUseIdentityProjection(@Cast("bool") boolean useIdentityProjection);
        public native @Cast("bool") boolean getUseIdentityProjection();
        public native void setUseIdentityView(@Cast("bool") boolean useIdentityView);
        public native @Cast("bool") boolean getUseIdentityView();



        public native ManualObjectSection getSection(@Cast("unsigned int") int index);



        public native @Cast("unsigned int") int getNumSections();
        public native void setKeepDeclarationOrder(@Cast("bool") boolean keepOrder);





        public native @Cast("bool") boolean getKeepDeclarationOrder();



        public native @Const @ByRef String getMovableType();

        public native void _updateRenderQueue(RenderQueue queue, Camera camera, @Const Camera lodCamera);

        public native EdgeData getEdgeList();

        public native @Cast("bool") boolean hasEdgeList();


        @NoOffset public static class ManualObjectSection extends Renderable {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public ManualObjectSection(Pointer p) { super(p); }
            public Pointer asPointer() { return asPointer(this); }
            @Namespace public static native @Name("static_cast<MovableAlloc*>") Pointer asPointer(ManualObject.ManualObjectSection pointer);
        
            public ManualObjectSection(ManualObject parent, @Const @ByRef String materialName,
                            @ByVal OperationType opType, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName) { super((Pointer)null); allocate(parent, materialName, opType, groupName); }
            private native void allocate(ManualObject parent, @Const @ByRef String materialName,
                            @ByVal OperationType opType, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName);
            public ManualObjectSection(ManualObject parent, @Const @ByRef String materialName,
                            @ByVal OperationType opType) { super((Pointer)null); allocate(parent, materialName, opType); }
            private native void allocate(ManualObject parent, @Const @ByRef String materialName,
                            @ByVal OperationType opType);


            public native RenderOperation getRenderOperation();

            public native @Const @ByRef String getMaterialName();

            public native @Const @ByRef String getMaterialGroup();

            public native void setMaterialName(@Const @ByRef String name, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME)") String groupName );
            public native void setMaterialName(@Const @ByRef String name );

            public native void set32BitIndices(@Cast("bool") boolean n32);

            public native @Cast("bool") boolean get32BitIndices();



            public native @Cast("const Ogre::MaterialPtr*") @ByRef RealControllerFunctionSPtr getMaterial();

            public native void getRenderOperation(@ByRef RenderOperation op, @Cast("bool") boolean casterPass);

            public native void getWorldTransforms(Matrix4 xform);

            public native double getSquaredViewDepth(@Const Camera arg0);

            public native @Cast("const Ogre::LightList*") @ByRef HashedVector getLights();



        }

    }



    @Namespace("Ogre::v1") @NoOffset public static class ManualObjectFactory extends MovableObjectFactory {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ManualObjectFactory(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ManualObjectFactory(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ManualObjectFactory position(long position) {
            return (ManualObjectFactory)super.position(position);
        }
    
        public ManualObjectFactory() { super((Pointer)null); allocate(); }
        private native void allocate();

        public static native @ByRef String FACTORY_TYPE_NAME(); public static native void FACTORY_TYPE_NAME(String FACTORY_TYPE_NAME);

        public native @Const @ByRef String getType();
        public native void destroyInstance( MovableObject obj);

    }




    @Namespace("Ogre") @NoOffset public static class MaterialManager extends ResourceManager {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MaterialManager(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MaterialManager(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public MaterialManager position(long position) {
            return (MaterialManager)super.position(position);
        }
        public MaterialManagerSgtRef asMaterialManagerSgtRef() { return asMaterialManagerSgtRef(this); }
        @Namespace public static native @Name("static_cast<Ogre::Singleton<Ogre::MaterialManager>*>") MaterialManagerSgtRef asMaterialManagerSgtRef(MaterialManager pointer);
    



        public static class Listener extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Listener(Pointer p) { super(p); }
        
            public native Technique handleSchemeNotFound(@Cast("unsigned short") short schemeIndex,
                            @Const @ByRef String schemeName, Material originalMaterial, @Cast("unsigned short") short lodIndex,
                            @Const Renderable rend);





   public native @Cast("bool") boolean afterIlluminationPassesCreated(Technique technique);





   public native @Cast("bool") boolean beforeIlluminationPassesCleared(Technique technique);
        }

        public static native @ByRef String DEFAULT_SCHEME_NAME(); public static native void DEFAULT_SCHEME_NAME(String DEFAULT_SCHEME_NAME);



        public native @ByVal @Cast("Ogre::MaterialPtr*") RealControllerFunctionSPtr create(@Const @ByRef String name, @Const @ByRef String group,
                                    @Cast("bool") boolean isManual/*=false*/, ManualResourceLoader loader/*=0*/,
                                    @Cast("const Ogre::NameValuePairList*") SStringMapRef createParams/*=0*/);
        public native @ByVal @Cast("Ogre::MaterialPtr*") RealControllerFunctionSPtr create(@Const @ByRef String name, @Const @ByRef String group);



        public native @ByVal @Cast("Ogre::MaterialPtr*") RealControllerFunctionSPtr getByName(@Const @ByRef String name, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME)") String groupName);
        public native @ByVal @Cast("Ogre::MaterialPtr*") RealControllerFunctionSPtr getByName(@Const @ByRef String name);



        public MaterialManager() { super((Pointer)null); allocate(); }
        private native void allocate();



        public native void initialise();



        public native void parseScript(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream, @Const @ByRef String groupName);
        public native @ByVal @Cast("Ogre::MaterialPtr*") RealControllerFunctionSPtr getDefaultSettings();




        public native @Cast("unsigned short") short _getSchemeIndex(@Const @ByRef String name);



        public native @Const @ByRef String _getSchemeName(@Cast("unsigned short") short index);



        public native @Cast("unsigned short") short _getActiveSchemeIndex();




        public native @Const @ByRef String getActiveScheme();




        public native void setActiveScheme(@Const @ByRef String schemeName);





        public native void addListener(Listener l, @Cast("const Ogre::Ogre::String*") @ByRef(nullValue = "Ogre::Ogre::String(Ogre::BLANKSTRING)") String schemeName);
        public native void addListener(Listener l);





        public native void removeListener(Listener l, @Cast("const Ogre::Ogre::String*") @ByRef(nullValue = "Ogre::Ogre::String(Ogre::BLANKSTRING)") String schemeName);
        public native void removeListener(Listener l);


        public native Technique _arbitrateMissingTechniqueForActiveScheme(
                    Material mat, @Cast("unsigned short") short lodIndex, @Const Renderable rend);


  public native void _notifyAfterIlluminationPassesCreated(Technique mat);


  public native void _notifyBeforeIlluminationPassesCleared(Technique mat);
        public static native @ByRef MaterialManager getSingleton();
        public static native MaterialManager getSingletonPtr();

    }




    @Namespace("Ogre") public static class MaterialScriptProgramDefinition extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public MaterialScriptProgramDefinition() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MaterialScriptProgramDefinition(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MaterialScriptProgramDefinition(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public MaterialScriptProgramDefinition position(long position) {
            return (MaterialScriptProgramDefinition)super.position(position);
        }
    
        public native @ByRef String name(); public native MaterialScriptProgramDefinition name(String name);
        public native @Cast("Ogre::GpuProgramType") int progType(); public native MaterialScriptProgramDefinition progType(int progType);
        public native @ByRef String language(); public native MaterialScriptProgramDefinition language(String language);
        public native @ByRef String source(); public native MaterialScriptProgramDefinition source(String source);
        public native @ByRef String syntax(); public native MaterialScriptProgramDefinition syntax(String syntax);
        public native @Cast("bool") boolean supportsSkeletalAnimation(); public native MaterialScriptProgramDefinition supportsSkeletalAnimation(boolean supportsSkeletalAnimation);
        public native @Cast("bool") boolean supportsMorphAnimation(); public native MaterialScriptProgramDefinition supportsMorphAnimation(boolean supportsMorphAnimation);
        public native short supportsPoseAnimation(); public native MaterialScriptProgramDefinition supportsPoseAnimation(short supportsPoseAnimation);
        public native @Cast("bool") boolean usesVertexTextureFetch(); public native MaterialScriptProgramDefinition usesVertexTextureFetch(boolean usesVertexTextureFetch);
        public native @ByRef @Cast("vector<std::pair<Ogre::String,Ogre::String> >::type*") StringPairVectorRef customParameters(); public native MaterialScriptProgramDefinition customParameters(StringPairVectorRef customParameters);
    }


    @Namespace("Ogre") @NoOffset public static class MaterialSerializer extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MaterialSerializer(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MaterialSerializer(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public MaterialSerializer position(long position) {
            return (MaterialSerializer)super.position(position);
        }
    


        /** enum Ogre::MaterialSerializer::SerializeEvent */
        public static final int
            MSE_PRE_WRITE = 0,
            MSE_WRITE_BEGIN = 1,
            MSE_WRITE_END = 2,
            MSE_POST_WRITE = 3;




        public static class Listener extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public Listener() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public Listener(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Listener(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public Listener position(long position) {
                return (Listener)super.position(position);
            }
        
            public native void materialEventRaised(MaterialSerializer ser,
                            @Cast("Ogre::MaterialSerializer::SerializeEvent") int event, @Cast("bool*") @ByRef BoolPointer skip, @Const Material mat);
            public native void materialEventRaised(MaterialSerializer ser,
                            @Cast("Ogre::MaterialSerializer::SerializeEvent") int event, @Cast("bool*") @ByRef boolean[] skip, @Const Material mat);
            public native void techniqueEventRaised(MaterialSerializer ser,
                            @Cast("Ogre::MaterialSerializer::SerializeEvent") int event, @Cast("bool*") @ByRef BoolPointer skip, @Const Technique tech);
            public native void techniqueEventRaised(MaterialSerializer ser,
                            @Cast("Ogre::MaterialSerializer::SerializeEvent") int event, @Cast("bool*") @ByRef boolean[] skip, @Const Technique tech);
            public native void passEventRaised(MaterialSerializer ser,
                            @Cast("Ogre::MaterialSerializer::SerializeEvent") int event, @Cast("bool*") @ByRef BoolPointer skip, @Const Pass pass);
            public native void passEventRaised(MaterialSerializer ser,
                            @Cast("Ogre::MaterialSerializer::SerializeEvent") int event, @Cast("bool*") @ByRef boolean[] skip, @Const Pass pass);
            public native void gpuProgramRefEventRaised(MaterialSerializer ser,
                            @Cast("Ogre::MaterialSerializer::SerializeEvent") int event, @Cast("bool*") @ByRef BoolPointer skip,
                            @Const @ByRef String attrib,
                            @Cast("const Ogre::GpuProgramPtr*") @ByRef RealControllerFunctionSPtr program,
                            @Cast("const Ogre::GpuProgramParametersSharedPtr*") @ByRef RealControllerFunctionSPtr params,
                            GpuProgramParameters defaultParams);
            public native void gpuProgramRefEventRaised(MaterialSerializer ser,
                            @Cast("Ogre::MaterialSerializer::SerializeEvent") int event, @Cast("bool*") @ByRef boolean[] skip,
                            @Const @ByRef String attrib,
                            @Cast("const Ogre::GpuProgramPtr*") @ByRef RealControllerFunctionSPtr program,
                            @Cast("const Ogre::GpuProgramParametersSharedPtr*") @ByRef RealControllerFunctionSPtr params,
                            GpuProgramParameters defaultParams);
            public native void textureUnitStateEventRaised(MaterialSerializer ser,
                            @Cast("Ogre::MaterialSerializer::SerializeEvent") int event, @Cast("bool*") @ByRef BoolPointer skip, @Const TextureUnitState textureUnit);
            public native void textureUnitStateEventRaised(MaterialSerializer ser,
                            @Cast("Ogre::MaterialSerializer::SerializeEvent") int event, @Cast("bool*") @ByRef boolean[] skip, @Const TextureUnitState textureUnit);
        }

        public MaterialSerializer() { super((Pointer)null); allocate(); }
        private native void allocate();
        public native void queueForExport(@Cast("const Ogre::MaterialPtr*") @ByRef RealControllerFunctionSPtr pMat, @Cast("bool") boolean clearQueued/*=false*/,
                    @Cast("bool") boolean exportDefaults/*=false*/, @Const @ByRef(nullValue = "Ogre::String(\"\")") String materialName);
        public native void queueForExport(@Cast("const Ogre::MaterialPtr*") @ByRef RealControllerFunctionSPtr pMat);
        public native void exportQueued(@Const @ByRef String filename, @Cast("const bool") boolean includeProgDef/*=false*/, @Const @ByRef(nullValue = "Ogre::String(\"\")") String programFilename);
        public native void exportQueued(@Const @ByRef String filename);
        public native void exportMaterial(@Cast("const Ogre::MaterialPtr*") @ByRef RealControllerFunctionSPtr pMat, @Const @ByRef String filename, @Cast("bool") boolean exportDefaults/*=false*/,
                    @Cast("const bool") boolean includeProgDef/*=false*/, @Const @ByRef(nullValue = "Ogre::String(\"\")") String programFilename,
                    @Const @ByRef(nullValue = "Ogre::String(\"\")") String materialName);
        public native void exportMaterial(@Cast("const Ogre::MaterialPtr*") @ByRef RealControllerFunctionSPtr pMat, @Const @ByRef String filename);

        public native @Const @ByRef String getQueuedAsString();

        public native void clearQueue();




        public native void addListener(Listener listener);




        public native void removeListener(Listener listener);
        public native void beginSection(@Cast("unsigned short") short level, @Cast("const bool") boolean useMainBuffer/*=true*/);
        public native void beginSection(@Cast("unsigned short") short level);
        public native void endSection(@Cast("unsigned short") short level, @Cast("const bool") boolean useMainBuffer/*=true*/);
        public native void endSection(@Cast("unsigned short") short level);

        public native void writeAttribute(@Cast("unsigned short") short level, @Const @ByRef String att, @Cast("const bool") boolean useMainBuffer/*=true*/);
        public native void writeAttribute(@Cast("unsigned short") short level, @Const @ByRef String att);

        public native void writeValue(@Const @ByRef String val, @Cast("const bool") boolean useMainBuffer/*=true*/);
        public native void writeValue(@Const @ByRef String val);

        public native @ByVal String quoteWord(@Const @ByRef String val);


        public native void writeComment(@Cast("unsigned short") short level, @Const @ByRef String comment, @Cast("const bool") boolean useMainBuffer/*=true*/);
        public native void writeComment(@Cast("unsigned short") short level, @Const @ByRef String comment);



    }



    @Namespace("Ogre::v1") @NoOffset public static class PatchSurface extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public PatchSurface(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public PatchSurface(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public PatchSurface position(long position) {
            return (PatchSurface)super.position(position);
        }
    
        public PatchSurface() { super((Pointer)null); allocate(); }
        private native void allocate();

        /** enum Ogre::v1::PatchSurface::PatchSurfaceType */
        public static final int

            PST_BEZIER = 0;


        /** enum Ogre::v1::PatchSurface:: */
        public static final int
            AUTO_LEVEL = -1;

        /** enum Ogre::v1::PatchSurface::VisibleSide */
        public static final int

            VS_FRONT = 0,

            VS_BACK = 1,

            VS_BOTH = 2;
        public native void defineSurface(Pointer controlPointBuffer,
                    VertexDeclaration declaration, @Cast("size_t") long width, @Cast("size_t") long height,
                    @Cast("Ogre::v1::PatchSurface::PatchSurfaceType") int pType/*=Ogre::v1::PatchSurface::PST_BEZIER*/,
                    @Cast("size_t") long uMaxSubdivisionLevel/*=Ogre::v1::PatchSurface::AUTO_LEVEL*/, @Cast("size_t") long vMaxSubdivisionLevel/*=Ogre::v1::PatchSurface::AUTO_LEVEL*/,
                    @Cast("Ogre::v1::PatchSurface::VisibleSide") int visibleSide/*=Ogre::v1::PatchSurface::VS_FRONT*/);
        public native void defineSurface(Pointer controlPointBuffer,
                    VertexDeclaration declaration, @Cast("size_t") long width, @Cast("size_t") long height);






        public native @Cast("size_t") long getRequiredVertexCount();





        public native @Cast("size_t") long getRequiredIndexCount();


        public native @Cast("size_t") long getCurrentIndexCount();

        public native @Cast("size_t") long getIndexOffset();

        public native @Cast("size_t") long getVertexOffset();



        public native @Const @ByRef AxisAlignedBox getBounds();


        public native double getBoundingSphereRadius();
        public native void build(@ByVal HardwareVertexBufferSharedPtr destVertexBuffer, @Cast("size_t") long vertexStart,
                    @ByVal HardwareIndexBufferSharedPtr destIndexBuffer, @Cast("size_t") long indexStart);
        public native void setSubdivisionFactor(double factor);


        public native double getSubdivisionFactor();

        public native Pointer getControlPointBuffer();


        public native void notifyControlPointBufferDeallocated();



    }





    @Name("Ogre::MeshManager") @NoOffset public static class MeshManager extends ResourceManager {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MeshManager(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MeshManager(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public MeshManager position(long position) {
            return (MeshManager)super.position(position);
        }
        public MeshManagerSgtRef asMeshManagerSgtRef() { return asMeshManagerSgtRef(this); }
        @Namespace public static native @Name("static_cast<Ogre::Singleton<Ogre::MeshManager>*>") MeshManagerSgtRef asMeshManagerSgtRef(MeshManager pointer);
        public ManualResourceLoader asManualResourceLoader() { return asManualResourceLoader(this); }
        @Namespace public static native @Name("static_cast<Ogre::ManualResourceLoader*>") ManualResourceLoader asManualResourceLoader(MeshManager pointer);
    
        public MeshManager() { super((Pointer)null); allocate(); }
        private native void allocate();


        public native void _initialise();



        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr getByName(@Const @ByRef String name, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME)") String groupName);
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr getByName(@Const @ByRef String name);




        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr create(@Const @ByRef String name, @Const @ByRef String group,
                                    @Cast("bool") boolean isManual/*=false*/, ManualResourceLoader loader/*=0*/,
                                    @Cast("const Ogre::NameValuePairList*") SStringMapRef createParams/*=0*/);
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr create(@Const @ByRef String name, @Const @ByRef String group);
        public native @ByVal ResourceCreateOrRetrieveResult createOrRetrieve(
                    @Const @ByRef String name,
                    @Const @ByRef String group,
                    @Cast("bool") boolean isManual/*=false*/, ManualResourceLoader loader/*=0*/,
                    @Cast("const Ogre::NameValuePairList*") SStringMapRef params/*=0*/,
                    @ByVal(nullValue = "HardwareBuffer::Usage(HardwareBuffer::HBU_STATIC_WRITE_ONLY)") Usage vertexBufferUsage,
                    @ByVal(nullValue = "HardwareBuffer::Usage(HardwareBuffer::HBU_STATIC_WRITE_ONLY)") Usage indexBufferUsage,
                    @Cast("bool") boolean vertexBufferShadowed/*=true*/, @Cast("bool") boolean indexBufferShadowed/*=true*/);
        public native @ByVal ResourceCreateOrRetrieveResult createOrRetrieve(
                    @Const @ByRef String name,
                    @Const @ByRef String group);
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr prepare( @Const @ByRef String filename, @Const @ByRef String groupName,
                    @ByVal(nullValue = "HardwareBuffer::Usage(HardwareBuffer::HBU_STATIC_WRITE_ONLY)") Usage vertexBufferUsage,
                    @ByVal(nullValue = "HardwareBuffer::Usage(HardwareBuffer::HBU_STATIC_WRITE_ONLY)") Usage indexBufferUsage,
                    @Cast("bool") boolean vertexBufferShadowed/*=true*/, @Cast("bool") boolean indexBufferShadowed/*=true*/);
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr prepare( @Const @ByRef String filename, @Const @ByRef String groupName);
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr load( @Const @ByRef String filename, @Const @ByRef String groupName,
                    @ByVal(nullValue = "HardwareBuffer::Usage(HardwareBuffer::HBU_STATIC_WRITE_ONLY)") Usage vertexBufferUsage,
                    @ByVal(nullValue = "HardwareBuffer::Usage(HardwareBuffer::HBU_STATIC_WRITE_ONLY)") Usage indexBufferUsage,
                    @Cast("bool") boolean vertexBufferShadowed/*=true*/, @Cast("bool") boolean indexBufferShadowed/*=true*/);
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr load( @Const @ByRef String filename, @Const @ByRef String groupName);
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr createManual( @Const @ByRef String name, @Const @ByRef String groupName,
                    ManualResourceLoader loader/*=0*/);
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr createManual( @Const @ByRef String name, @Const @ByRef String groupName);
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr createPlane(
                    @Const @ByRef String name, @Const @ByRef String groupName, @Const @ByRef Plane plane,
                    double width, double height,
                    int xsegments/*=1*/, int ysegments/*=1*/,
                    @Cast("bool") boolean normals/*=true*/, @Cast("unsigned short") short numTexCoordSets/*=1*/,
                    double uTile/*=1.0f*/, double vTile/*=1.0f*/, @Const @ByRef(nullValue = "Ogre::Vector3::UNIT_Y") Vector3 upVector,
                    @ByVal(nullValue = "HardwareBuffer::Usage(HardwareBuffer::HBU_STATIC_WRITE_ONLY)") Usage vertexBufferUsage,
                    @ByVal(nullValue = "HardwareBuffer::Usage(HardwareBuffer::HBU_STATIC_WRITE_ONLY)") Usage indexBufferUsage,
                    @Cast("bool") boolean vertexShadowBuffer/*=true*/, @Cast("bool") boolean indexShadowBuffer/*=true*/);
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr createPlane(
                    @Const @ByRef String name, @Const @ByRef String groupName, @Const @ByRef Plane plane,
                    double width, double height);
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr createCurvedIllusionPlane(
                    @Const @ByRef String name, @Const @ByRef String groupName, @Const @ByRef Plane plane,
                    double width, double height, double curvature,
                    int xsegments/*=1*/, int ysegments/*=1*/,
                    @Cast("bool") boolean normals/*=true*/, @Cast("unsigned short") short numTexCoordSets/*=1*/,
                    double uTile/*=1.0f*/, double vTile/*=1.0f*/, @Const @ByRef(nullValue = "Ogre::Vector3::UNIT_Y") Vector3 upVector,
                    @Const @ByRef(nullValue = "Ogre::Quaternion::IDENTITY") Quaternion orientation,
                    @ByVal(nullValue = "HardwareBuffer::Usage(HardwareBuffer::HBU_STATIC_WRITE_ONLY)") Usage vertexBufferUsage,
                    @ByVal(nullValue = "HardwareBuffer::Usage(HardwareBuffer::HBU_STATIC_WRITE_ONLY)") Usage indexBufferUsage,
                    @Cast("bool") boolean vertexShadowBuffer/*=true*/, @Cast("bool") boolean indexShadowBuffer/*=true*/,
                    int ySegmentsToKeep/*=-1*/);
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr createCurvedIllusionPlane(
                    @Const @ByRef String name, @Const @ByRef String groupName, @Const @ByRef Plane plane,
                    double width, double height, double curvature);
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr createCurvedPlane(
                    @Const @ByRef String name, @Const @ByRef String groupName, @Const @ByRef Plane plane,
                    double width, double height, double bow/*=0.5f*/,
                    int xsegments/*=1*/, int ysegments/*=1*/,
                    @Cast("bool") boolean normals/*=false*/, @Cast("unsigned short") short numTexCoordSets/*=1*/,
                    double uTile/*=1.0f*/, double vTile/*=1.0f*/, @Const @ByRef(nullValue = "Ogre::Vector3::UNIT_Y") Vector3 upVector,
                    @ByVal(nullValue = "HardwareBuffer::Usage(HardwareBuffer::HBU_STATIC_WRITE_ONLY)") Usage vertexBufferUsage,
                    @ByVal(nullValue = "HardwareBuffer::Usage(HardwareBuffer::HBU_STATIC_WRITE_ONLY)") Usage indexBufferUsage,
                    @Cast("bool") boolean vertexShadowBuffer/*=true*/, @Cast("bool") boolean indexShadowBuffer/*=true*/);
        public native @ByVal @Cast("Ogre::MeshPtr*") RealControllerFunctionSPtr createCurvedPlane(
                    @Const @ByRef String name, @Const @ByRef String groupName, @Const @ByRef Plane plane,
                    double width, double height);
        public native @ByVal PatchMeshPtr createBezierPatch(
                    @Const @ByRef String name, @Const @ByRef String groupName, Pointer controlPointBuffer,
                    VertexDeclaration declaration, @Cast("size_t") long width, @Cast("size_t") long height,
                    @Cast("size_t") long uMaxSubdivisionLevel/*=PatchSurface::AUTO_LEVEL*/,
                    @Cast("size_t") long vMaxSubdivisionLevel/*=PatchSurface::AUTO_LEVEL*/,
                    @ByVal(nullValue = "PatchSurface::VisibleSide(PatchSurface::VS_FRONT)") VisibleSide visibleSide,
                    @ByVal(nullValue = "HardwareBuffer::Usage(HardwareBuffer::HBU_STATIC_WRITE_ONLY)") Usage vbUsage,
                    @ByVal(nullValue = "HardwareBuffer::Usage(HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY)") Usage ibUsage,
                    @Cast("bool") boolean vbUseShadow/*=true*/, @Cast("bool") boolean ibUseShadow/*=true*/);
        public native @ByVal PatchMeshPtr createBezierPatch(
                    @Const @ByRef String name, @Const @ByRef String groupName, Pointer controlPointBuffer,
                    VertexDeclaration declaration, @Cast("size_t") long width, @Cast("size_t") long height);




        public native void setPrepareAllMeshesForShadowVolumes(@Cast("bool") boolean enable);

        public native @Cast("bool") boolean getPrepareAllMeshesForShadowVolumes();
        public static native @ByRef MeshManager getSingleton();
        public static native MeshManager getSingletonPtr();




        public native double getBoundsPaddingFactor();



        public native void setBoundsPaddingFactor(double paddingFactor);




        public static native void unshareVertices( Mesh mesh );



        public native void setListener(MeshSerializerListener listener);



        public native MeshSerializerListener getListener();


        public native void loadResource(Resource res);
    }






    @Namespace("Ogre") @NoOffset public static class MovablePlane extends Plane {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MovablePlane(Pointer p) { super(p); }
        public MovableObject asMovableObject() { return asMovableObject(this); }
        @Namespace public static native @Name("static_cast<Ogre::MovableObject*>") MovableObject asMovableObject(MovablePlane pointer);
    

        public MovablePlane( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager ) { super((Pointer)null); allocate(id, objectMemoryManager, manager); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager );
        public MovablePlane( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager,
                              @Const @ByRef Plane rhs ) { super((Pointer)null); allocate(id, objectMemoryManager, manager, rhs); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager,
                              @Const @ByRef Plane rhs );

        public MovablePlane( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager,
                              @Const @ByRef Vector3 rkNormal, double fConstant ) { super((Pointer)null); allocate(id, objectMemoryManager, manager, rkNormal, fConstant); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager,
                              @Const @ByRef Vector3 rkNormal, double fConstant );
        public MovablePlane( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager,
                              @Const @ByRef Vector3 rkNormal, @Const @ByRef Vector3 rkPoint ) { super((Pointer)null); allocate(id, objectMemoryManager, manager, rkNormal, rkPoint); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager,
                              @Const @ByRef Vector3 rkNormal, @Const @ByRef Vector3 rkPoint );
        public MovablePlane( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager,
                              @Const @ByRef Vector3 rkPoint0, @Const @ByRef Vector3 rkPoint1, @Const @ByRef Vector3 rkPoint2 ) { super((Pointer)null); allocate(id, objectMemoryManager, manager, rkPoint0, rkPoint1, rkPoint2); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager,
                              @Const @ByRef Vector3 rkPoint0, @Const @ByRef Vector3 rkPoint1, @Const @ByRef Vector3 rkPoint2 );

        public native @Const @ByRef AxisAlignedBox getBoundingBox();

        public native void _updateRenderQueue(RenderQueue arg0, Camera camera, @Const Camera lodCamera);

        public native @Const @ByRef String getMovableType();

        public native @Const @ByRef Plane _getDerivedPlane();
    }



    @Namespace("Ogre::v1") @NoOffset public static class EdgeData extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public EdgeData(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public EdgeData(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public EdgeData position(long position) {
            return (EdgeData)super.position(position);
        }
    

        public EdgeData() { super((Pointer)null); allocate(); }
        private native void allocate();


        @NoOffset public static class Triangle extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Triangle(Pointer p) { super(p); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public Triangle(long size) { super((Pointer)null); allocateArray(size); }
            private native void allocateArray(long size);
            @Override public Triangle position(long position) {
                return (Triangle)super.position(position);
            }
        


            public native @Cast("size_t") long indexSet(); public native Triangle indexSet(long indexSet);

            public native @Cast("size_t") long vertexSet(); public native Triangle vertexSet(long vertexSet);

            public native @Cast("size_t") long vertIndex(int i); public native Triangle vertIndex(int i, long vertIndex);
            @MemberGetter public native @Cast("size_t*") SizeTPointer vertIndex();


            public native @Cast("size_t") long sharedVertIndex(int i); public native Triangle sharedVertIndex(int i, long sharedVertIndex);
            @MemberGetter public native @Cast("size_t*") SizeTPointer sharedVertIndex();

            public Triangle() { super((Pointer)null); allocate(); }
            private native void allocate();
        }

        public static class Edge extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public Edge() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public Edge(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Edge(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public Edge position(long position) {
                return (Edge)super.position(position);
            }
        



            public native @Cast("size_t") long triIndex(int i); public native Edge triIndex(int i, long triIndex);
            @MemberGetter public native @Cast("size_t*") SizeTPointer triIndex();


            public native @Cast("size_t") long vertIndex(int i); public native Edge vertIndex(int i, long vertIndex);
            @MemberGetter public native @Cast("size_t*") SizeTPointer vertIndex();

            public native @Cast("size_t") long sharedVertIndex(int i); public native Edge sharedVertIndex(int i, long sharedVertIndex);
            @MemberGetter public native @Cast("size_t*") SizeTPointer sharedVertIndex();

            public native @Cast("bool") boolean degenerate(); public native Edge degenerate(boolean degenerate);
        }


        public static class EdgeGroup extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public EdgeGroup() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public EdgeGroup(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public EdgeGroup(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public EdgeGroup position(long position) {
                return (EdgeGroup)super.position(position);
            }
        

            public native @Cast("size_t") long vertexSet(); public native EdgeGroup vertexSet(long vertexSet);

            @MemberGetter public native @Const VertexData vertexData();




            public native @Cast("size_t") long triStart(); public native EdgeGroup triStart(long triStart);

            public native @Cast("size_t") long triCount(); public native EdgeGroup triCount(long triCount);

            public native @ByRef @Cast("Ogre::v1::EdgeData::EdgeList*") EdgeVectorRef edges(); public native EdgeGroup edges(EdgeVectorRef edges);

        }




        public native @ByRef @Cast("Ogre::v1::EdgeData::TriangleList*") TriangleVectorRef triangles(); public native EdgeData triangles(TriangleVectorRef triangles);

        public native @ByRef @Cast("Ogre::v1::EdgeData::TriangleFaceNormalList*") CharPtrVectorRef triangleFaceNormals(); public native EdgeData triangleFaceNormals(CharPtrVectorRef triangleFaceNormals);

        public native @ByRef @Cast("Ogre::v1::EdgeData::TriangleLightFacingList*") CharVectorRef triangleLightFacings(); public native EdgeData triangleLightFacings(CharVectorRef triangleLightFacings);

        public native @ByRef @Cast("Ogre::v1::EdgeData::EdgeGroupList*") EdgeGroupVectorRef edgeGroups(); public native EdgeData edgeGroups(EdgeGroupVectorRef edgeGroups);

        public native @Cast("bool") boolean isClosed(); public native EdgeData isClosed(boolean isClosed);
        public native void updateTriangleLightFacing(@Const @ByRef Vector4 lightPos);





        public native void updateFaceNormals(@Cast("size_t") long vertexSet, @Const @ByRef HardwareVertexBufferSharedPtr positionBuffer);

        public native EdgeData clone();



        public native void log(Log log);

    }
    @Namespace("Ogre::v1") @NoOffset public static class EdgeListBuilder extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public EdgeListBuilder(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public EdgeListBuilder(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public EdgeListBuilder position(long position) {
            return (EdgeListBuilder)super.position(position);
        }
    

        public EdgeListBuilder() { super((Pointer)null); allocate(); }
        private native void allocate();





        public native void addVertexData(@Const VertexData vertexData);
        public native void addIndexData(@Const IndexData indexData, @Cast("size_t") long vertexSet/*=0*/,
                    @Cast("Ogre::v1::RenderOperation::OperationType") int opType/*=Ogre::v1::RenderOperation::OT_TRIANGLE_LIST*/);
        public native void addIndexData(@Const IndexData indexData);





        public native EdgeData build();


        public native void log(Log l);
    }





    @Namespace("Ogre::v1") @NoOffset public static class MeshSerializerImpl extends Serializer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MeshSerializerImpl(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MeshSerializerImpl(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public MeshSerializerImpl position(long position) {
            return (MeshSerializerImpl)super.position(position);
        }
    
        public MeshSerializerImpl() { super((Pointer)null); allocate(); }
        private native void allocate();
        public native void exportMesh(@Const Mesh pMesh, @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr stream,
                    @ByVal(nullValue = "Endian(ENDIAN_NATIVE)") Endian endianMode);
        public native void exportMesh(@Const Mesh pMesh, @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr stream);
        public native void importMesh(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream, Mesh pDest, MeshSerializerListener listener);
    }




    @Namespace("Ogre::v1") public static class MeshSerializerImpl_v1_10 extends MeshSerializerImpl {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MeshSerializerImpl_v1_10(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MeshSerializerImpl_v1_10(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public MeshSerializerImpl_v1_10 position(long position) {
            return (MeshSerializerImpl_v1_10)super.position(position);
        }
    
        public MeshSerializerImpl_v1_10() { super((Pointer)null); allocate(); }
        private native void allocate();
    }





    @Namespace("Ogre::v1") public static class MeshSerializerImpl_v1_8 extends MeshSerializerImpl_v1_10 {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MeshSerializerImpl_v1_8(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MeshSerializerImpl_v1_8(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public MeshSerializerImpl_v1_8 position(long position) {
            return (MeshSerializerImpl_v1_8)super.position(position);
        }
    
        public MeshSerializerImpl_v1_8() { super((Pointer)null); allocate(); }
        private native void allocate();
    }




    @Namespace("Ogre::v1") public static class MeshSerializerImpl_v1_41 extends MeshSerializerImpl_v1_8 {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MeshSerializerImpl_v1_41(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MeshSerializerImpl_v1_41(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public MeshSerializerImpl_v1_41 position(long position) {
            return (MeshSerializerImpl_v1_41)super.position(position);
        }
    
        public MeshSerializerImpl_v1_41() { super((Pointer)null); allocate(); }
        private native void allocate();
    }




    @Namespace("Ogre::v1") public static class MeshSerializerImpl_v1_4 extends MeshSerializerImpl_v1_41 {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MeshSerializerImpl_v1_4(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MeshSerializerImpl_v1_4(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public MeshSerializerImpl_v1_4 position(long position) {
            return (MeshSerializerImpl_v1_4)super.position(position);
        }
    
        public MeshSerializerImpl_v1_4() { super((Pointer)null); allocate(); }
        private native void allocate();

    }




    @Namespace("Ogre::v1") public static class MeshSerializerImpl_v1_3 extends MeshSerializerImpl_v1_4 {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MeshSerializerImpl_v1_3(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MeshSerializerImpl_v1_3(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public MeshSerializerImpl_v1_3 position(long position) {
            return (MeshSerializerImpl_v1_3)super.position(position);
        }
    
        public MeshSerializerImpl_v1_3() { super((Pointer)null); allocate(); }
        private native void allocate();
    }




    @Namespace("Ogre::v1") public static class MeshSerializerImpl_v1_2 extends MeshSerializerImpl_v1_3 {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MeshSerializerImpl_v1_2(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MeshSerializerImpl_v1_2(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public MeshSerializerImpl_v1_2 position(long position) {
            return (MeshSerializerImpl_v1_2)super.position(position);
        }
    
        public MeshSerializerImpl_v1_2() { super((Pointer)null); allocate(); }
        private native void allocate();
    }




    @Namespace("Ogre::v1") public static class MeshSerializerImpl_v1_1 extends MeshSerializerImpl_v1_2 {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MeshSerializerImpl_v1_1(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MeshSerializerImpl_v1_1(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public MeshSerializerImpl_v1_1 position(long position) {
            return (MeshSerializerImpl_v1_1)super.position(position);
        }
    
        public MeshSerializerImpl_v1_1() { super((Pointer)null); allocate(); }
        private native void allocate();
    }







    /** enum Ogre::v1::MeshVersion */
    public static final int

        MESH_VERSION_LATEST = 0,


        MESH_VERSION_2_1 = 1,


        MESH_VERSION_1_10 = 2,

        MESH_VERSION_1_8 = 3,

        MESH_VERSION_1_7 = 4,

        MESH_VERSION_1_4 = 5,

        MESH_VERSION_1_0 = 6,


        MESH_VERSION_LEGACY = 7;
    @Namespace("Ogre::v1") @NoOffset public static class MeshSerializer extends Serializer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MeshSerializer(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MeshSerializer(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public MeshSerializer position(long position) {
            return (MeshSerializer)super.position(position);
        }
    
        public MeshSerializer() { super((Pointer)null); allocate(); }
        private native void allocate();
        public native void exportMesh(@Const Mesh pMesh, @Const @ByRef String filename,
                    @ByVal(nullValue = "Endian(ENDIAN_NATIVE)") Endian endianMode);
        public native void exportMesh(@Const Mesh pMesh, @Const @ByRef String filename);
        public native void exportMesh(@Const Mesh pMesh, @Const @ByRef String filename,
                                @Cast("Ogre::v1::MeshVersion") int version,
                                @ByVal(nullValue = "Endian(ENDIAN_NATIVE)") Endian endianMode);
        public native void exportMesh(@Const Mesh pMesh, @Const @ByRef String filename,
                                @Cast("Ogre::v1::MeshVersion") int version);
        public native void exportMesh(@Const Mesh pMesh, @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr stream,
                    @ByVal(nullValue = "Endian(ENDIAN_NATIVE)") Endian endianMode);
        public native void exportMesh(@Const Mesh pMesh, @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr stream);
        public native void exportMesh(@Const Mesh pMesh, @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr stream,
                                @Cast("Ogre::v1::MeshVersion") int version,
                                @ByVal(nullValue = "Endian(ENDIAN_NATIVE)") Endian endianMode);
        public native void exportMesh(@Const Mesh pMesh, @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr stream,
                                @Cast("Ogre::v1::MeshVersion") int version);
        public native void importMesh(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream, Mesh pDest);


        public native void setListener(MeshSerializerListener listener);

        public native MeshSerializerListener getListener();

    }
    @Namespace("Ogre::v1") public static class MeshSerializerListener extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MeshSerializerListener(Pointer p) { super(p); }
    

        public native void processMaterialName(Mesh mesh, String name);

        public native void processSkeletonName(Mesh mesh, String name);

        public native void processMeshCompleted(Mesh mesh);
    }




    @Namespace("Ogre") @NoOffset public static class ParticleAffector extends StringInterface {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ParticleAffector(Pointer p) { super(p); }
        public Pointer asPointer() { return asPointer(this); }
        @Namespace public static native @Name("static_cast<FXAlloc*>") Pointer asPointer(ParticleAffector pointer);
    
        public native void _initParticle(Particle pParticle);
        public native void _affectParticles(ParticleSystem pSystem, double timeElapsed);






        public native @Const @ByRef String getType();

    }





        @Namespace("Ogre::EmitterCommands") public static class CmdAngle extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdAngle() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdAngle(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdAngle(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdAngle position(long position) {
                return (CmdAngle)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        @Namespace("Ogre::EmitterCommands") public static class CmdColour extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdColour() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdColour(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdColour(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdColour position(long position) {
                return (CmdColour)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }


        @Namespace("Ogre::EmitterCommands") public static class CmdColourRangeStart extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdColourRangeStart() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdColourRangeStart(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdColourRangeStart(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdColourRangeStart position(long position) {
                return (CmdColourRangeStart)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        @Namespace("Ogre::EmitterCommands") public static class CmdColourRangeEnd extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdColourRangeEnd() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdColourRangeEnd(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdColourRangeEnd(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdColourRangeEnd position(long position) {
                return (CmdColourRangeEnd)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }


        @Namespace("Ogre::EmitterCommands") public static class CmdDirection extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdDirection() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdDirection(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdDirection(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdDirection position(long position) {
                return (CmdDirection)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }


        @Namespace("Ogre::EmitterCommands") public static class CmdUp extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdUp() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdUp(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdUp(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdUp position(long position) {
                return (CmdUp)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }


        @Namespace("Ogre::EmitterCommands") public static class CmdDirPositionRef extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdDirPositionRef() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdDirPositionRef(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdDirPositionRef(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdDirPositionRef position(long position) {
                return (CmdDirPositionRef)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }


        @Namespace("Ogre::EmitterCommands") public static class CmdEmissionRate extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdEmissionRate() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdEmissionRate(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdEmissionRate(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdEmissionRate position(long position) {
                return (CmdEmissionRate)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        @Namespace("Ogre::EmitterCommands") public static class CmdVelocity extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdVelocity() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdVelocity(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdVelocity(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdVelocity position(long position) {
                return (CmdVelocity)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        @Namespace("Ogre::EmitterCommands") public static class CmdMinVelocity extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdMinVelocity() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdMinVelocity(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdMinVelocity(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdMinVelocity position(long position) {
                return (CmdMinVelocity)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        @Namespace("Ogre::EmitterCommands") public static class CmdMaxVelocity extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdMaxVelocity() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdMaxVelocity(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdMaxVelocity(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdMaxVelocity position(long position) {
                return (CmdMaxVelocity)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        @Namespace("Ogre::EmitterCommands") public static class CmdTTL extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdTTL() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdTTL(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdTTL(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdTTL position(long position) {
                return (CmdTTL)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        @Namespace("Ogre::EmitterCommands") public static class CmdMinTTL extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdMinTTL() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdMinTTL(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdMinTTL(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdMinTTL position(long position) {
                return (CmdMinTTL)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        @Namespace("Ogre::EmitterCommands") public static class CmdMaxTTL extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdMaxTTL() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdMaxTTL(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdMaxTTL(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdMaxTTL position(long position) {
                return (CmdMaxTTL)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        @Namespace("Ogre::EmitterCommands") public static class CmdPosition extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdPosition() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdPosition(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdPosition(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdPosition position(long position) {
                return (CmdPosition)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        @Namespace("Ogre::EmitterCommands") public static class CmdDuration extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdDuration() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdDuration(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdDuration(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdDuration position(long position) {
                return (CmdDuration)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        @Namespace("Ogre::EmitterCommands") public static class CmdMinDuration extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdMinDuration() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdMinDuration(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdMinDuration(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdMinDuration position(long position) {
                return (CmdMinDuration)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        @Namespace("Ogre::EmitterCommands") public static class CmdMaxDuration extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdMaxDuration() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdMaxDuration(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdMaxDuration(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdMaxDuration position(long position) {
                return (CmdMaxDuration)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        @Namespace("Ogre::EmitterCommands") public static class CmdRepeatDelay extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdRepeatDelay() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdRepeatDelay(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdRepeatDelay(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdRepeatDelay position(long position) {
                return (CmdRepeatDelay)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        @Namespace("Ogre::EmitterCommands") public static class CmdMinRepeatDelay extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdMinRepeatDelay() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdMinRepeatDelay(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdMinRepeatDelay(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdMinRepeatDelay position(long position) {
                return (CmdMinRepeatDelay)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        @Namespace("Ogre::EmitterCommands") public static class CmdMaxRepeatDelay extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdMaxRepeatDelay() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdMaxRepeatDelay(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdMaxRepeatDelay(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdMaxRepeatDelay position(long position) {
                return (CmdMaxRepeatDelay)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        @Namespace("Ogre::EmitterCommands") public static class CmdName extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdName() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdName(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdName(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdName position(long position) {
                return (CmdName)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }


        @Namespace("Ogre::EmitterCommands") public static class CmdEmittedEmitter extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdEmittedEmitter() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdEmittedEmitter(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdEmittedEmitter(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdEmittedEmitter position(long position) {
                return (CmdEmittedEmitter)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

    




    @Namespace("Ogre") public static class ParticleVisualData extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ParticleVisualData(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ParticleVisualData(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ParticleVisualData position(long position) {
            return (ParticleVisualData)super.position(position);
        }
    
        public ParticleVisualData() { super((Pointer)null); allocate(); }
        private native void allocate();

    }


    @Namespace("Ogre") @NoOffset public static class Particle extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Particle(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Particle(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Particle position(long position) {
            return (Particle)super.position(position);
        }
    

        /** enum Ogre::Particle::ParticleType */
        public static final int
            Visual = 0,
            Emitter = 1;


        public native @Cast("bool") boolean mOwnDimensions(); public native Particle mOwnDimensions(boolean mOwnDimensions);

        public native double mWidth(); public native Particle mWidth(double mWidth);

        public native double mHeight(); public native Particle mHeight(double mHeight);

        public native @ByRef Radian mRotation(); public native Particle mRotation(Radian mRotation);



        public native @ByRef Vector3 mPosition(); public native Particle mPosition(Vector3 mPosition);

        public native @ByRef Vector3 mDirection(); public native Particle mDirection(Vector3 mDirection);

        public native @ByRef ColourValue mColour(); public native Particle mColour(ColourValue mColour);

        public native double mTimeToLive(); public native Particle mTimeToLive(double mTimeToLive);

        public native double mTotalTimeToLive(); public native Particle mTotalTimeToLive(double mTotalTimeToLive);

        public native @ByRef Radian mRotationSpeed(); public native Particle mRotationSpeed(Radian mRotationSpeed);

        public native @Cast("Ogre::Particle::ParticleType") int mParticleType(); public native Particle mParticleType(int mParticleType);

        public Particle() { super((Pointer)null); allocate(); }
        private native void allocate();
        public native void setDimensions(double width, double height);






        public native @Cast("bool") boolean hasOwnDimensions();


        public native double getOwnWidth();


        public native double getOwnHeight();


        public native void setRotation(@Const @ByRef Radian rad);

        public native @Const @ByRef Radian getRotation();



        public native void _notifyOwner(ParticleSystem owner);



        public native void _notifyVisualData(ParticleVisualData vis);


        public native ParticleVisualData getVisualData();


        public native void resetDimensions();
    }



    @Namespace("Ogre") @NoOffset public static class ParticleEmitter extends StringInterface {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ParticleEmitter(Pointer p) { super(p); }
        public Particle asParticle() { return asParticle(this); }
        @Namespace public static native @Name("static_cast<Ogre::Particle*>") Particle asParticle(ParticleEmitter pointer);
    


        public native void setPosition(@Const @ByRef Vector3 pos);


        public native @Const @ByRef Vector3 getPosition();
        public native void setDirection(@Const @ByRef Vector3 direction);


        public native @Const @ByRef Vector3 getDirection();
        public native void setUp(@Const @ByRef Vector3 up);


        public native @Const @ByRef Vector3 getUp();
        public native void setDirPositionReference( @Const @ByRef Vector3 position, @Cast("bool") boolean enable );


        public native @Const @ByRef Vector3 getDirPositionReference();


        public native @Cast("bool") boolean getDirPositionReferenceEnabled();
        public native void setAngle(@Const @ByRef Radian angle);


        public native @Const @ByRef Radian getAngle();
        public native void setParticleVelocity(double speed);
        public native void setParticleVelocity(double min, double max);

        public native void setMinParticleVelocity(double min);

        public native void setMaxParticleVelocity(double max);


        public native double getParticleVelocity();


        public native double getMinParticleVelocity();


        public native double getMaxParticleVelocity();
        public native void setEmissionRate(double particlesPerSecond);


        public native double getEmissionRate();
        public native void setTimeToLive(double ttl);
        public native void setTimeToLive(double minTtl, double maxTtl);


        public native void setMinTimeToLive(double min);

        public native void setMaxTimeToLive(double max);


        public native double getTimeToLive();


        public native double getMinTimeToLive();

        public native double getMaxTimeToLive();
        public native void setColour(@Const @ByRef ColourValue colour);
        public native void setColour(@Const @ByRef ColourValue colourStart, @Const @ByRef ColourValue colourEnd);

        public native void setColourRangeStart(@Const @ByRef ColourValue colour);

        public native void setColourRangeEnd(@Const @ByRef ColourValue colour);

        public native @Const @ByRef ColourValue getColour();

        public native @Const @ByRef ColourValue getColourRangeStart();

        public native @Const @ByRef ColourValue getColourRangeEnd();
        public native @Cast("unsigned short") short _getEmissionCount(double timeElapsed);
        public native void _initParticle(Particle pParticle);







        public native @Const @ByRef String getType();





        public native void setEnabled(@Cast("bool") boolean enabled);


        public native @Cast("bool") boolean getEnabled();
        public native void setStartTime(double startTime);

        public native double getStartTime();
        public native void setDuration(double duration);


        public native double getDuration();
        public native void setDuration(double min, double max);

        public native void setMinDuration(double min);

        public native void setMaxDuration(double max);

        public native double getMinDuration();

        public native double getMaxDuration();
        public native void setRepeatDelay(double duration);


        public native double getRepeatDelay();
        public native void setRepeatDelay(double min, double max);

        public native void setMinRepeatDelay(double min);

        public native void setMaxRepeatDelay(double max);

        public native double getMinRepeatDelay();

        public native double getMaxRepeatDelay();


        public native @Const @ByRef String getName();


        public native void setName(@Const @ByRef String newName);


        public native @Const @ByRef String getEmittedEmitter();


        public native void setEmittedEmitter(@Const @ByRef String emittedEmitter);


        public native @Cast("bool") boolean isEmitted();


        public native void setEmitted(@Cast("bool") boolean emitted);


    }




    @Namespace("Ogre") @NoOffset public static class ParticleIterator extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ParticleIterator(Pointer p) { super(p); }
    

        public native @Cast("bool") boolean end();


        public native Particle getNext();
    }



    @Namespace("Ogre") @NoOffset public static class ParticleSystem extends StringInterface {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ParticleSystem(Pointer p) { super(p); }
        public MovableObject asMovableObject() { return asMovableObject(this); }
        @Namespace public static native @Name("static_cast<Ogre::MovableObject*>") MovableObject asMovableObject(ParticleSystem pointer);
    


        public static class CmdQuota extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdQuota() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdQuota(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdQuota(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdQuota position(long position) {
                return (CmdQuota)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        public static class CmdEmittedEmitterQuota extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdEmittedEmitterQuota() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdEmittedEmitterQuota(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdEmittedEmitterQuota(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdEmittedEmitterQuota position(long position) {
                return (CmdEmittedEmitterQuota)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        public static class CmdMaterial extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdMaterial() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdMaterial(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdMaterial(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdMaterial position(long position) {
                return (CmdMaterial)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        public static class CmdCull extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdCull() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdCull(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdCull(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdCull position(long position) {
                return (CmdCull)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        public static class CmdWidth extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdWidth() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdWidth(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdWidth(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdWidth position(long position) {
                return (CmdWidth)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        public static class CmdHeight extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdHeight() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdHeight(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdHeight(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdHeight position(long position) {
                return (CmdHeight)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        public static class CmdRenderer extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdRenderer() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdRenderer(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdRenderer(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdRenderer position(long position) {
                return (CmdRenderer)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        public static class CmdSorted extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdSorted() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdSorted(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdSorted(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdSorted position(long position) {
                return (CmdSorted)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        public static class CmdLocalSpace extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdLocalSpace() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdLocalSpace(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdLocalSpace(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdLocalSpace position(long position) {
                return (CmdLocalSpace)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        public static class CmdIterationInterval extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdIterationInterval() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdIterationInterval(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdIterationInterval(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdIterationInterval position(long position) {
                return (CmdIterationInterval)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }

        public static class CmdNonvisibleTimeout extends ParamCommand {
            static { Loader.load(); }
            /** Default native constructor. */
            public CmdNonvisibleTimeout() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public CmdNonvisibleTimeout(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public CmdNonvisibleTimeout(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public CmdNonvisibleTimeout position(long position) {
                return (CmdNonvisibleTimeout)super.position(position);
            }
        
            public native @ByVal String doGet(@Const Pointer target);
            public native void doSet(Pointer target, @Const @ByRef String val);
        }






        public ParticleSystem( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager,
                                @Const @ByRef String resourceGroupName ) { super((Pointer)null); allocate(id, objectMemoryManager, manager, resourceGroupName); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager,
                                @Const @ByRef String resourceGroupName );
        public native void setRenderer(@Const @ByRef String typeName);


        public native ParticleSystemRenderer getRenderer();

        public native @Const @ByRef String getRendererName();
        public native ParticleEmitter addEmitter(@Const @ByRef String emitterType);
        public native ParticleEmitter getEmitter(@Cast("unsigned short") short index);


        public native @Cast("unsigned short") short getNumEmitters();
        public native void removeEmitter(@Cast("unsigned short") short index);


        public native void removeAllEmitters();







        public native void removeEmitter(ParticleEmitter emitter);
        public native ParticleAffector addAffector(@Const @ByRef String affectorType);
        public native ParticleAffector getAffector(@Cast("unsigned short") short index);


        public native @Cast("unsigned short") short getNumAffectors();
        public native void removeAffector(@Cast("unsigned short") short index);


        public native void removeAllAffectors();



        public native void clear();
        public native @Cast("size_t") long getNumParticles();
        public native Particle createParticle();
        public native Particle createEmitterParticle(@Const @ByRef String emitterName);







        public native Particle getParticle(@Cast("size_t") long index);





        public native @Cast("size_t") long getParticleQuota();
        public native void setParticleQuota(@Cast("size_t") long quota);





        public native @Cast("size_t") long getEmittedEmitterQuota();






        public native void setEmittedEmitterQuota(@Cast("size_t") long quota);






        public native @ByRef @Name("operator =") ParticleSystem put(@Const @ByRef ParticleSystem rhs);







        public native void _update(double timeElapsed);







        public native @ByVal ParticleIterator _getIterator();





        public native void setMaterialName( @Const @ByRef String name, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME)") String groupName );
        public native void setMaterialName( @Const @ByRef String name );




        public native @Const @ByRef String getMaterialName();





        public native void _notifyAttached(Node parent);





        public native void _updateRenderQueue(RenderQueue queue, Camera camera, @Const Camera lodCamera);
        public native void fastForward(double time, double interval/*=0.1*/);
        public native void fastForward(double time);
        public native void setSpeedFactor(double speedFactor);



        public native double getSpeedFactor();
        public native void setIterationInterval(double iterationInterval);



        public native double getIterationInterval();



        public static native void setDefaultIterationInterval(double iterationInterval);



        public static native double getDefaultIterationInterval();
        public native void setNonVisibleUpdateTimeout(double timeout);



        public native double getNonVisibleUpdateTimeout();



        public static native void setDefaultNonVisibleUpdateTimeout(double timeout);



        public static native double getDefaultNonVisibleUpdateTimeout();


        public native @Const @ByRef String getMovableType();



        public native void _notifyParticleResized();



        public native void _notifyParticleRotated();
        public native void setDefaultDimensions(double width, double height);


        public native void setDefaultWidth(double width);

        public native double getDefaultWidth();

        public native void setDefaultHeight(double height);

        public native double getDefaultHeight();

        public native @Cast("bool") boolean getCullIndividually();
        public native void setCullIndividually(@Cast("bool") boolean cullIndividual);

        public native @Const @ByRef String getResourceGroupName();






        public native @Const @ByRef String getOrigin();

        public native void _notifyOrigin(@Const @ByRef String origin);


        public native void setRenderQueueGroup(@Cast("Ogre::uint8") byte queueID);

        public native void setRenderQueueSubGroup( @Cast("Ogre::uint8") byte subGroup );







        public native void setSortingEnabled(@Cast("bool") boolean enabled);

        public native @Cast("bool") boolean getSortingEnabled();
        public native void setBoundsAutoUpdated(@Cast("bool") boolean autoUpdate, double stopIn/*=0.0f*/);
        public native void setBoundsAutoUpdated(@Cast("bool") boolean autoUpdate);
        public native void setKeepParticlesInLocalSpace(@Cast("bool") boolean keepLocal);




        public native @Cast("bool") boolean getKeepParticlesInLocalSpace();
        public native void _updateBounds();
        public native void setEmitting(@Cast("bool") boolean v);






        public native @Cast("bool") boolean getEmitting();
    }




    @Namespace("Ogre") @NoOffset public static class ParticleSystemManager extends ParticleSystemManagerSgtRef {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ParticleSystemManager(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ParticleSystemManager(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ParticleSystemManager position(long position) {
            return (ParticleSystemManager)super.position(position);
        }
        public ScriptLoader asScriptLoader() { return asScriptLoader(this); }
        @Namespace public static native @Name("static_cast<Ogre::ScriptLoader*>") ScriptLoader asScriptLoader(ParticleSystemManager pointer);
        public Pointer asPointer() { return asPointer(this); }
        @Namespace public static native @Name("static_cast<FXAlloc*>") Pointer asPointer(ParticleSystemManager pointer);
    

        public ParticleSystemManager() { super((Pointer)null); allocate(); }
        private native void allocate();
        public native void addEmitterFactory(ParticleEmitterFactory factory);
        public native void addAffectorFactory(ParticleAffectorFactory factory);
        public native void addRendererFactory(ParticleSystemRendererFactory factory);
        public native void addTemplate(@Const @ByRef String name, ParticleSystem sysTemplate);
        public native void removeTemplate(@Const @ByRef String name, @Cast("bool") boolean deleteTemplate/*=true*/);
        public native void removeTemplate(@Const @ByRef String name);







        public native void removeAllTemplates(@Cast("bool") boolean deleteTemplate/*=true*/);
        public native void removeAllTemplates();
        public native void removeTemplatesByResourceGroup(@Const @ByRef String resourceGroup);
        public native ParticleSystem createTemplate(@Const @ByRef String name, @Const @ByRef String resourceGroup);






        public native ParticleSystem getTemplate(@Const @ByRef String name);
        public native ParticleEmitter _createEmitter(@Const @ByRef String emitterType, ParticleSystem psys);
        public native void _destroyEmitter(ParticleEmitter emitter);
        public native ParticleAffector _createAffector(@Const @ByRef String affectorType, ParticleSystem psys);
        public native void _destroyAffector(ParticleAffector affector);
        public native ParticleSystemRenderer _createRenderer(@Const @ByRef String rendererType, SceneManager sceneManager);
        public native void _destroyRenderer(ParticleSystemRenderer renderer);






        public native void _initialise();


        public native @Cast("const Ogre::StringVector*") @ByRef StringVectorRef getScriptPatterns();

        public native void parseScript(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream, @Const @ByRef String groupName);

        public native double getLoadingOrder();

        public native @ByVal @Cast("Ogre::ParticleSystemManager::ParticleAffectorFactoryIterator*") AnimationStateMapIteratorRef getAffectorFactoryIterator();

        public native @ByVal @Cast("Ogre::ParticleSystemManager::ParticleEmitterFactoryIterator*") AnimationStateMapIteratorRef getEmitterFactoryIterator();

        public native @ByVal @Cast("Ogre::ParticleSystemManager::ParticleRendererFactoryIterator*") AnimationStateMapIteratorRef getRendererFactoryIterator();

        public native @ByVal @Cast("Ogre::ParticleSystemManager::ParticleSystemTemplateIterator*") AnimationStateMapIteratorRef getTemplateIterator();


        public native ParticleSystemFactory _getFactory();
        public static native @ByRef ParticleSystemManager getSingleton();
        public static native ParticleSystemManager getSingletonPtr();

    }


    @Namespace("Ogre") @NoOffset public static class ParticleSystemFactory extends MovableObjectFactory {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ParticleSystemFactory(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ParticleSystemFactory(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ParticleSystemFactory position(long position) {
            return (ParticleSystemFactory)super.position(position);
        }
    
        public ParticleSystemFactory() { super((Pointer)null); allocate(); }
        private native void allocate();

        public static native @ByRef String FACTORY_TYPE_NAME(); public static native void FACTORY_TYPE_NAME(String FACTORY_TYPE_NAME);

        public native @Const @ByRef String getType();
        public native void destroyInstance( MovableObject obj);

    }




    @Namespace("Ogre") @NoOffset public static class Pass extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Pass(Pointer p) { super(p); }
    

        public static native void _getBlendFlags(@Cast("Ogre::SceneBlendType") int type, @Cast("Ogre::SceneBlendFactor*") @ByRef IntPointer source, @Cast("Ogre::SceneBlendFactor*") @ByRef IntPointer dest);
        public static native void _getBlendFlags(@Cast("Ogre::SceneBlendType") int type, @Cast("Ogre::SceneBlendFactor*") @ByRef IntBuffer source, @Cast("Ogre::SceneBlendFactor*") @ByRef IntBuffer dest);
        public static native void _getBlendFlags(@Cast("Ogre::SceneBlendType") int type, @Cast("Ogre::SceneBlendFactor*") @ByRef int[] source, @Cast("Ogre::SceneBlendFactor*") @ByRef int[] dest);
                           
                           
                   
                      

        public Pass(Technique parent, @Cast("unsigned short") short index) { super((Pointer)null); allocate(parent, index); }
        private native void allocate(Technique parent, @Cast("unsigned short") short index);

        public Pass(Technique parent, @Cast("unsigned short") short index, @Const @ByRef Pass oth ) { super((Pointer)null); allocate(parent, index, oth); }
        private native void allocate(Technique parent, @Cast("unsigned short") short index, @Const @ByRef Pass oth );

        public native @ByRef @Name("operator =") Pass put(@Const @ByRef Pass oth);

        public native @Cast("Ogre::uint32") int getId();


        public native @Cast("bool") boolean isProgrammable();


        public native @Cast("bool") boolean hasVertexProgram();

        public native @Cast("bool") boolean hasFragmentProgram();

        public native @Cast("bool") boolean hasGeometryProgram();

        public native @Cast("bool") boolean hasTessellationHullProgram();

        public native @Cast("bool") boolean hasTessellationDomainProgram();

        public native @Cast("bool") boolean hasComputeProgram();

        public native @Cast("bool") boolean hasShadowCasterVertexProgram();

        public native @Cast("bool") boolean hasShadowCasterFragmentProgram();

        public native @Cast("size_t") long calculateSize();


        public native @Cast("unsigned short") short getIndex();





        public native void setName(@Const @ByRef String name);

        public native @Const @ByRef String getName();
        public native void setAmbient(double red, double green, double blue);
        public native void setAmbient(@Const @ByRef ColourValue ambient);
        public native void setDiffuse(double red, double green, double blue, double alpha);
        public native void setDiffuse(@Const @ByRef ColourValue diffuse);
        public native void setSpecular(double red, double green, double blue, double alpha);
        public native void setSpecular(@Const @ByRef ColourValue specular);






        public native void setShininess(double val);
        public native void setSelfIllumination(double red, double green, double blue);





        public native void setEmissive(double red, double green, double blue);
        public native void setSelfIllumination(@Const @ByRef ColourValue selfIllum);





        public native void setEmissive(@Const @ByRef ColourValue emissive);



        public native void setVertexColourTracking(@Cast("Ogre::TrackVertexColourType") int tracking);






        public native double getPointSize();
        public native void setPointSize(double ps);






        public native void setPointSpritesEnabled(@Cast("bool") boolean enabled);




        public native @Cast("bool") boolean getPointSpritesEnabled();
        public native void setPointAttenuation(@Cast("bool") boolean enabled,
                    double constant/*=0.0f*/, double linear/*=1.0f*/, double quadratic/*=0.0f*/);
        public native void setPointAttenuation(@Cast("bool") boolean enabled);


        public native @Cast("bool") boolean isPointAttenuationEnabled();


        public native double getPointAttenuationConstant();

        public native double getPointAttenuationLinear();

        public native double getPointAttenuationQuadratic();


        public native void setPointMinSize(double min);

        public native double getPointMinSize();



        public native void setPointMaxSize(double max);



        public native double getPointMaxSize();



        public native @Const @ByRef ColourValue getAmbient();



        public native @Const @ByRef ColourValue getDiffuse();



        public native @Const @ByRef ColourValue getSpecular();



        public native @Const @ByRef ColourValue getSelfIllumination();





        public native @Const @ByRef ColourValue getEmissive();



        public native double getShininess();



        public native @Cast("Ogre::TrackVertexColourType") int getVertexColourTracking();





        public native TextureUnitState createTextureUnitState();
        public native TextureUnitState createTextureUnitState( @Const @ByRef String textureName, @Cast("unsigned short") short texCoordSet/*=0*/);
        public native TextureUnitState createTextureUnitState( @Const @ByRef String textureName);





        public native void addTextureUnitState(TextureUnitState state);


        public native TextureUnitState getTextureUnitState( @Cast("size_t") long index );



        public native TextureUnitState getTextureUnitState(@Const @ByRef String name);







        public native @Cast("unsigned short") short getTextureUnitStateIndex(@Const TextureUnitState state);

        public native @ByVal @Cast("Ogre::Pass::TextureUnitStateIterator*") TechniquesVectorIteratorRef getTextureUnitStateIterator();





        public native void removeTextureUnitState(@Cast("unsigned short") short index);



        public native void removeAllTextureUnitStates();



        public native @Cast("unsigned short") short getNumTextureUnitStates();

        public native @Cast("size_t") long getNumShadowContentTextures();


        public native void recreateShadowContentTypeLookup();





        public native void insertShadowContentTypeLookup( @Cast("size_t") long textureUnitIndex );




        public native void removeShadowContentTypeLookup( @Cast("size_t") long textureUnitIndex );


        public native @Cast("bool") boolean isTransparent();


        public native @Cast("bool") boolean getColourWriteEnabled();
        public native void setMaxSimultaneousLights(@Cast("unsigned short") short maxLights);

        public native @Cast("unsigned short") short getMaxSimultaneousLights();
        public native void setStartLight(@Cast("unsigned short") short startLight);

        public native @Cast("unsigned short") short getStartLight();


        public native void setLightMask(@Cast("Ogre::uint32") int mask);

        public native @Cast("Ogre::uint32") int getLightMask();





        public native void setShadingMode( @Cast("Ogre::ShadeOptions") int mode );



        public native @Cast("Ogre::ShadeOptions") int getShadingMode();






        public native void setPolygonModeOverrideable(@Cast("bool") boolean override);




        public native @Cast("bool") boolean getPolygonModeOverrideable();
        public native void setFog(
                    @Cast("bool") boolean overrideScene,
                    @Cast("Ogre::FogMode") int mode/*=Ogre::FOG_NONE*/,
                    @Const @ByRef(nullValue = "Ogre::ColourValue::White") ColourValue colour,
                    double expDensity/*=0.001*/, double linearStart/*=0.0*/, double linearEnd/*=1.0*/ );
        public native void setFog(
                    @Cast("bool") boolean overrideScene );



        public native @Cast("bool") boolean getFogOverride();





        public native @Cast("Ogre::FogMode") int getFogMode();



        public native @Const @ByRef ColourValue getFogColour();





        public native double getFogStart();





        public native double getFogEnd();





        public native double getFogDensity();


        public native HlmsDatablock _getDatablock();


        public native void setMacroblock( @Const @ByRef HlmsMacroblock macroblock );




        public native @Const HlmsMacroblock getMacroblock();


        public native void setBlendblock( @Const @ByRef HlmsBlendblock blendblock );




        public native @Const HlmsBlendblock getBlendblock();



        public native void setAlphaRejectFunction(@Cast("Ogre::CompareFunction") int func);



        public native void setAlphaRejectValue(@Cast("unsigned char") byte val);



        public native @Cast("Ogre::CompareFunction") int getAlphaRejectFunction();



        public native @Cast("unsigned char") byte getAlphaRejectValue();
        public native void setIteratePerLight(@Cast("bool") boolean enabled,
                                        @Cast("bool") boolean onlyForOneLightType/*=true*/, @Cast("Ogre::Light::LightTypes") int lightType/*=Ogre::Light::LT_POINT*/);
        public native void setIteratePerLight(@Cast("bool") boolean enabled);


        public native @Cast("bool") boolean getIteratePerLight();

        public native @Cast("bool") boolean getRunOnlyForOneLightType();


        public native @Cast("Ogre::Light::LightTypes") int getOnlyLightType();
        public native void setLightCountPerIteration(@Cast("unsigned short") short c);



        public native @Cast("unsigned short") short getLightCountPerIteration();


        public native Technique getParent();


        public native @Const @ByRef String getResourceGroup();
        public native void setVertexProgram(@Const @ByRef String name, @Cast("bool") boolean resetParams/*=true*/);
        public native void setVertexProgram(@Const @ByRef String name);






        public native void setVertexProgramParameters(@ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr params);

        public native @Const @ByRef String getVertexProgramName();

        public native @ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr getVertexProgramParameters();

        public native @Cast("const Ogre::GpuProgramPtr*") @ByRef RealControllerFunctionSPtr getVertexProgram();
        public native void setShadowCasterVertexProgram(@Const @ByRef String name);






        public native void setShadowCasterVertexProgramParameters(@ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr params);

        public native @Const @ByRef String getShadowCasterVertexProgramName();

        public native @ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr getShadowCasterVertexProgramParameters();


        public native @Cast("const Ogre::GpuProgramPtr*") @ByRef RealControllerFunctionSPtr getShadowCasterVertexProgram();
        public native void setShadowCasterFragmentProgram(@Const @ByRef String name);






        public native void setShadowCasterFragmentProgramParameters(@ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr params);

        public native @Const @ByRef String getShadowCasterFragmentProgramName();

        public native @ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr getShadowCasterFragmentProgramParameters();


        public native @Cast("const Ogre::GpuProgramPtr*") @ByRef RealControllerFunctionSPtr getShadowCasterFragmentProgram();
        public native void setFragmentProgram(@Const @ByRef String name, @Cast("bool") boolean resetParams/*=true*/);
        public native void setFragmentProgram(@Const @ByRef String name);




        public native void setFragmentProgramParameters(@ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr params);

        public native @Const @ByRef String getFragmentProgramName();

        public native @ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr getFragmentProgramParameters();

        public native @Cast("const Ogre::GpuProgramPtr*") @ByRef RealControllerFunctionSPtr getFragmentProgram();
        public native void setGeometryProgram(@Const @ByRef String name, @Cast("bool") boolean resetParams/*=true*/);
        public native void setGeometryProgram(@Const @ByRef String name);




        public native void setGeometryProgramParameters(@ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr params);

        public native @Const @ByRef String getGeometryProgramName();

        public native @ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr getGeometryProgramParameters();

        public native @Cast("const Ogre::GpuProgramPtr*") @ByRef RealControllerFunctionSPtr getGeometryProgram();


        public native void _notifyIndex(@Cast("unsigned short") short index);


        public native void _prepare();

        public native void _unprepare();

        public native void _load();

        public native void _unload();

        public native @Cast("bool") boolean isLoaded();





        public native void _updateAutoParams(@Const AutoParamDataSource source, @Cast("Ogre::uint16") short variabilityMask);







        public native @Cast("size_t") long _getTextureUnitWithContentTypeIndex( @Cast("Ogre::TextureUnitState::ContentType") int contentType,
                                                            @Cast("size_t") long index);
        public native void setSamplerblock( @Const @ByRef HlmsSamplerblock samplerblock );



        public native @Cast("bool") boolean isAmbientOnly();
        public native void setPassIterationCount(@Cast("const size_t") long count);



        public native @Cast("size_t") long getPassIterationCount();
        public native @Cast("bool") boolean applyTextureAliases(@Cast("const Ogre::AliasTextureNamePairList*") @ByRef SStringMapRef aliasList, @Cast("const bool") boolean apply/*=true*/);
        public native @Cast("bool") boolean applyTextureAliases(@Cast("const Ogre::AliasTextureNamePairList*") @ByRef SStringMapRef aliasList);
        public native void setLightScissoringEnabled(@Cast("bool") boolean enabled);



        public native @Cast("bool") boolean getLightScissoringEnabled();
        public native void setLightClipPlanesEnabled(@Cast("bool") boolean enabled);



        public native @Cast("bool") boolean getLightClipPlanesEnabled();





        public native @ByRef UserObjectBindings getUserObjectBindings();
        public native void setTessellationHullProgram(@Const @ByRef String name, @Cast("bool") boolean resetParams/*=true*/);
        public native void setTessellationHullProgram(@Const @ByRef String name);




        public native void setTessellationHullProgramParameters(@ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr params);

        public native @Const @ByRef String getTessellationHullProgramName();

        public native @ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr getTessellationHullProgramParameters();

        public native @Cast("const Ogre::GpuProgramPtr*") @ByRef RealControllerFunctionSPtr getTessellationHullProgram();
        public native void setTessellationDomainProgram(@Const @ByRef String name, @Cast("bool") boolean resetParams/*=true*/);
        public native void setTessellationDomainProgram(@Const @ByRef String name);




        public native void setTessellationDomainProgramParameters(@ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr params);

        public native @Const @ByRef String getTessellationDomainProgramName();

        public native @ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr getTessellationDomainProgramParameters();

        public native @Cast("const Ogre::GpuProgramPtr*") @ByRef RealControllerFunctionSPtr getTessellationDomainProgram();
        public native void setComputeProgram(@Const @ByRef String name, @Cast("bool") boolean resetParams/*=true*/);
        public native void setComputeProgram(@Const @ByRef String name);




        public native void setComputeProgramParameters(@ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr params);

        public native @Const @ByRef String getComputeProgramName();

        public native @ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr getComputeProgramParameters();

        public native @Cast("const Ogre::GpuProgramPtr*") @ByRef RealControllerFunctionSPtr getComputeProgram();
    }





    @Namespace("Ogre::v1") @NoOffset public static class PatchMesh extends Mesh {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public PatchMesh(Pointer p) { super(p); }
    

        public PatchMesh(ResourceManager creator, @Const @ByRef String name, @Cast("Ogre::ResourceHandle") long handle,
                    @Const @ByRef String group) { super((Pointer)null); allocate(creator, name, handle, group); }
        private native void allocate(ResourceManager creator, @Const @ByRef String name, @Cast("Ogre::ResourceHandle") long handle,
                    @Const @ByRef String group);

        public native void update(Pointer controlPointBuffer, @Cast("size_t") long width, @Cast("size_t") long height,
                            @Cast("size_t") long uMaxSubdivisionLevel, @Cast("size_t") long vMaxSubdivisionLevel,
                            @Cast("Ogre::v1::PatchSurface::VisibleSide") int visibleSide);

        public native void define(Pointer controlPointBuffer,
                    VertexDeclaration declaration, @Cast("size_t") long width, @Cast("size_t") long height,
                    @Cast("size_t") long uMaxSubdivisionLevel/*=Ogre::v1::PatchSurface::AUTO_LEVEL*/,
                    @Cast("size_t") long vMaxSubdivisionLevel/*=Ogre::v1::PatchSurface::AUTO_LEVEL*/,
                    @Cast("Ogre::v1::PatchSurface::VisibleSide") int visibleSide/*=Ogre::v1::PatchSurface::VS_FRONT*/,
                    @Cast("Ogre::v1::HardwareBuffer::Usage") int vbUsage/*=Ogre::v1::HardwareBuffer::HBU_STATIC_WRITE_ONLY*/,
                    @Cast("Ogre::v1::HardwareBuffer::Usage") int ibUsage/*=Ogre::v1::HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY*/,
                    @Cast("bool") boolean vbUseShadow/*=false*/, @Cast("bool") boolean ibUseShadow/*=false*/);
        public native void define(Pointer controlPointBuffer,
                    VertexDeclaration declaration, @Cast("size_t") long width, @Cast("size_t") long height);




        public native void setSubdivision(double factor);

    }




    /** enum Ogre::ProfileGroupMask */
    public static final int

        OGREPROF_USER_DEFAULT =  0x00000001,

        OGREPROF_ALL =  0xFF000000,

        OGREPROF_GENERAL =  0x80000000,

        OGREPROF_CULLING =  0x40000000,

        OGREPROF_RENDERING =  0x20000000;
    @Namespace("Ogre") @NoOffset public static class Profile extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Profile(Pointer p) { super(p); }
    
            public Profile(@Const @ByRef String profileName, @Cast("Ogre::uint32") int groupID/*=(Ogre::uint32)Ogre::OGREPROF_USER_DEFAULT*/) { super((Pointer)null); allocate(profileName, groupID); }
            private native void allocate(@Const @ByRef String profileName, @Cast("Ogre::uint32") int groupID/*=(Ogre::uint32)Ogre::OGREPROF_USER_DEFAULT*/);
            public Profile(@Const @ByRef String profileName) { super((Pointer)null); allocate(profileName); }
            private native void allocate(@Const @ByRef String profileName);

    }




    @Namespace("Ogre") public static class ProfileFrame extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public ProfileFrame() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ProfileFrame(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ProfileFrame(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public ProfileFrame position(long position) {
            return (ProfileFrame)super.position(position);
        }
    


        public native @Cast("Ogre::ulong") long frameTime(); public native ProfileFrame frameTime(long frameTime);


        public native @Cast("Ogre::uint") int calls(); public native ProfileFrame calls(int calls);


        public native @Cast("Ogre::uint") int hierarchicalLvl(); public native ProfileFrame hierarchicalLvl(int hierarchicalLvl);

    }


    @Namespace("Ogre") public static class ProfileHistory extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public ProfileHistory() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ProfileHistory(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ProfileHistory(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public ProfileHistory position(long position) {
            return (ProfileHistory)super.position(position);
        }
    

        public native double currentTimePercent(); public native ProfileHistory currentTimePercent(double currentTimePercent);

        public native double currentTimeMillisecs(); public native ProfileHistory currentTimeMillisecs(double currentTimeMillisecs);


        public native double maxTimePercent(); public native ProfileHistory maxTimePercent(double maxTimePercent);

        public native double maxTimeMillisecs(); public native ProfileHistory maxTimeMillisecs(double maxTimeMillisecs);


        public native double minTimePercent(); public native ProfileHistory minTimePercent(double minTimePercent);

        public native double minTimeMillisecs(); public native ProfileHistory minTimeMillisecs(double minTimeMillisecs);


        public native @Cast("Ogre::uint") int numCallsThisFrame(); public native ProfileHistory numCallsThisFrame(int numCallsThisFrame);


        public native double totalTimePercent(); public native ProfileHistory totalTimePercent(double totalTimePercent);

        public native double totalTimeMillisecs(); public native ProfileHistory totalTimeMillisecs(double totalTimeMillisecs);



        public native @Cast("Ogre::ulong") long totalCalls(); public native ProfileHistory totalCalls(long totalCalls);


        public native @Cast("Ogre::uint") int hierarchicalLvl(); public native ProfileHistory hierarchicalLvl(int hierarchicalLvl);

    }


    @Namespace("Ogre") @NoOffset public static class ProfileInstance extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ProfileInstance(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ProfileInstance(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ProfileInstance position(long position) {
            return (ProfileInstance)super.position(position);
        }
    
        public ProfileInstance() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native void logResults();
        public native void reset();

        public native @Cast("bool") boolean watchForMax();
        public native @Cast("bool") boolean watchForMin();
        public native @Cast("bool") boolean watchForLimit(double limit, @Cast("bool") boolean greaterThan/*=true*/);
        public native @Cast("bool") boolean watchForLimit(double limit);

        public native @Cast("bool") boolean watchForMax(@Const @ByRef String profileName);
        public native @Cast("bool") boolean watchForMin(@Const @ByRef String profileName);
        public native @Cast("bool") boolean watchForLimit(@Const @ByRef String profileName, double limit, @Cast("bool") boolean greaterThan/*=true*/);
        public native @Cast("bool") boolean watchForLimit(@Const @ByRef String profileName, double limit);


        public native @ByRef String name(); public native ProfileInstance name(String name);


        public native ProfileInstance parent(); public native ProfileInstance parent(ProfileInstance parent);

        public native @ByRef @Cast("Ogre::ProfileInstance::ProfileChildren*") ProfileInstanceMapRef children(); public native ProfileInstance children(ProfileInstanceMapRef children);

        public native @ByRef ProfileFrame frame(); public native ProfileInstance frame(ProfileFrame frame);
        public native @Cast("Ogre::ulong") long frameNumber(); public native ProfileInstance frameNumber(long frameNumber);

        public native @ByRef ProfileHistory history(); public native ProfileInstance history(ProfileHistory history);


        public native @Cast("Ogre::ulong") long currTime(); public native ProfileInstance currTime(long currTime);



        public native @Cast("Ogre::ulong") long accum(); public native ProfileInstance accum(long accum);


        public native @Cast("Ogre::uint") int hierarchicalLvl(); public native ProfileInstance hierarchicalLvl(int hierarchicalLvl);
    }






    @Namespace("Ogre") @NoOffset public static class ProfileSessionListener extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ProfileSessionListener(Pointer p) { super(p); }
    
        /** enum Ogre::ProfileSessionListener::DisplayMode */
        public static final int

            DISPLAY_PERCENTAGE = 0,

            DISPLAY_MILLISECONDS = 1;


        public native void initializeSession();


        public native void finializeSession();





        public native void changeEnableState(@Cast("bool") boolean enabled);


        public native void displayResults(@Const @ByRef ProfileInstance instance, @Cast("Ogre::ulong") long maxTotalFrameTime);


        public native void setDisplayMode(@Cast("Ogre::ProfileSessionListener::DisplayMode") int d);


        public native @Cast("Ogre::ProfileSessionListener::DisplayMode") int getDisplayMode();
    }
    @Namespace("Ogre") @NoOffset public static class Profiler extends ProfilerSgtRef {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Profiler(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Profiler(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Profiler position(long position) {
            return (Profiler)super.position(position);
        }
        public Pointer asPointer() { return asPointer(this); }
        @Namespace public static native @Name("static_cast<ProfilerAlloc*>") Pointer asPointer(Profiler pointer);
    
            public Profiler() { super((Pointer)null); allocate(); }
            private native void allocate();


            public native void setTimer(Timer t);


            public native Timer getTimer();
            public native void beginProfile(@Const @ByRef String profileName, @Cast("Ogre::uint32") int groupID/*=(Ogre::uint32)Ogre::OGREPROF_USER_DEFAULT*/);
            public native void beginProfile(@Const @ByRef String profileName);
            public native void endProfile(@Const @ByRef String profileName, @Cast("Ogre::uint32") int groupID/*=(Ogre::uint32)Ogre::OGREPROF_USER_DEFAULT*/);
            public native void endProfile(@Const @ByRef String profileName);




            public native void beginGPUEvent(@Const @ByRef String event);




            public native void endGPUEvent(@Const @ByRef String event);




            public native void markGPUEvent(@Const @ByRef String event);






            public native void setEnabled(@Cast("bool") boolean enabled);


            public native @Cast("bool") boolean getEnabled();




            public native void enableProfile(@Const @ByRef String profileName);




            public native void disableProfile(@Const @ByRef String profileName);



            public native void setProfileGroupMask(@Cast("Ogre::uint32") int mask);


            public native @Cast("Ogre::uint32") int getProfileGroupMask();






            public native @Cast("bool") boolean watchForMax(@Const @ByRef String profileName);






            public native @Cast("bool") boolean watchForMin(@Const @ByRef String profileName);
            public native @Cast("bool") boolean watchForLimit(@Const @ByRef String profileName, double limit, @Cast("bool") boolean greaterThan/*=true*/);
            public native @Cast("bool") boolean watchForLimit(@Const @ByRef String profileName, double limit);


            public native void logResults();


            public native void reset();


            public native void setUpdateDisplayFrequency(@Cast("Ogre::uint") int freq);


            public native @Cast("Ogre::uint") int getUpdateDisplayFrequency();







            public native void addListener(ProfileSessionListener listener);







            public native void removeListener(ProfileSessionListener listener);
            public static native @ByRef Profiler getSingleton();
            public static native Profiler getSingletonPtr();


    }




    @Namespace("Ogre") public static class RenderQueueListener extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public RenderQueueListener() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public RenderQueueListener(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderQueueListener(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public RenderQueueListener position(long position) {
            return (RenderQueueListener)super.position(position);
        }
    



        public native void preRenderQueues();


        public native void postRenderQueues();
        public native void renderQueueStarted( RenderQueue rq, @Cast("Ogre::uint8") byte queueGroupId, @Const @ByRef String invocation,
                                                 @Cast("bool*") @ByRef BoolPointer skipThisInvocation);
        public native void renderQueueStarted( RenderQueue rq, @Cast("Ogre::uint8") byte queueGroupId, @Const @ByRef String invocation,
                                                 @Cast("bool*") @ByRef boolean[] skipThisInvocation);
        public native void renderQueueEnded(@Cast("Ogre::uint8") byte queueGroupId, @Const @ByRef String invocation,
                    @Cast("bool*") @ByRef BoolPointer repeatThisInvocation);
        public native void renderQueueEnded(@Cast("Ogre::uint8") byte queueGroupId, @Const @ByRef String invocation,
                    @Cast("bool*") @ByRef boolean[] repeatThisInvocation);
    }








    @Namespace("Ogre") public static class RenderObjectListener extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderObjectListener(Pointer p) { super(p); }
    
        public native void notifyRenderSingleObject(Renderable rend, @Const Pass pass, @Const AutoParamDataSource source,
                    @Cast("const Ogre::LightList*") HashedVector pLightList, @Cast("bool") boolean suppressRenderStateChanges);
    }


    @Namespace("Ogre") public static class StringConverter extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public StringConverter() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public StringConverter(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public StringConverter(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public StringConverter position(long position) {
            return (StringConverter)super.position(position);
        }
    


        public static native @ByVal String toString(double val, @Cast("unsigned short") short precision/*=6*/,
                    @Cast("unsigned short") short width/*=0*/, @Cast("char") byte fill/*=' '*/,
                    @ByVal(nullValue = "std::ios::fmtflags(0)") fmtflags flags);
        public static native @ByVal String toString(double val);


        public static native @ByVal String toString(@ByVal Radian val, @Cast("unsigned short") short precision/*=6*/,
                    @Cast("unsigned short") short width/*=0*/, @Cast("char") byte fill/*=' '*/,
                    @ByVal(nullValue = "std::ios::fmtflags(0)") fmtflags flags);
        public static native @ByVal String toString(@ByVal Radian val);

        public static native @ByVal String toString(@ByVal Degree val, @Cast("unsigned short") short precision/*=6*/,
                    @Cast("unsigned short") short width/*=0*/, @Cast("char") byte fill/*=' '*/,
                    @ByVal(nullValue = "std::ios::fmtflags(0)") fmtflags flags);
        public static native @ByVal String toString(@ByVal Degree val);

        public static native @ByVal String toString(int val, @Cast("unsigned short") short width/*=0*/,
                    @Cast("char") byte fill/*=' '*/,
                    @ByVal(nullValue = "std::ios::fmtflags(0)") fmtflags flags);
        public static native @ByVal String toString(int val);

        public static native @ByVal String toString(@Cast("size_t") long val,
                    @Cast("unsigned short") short width/*=0*/, @Cast("char") byte fill/*=' '*/,
                    @ByVal(nullValue = "std::ios::fmtflags(0)") fmtflags flags);
        public static native @ByVal String toString(@Cast("size_t") long val);



        public static native @ByVal String toString(@Cast("bool") boolean val, @Cast("bool") boolean yesNo/*=false*/);
        public static native @ByVal String toString(@Cast("bool") boolean val);




        public static native @ByVal String toString(@Const @ByRef Vector2 val);




        public static native @ByVal String toString(@Const @ByRef Vector3 val);




        public static native @ByVal String toString(@Const @ByRef Vector4 val);




        public static native @ByVal String toString(@Const @ByRef Matrix3 val);





        public static native @ByVal String toString(@Const @ByRef Matrix4 val);




        public static native @ByVal String toString(@Const @ByRef Quaternion val);




        public static native @ByVal String toString(@Const @ByRef ColourValue val);





        public static native @ByVal String toString(@Cast("const Ogre::StringVector*") @ByRef StringVectorRef val);





        public static native double parseReal(@Const @ByRef String val, double defaultValue/*=0*/);
        public static native double parseReal(@Const @ByRef String val);




        public static native @ByVal Radian parseAngle(@Const @ByRef String val, @ByVal(nullValue = "Ogre::Radian(0)") Radian defaultValue);
        public static native @ByVal Radian parseAngle(@Const @ByRef String val);




        public static native int parseInt(@Const @ByRef String val, int defaultValue/*=0*/);
        public static native int parseInt(@Const @ByRef String val);




        public static native @Cast("unsigned int") int parseUnsignedInt(@Const @ByRef String val, @Cast("unsigned int") int defaultValue/*=0*/);
        public static native @Cast("unsigned int") int parseUnsignedInt(@Const @ByRef String val);




        public static native long parseLong(@Const @ByRef String val, long defaultValue/*=0*/);
        public static native long parseLong(@Const @ByRef String val);




        public static native @Cast("unsigned long") long parseUnsignedLong(@Const @ByRef String val, @Cast("unsigned long") long defaultValue/*=0*/);
        public static native @Cast("unsigned long") long parseUnsignedLong(@Const @ByRef String val);




        public static native @Cast("size_t") long parseSizeT(@Const @ByRef String val, @Cast("size_t") long defaultValue/*=0*/);
        public static native @Cast("size_t") long parseSizeT(@Const @ByRef String val);






        public static native @Cast("bool") boolean parseBool(@Const @ByRef String val, @Cast("bool") boolean defaultValue/*=0*/);
        public static native @Cast("bool") boolean parseBool(@Const @ByRef String val);





        public static native @ByVal Vector2 parseVector2(@Const @ByRef String val, @Const @ByRef(nullValue = "Ogre::Vector2::ZERO") Vector2 defaultValue);
        public static native @ByVal Vector2 parseVector2(@Const @ByRef String val);





        public static native @ByVal Vector3 parseVector3(@Const @ByRef String val, @Const @ByRef(nullValue = "Ogre::Vector3::ZERO") Vector3 defaultValue);
        public static native @ByVal Vector3 parseVector3(@Const @ByRef String val);





        public static native @ByVal Vector4 parseVector4(@Const @ByRef String val, @Const @ByRef(nullValue = "Ogre::Vector4::ZERO") Vector4 defaultValue);
        public static native @ByVal Vector4 parseVector4(@Const @ByRef String val);





        public static native @ByVal Matrix3 parseMatrix3(@Const @ByRef String val, @Const @ByRef(nullValue = "Ogre::Matrix3::IDENTITY") Matrix3 defaultValue);
        public static native @ByVal Matrix3 parseMatrix3(@Const @ByRef String val);





        public static native @ByVal Matrix4 parseMatrix4(@Const @ByRef String val, @Const @ByRef(nullValue = "Ogre::Matrix4::IDENTITY") Matrix4 defaultValue);
        public static native @ByVal Matrix4 parseMatrix4(@Const @ByRef String val);





        public static native @ByVal Quaternion parseQuaternion(@Const @ByRef String val, @Const @ByRef(nullValue = "Ogre::Quaternion::IDENTITY") Quaternion defaultValue);
        public static native @ByVal Quaternion parseQuaternion(@Const @ByRef String val);





        public static native @ByVal ColourValue parseColourValue(@Const @ByRef String val, @Const @ByRef(nullValue = "Ogre::ColourValue::Black") ColourValue defaultValue);
        public static native @ByVal ColourValue parseColourValue(@Const @ByRef String val);






        public static native @ByVal @Cast("Ogre::StringVector*") StringVectorRef parseStringVector(@Const @ByRef String val);

        public static native @Cast("bool") boolean isNumber(@Const @ByRef String val);





  public static native @Cast("Ogre::ColourBufferType") int parseColourBuffer(@Const @ByRef String val, @Cast("Ogre::ColourBufferType") int defaultValue/*=Ogre::CBT_BACK*/);
  public static native @Cast("Ogre::ColourBufferType") int parseColourBuffer(@Const @ByRef String val);





  public static native @Cast("Ogre::StereoModeType") int parseStereoMode(@Const @ByRef String val, @Cast("Ogre::StereoModeType") int defaultValue/*=Ogre::SMT_NONE*/);
  public static native @Cast("Ogre::StereoModeType") int parseStereoMode(@Const @ByRef String val);


        public static native void setDefaultStringLocale(@Const @ByRef String loc);

        public static native @ByVal String getDefaultStringLocale();

        public static native void setUseLocale(@Cast("bool") boolean useLocale);

        public static native @Cast("bool") boolean isUseLocale();
    }





    /** enum Ogre::CapabilitiesCategory */
    public static final int
        CAPS_CATEGORY_COMMON = 0,
        CAPS_CATEGORY_COMMON_2 = 1,
        CAPS_CATEGORY_COMMON_3 = 2,
        CAPS_CATEGORY_D3D9 = 3,
        CAPS_CATEGORY_GL = 4,

        CAPS_CATEGORY_COUNT = 5;





    /** enum Ogre::Capabilities */
    public static final int

        RSC_AUTOMIPMAP =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 0)),
        RSC_BLENDING =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 1)),

        RSC_ANISOTROPY =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 2)),

        RSC_DOT3 =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 3)),

        RSC_CUBEMAPPING =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 4)),

        RSC_HWSTENCIL =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 5)),

        RSC_VBO =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 7)),

        RSC_32BIT_INDEX =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 8)),

        RSC_VERTEX_PROGRAM =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 9)),

        RSC_FRAGMENT_PROGRAM =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 10)),




        RSC_TEXTURE_SIGNED_INT =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 11)),

        RSC_TWO_SIDED_STENCIL =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 12)),

        RSC_STENCIL_WRAP =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 13)),

        RSC_HWOCCLUSION =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 14)),

        RSC_USER_CLIP_PLANES =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 15)),

        RSC_VERTEX_FORMAT_UBYTE4 =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 16)),

        RSC_INFINITE_FAR_PLANE =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 17)),

        RSC_HWRENDER_TO_TEXTURE =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 18)),

        RSC_TEXTURE_FLOAT =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 19)),

        RSC_NON_POWER_OF_2_TEXTURES =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 20)),

        RSC_TEXTURE_3D =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 21)),

        RSC_POINT_SPRITES =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 22)),

        RSC_POINT_EXTENDED_PARAMETERS =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 23)),

        RSC_VERTEX_TEXTURE_FETCH =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 24)),

        RSC_MIPMAP_LOD_BIAS =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 25)),

        RSC_GEOMETRY_PROGRAM =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 26)),

        RSC_HWRENDER_TO_VERTEX_BUFFER =  ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 27)),


        RSC_TEXTURE_COMPRESSION =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 0)),

        RSC_TEXTURE_COMPRESSION_DXT =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 1)),

        RSC_TEXTURE_COMPRESSION_VTC =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 2)),

        RSC_TEXTURE_COMPRESSION_PVRTC =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 3)),

        RSC_TEXTURE_COMPRESSION_ATC =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 4)),

        RSC_TEXTURE_COMPRESSION_ETC1 =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 5)),

        RSC_TEXTURE_COMPRESSION_ETC2 =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 6)),

        RSC_TEXTURE_COMPRESSION_BC4_BC5 =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 7)),

        RSC_TEXTURE_COMPRESSION_BC6H_BC7 =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 8)),

        RSC_FIXED_FUNCTION =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 9)),

        RSC_MRT_DIFFERENT_BIT_DEPTHS =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 10)),

        RSC_ALPHA_TO_COVERAGE =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 11)),





        RSC_HW_GAMMA =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 12)),

        RSC_RTT_SEPARATE_DEPTHBUFFER =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 13)),


        RSC_RTT_MAIN_DEPTHBUFFER_ATTACHABLE =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 14)),


        RSC_RTT_DEPTHBUFFER_RESOLUTION_LESSEQUAL =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 15)),

        RSC_VERTEX_BUFFER_INSTANCE_DATA =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 16)),

        RSC_CAN_GET_COMPILED_SHADER_BUFFER =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 17)),

        RSC_SHADER_SUBROUTINE =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 18)),

        RSC_HWRENDER_TO_TEXTURE_3D =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 19)),

        RSC_TEXTURE_1D =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 20)),

        RSC_TESSELLATION_HULL_PROGRAM =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 21)),

        RSC_TESSELLATION_DOMAIN_PROGRAM =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 22)),

        RSC_COMPUTE_PROGRAM =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 23)),

        RSC_HWOCCLUSION_ASYNCHRONOUS =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 24)),

        RSC_ATOMIC_COUNTERS =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 25)),

        RSC_READ_BACK_AS_TEXTURE =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 26)),

        RSC_EXPLICIT_FSAA_RESOLVE =  ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 27)),


        RSC_COMPLETE_TEXTURE_BINDING =  ((CAPS_CATEGORY_COMMON_3 << (32 - 4)) | (1 << 0)),

        RSC_TEXTURE_2D_ARRAY =  ((CAPS_CATEGORY_COMMON_3 << (32 - 4)) | (1 << 1)),

        RSC_TEXTURE_CUBE_MAP_ARRAY =  ((CAPS_CATEGORY_COMMON_3 << (32 - 4)) | (1 << 2)),

        RSC_TEXTURE_GATHER =  ((CAPS_CATEGORY_COMMON_3 << (32 - 4)) | (1 << 3)),

        RSC_UAV =  ((CAPS_CATEGORY_COMMON_3 << (32 - 4)) | (1 << 4)),



        RSC_EXPLICIT_API =  ((CAPS_CATEGORY_COMMON_3 << (32 - 4)) | (1 << 5)),



        RSC_PERSTAGECONSTANT =  ((CAPS_CATEGORY_D3D9 << (32 - 4)) | (1 << 0)),



        RSC_GL1_5_NOVBO =  ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 1)),

        RSC_FBO =  ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 2)),

        RSC_FBO_ARB =  ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 3)),

        RSC_FBO_ATI =  ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 4)),

        RSC_PBUFFER =  ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 5)),

        RSC_GL1_5_NOHWOCCLUSION =  ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 6)),

        RSC_POINT_EXTENDED_PARAMETERS_ARB =  ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 7)),

        RSC_POINT_EXTENDED_PARAMETERS_EXT =  ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 8)),

        RSC_SEPARATE_SHADER_OBJECTS =  ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 9)),

        RSC_VAO =  ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 10));



    @Namespace("Ogre") @NoOffset public static class DriverVersion extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public DriverVersion(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public DriverVersion(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public DriverVersion position(long position) {
            return (DriverVersion)super.position(position);
        }
    
        public native int major(); public native DriverVersion major(int major);
        public native int minor(); public native DriverVersion minor(int minor);
        public native int release(); public native DriverVersion release(int release);
        public native int build(); public native DriverVersion build(int build);

        public DriverVersion() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native @ByVal String toString();

        public native void fromString(@Const @ByRef String versionString);
    }


    /** enum Ogre::GPUVendor */
    public static final int
        GPU_UNKNOWN = 0,
        GPU_NVIDIA = 1,
        GPU_AMD = 2,
        GPU_INTEL = 3,
        GPU_S3 = 4,
        GPU_MATROX = 5,
        GPU_3DLABS = 6,
        GPU_SIS = 7,
        GPU_IMAGINATION_TECHNOLOGIES = 8,
        GPU_APPLE = 9,
        GPU_NOKIA = 10,
        GPU_MS_SOFTWARE = 11,
        GPU_MS_WARP = 12,
        GPU_ARM = 13,
        GPU_QUALCOMM = 14,
        GPU_MOZILLA = 15,
        GPU_WEBKIT = 16,

        GPU_VENDOR_COUNT = 17;






    @Namespace("Ogre") @NoOffset public static class RenderSystemCapabilities extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderSystemCapabilities(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public RenderSystemCapabilities(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public RenderSystemCapabilities position(long position) {
            return (RenderSystemCapabilities)super.position(position);
        }
    
        public RenderSystemCapabilities() { super((Pointer)null); allocate(); }
        private native void allocate();

        public native @Cast("size_t") long calculateSize();


        public native void setDriverVersion(@Const @ByRef DriverVersion version);

        public native void parseDriverVersionFromString(@Const @ByRef String versionString);


        public native @ByVal DriverVersion getDriverVersion();

        public native @Cast("Ogre::GPUVendor") int getVendor();

        public native void setVendor(@Cast("Ogre::GPUVendor") int v);


        public native void parseVendorFromString(@Const @ByRef String vendorString);


        public static native @Cast("Ogre::GPUVendor") int vendorFromString(@Const @ByRef String vendorString);

        public static native @ByVal String vendorToString(@Cast("Ogre::GPUVendor") int v);

        public native @Cast("bool") boolean isDriverOlderThanVersion(@Const @ByRef DriverVersion v);

        public native void setNumWorldMatrices(short num);

        public native void setNumTextureUnits(short num);

        public native void setStencilBufferBitDepth(short num);

        public native void setNumVertexBlendMatrices(short num);


        public native void setNumMultiRenderTargets(short num);

        public native short getNumWorldMatrices();
        public native short getNumTextureUnits();







        public native short getStencilBufferBitDepth();



        public native short getNumVertexBlendMatrices();


        public native short getNumMultiRenderTargets();



        public native @Cast("bool") boolean isCapabilityRenderSystemSpecific(@Cast("const Ogre::Capabilities") int c);



        public native void setCapability(@Cast("const Ogre::Capabilities") int c);



        public native void unsetCapability(@Cast("const Ogre::Capabilities") int c);



        public native @Cast("bool") boolean hasCapability(@Cast("const Ogre::Capabilities") int c);



        public native void addShaderProfile(@Const @ByRef String profile);



        public native void removeShaderProfile(@Const @ByRef String profile);



        public native @Cast("bool") boolean isShaderProfileSupported(@Const @ByRef String profile);




        public native @Cast("const Ogre::RenderSystemCapabilities::ShaderProfiles*") @ByRef StringSetRef getSupportedShaderProfiles();



        public native short getVertexProgramConstantFloatCount();

        public native short getVertexProgramConstantIntCount();

        public native short getVertexProgramConstantBoolCount();

        public native short getGeometryProgramConstantFloatCount();

        public native short getGeometryProgramConstantIntCount();

        public native short getGeometryProgramConstantBoolCount();

        public native short getFragmentProgramConstantFloatCount();

        public native short getFragmentProgramConstantIntCount();

        public native short getFragmentProgramConstantBoolCount();


        public native void setDeviceName(@Const @ByRef String name);


        public native @ByVal String getDeviceName();


        public native void setVertexProgramConstantFloatCount(short c);

        public native void setVertexProgramConstantIntCount(short c);

        public native void setVertexProgramConstantBoolCount(short c);

        public native void setGeometryProgramConstantFloatCount(short c);

        public native void setGeometryProgramConstantIntCount(short c);

        public native void setGeometryProgramConstantBoolCount(short c);

        public native void setFragmentProgramConstantFloatCount(short c);

        public native void setFragmentProgramConstantIntCount(short c);

        public native void setFragmentProgramConstantBoolCount(short c);

        public native void setMaximumResolutions( short res2d, short res3d, short resCube );

        public native short getMaximumResolution2D();

        public native short getMaximumResolution3D();

        public native short getMaximumResolutionCubemap();

        public native void setMaxPointSize(double s);

        public native double getMaxPointSize();

        public native void setNonPOW2TexturesLimited(@Cast("bool") boolean l);
        public native @Cast("bool") boolean getNonPOW2TexturesLimited();

        public native void setMaxSupportedAnisotropy(double s);

        public native double getMaxSupportedAnisotropy();


        public native void setNumVertexTextureUnits(short n);

        public native short getNumVertexTextureUnits();

        public native void setVertexTextureUnitsShared(@Cast("bool") boolean shared);

        public native @Cast("bool") boolean getVertexTextureUnitsShared();


        public native void setGeometryProgramNumOutputVertices(int numOutputVertices);

        public native int getGeometryProgramNumOutputVertices();


        public native @ByVal String getRenderSystemName();

        public native void setRenderSystemName(@Const @ByRef String rs);


        public native void setCategoryRelevant(@Cast("Ogre::CapabilitiesCategory") int cat, @Cast("bool") boolean relevant);


        public native @Cast("bool") boolean isCategoryRelevant(@Cast("Ogre::CapabilitiesCategory") int cat);




        public native void log(Log pLog);



        public native void setTessellationHullProgramConstantFloatCount(short c);

        public native void setTessellationHullProgramConstantIntCount(short c);

        public native void setTessellationHullProgramConstantBoolCount(short c);

        public native short getTessellationHullProgramConstantFloatCount();

        public native short getTessellationHullProgramConstantIntCount();

        public native short getTessellationHullProgramConstantBoolCount();


        public native void setTessellationDomainProgramConstantFloatCount(short c);

        public native void setTessellationDomainProgramConstantIntCount(short c);

        public native void setTessellationDomainProgramConstantBoolCount(short c);

        public native short getTessellationDomainProgramConstantFloatCount();

        public native short getTessellationDomainProgramConstantIntCount();

        public native short getTessellationDomainProgramConstantBoolCount();


        public native void setComputeProgramConstantFloatCount(short c);

        public native void setComputeProgramConstantIntCount(short c);

        public native void setComputeProgramConstantBoolCount(short c);

        public native short getComputeProgramConstantFloatCount();

        public native short getComputeProgramConstantIntCount();

        public native short getComputeProgramConstantBoolCount();

    }




    @Namespace("Ogre") public static class ConfigOption extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public ConfigOption() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ConfigOption(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ConfigOption(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public ConfigOption position(long position) {
            return (ConfigOption)super.position(position);
        }
    
        public native @ByRef String name(); public native ConfigOption name(String name);
        public native @ByRef String currentValue(); public native ConfigOption currentValue(String currentValue);
        public native @ByRef @Cast("Ogre::StringVector*") StringVectorRef possibleValues(); public native ConfigOption possibleValues(StringVectorRef possibleValues);
        public native @Cast("bool") boolean immutable(); public native ConfigOption immutable(boolean immutable);
    }



    /** enum Ogre::ResourceLayout::Layout */
    public static final int
        Undefined = 0,
        Texture = 1,
        TextureDepth = 2,
        RenderTarget = 3,
        RenderDepth = 4,
        Clear = 5,
        Uav = 6,
        CopySrc = 7,
        CopyDst = 8,

        NumResourceLayouts = 9;
    
    /** enum Ogre::WriteBarrier::WriteBarrier */
    public static final int

        CpuWrite =  0x00000001,

        Uav =  0x00000002,

        RenderTarget =  0x00000004,

        DepthStencil =  0x00000008,


        WriteBarrierEnum =  0xffffffff;
    
    /** enum Ogre::ReadBarrier::ReadBarrier */
    public static final int

        CpuRead =  0x00000001,

        Indirect =  0x00000002,

        VertexBuffer =  0x00000004,

        IndexBuffer =  0x00000008,

        ConstBuffer =  0x00000010,

        Texture =  0x00000020,

        Uav =  0x00000040,

        RenderTarget =  0x00000080,

        DepthStencil =  0x00000100,

        ReadBarrierEnum =  0xffffffff;
    

    /** enum Ogre::ResourceAccess::ResourceAccess */
    public static final int
        Undefined =  0x00,
        Read =  0x01,
        Write =  0x10,
        ReadWrite =  Read | Write;

    @Namespace("Ogre::ResourceAccess") public static native @Cast("const char*") BytePointer toString( @Cast("Ogre::ResourceAccess::ResourceAccess") int value );
    

    @Namespace("Ogre") public static class ResourceTransition extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public ResourceTransition() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ResourceTransition(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ResourceTransition(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public ResourceTransition position(long position) {
            return (ResourceTransition)super.position(position);
        }
    

        public native @Cast("Ogre::ResourceLayout::Layout") int oldLayout(); public native ResourceTransition oldLayout(int oldLayout);
        public native @Cast("Ogre::ResourceLayout::Layout") int newLayout(); public native ResourceTransition newLayout(int newLayout);

        public native @Cast("Ogre::uint32") int writeBarrierBits(); public native ResourceTransition writeBarrierBits(int writeBarrierBits);
        public native @Cast("Ogre::uint32") int readBarrierBits(); public native ResourceTransition readBarrierBits(int readBarrierBits);

        public native Pointer mRsData(); public native ResourceTransition mRsData(Pointer mRsData);
    }





    /** enum Ogre::TexCoordCalcMethod */
    public static final int

        TEXCALC_NONE = 0,

        TEXCALC_ENVIRONMENT_MAP = 1,

        TEXCALC_ENVIRONMENT_MAP_PLANAR = 2,
        TEXCALC_ENVIRONMENT_MAP_REFLECTION = 3,
        TEXCALC_ENVIRONMENT_MAP_NORMAL = 4,

        TEXCALC_PROJECTIVE_TEXTURE = 5;
    @Namespace("Ogre") @NoOffset public static class RenderSystem extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderSystem(Pointer p) { super(p); }
    



        public native @Const @ByRef String getName();



  public native @Const @ByRef String getFriendlyName();
        public native @Cast("Ogre::ConfigOptionMap*") @ByRef SConfigOptionMapRef getConfigOptions();
        public native void setConfigOption(@Const @ByRef String name, @Const @ByRef String value);



        public native HardwareOcclusionQuery createHardwareOcclusionQuery();



        public native void destroyHardwareOcclusionQuery(HardwareOcclusionQuery hq);





        public native @ByVal String validateConfigOptions();
        public native RenderWindow _initialise(@Cast("bool") boolean autoCreateWindow, @Const @ByRef(nullValue = "Ogre::String(\"OGRE Render Window\")") String windowTitle);
        public native RenderWindow _initialise(@Cast("bool") boolean autoCreateWindow);






        public native @Cast("bool") boolean isStaticBufferLockable();


        public native RenderSystemCapabilities createRenderSystemCapabilities();
        public native RenderSystemCapabilities getMutableCapabilities();







        public native void useCustomRenderSystemCapabilities(RenderSystemCapabilities capabilities);



        public native void reinitialise();



        public native void shutdown();







        public native void setWBufferEnabled(@Cast("bool") boolean enabled);



        public native @Cast("bool") boolean getWBufferEnabled();
        public native RenderWindow _createRenderWindow(@Const @ByRef String name, @Cast("unsigned int") int width, @Cast("unsigned int") int height,
                    @Cast("bool") boolean fullScreen, @Cast("const Ogre::NameValuePairList*") SStringMapRef miscParams/*=0*/);
        public native RenderWindow _createRenderWindow(@Const @ByRef String name, @Cast("unsigned int") int width, @Cast("unsigned int") int height,
                    @Cast("bool") boolean fullScreen);
        public native @Cast("bool") boolean _createRenderWindows(@Cast("const Ogre::RenderWindowDescriptionList*") @ByRef RenderWindowDescriptionVectorRef renderWindowDescriptions,
                    @Cast("Ogre::RenderWindowList*") @ByRef RenderWindowPtrVectorRef createdWindows);






        public native MultiRenderTarget createMultiRenderTarget(@Const @ByRef String name);


        public native void destroyRenderWindow(@Const @ByRef String name);

        public native void destroyRenderTexture(@Const @ByRef String name);

        public native void destroyRenderTarget(@Const @ByRef String name);



        public native void attachRenderTarget( @ByRef RenderTarget target );



        public native RenderTarget getRenderTarget( @Const @ByRef String name );





        public native RenderTarget detachRenderTarget( @Const @ByRef String name );


        public native @ByVal @Cast("Ogre::RenderSystem::RenderTargetIterator*") AnimationStateMapIteratorRef getRenderTargetIterator();


        public native @ByVal String getErrorDescription(long errorNumber);



        public native @ByVal HardwareVertexBufferSharedPtr getGlobalInstanceVertexBuffer();


        public native void setGlobalInstanceVertexBuffer(@Const @ByRef HardwareVertexBufferSharedPtr val);


        public native VertexDeclaration getGlobalInstanceVertexBufferVertexDeclaration();


        public native void setGlobalInstanceVertexBufferVertexDeclaration( VertexDeclaration val);


        public native @Cast("size_t") long getGlobalNumberOfInstances();


        public native void setGlobalNumberOfInstances(@Cast("const size_t") long val);



        public native @Cast("bool") boolean getFixedPipelineEnabled();






        public native void setDepthBufferFor( RenderTarget renderTarget, @Cast("bool") boolean exactMatch );

        public native void createUniqueDepthBufferFor( RenderTarget renderTarget, @Cast("bool") boolean exactMatch );

        public native void _destroyDepthBuffer( DepthBuffer depthBuffer );
        public native void _useLights(@Cast("const Ogre::LightList*") @ByRef HashedVector lights, @Cast("unsigned short") short limit);


        public native @Cast("bool") boolean areFixedFunctionLightsInViewSpace();

        public native void _setWorldMatrix(@Const @ByRef Matrix4 m);

        public native void _setWorldMatrices(@Const Matrix4 m, @Cast("unsigned short") short count);

        public native void _setViewMatrix(@Const @ByRef Matrix4 m);

        public native void _setProjectionMatrix(@Const @ByRef Matrix4 m);





        public native void _setTextureUnitSettings(@Cast("size_t") long texUnit, @ByRef TextureUnitState tl);

        public native void _setBindingType(@Cast("Ogre::TextureUnitState::BindingType") int bindigType);

        public native void _disableTextureUnit(@Cast("size_t") long texUnit);

        public native void _disableTextureUnitsFrom(@Cast("size_t") long texUnit);
        public native void _setSurfaceParams(@Const @ByRef ColourValue ambient,
                    @Const @ByRef ColourValue diffuse, @Const @ByRef ColourValue specular,
                    @Const @ByRef ColourValue emissive, double shininess,
                    @Cast("Ogre::TrackVertexColourType") int tracking/*=Ogre::TVC_NONE*/);
        public native void _setSurfaceParams(@Const @ByRef ColourValue ambient,
                    @Const @ByRef ColourValue diffuse, @Const @ByRef ColourValue specular,
                    @Const @ByRef ColourValue emissive, double shininess);






        public native void _setPointSpritesEnabled(@Cast("bool") boolean enabled);
        public native void _setPointParameters(double size, @Cast("bool") boolean attenuationEnabled,
                    double constant, double linear, double quadratic, double minSize, double maxSize);
        public native void _setTexture(@Cast("size_t") long unit, @Cast("bool") boolean enabled, Texture texPtr);
        public native void setUavStartingSlot( @Cast("Ogre::uint32") int startingSlot );
        public native void queueBindUAV( @Cast("Ogre::uint32") int slot, @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr texture,
                                           @Cast("Ogre::ResourceAccess::ResourceAccess") int access/*=Ogre::ResourceAccess::ReadWrite*/,
                                           @Cast("Ogre::int32") int mipmapLevel/*=0*/, @Cast("Ogre::int32") int textureArrayIndex/*=0*/,
                                           @Cast("Ogre::PixelFormat") int pixelFormat/*=Ogre::PF_UNKNOWN*/ );
        public native void queueBindUAV( @Cast("Ogre::uint32") int slot, @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr texture );



        public native void clearUAVs();



        public native void flushUAVs();
        public native void _setTexture(@Cast("size_t") long unit, @Cast("bool") boolean enabled, @Const @ByRef String texname);

        public native void _resourceTransitionCreated( ResourceTransition resTransition );
        public native void _resourceTransitionDestroyed( ResourceTransition resTransition );
        public native void _executeResourceTransition( ResourceTransition resTransition );

        public native void _hlmsMacroblockCreated( HlmsMacroblock newBlock );
        public native void _hlmsMacroblockDestroyed( HlmsMacroblock block );
        public native void _hlmsBlendblockCreated( HlmsBlendblock newBlock );
        public native void _hlmsBlendblockDestroyed( HlmsBlendblock block );
        public native void _hlmsSamplerblockCreated( HlmsSamplerblock newBlock );
        public native void _hlmsSamplerblockDestroyed( HlmsSamplerblock block );

        public native void _setIndirectBuffer( IndirectBufferPacked indirectBuffer );
        public native void _setVertexTexture(@Cast("size_t") long unit, @Cast("const Ogre::TexturePtr*") @ByRef RealControllerFunctionSPtr tex);
        public native void _setGeometryTexture(@Cast("size_t") long unit, @Cast("const Ogre::TexturePtr*") @ByRef RealControllerFunctionSPtr tex);
        public native void _setComputeTexture(@Cast("size_t") long unit, @Cast("const Ogre::TexturePtr*") @ByRef RealControllerFunctionSPtr tex);
        public native void _setTessellationHullTexture(@Cast("size_t") long unit, @Cast("const Ogre::TexturePtr*") @ByRef RealControllerFunctionSPtr tex);
        public native void _setTessellationDomainTexture(@Cast("size_t") long unit, @Cast("const Ogre::TexturePtr*") @ByRef RealControllerFunctionSPtr tex);
        public native void _setTextureCoordSet(@Cast("size_t") long unit, @Cast("size_t") long index);
        public native void _setTextureCoordCalculation(@Cast("size_t") long unit, @Cast("Ogre::TexCoordCalcMethod") int m,
                    @Const Frustum frustum/*=0*/);
        public native void _setTextureCoordCalculation(@Cast("size_t") long unit, @Cast("Ogre::TexCoordCalcMethod") int m);







        public native void _setTextureBlendMode(@Cast("size_t") long unit, @Const @ByRef LayerBlendModeEx bm);





        public native void _setTextureMatrix(@Cast("size_t") long unit, @Const @ByRef Matrix4 xform);




        public native void _setTextureProjectionRelativeTo(@Cast("bool") boolean enabled, @Const @ByRef Vector3 pos);
        public native DepthBuffer _createDepthBufferFor( RenderTarget renderTarget,
                                                            @Cast("bool") boolean exactMatchFormat );
        public native void _cleanupDepthBuffers( @Cast("bool") boolean bCleanManualBuffers/*=true*/ );
        public native void _cleanupDepthBuffers( );



        public native void _beginFrameOnce();





        public native void _beginFrame();



        public static class RenderSystemContext extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public RenderSystemContext() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public RenderSystemContext(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public RenderSystemContext(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public RenderSystemContext position(long position) {
                return (RenderSystemContext)super.position(position);
            }
         }





        public native RenderSystemContext _pauseFrame();






        public native void _resumeFrame(RenderSystemContext context);




        public native void _endFrame();


        public native void _update();
        public native void _setViewport(Viewport vp);

        public native Viewport _getViewport();


        public native void _setHlmsMacroblock( @Const HlmsMacroblock macroblock );


        public native void _setHlmsBlendblock( @Const HlmsBlendblock blendblock );



        public native void _setHlmsSamplerblock( @Cast("Ogre::uint8") byte texUnit, @Const HlmsSamplerblock Samplerblock );


        public native void _setProgramsFromHlms( @Const HlmsCache hlmsCache );
        public native void _beginGeometryCount();

        public native @Cast("unsigned int") int _getFaceCount();

        public native @Cast("unsigned int") int _getBatchCount();

        public native @Cast("unsigned int") int _getVertexCount();
        public native void convertColourValue(@Const @ByRef ColourValue colour, @Cast("Ogre::uint32*") IntPointer pDest);
        public native void convertColourValue(@Const @ByRef ColourValue colour, @Cast("Ogre::uint32*") IntBuffer pDest);
        public native void convertColourValue(@Const @ByRef ColourValue colour, @Cast("Ogre::uint32*") int[] pDest);



        public native @Cast("Ogre::VertexElementType") int getColourVertexElementType();







        public native void _convertProjectionMatrix(@Const @ByRef Matrix4 matrix,
                    @ByRef Matrix4 dest, @Cast("bool") boolean forGpuProgram/*=false*/);
        public native void _convertProjectionMatrix(@Const @ByRef Matrix4 matrix,
                    @ByRef Matrix4 dest);







        public native void _makeProjectionMatrix(@Const @ByRef Radian fovy, double aspect, double nearPlane, double farPlane,
                    @ByRef Matrix4 dest, @Cast("bool") boolean forGpuProgram/*=false*/);
        public native void _makeProjectionMatrix(@Const @ByRef Radian fovy, double aspect, double nearPlane, double farPlane,
                    @ByRef Matrix4 dest);







        public native void _makeProjectionMatrix(double left, double right, double bottom, double top,
                    double nearPlane, double farPlane, @ByRef Matrix4 dest, @Cast("bool") boolean forGpuProgram/*=false*/);
        public native void _makeProjectionMatrix(double left, double right, double bottom, double top,
                    double nearPlane, double farPlane, @ByRef Matrix4 dest);






        public native void _makeOrthoMatrix(@Const @ByRef Radian fovy, double aspect, double nearPlane, double farPlane,
                    @ByRef Matrix4 dest, @Cast("bool") boolean forGpuProgram/*=false*/);
        public native void _makeOrthoMatrix(@Const @ByRef Radian fovy, double aspect, double nearPlane, double farPlane,
                    @ByRef Matrix4 dest);
        public native void _applyObliqueDepthProjection(@ByRef Matrix4 matrix, @Const @ByRef Plane plane,
                    @Cast("bool") boolean forGpuProgram);
        public native void setStencilCheckEnabled(@Cast("bool") boolean enabled);
        public native void setStencilBufferParams(@Cast("Ogre::CompareFunction") int func/*=Ogre::CMPF_ALWAYS_PASS*/,
                    @Cast("Ogre::uint32") int refValue/*=0*/, @Cast("Ogre::uint32") int compareMask/*=0xFFFFFFFF*/, @Cast("Ogre::uint32") int writeMask/*=0xFFFFFFFF*/,
                    @Cast("Ogre::StencilOperation") int stencilFailOp/*=Ogre::SOP_KEEP*/,
                    @Cast("Ogre::StencilOperation") int depthFailOp/*=Ogre::SOP_KEEP*/,
                    @Cast("Ogre::StencilOperation") int passOp/*=Ogre::SOP_KEEP*/,
                    @Cast("bool") boolean twoSidedOperation/*=false*/,
                    @Cast("bool") boolean readBackAsTexture/*=false*/);
        public native void setStencilBufferParams();




        public native void setVertexDeclaration(VertexDeclaration decl);

        public native void setVertexBufferBinding(VertexBufferBinding binding);
        public native void _render(@Const @ByRef RenderOperation op);







        public native void _setVertexArrayObject( @Const VertexArrayObject vao );


        public native void _render( @Const CbDrawCallIndexed cmd );
        public native void _render( @Const CbDrawCallStrip cmd );
        public native void _renderEmulated( @Const CbDrawCallIndexed cmd );
        public native void _renderEmulated( @Const CbDrawCallStrip cmd );


        public native void _startLegacyV1Rendering();
        public native void _setRenderOperation( @Const CbRenderOp cmd );

        public native void _renderUsingReadBackAsTexture(@Cast("unsigned int") int secondPass,@ByVal @Cast("Ogre::Ogre::String*") String variableName,@Cast("unsigned int") int StartSlot);


        public native @Const RenderSystemCapabilities getCapabilities();




        public native @Const @ByRef DriverVersion getDriverVersion();
        public native @Const @ByRef String _getDefaultViewportMaterialScheme();





        public native void bindGpuProgram(GpuProgram prg);






        public native void bindGpuProgramParameters(@Cast("Ogre::GpuProgramType") int gptype,
                    @ByVal @Cast("Ogre::GpuProgramParametersSharedPtr*") RealControllerFunctionSPtr params, @Cast("Ogre::uint16") short variabilityMask);



        public native void bindGpuProgramPassIterationParameters(@Cast("Ogre::GpuProgramType") int gptype);




        public native void unbindGpuProgram(@Cast("Ogre::GpuProgramType") int gptype);


        public native @Cast("bool") boolean isGpuProgramBound(@Cast("Ogre::GpuProgramType") int gptype);

        public native VaoManager getVaoManager();






        public native @Cast("Ogre::uint16") short getNativeShadingLanguageVersion();



        public native void setClipPlanes(@Cast("const Ogre::PlaneList*") @ByRef PlaneVectorRef clipPlanes);


        public native void addClipPlane(@Const @ByRef Plane p);

        public native void addClipPlane(double A, double B, double C, double D);



        public native void resetClipPlanes();


        public native void _initRenderTargets();



        public native void setInvertVertexWinding(@Cast("bool") boolean invert);




        public native @Cast("bool") boolean getInvertVertexWinding();
        public native void clearFrameBuffer(@Cast("unsigned int") int buffers,
                    @Const @ByRef(nullValue = "Ogre::ColourValue::Black") ColourValue colour,
                    double depth/*=1.0f*/, @Cast("unsigned short") short stencil/*=0*/);
        public native void clearFrameBuffer(@Cast("unsigned int") int buffers);


        public native void discardFrameBuffer( @Cast("unsigned int") int buffers );
        public native double getHorizontalTexelOffset();
        public native double getVerticalTexelOffset();
        public native double getMinimumDepthInputValue();
        public native double getMaximumDepthInputValue();





        public native void setCurrentPassIterationCount(@Cast("const size_t") long count);
        public native void setDeriveDepthBias(@Cast("bool") boolean derive, float baseValue/*=0.0f*/,
                    float multiplier/*=0.0f*/, float slopeScale/*=0.0f*/);
        public native void setDeriveDepthBias(@Cast("bool") boolean derive);







        public native void _setRenderTarget(RenderTarget target, @Cast("bool") boolean colourWrite);





        public static class Listener extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Listener(Pointer p) { super(p); }
        






            public native void eventOccurred(@Const @ByRef String eventName,
                            @Cast("const Ogre::NameValuePairList*") SStringMapRef parameters/*=0*/);
            public native void eventOccurred(@Const @ByRef String eventName);
        }
        public native void addListener(Listener l);


        public native void removeListener(Listener l);





        public native @Cast("const Ogre::StringVector*") @ByRef StringVectorRef getRenderSystemEvents();
        public native void preExtraThreadsStarted();





        public native void postExtraThreadsStarted();
        public native void registerThread();




        public native void unregisterThread();





        public native @Cast("unsigned int") int getDisplayMonitorCount();




        public native void beginProfileEvent( @Const @ByRef String eventName );




        public native void endProfileEvent( );





        public native void markProfileEvent( @Const @ByRef String event );



        public native @Cast("bool") boolean hasAnisotropicMipMapFilter();






        public native void getCustomAttribute(@Const @ByRef String name, Pointer pData);
  public native @Cast("bool") boolean setDrawBuffer(@Cast("Ogre::ColourBufferType") int colourBuffer);


        public native @Cast("bool") boolean checkExtension( @Const @ByRef String ext );



    }



    @Namespace("Ogre") public static class RenderTargetEvent extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public RenderTargetEvent() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public RenderTargetEvent(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderTargetEvent(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public RenderTargetEvent position(long position) {
            return (RenderTargetEvent)super.position(position);
        }
    

        public native RenderTarget source(); public native RenderTargetEvent source(RenderTarget source);
    }



    @Namespace("Ogre") public static class RenderTargetViewportEvent extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public RenderTargetViewportEvent() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public RenderTargetViewportEvent(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderTargetViewportEvent(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public RenderTargetViewportEvent position(long position) {
            return (RenderTargetViewportEvent)super.position(position);
        }
    

        public native Viewport source(); public native RenderTargetViewportEvent source(Viewport source);
    }
    @Namespace("Ogre") public static class RenderTargetListener extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public RenderTargetListener() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public RenderTargetListener(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderTargetListener(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public RenderTargetListener position(long position) {
            return (RenderTargetListener)super.position(position);
        }
    
        public native void preRenderTargetUpdate(@Const @ByRef RenderTargetEvent evt);
        public native void postRenderTargetUpdate(@Const @ByRef RenderTargetEvent evt);







        public native void preViewportUpdate(@Const @ByRef RenderTargetViewportEvent evt);






        public native void postViewportUpdate(@Const @ByRef RenderTargetViewportEvent evt);




        public native void viewportAdded(@Const @ByRef RenderTargetViewportEvent evt);



        public native void viewportRemoved(@Const @ByRef RenderTargetViewportEvent evt);
    }



    @Namespace("Ogre") @NoOffset public static class RenderTarget extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderTarget(Pointer p) { super(p); }
    
        /** enum Ogre::RenderTarget::StatFlags */
        public static final int
            SF_NONE = 0,
            SF_FPS = 1,
            SF_AVG_FPS = 2,
            SF_BEST_FPS = 4,
            SF_WORST_FPS = 8,
            SF_TRIANGLE_COUNT = 16,
            SF_ALL =  0xFFFF;

        public static class FrameStats extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public FrameStats() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public FrameStats(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public FrameStats(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public FrameStats position(long position) {
                return (FrameStats)super.position(position);
            }
        
            public native @Cast("size_t") long triangleCount(); public native FrameStats triangleCount(long triangleCount);
            public native @Cast("size_t") long batchCount(); public native FrameStats batchCount(long batchCount);
            public native int vBlankMissCount(); public native FrameStats vBlankMissCount(int vBlankMissCount);
        }

        /** enum Ogre::RenderTarget::FrameBuffer */
        public static final int
            FB_FRONT = 0,
            FB_BACK = 1,
            FB_AUTO = 2;


        public native @Const @ByRef String getName();


        public native void getMetrics(@Cast("unsigned int*") @ByRef IntPointer width, @Cast("unsigned int*") @ByRef IntPointer height, @Cast("unsigned int*") @ByRef IntPointer colourDepth);
        public native void getMetrics(@Cast("unsigned int*") @ByRef IntBuffer width, @Cast("unsigned int*") @ByRef IntBuffer height, @Cast("unsigned int*") @ByRef IntBuffer colourDepth);
        public native void getMetrics(@Cast("unsigned int*") @ByRef int[] width, @Cast("unsigned int*") @ByRef int[] height, @Cast("unsigned int*") @ByRef int[] colourDepth);

        public native @Cast("Ogre::uint32") int getWidth();
        public native @Cast("Ogre::uint32") int getHeight();
        public native @Cast("Ogre::uint32") int getColourDepth();
        public native void setDepthBufferPool( @Cast("Ogre::uint16") short poolId );


        public native @Cast("Ogre::uint16") short getDepthBufferPool();
        public native void setPreferDepthTexture( @Cast("bool") boolean preferDepthTexture );


        public native @Cast("bool") boolean prefersDepthTexture();
        public native void setDesiredDepthBufferFormat( @Cast("Ogre::PixelFormat") int desiredDepthBufferFormat );


        public native @Cast("Ogre::PixelFormat") int getDesiredDepthBufferFormat();

        public native DepthBuffer getDepthBuffer();


        public native @Cast("bool") boolean attachDepthBuffer( DepthBuffer depthBuffer, @Cast("bool") boolean exactFormatMatch );

        public native void detachDepthBuffer();





        public native void _detachDepthBuffer();
        public native void swapBuffers();

        public native void setFsaaResolveDirty();
        public native Viewport addViewport( float left/*=0.0f*/, float top/*=0.0f*/,
                                                float width/*=1.0f*/, float height/*=1.0f*/ );
        public native Viewport addViewport( );


        public native @Cast("unsigned short") short getNumViewports();


        public native Viewport getViewport(@Cast("unsigned short") short index);



        public native void removeViewport( Viewport vp );



        public native void removeAllViewports();

        public native @Const @ByRef FrameStats getStatistics();



        public native void resetStatistics();
        public native void getCustomAttribute(@Const @ByRef String name, Pointer pData);
        public native void addListener(RenderTargetListener listener);

        public native void removeListener(RenderTargetListener listener);

        public native void removeAllListeners();
        public native void setPriority( @Cast("Ogre::uchar") byte priority );

        public native @Cast("Ogre::uchar") byte getPriority();



        public native @Cast("bool") boolean isActive();



        public native void setActive( @Cast("bool") boolean state );






        public native void copyContentsToMemory(@Const @ByRef PixelBox dst, @Cast("Ogre::RenderTarget::FrameBuffer") int buffer/*=Ogre::RenderTarget::FB_AUTO*/);
        public native void copyContentsToMemory(@Const @ByRef PixelBox dst);




        public native @Cast("Ogre::PixelFormat") int suggestPixelFormat();


        public native void writeContentsToFile(@Const @ByRef String filename);



        public native @ByVal String writeContentsToTimestampedFile(@Const @ByRef String filenamePrefix, @Const @ByRef String filenameSuffix);

        public native @Cast("bool") boolean requiresTextureFlipping();


        public native @Cast("size_t") long getTriangleCount();

        public native @Cast("size_t") long getBatchCount();







        public native @Cast("bool") boolean isPrimary();


  public native @Cast("bool") boolean isStereoEnabled();
        public native @Cast("bool") boolean isHardwareGammaEnabled();



        public native @Cast("Ogre::uint") int getFSAA();



        public native @Const @ByRef String getFSAAHint();

        public native @Cast("bool") boolean isFsaaResolveDirty();







        public native void setFSAA(@Cast("Ogre::uint") int fsaa, @Const @ByRef String fsaaHint);

        public native void _setMipmapsUpdated();
        public native @Cast("bool") boolean isMipmapsDirty();




        public static class Impl extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public Impl() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public Impl(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Impl(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public Impl position(long position) {
                return (Impl)super.position(position);
            }
        
        }





        public native Impl _getImpl();
        public native void _beginUpdate();

        public native void _updateViewportCullPhase01(Viewport viewport, Camera camera, @Const Camera lodCamera,
                                                @Cast("Ogre::uint8") byte firstRq, @Cast("Ogre::uint8") byte lastRq );
        public native void _updateViewportRenderPhase02( Viewport viewport, Camera camera,
                                                           @Const Camera lodCamera,@Cast("Ogre::uint8") byte firstRq, @Cast("Ogre::uint8") byte lastRq,
                                                           @Cast("bool") boolean updateStatistics );


        public native @Cast("bool") boolean isRenderWindow();







        public native void _endUpdate();




        public native @Cast("bool") boolean getForceDisableColourWrites();
    }




    @Namespace("Ogre") @NoOffset public static class RenderTexture extends RenderTarget {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderTexture(Pointer p) { super(p); }
    
        public RenderTexture(HardwarePixelBuffer buffer, @Cast("Ogre::uint32") int zoffset) { super((Pointer)null); allocate(buffer, zoffset); }
        private native void allocate(HardwarePixelBuffer buffer, @Cast("Ogre::uint32") int zoffset);

        public native void copyContentsToMemory(@Const @ByRef PixelBox dst, @ByVal FrameBuffer buffer);
        public native @Cast("Ogre::PixelFormat") int suggestPixelFormat();
    }
    @Namespace("Ogre") @NoOffset public static class MultiRenderTarget extends RenderTarget {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MultiRenderTarget(Pointer p) { super(p); }
    
        public native void bindSurface(@Cast("size_t") long attachment, @Cast("Ogre::RenderTexture*") RenderTexture target);






        public native void unbindSurface(@Cast("size_t") long attachment);




        public native void copyContentsToMemory(@Const @ByRef PixelBox dst, @ByVal FrameBuffer buffer);
        public native void setFsaaResolveDirty();
        public native void swapBuffers();


        public native @Cast("Ogre::PixelFormat") int suggestPixelFormat();

        public native @Cast("const Ogre::MultiRenderTarget::BoundSufaceList*") @ByRef RenderTexturePtrVectorRef getBoundSurfaceList();


        public native @Cast("Ogre::RenderTexture*") RenderTexture getBoundSurface(@Cast("size_t") long index);


    }



    @Namespace("Ogre") @NoOffset public static class RenderWindow extends RenderTarget {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RenderWindow(Pointer p) { super(p); }
    
        public native float getViewPointToPixelScale();
        public native void create(@Const @ByRef String name, @Cast("unsigned int") int widthPt, @Cast("unsigned int") int heightPt,
                        @Cast("bool") boolean fullScreen, @Cast("const Ogre::NameValuePairList*") SStringMapRef miscParams);
        public native void setFullscreen(@Cast("bool") boolean fullScreen, @Cast("unsigned int") int widthPt, @Cast("unsigned int") int heightPt);



        public native void destroy();



        public native void resize(@Cast("unsigned int") int widthPt, @Cast("unsigned int") int heightPt);





        public native void windowMovedOrResized();



        public native void reposition(int leftPt, int topPt);



        public native @Cast("bool") boolean isVisible();



        public native void setVisible(@Cast("bool") boolean visible);



        public native @Cast("bool") boolean isHidden();
        public native void setHidden(@Cast("bool") boolean hidden);



        public native void setVSyncEnabled(@Cast("bool") boolean vsync);



        public native @Cast("bool") boolean isVSyncEnabled();




        public native void setVSyncInterval(@Cast("unsigned int") int interval);



        public native @Cast("unsigned int") int getVSyncInterval();




        public native @Cast("bool") boolean isActive();



        public native @Cast("bool") boolean isClosed();







        public native @Cast("bool") boolean isPrimary();



        public native @Cast("bool") boolean isFullScreen();




        public native void getMetrics(@Cast("unsigned int*") @ByRef IntPointer width, @Cast("unsigned int*") @ByRef IntPointer height, @Cast("unsigned int*") @ByRef IntPointer colourDepth,
                    @ByRef IntPointer left, @ByRef IntPointer top);
        public native void getMetrics(@Cast("unsigned int*") @ByRef IntBuffer width, @Cast("unsigned int*") @ByRef IntBuffer height, @Cast("unsigned int*") @ByRef IntBuffer colourDepth,
                    @ByRef IntBuffer left, @ByRef IntBuffer top);
        public native void getMetrics(@Cast("unsigned int*") @ByRef int[] width, @Cast("unsigned int*") @ByRef int[] height, @Cast("unsigned int*") @ByRef int[] colourDepth,
                    @ByRef int[] left, @ByRef int[] top);


        public native @Cast("Ogre::PixelFormat") int suggestPixelFormat();



        public native @Cast("bool") boolean isDeactivatedOnFocusChange();





        public native void setDeactivateOnFocusChange(@Cast("bool") boolean deactivate);

        public native @Cast("bool") boolean isRenderWindow();
    }




    @Namespace("Ogre") @NoOffset public static class WorkQueue extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public WorkQueue(Pointer p) { super(p); }
    



        @NoOffset public static class Request extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Request(Pointer p) { super(p); }
        

            public Request(@Cast("Ogre::uint16") short channel, @Cast("Ogre::uint16") short rtype, @Const @ByRef Any rData, @Cast("Ogre::uint8") byte retry, @Cast("Ogre::WorkQueue::RequestID") long rid) { super((Pointer)null); allocate(channel, rtype, rData, retry, rid); }
            private native void allocate(@Cast("Ogre::uint16") short channel, @Cast("Ogre::uint16") short rtype, @Const @ByRef Any rData, @Cast("Ogre::uint8") byte retry, @Cast("Ogre::WorkQueue::RequestID") long rid);

            public native void abortRequest();

            public native @Cast("Ogre::uint16") short getChannel();

            public native @Cast("Ogre::uint16") short getType();

            public native @Const @ByRef Any getData();

            public native @Cast("Ogre::uint8") byte getRetryCount();

            public native @Cast("Ogre::WorkQueue::RequestID") long getID();

            public native @Cast("bool") boolean getAborted();
        }



        @NoOffset public static class Response extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Response(Pointer p) { super(p); }
        

            @MemberGetter public native @Const Request mRequest();

            public native @Cast("bool") boolean mSuccess(); public native Response mSuccess(boolean mSuccess);

            public native @ByRef String mMessages(); public native Response mMessages(String mMessages);

            public native @ByRef Any mData(); public native Response mData(Any mData);
            public Response(@Const Request rq, @Cast("bool") boolean success, @Const @ByRef Any data, @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String msg) { super((Pointer)null); allocate(rq, success, data, msg); }
            private native void allocate(@Const Request rq, @Cast("bool") boolean success, @Const @ByRef Any data, @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String msg);
            public Response(@Const Request rq, @Cast("bool") boolean success, @Const @ByRef Any data) { super((Pointer)null); allocate(rq, success, data); }
            private native void allocate(@Const Request rq, @Cast("bool") boolean success, @Const @ByRef Any data);

            public native @Const Request getRequest();

            public native @Cast("bool") boolean succeeded();

            public native @Const @ByRef String getMessages();

            public native @Const @ByRef Any getData();

            public native void abortRequest();
        }
        @Name("Ogre::WorkQueue::RequestHandler") public static class WorkQueueRequestHandler extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public WorkQueueRequestHandler(Pointer p) { super(p); }
        







            public native @Cast("bool") boolean canHandleRequest(@Const WorkQueue.Request req, @Const WorkQueue srcQ);
            public native WorkQueue.Response handleRequest(@Const WorkQueue.Request req, @Const WorkQueue srcQ);
        }
        @Name("Ogre::WorkQueue::ResponseHandler") public static class WorkQueueResponseHandler extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public WorkQueueResponseHandler(Pointer p) { super(p); }
        







            public native @Cast("bool") boolean canHandleResponse(@Const WorkQueue.Response res, @Const WorkQueue srcQ);
            public native void handleResponse(@Const WorkQueue.Response res, @Const WorkQueue srcQ);
        }





        public native void startup(@Cast("bool") boolean forceRestart/*=true*/);
        public native void startup();
        public native void addRequestHandler(@Cast("Ogre::uint16") short channel, WorkQueueRequestHandler rh);

        public native void removeRequestHandler(@Cast("Ogre::uint16") short channel, WorkQueueRequestHandler rh);
        public native void addResponseHandler(@Cast("Ogre::uint16") short channel, WorkQueueResponseHandler rh);

        public native void removeResponseHandler(@Cast("Ogre::uint16") short channel, WorkQueueResponseHandler rh);
        public native @Cast("Ogre::WorkQueue::RequestID") long addRequest(@Cast("Ogre::uint16") short channel, @Cast("Ogre::uint16") short requestType, @Const @ByRef Any rData, @Cast("Ogre::uint8") byte retryCount/*=0*/,
                    @Cast("bool") boolean forceSynchronous/*=false*/, @Cast("bool") boolean idleThread/*=false*/);
        public native @Cast("Ogre::WorkQueue::RequestID") long addRequest(@Cast("Ogre::uint16") short channel, @Cast("Ogre::uint16") short requestType, @Const @ByRef Any rData);






        public native void abortRequest(@Cast("Ogre::WorkQueue::RequestID") long id);







        public native void abortRequestsByChannel(@Cast("Ogre::uint16") short channel);







        public native void abortPendingRequestsByChannel(@Cast("Ogre::uint16") short channel);





        public native void abortAllRequests();






        public native void setPaused(@Cast("bool") boolean pause);

        public native @Cast("bool") boolean isPaused();





        public native void setRequestsAccepted(@Cast("bool") boolean accept);

        public native @Cast("bool") boolean getRequestsAccepted();
        public native void processResponses();




        public native @Cast("unsigned long") long getResponseProcessingTimeLimit();






        public native void setResponseProcessingTimeLimit(@Cast("unsigned long") long ms);



        public native void shutdown();
        public native @Cast("Ogre::uint16") short getChannel(@Const @ByRef String channelName);

    }



    @Namespace("Ogre") @NoOffset public static class DefaultWorkQueueBase extends WorkQueue {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public DefaultWorkQueueBase(Pointer p) { super(p); }
    

        public native @Const @ByRef String getName();



        public native @Cast("size_t") long getWorkerThreadCount();






        public native void setWorkerThreadCount(@Cast("size_t") long c);
        public native @Cast("bool") boolean getWorkersCanAccessRenderSystem();
        public native void setWorkersCanAccessRenderSystem(@Cast("bool") boolean access);
        public native void _processNextRequest();


        public native void _threadMain();


        public native @Cast("bool") boolean isShuttingDown();


        public native void addRequestHandler(@Cast("Ogre::uint16") short channel, RequestHandler rh);

        public native void removeRequestHandler(@Cast("Ogre::uint16") short channel, RequestHandler rh);

        public native void addResponseHandler(@Cast("Ogre::uint16") short channel, ResponseHandler rh);

        public native void removeResponseHandler(@Cast("Ogre::uint16") short channel, ResponseHandler rh);


        public native @ByVal RequestID addRequest(@Cast("Ogre::uint16") short channel, @Cast("Ogre::uint16") short requestType, @Const @ByRef Any rData, @Cast("Ogre::uint8") byte retryCount/*=0*/,
                    @Cast("bool") boolean forceSynchronous/*=false*/, @Cast("bool") boolean idleThread/*=false*/);
        public native @ByVal RequestID addRequest(@Cast("Ogre::uint16") short channel, @Cast("Ogre::uint16") short requestType, @Const @ByRef Any rData);

        public native void abortRequest(@ByVal RequestID id);

        public native void abortRequestsByChannel(@Cast("Ogre::uint16") short channel);

        public native void abortPendingRequestsByChannel(@Cast("Ogre::uint16") short channel);

        public native void abortAllRequests();

        public native void setPaused(@Cast("bool") boolean pause);

        public native @Cast("bool") boolean isPaused();

        public native void setRequestsAccepted(@Cast("bool") boolean accept);

        public native @Cast("bool") boolean getRequestsAccepted();

        public native void processResponses();

        public native @Cast("unsigned long") long getResponseProcessingTimeLimit();

        public native void setResponseProcessingTimeLimit(@Cast("unsigned long") long ms);
    }



    @Namespace("Ogre") @NoOffset public static class BackgroundProcessResult extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public BackgroundProcessResult(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public BackgroundProcessResult(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public BackgroundProcessResult position(long position) {
            return (BackgroundProcessResult)super.position(position);
        }
    

        public native @Cast("bool") boolean error(); public native BackgroundProcessResult error(boolean error);

        public native @ByRef String message(); public native BackgroundProcessResult message(String message);

        public BackgroundProcessResult() { super((Pointer)null); allocate(); }
        private native void allocate();
    }
    @Namespace("Ogre") @NoOffset public static class ResourceBackgroundQueue extends ResourceBackgroundQueueSgtRef {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ResourceBackgroundQueue(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ResourceBackgroundQueue(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ResourceBackgroundQueue position(long position) {
            return (ResourceBackgroundQueue)super.position(position);
        }
        public Pointer asPointer() { return asPointer(this); }
        @Namespace public static native @Name("static_cast<ResourceAlloc*>") Pointer asPointer(ResourceBackgroundQueue pointer);
        public WorkQueueRequestHandler asWorkQueueRequestHandler() { return asWorkQueueRequestHandler(this); }
        @Namespace public static native @Name("static_cast<Ogre::WorkQueue::RequestHandler*>") WorkQueueRequestHandler asWorkQueueRequestHandler(ResourceBackgroundQueue pointer);
        public WorkQueueResponseHandler asWorkQueueResponseHandler() { return asWorkQueueResponseHandler(this); }
        @Namespace public static native @Name("static_cast<Ogre::WorkQueue::ResponseHandler*>") WorkQueueResponseHandler asWorkQueueResponseHandler(ResourceBackgroundQueue pointer);
    
        public static class Listener extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Listener(Pointer p) { super(p); }
        






            public native void operationCompleted(long ticket, @Const @ByRef BackgroundProcessResult result);

        }
        public ResourceBackgroundQueue() { super((Pointer)null); allocate(); }
        private native void allocate();




        public native void initialise();




        public native void shutdown();
        public native long initialiseResourceGroup(
                    @Const @ByRef String name, Listener listener/*=0*/);
        public native long initialiseResourceGroup(
                    @Const @ByRef String name);
        public native long initialiseAllResourceGroups(
                    Listener listener/*=0*/);
        public native long initialiseAllResourceGroups();
        public native long prepareResourceGroup(@Const @ByRef String name,
                    Listener listener/*=0*/);
        public native long prepareResourceGroup(@Const @ByRef String name);
        public native long loadResourceGroup(@Const @ByRef String name,
                    Listener listener/*=0*/);
        public native long loadResourceGroup(@Const @ByRef String name);
        public native long unload(
                    @Const @ByRef String resType, @Const @ByRef String name,
                    Listener listener/*=0*/);
        public native long unload(
                    @Const @ByRef String resType, @Const @ByRef String name);







        public native long unload(
                    @Const @ByRef String resType, @Cast("Ogre::ResourceHandle") long handle,
                    Listener listener/*=0*/);
        public native long unload(
                    @Const @ByRef String resType, @Cast("Ogre::ResourceHandle") long handle);







        public native long unloadResourceGroup(@Const @ByRef String name,
                    Listener listener/*=0*/);
        public native long unloadResourceGroup(@Const @ByRef String name);
        public native long prepare(
                    @Const @ByRef String resType, @Const @ByRef String name,
                    @Const @ByRef String group, @Cast("bool") boolean isManual/*=false*/,
                    ManualResourceLoader loader/*=0*/,
                    @Cast("const Ogre::NameValuePairList*") SStringMapRef loadParams/*=0*/,
                    Listener listener/*=0*/);
        public native long prepare(
                    @Const @ByRef String resType, @Const @ByRef String name,
                    @Const @ByRef String group);
        public native long load(
                    @Const @ByRef String resType, @Const @ByRef String name,
                    @Const @ByRef String group, @Cast("bool") boolean isManual/*=false*/,
                    ManualResourceLoader loader/*=0*/,
                    @Cast("const Ogre::NameValuePairList*") SStringMapRef loadParams/*=0*/,
                    Listener listener/*=0*/);
        public native long load(
                    @Const @ByRef String resType, @Const @ByRef String name,
                    @Const @ByRef String group);
        public native @Cast("bool") boolean isProcessComplete(long ticket);



        public native void abortRequest( long ticket );


        public native @Cast("bool") boolean canHandleRequest(@Const WorkQueue.Request req, @Const WorkQueue srcQ);

        public native WorkQueue.Response handleRequest(@Const WorkQueue.Request req, @Const WorkQueue srcQ);

        public native @Cast("bool") boolean canHandleResponse(@Const WorkQueue.Response res, @Const WorkQueue srcQ);

        public native void handleResponse(@Const WorkQueue.Response res, @Const WorkQueue srcQ);
        public static native @ByRef ResourceBackgroundQueue getSingleton();
        public static native ResourceBackgroundQueue getSingletonPtr();

    }





    @Namespace("Ogre::v1") @NoOffset public static class RibbonTrail extends BillboardChain {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RibbonTrail(Pointer p) { super(p); }
        public NodeListener asNodeListener() { return asNodeListener(this); }
        @Namespace public static native @Name("static_cast<Ogre::Node::Listener*>") NodeListener asNodeListener(RibbonTrail pointer);
    
        public RibbonTrail( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager,
                             @Cast("size_t") long maxElements/*=20*/, @Cast("size_t") long numberOfChains/*=1*/, @Cast("bool") boolean useTextureCoords/*=true*/,
                             @Cast("bool") boolean useVertexColours/*=true*/ ) { super((Pointer)null); allocate(id, objectMemoryManager, manager, maxElements, numberOfChains, useTextureCoords, useVertexColours); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager,
                             @Cast("size_t") long maxElements/*=20*/, @Cast("size_t") long numberOfChains/*=1*/, @Cast("bool") boolean useTextureCoords/*=true*/,
                             @Cast("bool") boolean useVertexColours/*=true*/ );
        public RibbonTrail( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager ) { super((Pointer)null); allocate(id, objectMemoryManager, manager); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager );




        public native void addNode(Node n);

        public native void removeNode(Node n);

        public native @ByVal @Cast("Ogre::v1::RibbonTrail::NodeIterator*") NodeTrackIteratorRef getNodeIterator();

        public native @Cast("size_t") long getChainIndexForNode(@Const Node n);







        public native void setTrailLength(double len);

        public native double getTrailLength();


        public native void setMaxChainElements(@Cast("size_t") long maxElements);

        public native void setNumberOfChains(@Cast("size_t") long numChains);

        public native void clearChain(@Cast("size_t") long chainIndex);







        public native void setInitialColour(@Cast("size_t") long chainIndex, @Const @ByRef ColourValue col);






        public native void setInitialColour(@Cast("size_t") long chainIndex, double r, double g, double b, double a/*=1.0*/);
        public native void setInitialColour(@Cast("size_t") long chainIndex, double r, double g, double b);

        public native @Const @ByRef ColourValue getInitialColour(@Cast("size_t") long chainIndex);





        public native void setColourChange(@Cast("size_t") long chainIndex, @Const @ByRef ColourValue valuePerSecond);





        public native void setInitialWidth(@Cast("size_t") long chainIndex, double width);

        public native double getInitialWidth(@Cast("size_t") long chainIndex);





        public native void setWidthChange(@Cast("size_t") long chainIndex, double widthDeltaPerSecond);

        public native double getWidthChange(@Cast("size_t") long chainIndex);





        public native void setColourChange(@Cast("size_t") long chainIndex, double r, double g, double b, double a);


        public native @Const @ByRef ColourValue getColourChange(@Cast("size_t") long chainIndex);


        public native void nodeUpdated(@Const Node node);

        public native void nodeDestroyed(@Const Node node);


        public native void _timeUpdate(double time);


        public native @Const @ByRef String getMovableType();

    }



    @Namespace("Ogre::v1") @NoOffset public static class RibbonTrailFactory extends MovableObjectFactory {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RibbonTrailFactory(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public RibbonTrailFactory(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public RibbonTrailFactory position(long position) {
            return (RibbonTrailFactory)super.position(position);
        }
    
        public RibbonTrailFactory() { super((Pointer)null); allocate(); }
        private native void allocate();

        public static native @ByRef String FACTORY_TYPE_NAME(); public static native void FACTORY_TYPE_NAME(String FACTORY_TYPE_NAME);

        public native @Const @ByRef String getType();
        public native void destroyInstance( MovableObject obj);

    }





    @Namespace("Ogre") @NoOffset public static class Ray extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Ray(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Ray(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Ray position(long position) {
            return (Ray)super.position(position);
        }
    
        public Ray() { super((Pointer)null); allocate(); }
        private native void allocate();
        public Ray(@Const @ByRef Vector3 origin, @Const @ByRef Vector3 direction) { super((Pointer)null); allocate(origin, direction); }
        private native void allocate(@Const @ByRef Vector3 origin, @Const @ByRef Vector3 direction);


        public native void setOrigin(@Const @ByRef Vector3 origin);

        public native @Const @ByRef Vector3 getOrigin();


        public native void setDirection(@Const @ByRef Vector3 dir);

        public native @Const @ByRef Vector3 getDirection();


        public native @ByVal Vector3 getPoint(double t);


        public native @ByVal @Name("operator *") Vector3 multiply(double t);







        public native @ByVal @Cast("std::pair<bool,Ogre::Real>*") RealPairRef intersects(@Const @ByRef Plane p);






        public native @ByVal @Cast("std::pair<bool,Ogre::Real>*") RealPairRef intersects(@Const @ByRef PlaneBoundedVolume p);






        public native @ByVal @Cast("std::pair<bool,Ogre::Real>*") RealPairRef intersects(@Const @ByRef Sphere s);






        public native @ByVal @Cast("std::pair<bool,Ogre::Real>*") RealPairRef intersects(@Const @ByRef AxisAlignedBox box);

    }




    @Namespace("Ogre") @NoOffset public static class SceneQuery extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SceneQuery(Pointer p) { super(p); }
    






        /** enum Ogre::SceneQuery::WorldFragmentType */
        public static final int

            WFT_NONE = 0,

            WFT_PLANE_BOUNDED_REGION = 1,

            WFT_SINGLE_INTERSECTION = 2,

            WFT_CUSTOM_GEOMETRY = 3,

            WFT_RENDER_OPERATION = 4;
        public static class WorldFragment extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public WorldFragment() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public WorldFragment(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public WorldFragment(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public WorldFragment position(long position) {
                return (WorldFragment)super.position(position);
            }
        

            public native @Cast("Ogre::SceneQuery::WorldFragmentType") int fragmentType(); public native WorldFragment fragmentType(int fragmentType);

            public native @ByRef Vector3 singleIntersection(); public native WorldFragment singleIntersection(Vector3 singleIntersection);

            public native @Cast("list<Ogre::Plane>::type*") PlaneListRef planes(); public native WorldFragment planes(PlaneListRef planes);

            public native Pointer geometry(); public native WorldFragment geometry(Pointer geometry);

            public native RenderOperation renderOp(); public native WorldFragment renderOp(RenderOperation renderOp);

        }
        public native @Cast("Ogre::uint8") byte mFirstRq(); public native SceneQuery mFirstRq(byte mFirstRq);
        public native @Cast("Ogre::uint8") byte mLastRq(); public native SceneQuery mLastRq(byte mLastRq);


        public SceneQuery(SceneManager mgr) { super((Pointer)null); allocate(mgr); }
        private native void allocate(SceneManager mgr);
        public native void setQueryMask(@Cast("Ogre::uint32") int mask);

        public native @Cast("Ogre::uint32") int getQueryMask();
        public native void setWorldFragmentType(@Cast("Ogre::SceneQuery::WorldFragmentType") int wft);


        public native @Cast("Ogre::SceneQuery::WorldFragmentType") int getWorldFragmentType();


        public native @Cast("const set<Ogre::SceneQuery::WorldFragmentType>::type*") WorldFragmentTypeSetRef getSupportedWorldFragmentTypes();


    }







    @Namespace("Ogre") public static class SceneQueryListener extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SceneQueryListener(Pointer p) { super(p); }
    





        public native @Cast("bool") boolean queryResult(MovableObject object);





        public native @Cast("bool") boolean queryResult(SceneQuery.WorldFragment fragment);

    }

    @Namespace("Ogre") @NoOffset public static class SceneQueryResult extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public SceneQueryResult() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public SceneQueryResult(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SceneQueryResult(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public SceneQueryResult position(long position) {
            return (SceneQueryResult)super.position(position);
        }
    

        public native @ByRef @Cast("Ogre::SceneQueryResultMovableList*") MovableObjectPtrListRef movables(); public native SceneQueryResult movables(MovableObjectPtrListRef movables);

        public native @ByRef @Cast("Ogre::SceneQueryResultWorldFragmentList*") WorldFragmentPtrListRef worldFragments(); public native SceneQueryResult worldFragments(WorldFragmentPtrListRef worldFragments);
    }







    @Namespace("Ogre") @NoOffset public static class RegionSceneQuery extends SceneQuery {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RegionSceneQuery(Pointer p) { super(p); }
        public SceneQueryListener asSceneQueryListener() { return asSceneQueryListener(this); }
        @Namespace public static native @Name("static_cast<Ogre::SceneQueryListener*>") SceneQueryListener asSceneQueryListener(RegionSceneQuery pointer);
    
        public native @ByRef SceneQueryResult execute();
        public native void execute(SceneQueryListener listener);




        public native @ByRef SceneQueryResult getLastResults();






        public native void clearResults();


        public native @Cast("bool") boolean queryResult(MovableObject first);

        public native @Cast("bool") boolean queryResult(SceneQuery.WorldFragment fragment);
    }


    @Namespace("Ogre") @NoOffset public static class AxisAlignedBoxSceneQuery extends RegionSceneQuery {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public AxisAlignedBoxSceneQuery(Pointer p) { super(p); }
    
        public AxisAlignedBoxSceneQuery(SceneManager mgr) { super((Pointer)null); allocate(mgr); }
        private native void allocate(SceneManager mgr);


        public native void setBox(@Const @ByRef AxisAlignedBox box);


        public native @Const @ByRef AxisAlignedBox getBox();

    }


    @Namespace("Ogre") @NoOffset public static class SphereSceneQuery extends RegionSceneQuery {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SphereSceneQuery(Pointer p) { super(p); }
    
        public SphereSceneQuery(SceneManager mgr) { super((Pointer)null); allocate(mgr); }
        private native void allocate(SceneManager mgr);

        public native void setSphere(@Const @ByRef Sphere sphere);


        public native @Const @ByRef Sphere getSphere();

    }



    @Namespace("Ogre") @NoOffset public static class PlaneBoundedVolumeListSceneQuery extends RegionSceneQuery {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public PlaneBoundedVolumeListSceneQuery(Pointer p) { super(p); }
    
        public PlaneBoundedVolumeListSceneQuery(SceneManager mgr) { super((Pointer)null); allocate(mgr); }
        private native void allocate(SceneManager mgr);

        public native void setVolumes(@Cast("const Ogre::PlaneBoundedVolumeList*") @ByRef PlaneBoundedVolumeVectorRef volumes);


        public native @Cast("const Ogre::PlaneBoundedVolumeList*") @ByRef PlaneBoundedVolumeVectorRef getVolumes();

    }
    @Namespace("Ogre") public static class RaySceneQueryListener extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RaySceneQueryListener(Pointer p) { super(p); }
    






        public native @Cast("bool") boolean queryResult(MovableObject obj, double distance);







        public native @Cast("bool") boolean queryResult(SceneQuery.WorldFragment fragment, double distance);

    }


    @Namespace("Ogre") public static class RaySceneQueryResultEntry extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public RaySceneQueryResultEntry() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public RaySceneQueryResultEntry(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RaySceneQueryResultEntry(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public RaySceneQueryResultEntry position(long position) {
            return (RaySceneQueryResultEntry)super.position(position);
        }
    

        public native double distance(); public native RaySceneQueryResultEntry distance(double distance);

        public native MovableObject movable(); public native RaySceneQueryResultEntry movable(MovableObject movable);

        public native SceneQuery.WorldFragment worldFragment(); public native RaySceneQueryResultEntry worldFragment(SceneQuery.WorldFragment worldFragment);

        public native @Cast("bool") @Name("operator <") boolean lessThan(@Const @ByRef RaySceneQueryResultEntry rhs);

    }


    @Namespace("Ogre") @NoOffset public static class RaySceneQuery extends SceneQuery {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public RaySceneQuery(Pointer p) { super(p); }
        public RaySceneQueryListener asRaySceneQueryListener() { return asRaySceneQueryListener(this); }
        @Namespace public static native @Name("static_cast<Ogre::RaySceneQueryListener*>") RaySceneQueryListener asRaySceneQueryListener(RaySceneQuery pointer);
    

        public native void setRay(@Const @ByRef Ray ray);

        public native @Const @ByRef Ray getRay();
        public native void setSortByDistance(@Cast("bool") boolean sort, short maxresults/*=0*/);
        public native void setSortByDistance(@Cast("bool") boolean sort);

        public native @Cast("bool") boolean getSortByDistance();


        public native short getMaxResults();
        public native @Cast("Ogre::RaySceneQueryResult*") @ByRef RaySceneQueryResultEntryVectorRef execute();
        public native void execute(RaySceneQueryListener listener);




        public native @Cast("Ogre::RaySceneQueryResult*") @ByRef RaySceneQueryResultEntryVectorRef getLastResults();






        public native void clearResults();


        public native @Cast("bool") boolean queryResult(MovableObject obj, double distance);

        public native @Cast("bool") boolean queryResult(SceneQuery.WorldFragment fragment, double distance);




    }






    @Namespace("Ogre") public static class IntersectionSceneQueryListener extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public IntersectionSceneQueryListener(Pointer p) { super(p); }
    






        public native @Cast("bool") boolean queryResult(MovableObject first, MovableObject second);







        public native @Cast("bool") boolean queryResult(MovableObject movable, SceneQuery.WorldFragment fragment);






    }

    @Namespace("Ogre") @NoOffset public static class IntersectionSceneQueryResult extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public IntersectionSceneQueryResult() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public IntersectionSceneQueryResult(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public IntersectionSceneQueryResult(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public IntersectionSceneQueryResult position(long position) {
            return (IntersectionSceneQueryResult)super.position(position);
        }
    

        public native @ByRef @Cast("Ogre::SceneQueryMovableIntersectionList*") SceneQueryMovableObjectPairListRef movables2movables(); public native IntersectionSceneQueryResult movables2movables(SceneQueryMovableObjectPairListRef movables2movables);

        public native @ByRef @Cast("Ogre::SceneQueryMovableWorldFragmentIntersectionList*") SceneQueryMovableObjectWorldFragmentPairListRef movables2world(); public native IntersectionSceneQueryResult movables2world(SceneQueryMovableObjectWorldFragmentPairListRef movables2world);



    }
    @Namespace("Ogre") @NoOffset public static class IntersectionSceneQuery extends SceneQuery {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public IntersectionSceneQuery(Pointer p) { super(p); }
        public IntersectionSceneQueryListener asIntersectionSceneQueryListener() { return asIntersectionSceneQueryListener(this); }
        @Namespace public static native @Name("static_cast<Ogre::IntersectionSceneQueryListener*>") IntersectionSceneQueryListener asIntersectionSceneQueryListener(IntersectionSceneQuery pointer);
    
        public native @ByRef IntersectionSceneQueryResult execute();
        public native void execute(IntersectionSceneQueryListener listener);




        public native @ByRef IntersectionSceneQueryResult getLastResults();






        public native void clearResults();


        public native @Cast("bool") boolean queryResult(MovableObject first, MovableObject second);

        public native @Cast("bool") boolean queryResult(MovableObject movable, SceneQuery.WorldFragment fragment);
    }







    @Namespace("Ogre") @Opaque public static class CompositorShadowNode extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public CompositorShadowNode() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public CompositorShadowNode(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @NoOffset public static class AutoParamDataSource extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public AutoParamDataSource(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public AutoParamDataSource(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public AutoParamDataSource position(long position) {
            return (AutoParamDataSource)super.position(position);
        }
    
        public AutoParamDataSource() { super((Pointer)null); allocate(); }
        private native void allocate();

         public native void setCurrentRenderable(@Const Renderable rend);

         public native void setWorldMatrices(@Const Matrix4 m, @Cast("size_t") long count);

         public native void setCurrentCamera(@Const Camera cam);

         public native void setCurrentLightList(@Cast("const Ogre::LightList*") HashedVector ll);

         public native void setTextureProjector(@Const Frustum frust, @Cast("size_t") long index);

         public native void setCurrentViewport(@Const Viewport viewport);

         public native void setShadowDirLightExtrusionDistance(double dist);

         public native void setCurrentSceneManager(@Const SceneManager sm);

         public native void setCurrentPass(@Const Pass pass);
         public native void setCurrentShadowNode(@Const CompositorShadowNode sn);

         public native @Const Camera getCurrentCamera();


         public native @Const @ByRef Matrix4 getWorldMatrix();
         public native @Const Matrix4 getWorldMatrixArray();
         public native @Cast("size_t") long getWorldMatrixCount();
         public native @Const @ByRef Matrix4 getViewMatrix();
         public native @Const @ByRef Matrix4 getViewProjectionMatrix();
         public native @Const @ByRef Matrix4 getProjectionMatrix();
         public native @Const @ByRef Matrix4 getWorldViewProjMatrix();
         public native @Const @ByRef Matrix4 getWorldViewMatrix();
         public native @Const @ByRef Matrix4 getInverseWorldMatrix();
         public native @Const @ByRef Matrix4 getInverseWorldViewMatrix();
         public native @Const @ByRef Matrix4 getInverseViewMatrix();
         public native @Const @ByRef Matrix4 getInverseTransposeWorldMatrix();
         public native @Const @ByRef Matrix4 getInverseTransposeWorldViewMatrix();
         public native @Const @ByRef Vector4 getCameraPosition();
         public native @Const @ByRef Vector4 getCameraPositionObjectSpace();
         public native @Const @ByRef Vector4 getLodCameraPosition();
         public native @Const @ByRef Vector4 getLodCameraPositionObjectSpace();
         public native @Cast("bool") boolean hasLightList();
         public native float getLightCount();
         public native float getLightCastsShadows(@Cast("size_t") long index);
         public native @Const @ByRef ColourValue getLightDiffuseColour(@Cast("size_t") long index);
         public native @Const @ByRef ColourValue getLightSpecularColour(@Cast("size_t") long index);
         public native @Const @ByVal ColourValue getLightDiffuseColourWithPower(@Cast("size_t") long index);
         public native @Const @ByVal ColourValue getLightSpecularColourWithPower(@Cast("size_t") long index);
         public native @ByVal Vector3 getLightPosition(@Cast("size_t") long index);
         public native @ByVal Vector4 getLightAs4DVector(@Cast("size_t") long index);
         public native @ByVal Vector3 getLightDirection(@Cast("size_t") long index);
         public native double getLightPowerScale(@Cast("size_t") long index);
         public native @ByVal Vector4 getLightAttenuation(@Cast("size_t") long index);
         public native @ByVal Vector4 getSpotlightParams(@Cast("size_t") long index);
         public native void setAmbientLightColour( @Const ColourValue hemispheres,
                                              @Const @ByRef Vector3 hemisphereDir );
         public native @Const @ByRef ColourValue getAmbientLightColour();
         public native @Const @ByRef ColourValue getSurfaceAmbientColour();
         public native @Const @ByRef ColourValue getSurfaceDiffuseColour();
         public native @Const @ByRef ColourValue getSurfaceSpecularColour();
         public native @Const @ByRef ColourValue getSurfaceEmissiveColour();
         public native double getSurfaceShininess();
         public native double getSurfaceAlphaRejectionValue();
         public native @ByVal ColourValue getDerivedAmbientLightColour();
         public native @ByVal ColourValue getDerivedSceneColour();
         public native void setFog(@Cast("Ogre::FogMode") int mode, @Const @ByRef ColourValue colour, double expDensity, double linearStart, double linearEnd);
         public native @Const @ByRef ColourValue getFogColour();
         public native @Const @ByRef Vector4 getFogParams();
         public native @Const @ByRef Matrix4 getTextureViewProjMatrix(@Cast("size_t") long index);
         public native @Const @ByRef Matrix4 getTextureWorldViewProjMatrix(@Cast("size_t") long index);
         public native @Const @ByRef Matrix4 getSpotlightViewProjMatrix(@Cast("size_t") long index);
         public native @Const @ByRef Matrix4 getSpotlightWorldViewProjMatrix(@Cast("size_t") long index);
         public native @Const @ByRef Matrix4 getTextureTransformMatrix(@Cast("size_t") long index);
         public native @Cast("const vector<Ogre::Real>::type*") @ByRef RealVectorRef getPssmSplits( @Cast("size_t") long shadowMapIdx );
         public native @Const RenderTarget getCurrentRenderTarget();
         public native @Const Renderable getCurrentRenderable();
         public native @Const Pass getCurrentPass();
         public native @ByVal Vector4 getTextureSize(@Cast("size_t") long index);
         public native @ByVal Vector4 getInverseTextureSize(@Cast("size_t") long index);
         public native @ByVal Vector4 getPackedTextureSize(@Cast("size_t") long index);
         public native double getShadowExtrusionDistance();
         public native @Const @ByRef Vector4 getSceneDepthRange();
         public native @Const @ByRef Vector4 getShadowSceneDepthRange(@Cast("size_t") long index);
         public native @Const @ByRef ColourValue getShadowColour();
         public native @ByVal Matrix4 getInverseViewProjMatrix();
         public native @ByVal Matrix4 getInverseTransposeViewProjMatrix();
         public native @ByVal Matrix4 getTransposeViewProjMatrix();
         public native @ByVal Matrix4 getTransposeViewMatrix();
         public native @ByVal Matrix4 getInverseTransposeViewMatrix();
         public native @ByVal Matrix4 getTransposeProjectionMatrix();
         public native @ByVal Matrix4 getInverseProjectionMatrix();
         public native @ByVal Matrix4 getInverseTransposeProjectionMatrix();
         public native @ByVal Matrix4 getTransposeWorldViewProjMatrix();
         public native @ByVal Matrix4 getInverseWorldViewProjMatrix();
         public native @ByVal Matrix4 getInverseTransposeWorldViewProjMatrix();
         public native @ByVal Matrix4 getTransposeWorldViewMatrix();
         public native @ByVal Matrix4 getTransposeWorldMatrix();
         public native double getTime();
         public native double getTime_0_X(double x);
         public native double getCosTime_0_X(double x);
         public native double getSinTime_0_X(double x);
         public native double getTanTime_0_X(double x);
         public native @ByVal Vector4 getTime_0_X_packed(double x);
         public native double getTime_0_1(double x);
         public native double getCosTime_0_1(double x);
         public native double getSinTime_0_1(double x);
         public native double getTanTime_0_1(double x);
         public native @ByVal Vector4 getTime_0_1_packed(double x);
         public native double getTime_0_2Pi(double x);
         public native double getCosTime_0_2Pi(double x);
         public native double getSinTime_0_2Pi(double x);
         public native double getTanTime_0_2Pi(double x);
         public native @ByVal Vector4 getTime_0_2Pi_packed(double x);
         public native double getFrameTime();
         public native double getFPS();
         public native double getViewportWidth();
         public native double getViewportHeight();
         public native double getInverseViewportWidth();
         public native double getInverseViewportHeight();
         public native @ByVal Vector3 getViewDirection();
         public native @ByVal Vector3 getViewSideVector();
         public native @ByVal Vector3 getViewUpVector();
         public native double getFOV();
         public native double getNearClipDistance();
         public native double getFarClipDistance();
         public native int getPassNumber();
         public native void setPassNumber(int passNumber);
         public native void incPassNumber();
         public native void updateLightCustomGpuParameter(@Const @ByRef GpuProgramParameters.AutoConstantEntry constantEntry, GpuProgramParameters params);

   public native @Const @ByRef Light _getBlankLight();
    }





    @Namespace("Ogre") @NoOffset public static class ShadowTextureConfig extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ShadowTextureConfig(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ShadowTextureConfig(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ShadowTextureConfig position(long position) {
            return (ShadowTextureConfig)super.position(position);
        }
    
        public native @Cast("unsigned int") int width(); public native ShadowTextureConfig width(int width);
        public native @Cast("unsigned int") int height(); public native ShadowTextureConfig height(int height);
        public native @Cast("Ogre::PixelFormat") int format(); public native ShadowTextureConfig format(int format);
        public native @Cast("unsigned int") int fsaa(); public native ShadowTextureConfig fsaa(int fsaa);
        public native @Cast("Ogre::uint16") short depthBufferPoolId(); public native ShadowTextureConfig depthBufferPoolId(short depthBufferPoolId);

        public ShadowTextureConfig() { super((Pointer)null); allocate(); }
        private native void allocate();
    }

    @Namespace("Ogre") public static native @Cast("bool") @Name("operator ==") boolean equals( @Const @ByRef ShadowTextureConfig lhs, @Const @ByRef ShadowTextureConfig rhs );
    @Namespace("Ogre") public static native @Cast("bool") @Name("operator !=") boolean notEquals( @Const @ByRef ShadowTextureConfig lhs, @Const @ByRef ShadowTextureConfig rhs );
    @Namespace("Ogre") @NoOffset public static class ShadowTextureManager extends ShadowTextureManagerSgtRef {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ShadowTextureManager(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ShadowTextureManager(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public ShadowTextureManager position(long position) {
            return (ShadowTextureManager)super.position(position);
        }
        public Pointer asPointer() { return asPointer(this); }
        @Namespace public static native @Name("static_cast<ShadowDataAlloc*>") Pointer asPointer(ShadowTextureManager pointer);
    
        public ShadowTextureManager() { super((Pointer)null); allocate(); }
        private native void allocate();




        public native void getShadowTextures(@Cast("const Ogre::ShadowTextureConfigList*") @ByRef ShadowTextureConfigVectorRef config,
                    @Cast("Ogre::ShadowTextureList*") @ByRef TexturePtrVectorRef listToPopulate);



        public native void getAllShadowTextures(@Cast("Ogre::ShadowTextureList*") @ByRef TexturePtrVectorRef listToPopulate);




        public native @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr getNullShadowTexture(@Cast("Ogre::PixelFormat") int format);






        public native void clearUnused();




        public native void clear();
        public static native @ByRef ShadowTextureManager getSingleton();
        public static native ShadowTextureManager getSingletonPtr();

    }




    @Namespace("Ogre") public static class MovableObjectLodChangedEvent extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public MovableObjectLodChangedEvent() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public MovableObjectLodChangedEvent(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MovableObjectLodChangedEvent(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public MovableObjectLodChangedEvent position(long position) {
            return (MovableObjectLodChangedEvent)super.position(position);
        }
    

        public native MovableObject movableObject(); public native MovableObjectLodChangedEvent movableObject(MovableObject movableObject);


        public native Camera camera(); public native MovableObjectLodChangedEvent camera(Camera camera);
    }


    @Namespace("Ogre") public static class EntityMeshLodChangedEvent extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public EntityMeshLodChangedEvent() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public EntityMeshLodChangedEvent(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public EntityMeshLodChangedEvent(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public EntityMeshLodChangedEvent position(long position) {
            return (EntityMeshLodChangedEvent)super.position(position);
        }
    

        public native Entity entity(); public native EntityMeshLodChangedEvent entity(Entity entity);


        public native Camera camera(); public native EntityMeshLodChangedEvent camera(Camera camera);


        public native double lodValue(); public native EntityMeshLodChangedEvent lodValue(double lodValue);


        public native short previousLodIndex(); public native EntityMeshLodChangedEvent previousLodIndex(short previousLodIndex);


        public native short newLodIndex(); public native EntityMeshLodChangedEvent newLodIndex(short newLodIndex);
    }


    @Namespace("Ogre") public static class EntityMaterialLodChangedEvent extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public EntityMaterialLodChangedEvent() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public EntityMaterialLodChangedEvent(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public EntityMaterialLodChangedEvent(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public EntityMaterialLodChangedEvent position(long position) {
            return (EntityMaterialLodChangedEvent)super.position(position);
        }
    

        public native SubEntity subEntity(); public native EntityMaterialLodChangedEvent subEntity(SubEntity subEntity);


        public native Camera camera(); public native EntityMaterialLodChangedEvent camera(Camera camera);


        public native double lodValue(); public native EntityMaterialLodChangedEvent lodValue(double lodValue);


        public native short previousLodIndex(); public native EntityMaterialLodChangedEvent previousLodIndex(short previousLodIndex);


        public native short newLodIndex(); public native EntityMaterialLodChangedEvent newLodIndex(short newLodIndex);
    }
    @Namespace("Ogre") public static class LodListener extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public LodListener() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public LodListener(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public LodListener(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public LodListener position(long position) {
            return (LodListener)super.position(position);
        }
    
        public native @Cast("bool") boolean prequeueMovableObjectLodChanged(@Const @ByRef MovableObjectLodChangedEvent evt);







        public native void postqueueMovableObjectLodChanged(@Const @ByRef MovableObjectLodChangedEvent evt);
        public native @Cast("bool") boolean prequeueEntityMeshLodChanged(@ByRef EntityMeshLodChangedEvent evt);







        public native void postqueueEntityMeshLodChanged(@Const @ByRef EntityMeshLodChangedEvent evt);
        public native @Cast("bool") boolean prequeueEntityMaterialLodChanged(@ByRef EntityMaterialLodChangedEvent evt);







        public native void postqueueEntityMaterialLodChanged(@Const @ByRef EntityMaterialLodChangedEvent evt);

    }



    @Namespace("Ogre") public static class IndexBufferPacked extends BufferPacked {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public IndexBufferPacked(Pointer p) { super(p); }
    
        /** enum Ogre::IndexBufferPacked::IndexType */
        public static final int
            IT_16BIT = 0,
            IT_32BIT = 1;

        public IndexBufferPacked( @Cast("size_t") long internalBufferStartBytes, @Cast("size_t") long numElements, @Cast("Ogre::uint32") int bytesPerElement,
                                   @Cast("Ogre::BufferType") int bufferType, Pointer initialData, @Cast("bool") boolean keepAsShadow,
                                   VaoManager vaoManager, BufferInterface bufferInterface ) { super((Pointer)null); allocate(internalBufferStartBytes, numElements, bytesPerElement, bufferType, initialData, keepAsShadow, vaoManager, bufferInterface); }
        private native void allocate( @Cast("size_t") long internalBufferStartBytes, @Cast("size_t") long numElements, @Cast("Ogre::uint32") int bytesPerElement,
                                   @Cast("Ogre::BufferType") int bufferType, Pointer initialData, @Cast("bool") boolean keepAsShadow,
                                   VaoManager vaoManager, BufferInterface bufferInterface );

        public native @Cast("Ogre::BufferPackedTypes") int getBufferPackedType();

        public native @Cast("Ogre::IndexBufferPacked::IndexType") int getIndexType();
    }


    @Namespace("Ogre") @NoOffset public static class VaoManager extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public VaoManager(Pointer p) { super(p); }
    


        public static native @Cast("Ogre::uint32") int calculateVertexSize( @Cast("const Ogre::VertexElement2Vec*") @ByRef VertexElement2VectorRef vertexElements );
        public native VertexBufferPacked createVertexBuffer( @Cast("const Ogre::VertexElement2Vec*") @ByRef VertexElement2VectorRef vertexElements,
                                                        @Cast("size_t") long numVertices, @Cast("Ogre::BufferType") int bufferType,
                                                        Pointer initialData, @Cast("bool") boolean keepAsShadow );

        public native MultiSourceVertexBufferPool createMultiSourceVertexBufferPool(
                                        @Cast("const Ogre::VertexElement2VecVec*") @ByRef VertexElement2VecVectorRef vertexElementsBySource,
                                        @Cast("size_t") long maxNumVertices, @Cast("Ogre::BufferType") int bufferType );







        public native void destroyVertexBuffer( VertexBufferPacked vertexBuffer );
        public native IndexBufferPacked createIndexBuffer( @Cast("Ogre::IndexBufferPacked::IndexType") int indexType,
                                                      @Cast("size_t") long numIndices, @Cast("Ogre::BufferType") int bufferType,
                                                      Pointer initialData, @Cast("bool") boolean keepAsShadow );





        public native void destroyIndexBuffer( IndexBufferPacked indexBuffer );
        public native ConstBufferPacked createConstBuffer( @Cast("size_t") long sizeBytes, @Cast("Ogre::BufferType") int bufferType,
                                                      Pointer initialData, @Cast("bool") boolean keepAsShadow );





        public native void destroyConstBuffer( ConstBufferPacked constBuffer );
        public native TexBufferPacked createTexBuffer( @Cast("Ogre::PixelFormat") int pixelFormat, @Cast("size_t") long sizeBytes,
                                                  @Cast("Ogre::BufferType") int bufferType,
                                                  Pointer initialData, @Cast("bool") boolean keepAsShadow );





        public native void destroyTexBuffer( TexBufferPacked texBuffer );





        public native IndirectBufferPacked createIndirectBuffer( @Cast("size_t") long sizeBytes, @Cast("Ogre::BufferType") int bufferType,
                                                            Pointer initialData, @Cast("bool") boolean keepAsShadow );





        public native void destroyIndirectBuffer( IndirectBufferPacked indirectBuffer );
        public native VertexArrayObject createVertexArrayObject( @Cast("const Ogre::VertexBufferPackedVec*") @ByRef VertexBufferPackedPtrVectorRef vertexBuffers,
                                                            IndexBufferPacked indexBuffer,
                                                            @Cast("Ogre::v1::RenderOperation::OperationType") int opType );
        public native void destroyVertexArrayObject( VertexArrayObject vao );






        public native StagingBuffer createStagingBuffer( @Cast("size_t") long sizeBytes, @Cast("bool") boolean forUpload );
        public native StagingBuffer getStagingBuffer( @Cast("size_t") long minSizeBytes, @Cast("bool") boolean forUpload );

        public native @ByVal @Cast("Ogre::AsyncTicketPtr*") RealControllerFunctionSPtr createAsyncTicket( BufferPacked creator, StagingBuffer stagingBuffer,
                                                          @Cast("size_t") long elementStart, @Cast("size_t") long elementCount );

        public native void _beginFrame();
        public native void _update();

        public native void _notifyStagingBufferEnteredZeroRef( StagingBuffer stagingBuffer );
        public native void _notifyStagingBufferLeftZeroRef( StagingBuffer stagingBuffer );

        public native @Cast("Ogre::uint32") int getConstBufferAlignment();
        public native @Cast("Ogre::uint32") int getTexBufferAlignment();
        public native @Cast("size_t") long getConstBufferMaxSize();
        public native @Cast("size_t") long getTexBufferMaxSize();

        public native @Cast("bool") boolean supportsPersistentMapping();



        public native @Cast("bool") boolean supportsIndirectBuffers();

        public native Timer getTimer();

        public native @Cast("Ogre::uint32") int getFrameCount();
        public native void setDefaultStagingBufferlifetime( @Cast("Ogre::uint32") int lifetime, @Cast("Ogre::uint32") int unfencedTime );

        public native @Cast("Ogre::uint32") int getDefaultStagingBufferUnfencedTime();
        public native @Cast("Ogre::uint32") int getDefaultStagingBufferLifetime();

        public native @Cast("Ogre::uint8") byte _getDynamicBufferCurrentFrameNoWait();
        public native @Cast("Ogre::uint8") byte getDynamicBufferMultiplier();




        public native @Cast("Ogre::uint8") byte waitForTailFrameToFinish();
    }

    @Namespace("Ogre") @NoOffset public static class VertexArrayObject extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public VertexArrayObject(Pointer p) { super(p); }
    
        public VertexArrayObject( @Cast("Ogre::uint32") int vaoName, @Cast("Ogre::uint32") int renderQueueId,
                                   @Cast("const Ogre::VertexBufferPackedVec*") @ByRef VertexBufferPackedPtrVectorRef vertexBuffers,
                                   IndexBufferPacked indexBuffer,
                                   @Cast("Ogre::v1::RenderOperation::OperationType") int operationType ) { super((Pointer)null); allocate(vaoName, renderQueueId, vertexBuffers, indexBuffer, operationType); }
        private native void allocate( @Cast("Ogre::uint32") int vaoName, @Cast("Ogre::uint32") int renderQueueId,
                                   @Cast("const Ogre::VertexBufferPackedVec*") @ByRef VertexBufferPackedPtrVectorRef vertexBuffers,
                                   IndexBufferPacked indexBuffer,
                                   @Cast("Ogre::v1::RenderOperation::OperationType") int operationType );

        public native @Cast("Ogre::uint32") int getRenderQueueId();
        public native @Cast("Ogre::uint32") int getVaoName();

        public native @Cast("const Ogre::VertexBufferPackedVec*") @ByRef VertexBufferPackedPtrVectorRef getVertexBuffers();
        public native IndexBufferPacked getIndexBuffer();

        public native @Cast("Ogre::v1::RenderOperation::OperationType") int getOperationType();

        public native @Cast("Ogre::uint32") int getPrimitiveStart();
        public native @Cast("Ogre::uint32") int getPrimitiveCount();
        public native void setPrimitiveRange( @Cast("Ogre::uint32") int primStart, @Cast("Ogre::uint32") int primCount );
        public native @Const VertexElement2 findBySemantic( @Cast("Ogre::VertexElementSemantic") int semantic, @Cast("size_t*") @ByRef SizeTPointer outIndex,
                                                      @Cast("size_t*") @ByRef SizeTPointer outOffset );




        public native @ByVal @Cast("Ogre::VertexElement2VecVec*") VertexElement2VecVectorRef getVertexDeclaration();
        public native VertexArrayObject clone( VaoManager vaoManager, @Cast("Ogre::SharedVertexBufferMap*") VertexBufferPackedPtrSelfMap sharedBuffers,
                                          int vertexBufferType/*=-1*/, int indexBufferType/*=-1*/ );
        public native VertexArrayObject clone( VaoManager vaoManager, @Cast("Ogre::SharedVertexBufferMap*") VertexBufferPackedPtrSelfMap sharedBuffers );

        @NoOffset public static class ReadRequests extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public ReadRequests(Pointer p) { super(p); }
        
            public native @Cast("Ogre::VertexElementSemantic") int semantic(); public native ReadRequests semantic(int semantic);
            public native @Cast("Ogre::VertexElementType") int type(); public native ReadRequests type(int type);
            public native @ByRef @Cast("Ogre::AsyncTicketPtr*") RealControllerFunctionSPtr asyncTicket(); public native ReadRequests asyncTicket(RealControllerFunctionSPtr asyncTicket);

            public native @Cast("char const*") BytePointer data(); public native ReadRequests data(BytePointer data);
            public native @Cast("size_t") long offset(); public native ReadRequests offset(long offset);
            public native @Const({false, true}) VertexBufferPacked vertexBuffer(); public native ReadRequests vertexBuffer(VertexBufferPacked vertexBuffer);

            public ReadRequests( @Cast("Ogre::VertexElementSemantic") int _semantic ) { super((Pointer)null); allocate(_semantic); }
            private native void allocate( @Cast("Ogre::VertexElementSemantic") int _semantic );
        }
        public native void readRequests( @Cast("Ogre::VertexArrayObject::ReadRequestsArray*") @ByRef RealFastArrayRef requests );


        public static native void mapAsyncTickets( @Cast("Ogre::VertexArrayObject::ReadRequestsArray*") @ByRef RealFastArrayRef tickets );


        public static native void unmapAsyncTickets( @Cast("Ogre::VertexArrayObject::ReadRequestsArray*") @ByRef RealFastArrayRef tickets );



        public static native @ByRef VertexBufferPacked msDummyVertexBuffer(); public static native void msDummyVertexBuffer(VertexBufferPacked msDummyVertexBuffer);
    }




    /** enum Ogre::SceneMemoryMgrTypes */
    ;
    @Namespace("Ogre") @NoOffset public static class NodeMemoryManager extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public NodeMemoryManager(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public NodeMemoryManager(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public NodeMemoryManager position(long position) {
            return (NodeMemoryManager)super.position(position);
        }
    
        public NodeMemoryManager() { super((Pointer)null); allocate(); }
        private native void allocate();


        public native void _setTwin( @Cast("Ogre::SceneMemoryMgrTypes") int memoryManagerType, NodeMemoryManager twinMemoryManager );

        public native SceneNode _getDummyNode();


        public native NodeMemoryManager getTwin();
        public native @Cast("Ogre::SceneMemoryMgrTypes") int getMemoryManagerType();







        public native void nodeCreated( @ByRef Transform outTransform, @Cast("size_t") long depth );
        public native void nodeAttached( @ByRef Transform outTransform, @Cast("size_t") long depth );
        public native void nodeDettached( @ByRef Transform outTransform, @Cast("size_t") long depth );







        public native void nodeDestroyed( @ByRef Transform outTransform, @Cast("size_t") long depth );
        public native void nodeMoved( @ByRef Transform inOutTransform, @Cast("size_t") long oldDepth, @Cast("size_t") long newDepth );
        public native void migrateTo( @ByRef Transform inOutTransform, @Cast("size_t") long depth,
                                NodeMemoryManager dstNodeMemoryManager );
        public native void migrateTo( @ByRef Transform inOutTransform, @Cast("size_t") long oldDepth, @Cast("size_t") long newDepth,
                                NodeMemoryManager dstNodeMemoryManager );






        public native void migrateToAndAttach( @ByRef Transform inOutTransform, @Cast("size_t") long depth,
                                         NodeMemoryManager dstNodeMemoryManager );







        public native void migrateToAndDetach( @ByRef Transform inOutTransform, @Cast("size_t") long depth,
                                         NodeMemoryManager dstNodeMemoryManager );






        public native @Cast("size_t") long getNumDepths();
        public native @Cast("size_t") long getFirstNode( @ByRef Transform outTransform, @Cast("size_t") long depth );


        public native void buildDiffList( @Cast("Ogre::ArrayMemoryManager::ManagerType") int managerType, @Cast("Ogre::uint16") short level,
                                            @Cast("const Ogre::MemoryPoolVec*") @ByRef CharPtrVectorRef basePtrs,
                                            @Cast("Ogre::ArrayMemoryManager::PtrdiffVec*") @ByRef CharPtrVectorRef outDiffsList );
        public native void applyRebase( @Cast("Ogre::ArrayMemoryManager::ManagerType") int managerType, @Cast("Ogre::uint16") short level,
                                            @Cast("const Ogre::MemoryPoolVec*") @ByRef CharPtrVectorRef newBasePtrs,
                                            @Cast("const Ogre::ArrayMemoryManager::PtrdiffVec*") @ByRef CharPtrVectorRef diffsList );
        public native void performCleanup( @Cast("Ogre::ArrayMemoryManager::ManagerType") int managerType, @Cast("Ogre::uint16") short level,
                                             @Cast("const Ogre::MemoryPoolVec*") @ByRef CharPtrVectorRef basePtrs, @Cast("size_t const*") SizeTPointer elementsMemSizes,
                                             @Cast("size_t") long startInstance, @Cast("size_t") long diffInstances );
    }




    @Namespace("Ogre") @NoOffset public static class BoneArrayMemoryManager extends ArrayMemoryManager {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public BoneArrayMemoryManager(Pointer p) { super(p); }
    
        /** enum Ogre::BoneArrayMemoryManager::MemoryTypes */
        public static final int
            Owner = 0,
            Position = 1,
            Orientation = 2,
            Scale = 3,
            ParentMat = 4,
            ParentNode = 5,
            WorldMat = 6,
            FinalMat = 7,
            InheritOrientation = 8,
            InheritScale = 9,
            NumMemoryTypes = 10;

        @MemberGetter public static native @Cast("const size_t") long ElementsMemSize(int i);
        @MemberGetter public static native @Cast("const size_t*") SizeTPointer ElementsMemSize();
        @MemberGetter public static native CleanupRoutines BoneCleanupRoutines(int i);
        @MemberGetter public static native @Const CleanupRoutines BoneCleanupRoutines();


        public BoneArrayMemoryManager(@Cast("Ogre::uint16") short depthLevel, @Cast("size_t") long hintMaxNodes,
                                        @Cast("size_t") long cleanupThreshold/*=100*/,
                                        @Cast("size_t") long maxHardLimit/*=MAX_MEMORY_SLOTS*/,
                                        RebaseListener rebaseListener/*=0*/ ) { super((Pointer)null); allocate(depthLevel, hintMaxNodes, cleanupThreshold, maxHardLimit, rebaseListener); }
        private native void allocate(@Cast("Ogre::uint16") short depthLevel, @Cast("size_t") long hintMaxNodes,
                                        @Cast("size_t") long cleanupThreshold/*=100*/,
                                        @Cast("size_t") long maxHardLimit/*=MAX_MEMORY_SLOTS*/,
                                        RebaseListener rebaseListener/*=0*/ );
        public BoneArrayMemoryManager(@Cast("Ogre::uint16") short depthLevel, @Cast("size_t") long hintMaxNodes ) { super((Pointer)null); allocate(depthLevel, hintMaxNodes); }
        private native void allocate(@Cast("Ogre::uint16") short depthLevel, @Cast("size_t") long hintMaxNodes );






        public native void createNewNode( @ByRef BoneTransform outTransform );







        public native void destroyNode( @ByRef BoneTransform inOutTransform );
        public native @Cast("size_t") long getFirstNode( @ByRef BoneTransform outTransform );
    }




    @Namespace("Ogre") @NoOffset public static class BoneMemoryManager extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public BoneMemoryManager(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public BoneMemoryManager(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public BoneMemoryManager position(long position) {
            return (BoneMemoryManager)super.position(position);
        }
    
        public BoneMemoryManager() { super((Pointer)null); allocate(); }
        private native void allocate();




        public native void _growToDepth( @Cast("const vector<size_t>::type*") @ByRef SizeVectorRef bonesPerDepth );







        public native void nodeCreated( @ByRef BoneTransform outTransform, @Cast("size_t") long depth );
        public native void nodeAttached( @ByRef BoneTransform outTransform, @Cast("size_t") long depth );
        public native void nodeDettached( @ByRef BoneTransform outTransform, @Cast("size_t") long depth );







        public native void nodeDestroyed( @ByRef BoneTransform outTransform, @Cast("size_t") long depth );
        public native void nodeMoved( @ByRef BoneTransform inOutTransform, @Cast("size_t") long oldDepth, @Cast("size_t") long newDepth );
        public native void migrateTo( @ByRef BoneTransform inOutTransform, @Cast("size_t") long depth,
                                BoneMemoryManager dstBoneMemoryManager );






        public native @Cast("size_t") long getNumDepths();
        public native @Cast("size_t") long getFirstNode( @ByRef BoneTransform outTransform, @Cast("size_t") long depth );

        public native void setBoneRebaseListener( BySkeletonDef l );


        public native void buildDiffList( @Cast("Ogre::ArrayMemoryManager::ManagerType") int managerType, @Cast("Ogre::uint16") short level,
                                            @Cast("const Ogre::MemoryPoolVec*") @ByRef CharPtrVectorRef basePtrs,
                                            @Cast("Ogre::ArrayMemoryManager::PtrdiffVec*") @ByRef CharPtrVectorRef outDiffsList );
        public native void applyRebase( @Cast("Ogre::ArrayMemoryManager::ManagerType") int managerType, @Cast("Ogre::uint16") short level,
                                            @Cast("const Ogre::MemoryPoolVec*") @ByRef CharPtrVectorRef newBasePtrs,
                                            @Cast("const Ogre::ArrayMemoryManager::PtrdiffVec*") @ByRef CharPtrVectorRef diffsList );
        public native void performCleanup( @Cast("Ogre::ArrayMemoryManager::ManagerType") int managerType, @Cast("Ogre::uint16") short level,
                                             @Cast("const Ogre::MemoryPoolVec*") @ByRef CharPtrVectorRef basePtrs, @Cast("size_t const*") SizeTPointer elementsMemSizes,
                                             @Cast("size_t") long startInstance, @Cast("size_t") long diffInstances );
    }











    @Namespace("Ogre") @NoOffset public static class BySkeletonDef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public BySkeletonDef(Pointer p) { super(p); }
    
        public native @Const({false, true}) SkeletonDef skeletonDef(); public native BySkeletonDef skeletonDef(SkeletonDef skeletonDef);
        public native @ByRef IdString skeletonDefName(); public native BySkeletonDef skeletonDefName(IdString skeletonDefName);
        public native @ByRef BoneMemoryManager boneMemoryManager(); public native BySkeletonDef boneMemoryManager(BoneMemoryManager boneMemoryManager);





        public native @ByRef @Cast("Ogre::FastArray<Ogre::SkeletonInstance*>*") SkeletonInstancePtrFastArrayRef skeletons(); public native BySkeletonDef skeletons(SkeletonInstancePtrFastArrayRef skeletons);





        public native @ByRef @Cast("Ogre::FastArray<size_t>*") SizeFastArrayRef threadStarts(); public native BySkeletonDef threadStarts(SizeFastArrayRef threadStarts);

        public BySkeletonDef( @Const SkeletonDef skeletonDef, @Cast("size_t") long threadCount ) { super((Pointer)null); allocate(skeletonDef, threadCount); }
        private native void allocate( @Const SkeletonDef skeletonDef, @Cast("size_t") long threadCount );

        public native void initializeMemoryManager();

        public native void updateThreadStarts();
        public native void _updateBoneStartTransforms();

        public native @Cast("bool") @Name("operator ==") boolean equals( @ByVal IdString name );
    }
    @Namespace("Ogre") public static class SkeletonAnimManager extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public SkeletonAnimManager() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public SkeletonAnimManager(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SkeletonAnimManager(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public SkeletonAnimManager position(long position) {
            return (SkeletonAnimManager)super.position(position);
        }
    
        public native @ByRef @Cast("Ogre::SkeletonAnimManager::BySkeletonDefList*") BySkeletonDefListRef bySkeletonDefs(); public native SkeletonAnimManager bySkeletonDefs(BySkeletonDefListRef bySkeletonDefs);


        public native SkeletonInstance createSkeletonInstance( @Const SkeletonDef skeletonDef,
                                                            @Cast("size_t") long numWorkerThreads );
        public native void destroySkeletonInstance( SkeletonInstance skeletonInstance );
    }




    @Namespace("Ogre") @Opaque public static class CompositorNodeDef extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public CompositorNodeDef() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public CompositorNodeDef(Pointer p) { super(p); }
    }







    /** enum Ogre::CompositorPassType */
    public static final int
        PASS_INVALID = 0,
        PASS_SCENE = 1,
        PASS_QUAD = 2,
        PASS_CLEAR = 3,
        PASS_STENCIL = 4,
        PASS_RESOLVE = 5,
        PASS_DEPTHCOPY = 6,
        PASS_UAV = 7,
        PASS_MIPMAP = 8,
        PASS_CUSTOM = 9;
    @Namespace("Ogre") @NoOffset public static class CompositorPassDef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public CompositorPassDef(Pointer p) { super(p); }
    

        public native float mVpLeft(); public native CompositorPassDef mVpLeft(float mVpLeft);
        public native float mVpTop(); public native CompositorPassDef mVpTop(float mVpTop);
        public native float mVpWidth(); public native CompositorPassDef mVpWidth(float mVpWidth);
        public native float mVpHeight(); public native CompositorPassDef mVpHeight(float mVpHeight);
        public native float mVpScissorLeft(); public native CompositorPassDef mVpScissorLeft(float mVpScissorLeft);
        public native float mVpScissorTop(); public native CompositorPassDef mVpScissorTop(float mVpScissorTop);
        public native float mVpScissorWidth(); public native CompositorPassDef mVpScissorWidth(float mVpScissorWidth);
        public native float mVpScissorHeight(); public native CompositorPassDef mVpScissorHeight(float mVpScissorHeight);


        public native @Cast("Ogre::uint32") int mShadowMapIdx(); public native CompositorPassDef mShadowMapIdx(int mShadowMapIdx);


        public native @Cast("Ogre::uint32") int mNumInitialPasses(); public native CompositorPassDef mNumInitialPasses(int mNumInitialPasses);


        public native @Cast("Ogre::uint32") int mIdentifier(); public native CompositorPassDef mIdentifier(int mIdentifier);



        public native @Cast("bool") boolean mBeginRtUpdate(); public native CompositorPassDef mBeginRtUpdate(boolean mBeginRtUpdate);

        public native @Cast("bool") boolean mEndRtUpdate(); public native CompositorPassDef mEndRtUpdate(boolean mEndRtUpdate);





        public native @Cast("bool") boolean mColourWrite(); public native CompositorPassDef mColourWrite(boolean mColourWrite);




        public native @Cast("bool") boolean mIncludeOverlays(); public native CompositorPassDef mIncludeOverlays(boolean mIncludeOverlays);

        public native @Cast("Ogre::uint8") byte mExecutionMask(); public native CompositorPassDef mExecutionMask(byte mExecutionMask);
        public native @Cast("Ogre::uint8") byte mViewportModifierMask(); public native CompositorPassDef mViewportModifierMask(byte mViewportModifierMask);

        public native @ByRef @Cast("Ogre::IdStringVec*") IdStringVectorRef mExposedTextures(); public native CompositorPassDef mExposedTextures(IdStringVectorRef mExposedTextures);

        @NoOffset public static class UavDependency extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public UavDependency(Pointer p) { super(p); }
        


            public native @Cast("Ogre::uint32") int uavSlot(); public native UavDependency uavSlot(int uavSlot);





            public native @Cast("Ogre::ResourceAccess::ResourceAccess") int access(); public native UavDependency access(int access);
            public native @Cast("bool") boolean allowWriteAfterWrite(); public native UavDependency allowWriteAfterWrite(boolean allowWriteAfterWrite);

            public UavDependency( @Cast("Ogre::uint32") int _uavSlot, @Cast("Ogre::ResourceAccess::ResourceAccess") int _access,
                                       @Cast("bool") boolean _allowWriteAfterWrite ) { super((Pointer)null); allocate(_uavSlot, _access, _allowWriteAfterWrite); }
            private native void allocate( @Cast("Ogre::uint32") int _uavSlot, @Cast("Ogre::ResourceAccess::ResourceAccess") int _access,
                                       @Cast("bool") boolean _allowWriteAfterWrite );
        }
        public native @ByRef @Cast("Ogre::CompositorPassDef::UavDependencyVec*") UavDependencyVectorRef mUavDependencies(); public native CompositorPassDef mUavDependencies(UavDependencyVectorRef mUavDependencies);
        public CompositorPassDef( @Cast("Ogre::CompositorPassType") int passType, @Cast("Ogre::uint32") int rtIndex ) { super((Pointer)null); allocate(passType, rtIndex); }
        private native void allocate( @Cast("Ogre::CompositorPassType") int passType, @Cast("Ogre::uint32") int rtIndex );

        public native @Cast("Ogre::CompositorPassType") int getType();
        public native @Cast("Ogre::uint32") int getRtIndex();
    }

    @Namespace("Ogre") @NoOffset public static class CompositorTargetDef extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public CompositorTargetDef(Pointer p) { super(p); }
    
        public CompositorTargetDef( @ByVal IdString renderTargetName, @Cast("Ogre::uint32") int rtIndex,
                                     CompositorNodeDef parentNodeDef ) { super((Pointer)null); allocate(renderTargetName, rtIndex, parentNodeDef); }
        private native void allocate( @ByVal IdString renderTargetName, @Cast("Ogre::uint32") int rtIndex,
                                     CompositorNodeDef parentNodeDef );

        public native @ByVal IdString getRenderTargetName();







        public native void setNumPasses( @Cast("size_t") long numPasses );

        public native CompositorPassDef addPass( @Cast("Ogre::CompositorPassType") int passType, @ByVal(nullValue = "Ogre::IdString()") IdString customId );
        public native CompositorPassDef addPass( @Cast("Ogre::CompositorPassType") int passType );

        public native @Cast("const Ogre::CompositorPassDefVec*") @ByRef CompositorPassDefPtrVectorRef getCompositorPasses();


        public native @Cast("Ogre::CompositorPassDefVec*") @ByRef CompositorPassDefPtrVectorRef getCompositorPassesNonConst();
    }




    @Namespace("Ogre") @Opaque public static class CompositorChannel extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public CompositorChannel() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public CompositorChannel(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @Opaque public static class CompositorNode extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public CompositorNode() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public CompositorNode(Pointer p) { super(p); }
    }

    @Namespace("Ogre") @NoOffset public static class CompositorTexture extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public CompositorTexture(Pointer p) { super(p); }
    
        public native @ByRef IdString name(); public native CompositorTexture name(IdString name);
        public native @Cast("Ogre::TextureVec const*") TexturePtrVectorRef textures(); public native CompositorTexture textures(TexturePtrVectorRef textures);

        public CompositorTexture( @ByVal IdString _name, @Cast("const Ogre::TextureVec*") TexturePtrVectorRef _textures ) { super((Pointer)null); allocate(_name, _textures); }
        private native void allocate( @ByVal IdString _name, @Cast("const Ogre::TextureVec*") TexturePtrVectorRef _textures );

        public native @Cast("bool") @Name("operator ==") boolean equals( @ByVal IdString right );
    }

    @Namespace("Ogre") public static class BoundUav extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public BoundUav() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public BoundUav(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public BoundUav(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public BoundUav position(long position) {
            return (BoundUav)super.position(position);
        }
    
        public native RenderTarget renderTarget(); public native BoundUav renderTarget(RenderTarget renderTarget);
        public native @Cast("Ogre::ResourceAccess::ResourceAccess") int boundAccess(); public native BoundUav boundAccess(int boundAccess);
    }
    @Namespace("Ogre") @NoOffset public static class CompositorPass extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public CompositorPass(Pointer p) { super(p); }
    

        public native void execute( @Const Camera lodCameraconst );

        public native void addResourceTransition( @ByVal iterator currentLayout,
                                            @Cast("Ogre::ResourceLayout::Layout") int newLayout,
                                            @Cast("Ogre::uint32") int readBarrierBits );
        public native void _placeBarriersAndEmulateUavExecution( BoundUav boundUavs,
                                                                   @Cast("Ogre::ResourceAccessMap*") @ByRef ResourceAccessRenderTargetPtrRef uavsAccess,
                                                                   @Cast("Ogre::ResourceLayoutMap*") @ByRef LayoutRenderTargetPtrRef resourcesLayout );


        public native void notifyRecreated( @Const @ByRef CompositorChannel oldChannel,
                                                @Const @ByRef CompositorChannel newChannel );


        public native void notifyDestroyed( @Const @ByRef CompositorChannel channel );


        public native void notifyCleared();

        public native void resetNumPassesLeft();

        public native @Cast("Ogre::CompositorPassType") int getType();

        public native Viewport getViewport();

        public native RenderTarget getRenderTarget();

        public native @Const CompositorPassDef getDefinition();

  public native @Const CompositorNode getParentNode();

        public native @Cast("const Ogre::CompositorTextureVec*") @ByRef CompositorTextureVectorRef getTextureDependencies();
    }




    @Namespace("Ogre") @NoOffset public static class ThreadHandle extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ThreadHandle(Pointer p) { super(p); }
    
        public ThreadHandle( @Cast("size_t") long threadIdx, Pointer userParam ) { super((Pointer)null); allocate(threadIdx, userParam); }
        private native void allocate( @Cast("size_t") long threadIdx, Pointer userParam );

        public native @Cast("size_t") long getThreadIdx();
        public native Pointer getUserParam();
        public native void _setOsHandle( @ByRef pthread_t handle );

        public native @ByVal pthread_t _getOsHandle();

    }




    public static class THREAD_ENTRY_POINT extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    THREAD_ENTRY_POINT(Pointer p) { super(p); }
        protected THREAD_ENTRY_POINT() { allocate(); }
        private native void allocate();
        public native Pointer call( Pointer lpThreadParameter );
    }


    @Namespace("Ogre") public static class Threads extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public Threads() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Threads(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Threads(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public Threads position(long position) {
            return (Threads)super.position(position);
        }
    
        public static native @ByVal @Cast("Ogre::ThreadHandlePtr*") RealControllerFunctionSPtr CreateThread( THREAD_ENTRY_POINT entryPoint,
                                                     @Cast("size_t") long threadIdx, Pointer param );
        public static native void WaitForThreads( @Cast("size_t") long numThreadHandles, @Cast("const Ogre::ThreadHandlePtr*") RealControllerFunctionSPtr threadHandles );
        public static native void WaitForThreads( @Cast("const Ogre::ThreadHandleVec*") @ByRef ThreadHandlePtrVectorRef threadHandles );



        public static native void Sleep( @Cast("Ogre::uint32") int milliseconds );
    }

    @Namespace("Ogre") public static class ViewPoint extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public ViewPoint() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public ViewPoint(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ViewPoint(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public ViewPoint position(long position) {
            return (ViewPoint)super.position(position);
        }
    
        public native @ByRef @Name("position") Vector3 _position(); public native ViewPoint _position(Vector3 _position);
        public native @ByRef Quaternion orientation(); public native ViewPoint orientation(Quaternion orientation);
    }
    /** enum Ogre::InstancingThreadedCullingMethod */
    public static final int
        INSTANCING_CULLING_SINGLETHREAD = 0,
        INSTANCING_CULLING_THREADED = 1;
    @Namespace("Ogre") @Opaque public static class UniformScalableTask extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public UniformScalableTask() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public UniformScalableTask(Pointer p) { super(p); }
    }
        @Namespace("Ogre::v1") @Opaque public static class Rectangle2D extends Pointer {
            /** Empty constructor. Calls {@code super((Pointer)null)}. */
            public Rectangle2D() { super((Pointer)null); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Rectangle2D(Pointer p) { super(p); }
        }
    


    @Namespace("Ogre") @NoOffset public static class CullFrustumRequest extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public CullFrustumRequest(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public CullFrustumRequest(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public CullFrustumRequest position(long position) {
            return (CullFrustumRequest)super.position(position);
        }
    

        public native @Cast("Ogre::uint8") byte firstRq(); public native CullFrustumRequest firstRq(byte firstRq);

        public native @Cast("Ogre::uint8") byte lastRq(); public native CullFrustumRequest lastRq(byte lastRq);

        public native @Cast("bool") boolean casterPass(); public native CullFrustumRequest casterPass(boolean casterPass);

        public native @Cast("bool") boolean addToRenderQueue(); public native CullFrustumRequest addToRenderQueue(boolean addToRenderQueue);




        public native @Cast("Ogre::CullFrustumRequest::ObjectMemoryManagerVec const*") ObjectMemoryManagerPtrVectorRef objectMemManager(); public native CullFrustumRequest objectMemManager(ObjectMemoryManagerPtrVectorRef objectMemManager);

        public native @Const({false, true}) Camera camera(); public native CullFrustumRequest camera(Camera camera);

        public native @Const({false, true}) Camera lodCamera(); public native CullFrustumRequest lodCamera(Camera lodCamera);

        public CullFrustumRequest() { super((Pointer)null); allocate(); }
        private native void allocate();
        public CullFrustumRequest( @Cast("Ogre::uint8") byte _firstRq, @Cast("Ogre::uint8") byte _lastRq, @Cast("bool") boolean _casterPass,
                                    @Cast("bool") boolean _addToRenderQueue,
                                    @Cast("const Ogre::CullFrustumRequest::ObjectMemoryManagerVec*") ObjectMemoryManagerPtrVectorRef _objectMemManager,
                                    @Const Camera _camera, @Const Camera _lodCamera ) { super((Pointer)null); allocate(_firstRq, _lastRq, _casterPass, _addToRenderQueue, _objectMemManager, _camera, _lodCamera); }
        private native void allocate( @Cast("Ogre::uint8") byte _firstRq, @Cast("Ogre::uint8") byte _lastRq, @Cast("bool") boolean _casterPass,
                                    @Cast("bool") boolean _addToRenderQueue,
                                    @Cast("const Ogre::CullFrustumRequest::ObjectMemoryManagerVec*") ObjectMemoryManagerPtrVectorRef _objectMemManager,
                                    @Const Camera _camera, @Const Camera _lodCamera );
    }

    @Namespace("Ogre") @NoOffset public static class UpdateLodRequest extends CullFrustumRequest {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public UpdateLodRequest(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public UpdateLodRequest(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public UpdateLodRequest position(long position) {
            return (UpdateLodRequest)super.position(position);
        }
    
        public native double lodBias(); public native UpdateLodRequest lodBias(double lodBias);

        public UpdateLodRequest() { super((Pointer)null); allocate(); }
        private native void allocate();
        public UpdateLodRequest( @Cast("Ogre::uint8") byte _firstRq, @Cast("Ogre::uint8") byte _lastRq,
                                    @Const ObjectMemoryManagerVec _objectMemManager,
                                    @Const Camera _camera, @Const Camera _lodCamera, double _lodBias ) { super((Pointer)null); allocate(_firstRq, _lastRq, _objectMemManager, _camera, _lodCamera, _lodBias); }
        private native void allocate( @Cast("Ogre::uint8") byte _firstRq, @Cast("Ogre::uint8") byte _lastRq,
                                    @Const ObjectMemoryManagerVec _objectMemManager,
                                    @Const Camera _camera, @Const Camera _lodCamera, double _lodBias );
    }

    @Namespace("Ogre") @NoOffset public static class UpdateTransformRequest extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public UpdateTransformRequest(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public UpdateTransformRequest(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public UpdateTransformRequest position(long position) {
            return (UpdateTransformRequest)super.position(position);
        }
    
        public native @ByRef Transform t(); public native UpdateTransformRequest t(Transform t);

        public native @Cast("size_t") long numNodesPerThread(); public native UpdateTransformRequest numNodesPerThread(long numNodesPerThread);
        public native @Cast("size_t") long numTotalNodes(); public native UpdateTransformRequest numTotalNodes(long numTotalNodes);

        public UpdateTransformRequest() { super((Pointer)null); allocate(); }
        private native void allocate();

        public UpdateTransformRequest( @Const @ByRef Transform _t, @Cast("size_t") long _numNodesPerThread, @Cast("size_t") long _numTotalNodes ) { super((Pointer)null); allocate(_t, _numNodesPerThread, _numTotalNodes); }
        private native void allocate( @Const @ByRef Transform _t, @Cast("size_t") long _numNodesPerThread, @Cast("size_t") long _numTotalNodes );
    }

    @Namespace("Ogre") @NoOffset public static class InstanceBatchCullRequest extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public InstanceBatchCullRequest(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public InstanceBatchCullRequest(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public InstanceBatchCullRequest position(long position) {
            return (InstanceBatchCullRequest)super.position(position);
        }
    
        public native @Const({false, true}) Frustum frustum(); public native InstanceBatchCullRequest frustum(Frustum frustum);
        public native @Const({false, true}) Camera lodCamera(); public native InstanceBatchCullRequest lodCamera(Camera lodCamera);
        public native @Cast("Ogre::uint32") int combinedVisibilityFlags(); public native InstanceBatchCullRequest combinedVisibilityFlags(int combinedVisibilityFlags);
        public InstanceBatchCullRequest() { super((Pointer)null); allocate(); }
        private native void allocate();
        public InstanceBatchCullRequest( @Const Frustum _frustum, @Const Camera _lodCamera,
                                          @Cast("Ogre::uint32") int _combinedVisibilityFlags ) { super((Pointer)null); allocate(_frustum, _lodCamera, _combinedVisibilityFlags); }
        private native void allocate( @Const Frustum _frustum, @Const Camera _lodCamera,
                                          @Cast("Ogre::uint32") int _combinedVisibilityFlags );
    }

    @Namespace("Ogre") @NoOffset public static class BuildLightListRequest extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public BuildLightListRequest(Pointer p) { super(p); }
    
        public native @Cast("size_t") long startLightIdx(); public native BuildLightListRequest startLightIdx(long startLightIdx);

        public BuildLightListRequest() { super((Pointer)null); allocate(); }
        private native void allocate();
        public BuildLightListRequest( @Cast("size_t") long _startLightIdx ) { super((Pointer)null); allocate(_startLightIdx); }
        private native void allocate( @Cast("size_t") long _startLightIdx );
    }
    @Namespace("Ogre") @NoOffset public static class SceneManager extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SceneManager(Pointer p) { super(p); }
    

        public static native @Cast("Ogre::uint32") int QUERY_ENTITY_DEFAULT_MASK(); public static native void QUERY_ENTITY_DEFAULT_MASK(int QUERY_ENTITY_DEFAULT_MASK);

        public static native @Cast("Ogre::uint32") int QUERY_FX_DEFAULT_MASK(); public static native void QUERY_FX_DEFAULT_MASK(int QUERY_FX_DEFAULT_MASK);

        public static native @Cast("Ogre::uint32") int QUERY_STATICGEOMETRY_DEFAULT_MASK(); public static native void QUERY_STATICGEOMETRY_DEFAULT_MASK(int QUERY_STATICGEOMETRY_DEFAULT_MASK);

        public static native @Cast("Ogre::uint32") int QUERY_LIGHT_DEFAULT_MASK(); public static native void QUERY_LIGHT_DEFAULT_MASK(int QUERY_LIGHT_DEFAULT_MASK);

        public static native @Cast("Ogre::uint32") int QUERY_FRUSTUM_DEFAULT_MASK(); public static native void QUERY_FRUSTUM_DEFAULT_MASK(int QUERY_FRUSTUM_DEFAULT_MASK);


        /** enum Ogre::SceneManager::IlluminationRenderStage */
        public static final int

            IRS_NONE = 0,

            IRS_RENDER_TO_TEXTURE = 1;

        public static class SkyDomeGenParameters extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public SkyDomeGenParameters() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public SkyDomeGenParameters(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public SkyDomeGenParameters(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public SkyDomeGenParameters position(long position) {
                return (SkyDomeGenParameters)super.position(position);
            }
        
            public native double skyDomeCurvature(); public native SkyDomeGenParameters skyDomeCurvature(double skyDomeCurvature);
            public native double skyDomeTiling(); public native SkyDomeGenParameters skyDomeTiling(double skyDomeTiling);
            public native double skyDomeDistance(); public native SkyDomeGenParameters skyDomeDistance(double skyDomeDistance);
            public native int skyDomeXSegments(); public native SkyDomeGenParameters skyDomeXSegments(int skyDomeXSegments);
            public native int skyDomeYSegments(); public native SkyDomeGenParameters skyDomeYSegments(int skyDomeYSegments);
            public native int skyDomeYSegments_keep(); public native SkyDomeGenParameters skyDomeYSegments_keep(int skyDomeYSegments_keep);
        }

        public static class SkyPlaneGenParameters extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public SkyPlaneGenParameters() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public SkyPlaneGenParameters(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public SkyPlaneGenParameters(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public SkyPlaneGenParameters position(long position) {
                return (SkyPlaneGenParameters)super.position(position);
            }
        
            public native double skyPlaneScale(); public native SkyPlaneGenParameters skyPlaneScale(double skyPlaneScale);
            public native double skyPlaneTiling(); public native SkyPlaneGenParameters skyPlaneTiling(double skyPlaneTiling);
            public native double skyPlaneBow(); public native SkyPlaneGenParameters skyPlaneBow(double skyPlaneBow);
            public native int skyPlaneXSegments(); public native SkyPlaneGenParameters skyPlaneXSegments(int skyPlaneXSegments);
            public native int skyPlaneYSegments(); public native SkyPlaneGenParameters skyPlaneYSegments(int skyPlaneYSegments);
        }

        public static class SkyBoxGenParameters extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public SkyBoxGenParameters() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public SkyBoxGenParameters(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public SkyBoxGenParameters(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public SkyBoxGenParameters position(long position) {
                return (SkyBoxGenParameters)super.position(position);
            }
        
            public native double skyBoxDistance(); public native SkyBoxGenParameters skyBoxDistance(double skyBoxDistance);
        }




        public static class Listener extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Listener(Pointer p) { super(p); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public Listener(long size) { super((Pointer)null); allocateArray(size); }
            private native void allocateArray(long size);
            @Override public Listener position(long position) {
                return (Listener)super.position(position);
            }
        
            public Listener() { super((Pointer)null); allocate(); }
            private native void allocate();
            public native void preFindVisibleObjects(SceneManager source,
                            @Cast("Ogre::SceneManager::IlluminationRenderStage") int irs, Viewport v);
            public native void postFindVisibleObjects(SceneManager source,
                            @Cast("Ogre::SceneManager::IlluminationRenderStage") int irs, Viewport v);
            public native void shadowTexturesUpdated(@Cast("size_t") long numberOfShadowTextures);
            public native void shadowTextureCasterPreViewProj( @Const Light light,
                            Camera camera, @Cast("size_t") long iteration);
            public native @Cast("bool") boolean sortLightsAffectingFrustum(@Cast("Ogre::LightList*") @ByRef HashedVector lightList);


            public native void sceneManagerDestroyed(SceneManager source);
        }


        public static class RenderContext extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public RenderContext() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public RenderContext(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public RenderContext(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public RenderContext position(long position) {
                return (RenderContext)super.position(position);
            }
        
            public native RenderQueue renderQueue(); public native RenderContext renderQueue(RenderQueue renderQueue);
            public native Viewport viewport(); public native RenderContext viewport(Viewport viewport);
            public native Camera camera(); public native RenderContext camera(Camera camera);
            public native RenderSystem.RenderSystemContext rsContext(); public native RenderContext rsContext(RenderSystem.RenderSystemContext rsContext);
        }




        public native RenderContext _pauseRendering();



        public native void _resumeRendering(RenderContext context);
               


        public native @Const @ByRef String getName();







        public native @Const @ByRef String getTypeName();

        public native @Cast("size_t") long getNumWorkerThreads();
        public native Camera createCamera(@Const @ByRef String name, @Cast("bool") boolean notShadowCaster/*=true*/, @Cast("bool") boolean forCubemapping/*=false*/);
        public native Camera createCamera(@Const @ByRef String name);







        public native Camera findCamera( @ByVal IdString name );







        public native Camera findCameraNoThrow( @ByVal IdString name );
        public native void destroyCamera(Camera cam);







        public native void destroyAllCameras();
        public native Light createLight();


        public native void clearFrameData();

        public native @Const @ByRef LightListInfo getGlobalLightList();



        public native @Cast("const Ogre::PlaneList*") @ByRef PlaneVectorRef getLightClippingPlanes(@Const Light l);



        public native @Const @ByRef RealRect getLightScissorRect(@Const Light l, @Const Camera cam);





        public native void destroyLight(Light light);


        public native void destroyAllLights();


        public native TagPoint _createTagPoint( SceneNode parent, NodeMemoryManager nodeMemoryManager );



        public native TagPoint createTagPoint();






        public native SceneNode _createSceneNode( SceneNode parent, NodeMemoryManager nodeMemoryManager );
        public native SceneNode createSceneNode( @Cast("Ogre::SceneMemoryMgrTypes") int sceneType/*=Ogre::SCENE_DYNAMIC*/ );
        public native SceneNode createSceneNode( );







        public native void destroySceneNode(SceneNode sn);
        public native SceneNode getRootSceneNode( @Cast("Ogre::SceneMemoryMgrTypes") int sceneType/*=Ogre::SCENE_DYNAMIC*/ );
        public native SceneNode getRootSceneNode( );







                   public native SceneNode getSceneNode( @Cast("Ogre::IdType") int id );




        public native void registerSceneNodeListener( SceneNode sceneNode );



        public native void unregisterSceneNodeListener( SceneNode sceneNode );


        public native RenderQueue getRenderQueue();
        public native void setForward3D( @Cast("bool") boolean bEnable, @Cast("Ogre::uint32") int width, @Cast("Ogre::uint32") int height, @Cast("Ogre::uint32") int numSlices,
                                   @Cast("Ogre::uint32") int lightsPerCell, float minDistance, float maxDistance );

        public native Forward3D getForward3D();

        public native @ByRef NodeMemoryManager _getNodeMemoryManager(@Cast("Ogre::SceneMemoryMgrTypes") int sceneType);
        public native @ByRef NodeMemoryManager _getTagPointNodeMemoryManager();







        public native @ByRef ObjectMemoryManager _getEntityMemoryManager(@Cast("Ogre::SceneMemoryMgrTypes") int sceneType);






        public native Item createItem( @Const @ByRef String meshName,
                                          @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME)") String groupName,
                                          @Cast("Ogre::SceneMemoryMgrTypes") int sceneType/*=Ogre::SCENE_DYNAMIC*/ );
        public native Item createItem( @Const @ByRef String meshName );





        public native Item createItem( @Cast("const Ogre::MeshPtr*") @ByRef RealControllerFunctionSPtr pMesh,
                                          @Cast("Ogre::SceneMemoryMgrTypes") int sceneType/*=Ogre::SCENE_DYNAMIC*/ );
        public native Item createItem( @Cast("const Ogre::MeshPtr*") @ByRef RealControllerFunctionSPtr pMesh );


        public native void destroyItem( Item item );


        public native void destroyAllItems();






        public native Entity createEntity( @Const @ByRef String meshName,
                                                  @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME)") String groupName,
                                                  @Cast("Ogre::SceneMemoryMgrTypes") int sceneType/*=Ogre::SCENE_DYNAMIC*/ );
        public native Entity createEntity( @Const @ByRef String meshName );





        public native Entity createEntity( @Const @ByRef MeshPtr pMesh,
                                                  @Cast("Ogre::SceneMemoryMgrTypes") int sceneType/*=Ogre::SCENE_DYNAMIC*/ );
        public native Entity createEntity( @Const @ByRef MeshPtr pMesh );







        /** enum Ogre::SceneManager::PrefabType */
        public static final int
            PT_PLANE = 0,
            PT_CUBE = 1,
            PT_SPHERE = 2;




        public native Entity createEntity( @Cast("Ogre::SceneManager::PrefabType") int ptype,
                                                  @Cast("Ogre::SceneMemoryMgrTypes") int sceneType/*=Ogre::SCENE_DYNAMIC*/ );
        public native Entity createEntity( @Cast("Ogre::SceneManager::PrefabType") int ptype );
        public native void destroyEntity(Entity ent);
        public native void destroyAllEntities();
        public native Rectangle2D createRectangle2D( @Cast("bool") boolean bQuad,
                                                            @Cast("Ogre::SceneMemoryMgrTypes") int sceneType/*=Ogre::SCENE_STATIC*/ );
        public native Rectangle2D createRectangle2D( @Cast("bool") boolean bQuad );






        public native void destroyRectangle2D( Rectangle2D rect );
        public native void destroyAllRectangle2D();
        public native void _addCompositorTexture( @ByVal IdString name, @Cast("const Ogre::TextureVec*") TexturePtrVectorRef texs );



        public native @Cast("const Ogre::CompositorTextureVec*") @ByRef CompositorTextureVectorRef getCompositorTextures();


        public native @Cast("size_t") long getNumCompositorTextures();


        public native void _removeCompositorTextures( @Cast("size_t") long from );


        public native SkeletonInstance createSkeletonInstance( @Const SkeletonDef skeletonDef );

        public native void destroySkeletonInstance( SkeletonInstance skeletonInstance );




        public native ManualObject createManualObject( @Cast("Ogre::SceneMemoryMgrTypes") int sceneType/*=Ogre::SCENE_DYNAMIC*/ );
        public native ManualObject createManualObject( );


        public native void destroyManualObject(ManualObject obj);


        public native void destroyAllManualObjects();



        public native BillboardChain createBillboardChain();


        public native void destroyBillboardChain(BillboardChain obj);


        public native void destroyAllBillboardChains();



        public native RibbonTrail createRibbonTrail();


        public native void destroyRibbonTrail(RibbonTrail obj);


        public native void destroyAllRibbonTrails();
        public native ParticleSystem createParticleSystem( @Const @ByRef String templateName );
        public native ParticleSystem createParticleSystem( @Cast("size_t") long quota/*=500*/,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String resourceGroup );
        public native ParticleSystem createParticleSystem( );



        public native void destroyParticleSystem(ParticleSystem obj);


        public native void destroyAllParticleSystems();






        public native void clearScene();
        public native void setAmbientLight( @Const @ByRef ColourValue upperHemisphere, @Const @ByRef ColourValue lowerHemisphere,
                                      @Const @ByRef Vector3 hemisphereDir, double envmapScale/*=1.0f*/ );
        public native void setAmbientLight( @Const @ByRef ColourValue upperHemisphere, @Const @ByRef ColourValue lowerHemisphere,
                                      @Const @ByRef Vector3 hemisphereDir );



        public native @Const @ByRef ColourValue getAmbientLightUpperHemisphere();
        public native @Const @ByRef ColourValue getAmbientLightLowerHemisphere();
        public native @Const @ByRef Vector3 getAmbientLightHemisphereDir();
        public native void prepareWorldGeometry(@Const @ByRef String filename);
        public native void prepareWorldGeometry(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String typeName);
        public native void prepareWorldGeometry(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream);
        public native void setWorldGeometry(@Const @ByRef String filename);
        public native void setWorldGeometry(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String typeName);
        public native void setWorldGeometry(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream);
        public native @Cast("size_t") long estimateWorldGeometry(@Const @ByRef String filename);
        public native @Cast("size_t") long estimateWorldGeometry(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String typeName);
        public native @Cast("size_t") long estimateWorldGeometry(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream);
        public native @ByVal ViewPoint getSuggestedViewpoint(@Cast("bool") boolean random/*=false*/);
        public native @ByVal ViewPoint getSuggestedViewpoint();
        public native @Cast("bool") boolean setOption( @Const @ByRef String strKey, @Const Pointer pValue );
        public native @Cast("bool") boolean getOption( @Const @ByRef String strKey, Pointer pDestValue );
        public native @Cast("bool") boolean hasOption( @Const @ByRef String strKey );
        public native @Cast("bool") boolean getOptionValues( @Const @ByRef String strKey, @Cast("Ogre::StringVector*") @ByRef StringVectorRef refValueList );







        public native @Cast("bool") boolean getOptionKeys( @Cast("Ogre::StringVector*") @ByRef StringVectorRef refKeys );


        public native @Cast("Ogre::VisibleObjectsPerThreadArray*") @ByRef RealFastArrayRef _getTmpVisibleObjectsList();

        public native @Cast("Ogre::InstancingThreadedCullingMethod") int getInstancingThreadedCullingMethod();






        public native void notifyStaticAabbDirty( MovableObject movableObject );
        public native void notifyStaticDirty( Node node );






        public native void updateAllAnimations();
        public native void updateAllTransforms();






        public native void updateAllTagPoints();
        public native void updateAllBounds( @Cast("const Ogre::SceneManager::ObjectMemoryManagerVec*") @ByRef ObjectMemoryManagerPtrVectorRef objectMemManager );



        public native void updateAllLods( @Const Camera lodCamera, double lodBias, @Cast("Ogre::uint8") byte firstRq, @Cast("Ogre::uint8") byte lastRq );



        public native void updateSceneGraph();





        public native void _applySceneAnimations();
        public native void _cullPhase01(Camera camera, @Const Camera lodCamera,
                                          Viewport vp, @Cast("Ogre::uint8") byte firstRq, @Cast("Ogre::uint8") byte lastRq );
        public native void _renderPhase02( Camera camera, @Const Camera lodCamera, Viewport vp,
                                             @Cast("Ogre::uint8") byte firstRq, @Cast("Ogre::uint8") byte lastRq, @Cast("bool") boolean includeOverlays );

        public native void cullLights( Camera camera, @Cast("Ogre::Light::LightTypes") int startType,
                                 @Cast("Ogre::Light::LightTypes") int endType, @Cast("Ogre::LightArray*") @ByRef RealFastArrayRef outLights );


        public native void _frameEnded();




        public native void _queueSkiesForRendering(Camera cam);
        public native void _setDestinationRenderSystem(RenderSystem sys);

        public native void _setViewport( Viewport vp );
        public native void setSkyPlane(
                    @Cast("bool") boolean enable,
                    @Const @ByRef Plane plane, @Const @ByRef String materialName, double scale/*=1000*/,
                    double tiling/*=10*/, @Cast("bool") boolean drawFirst/*=true*/, double bow/*=0*/,
                    int xsegments/*=1*/, int ysegments/*=1*/,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName);
        public native void setSkyPlane(
                    @Cast("bool") boolean enable,
                    @Const @ByRef Plane plane, @Const @ByRef String materialName);
        public native void _setSkyPlane(
                    @Cast("bool") boolean enable,
                    @Const @ByRef Plane plane, @Const @ByRef String materialName, @Cast("Ogre::uint8") byte renderQueue, double scale/*=1000*/,
                    double tiling/*=10*/, double bow/*=0*/, int xsegments/*=1*/, int ysegments/*=1*/,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName);
        public native void _setSkyPlane(
                    @Cast("bool") boolean enable,
                    @Const @ByRef Plane plane, @Const @ByRef String materialName, @Cast("Ogre::uint8") byte renderQueue);


        public native void setSkyPlaneEnabled(@Cast("bool") boolean enable);


        public native @Cast("bool") boolean isSkyPlaneEnabled();


        public native SceneNode getSkyPlaneNode();


        public native @Const @ByRef SkyPlaneGenParameters getSkyPlaneGenParameters();
        public native void setSkyBox(
                    @Cast("bool") boolean enable, @Const @ByRef String materialName, double distance/*=5000*/,
                    @Cast("bool") boolean drawFirst/*=true*/, @Const @ByRef(nullValue = "Ogre::Quaternion::IDENTITY") Quaternion orientation,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName);
        public native void setSkyBox(
                    @Cast("bool") boolean enable, @Const @ByRef String materialName);
        public native void _setSkyBox(
                    @Cast("bool") boolean enable, @Const @ByRef String materialName, @Cast("Ogre::uint8") byte renderQueue, double distance/*=5000*/,
                    @Const @ByRef(nullValue = "Ogre::Quaternion::IDENTITY") Quaternion orientation,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName);
        public native void _setSkyBox(
                    @Cast("bool") boolean enable, @Const @ByRef String materialName, @Cast("Ogre::uint8") byte renderQueue);


        public native void setSkyBoxEnabled(@Cast("bool") boolean enable);


        public native @Cast("bool") boolean isSkyBoxEnabled();


        public native SceneNode getSkyBoxNode();


        public native @Const @ByRef SkyBoxGenParameters getSkyBoxGenParameters();
        public native void setSkyDome(
                    @Cast("bool") boolean enable, @Const @ByRef String materialName, double curvature/*=10*/,
                    double tiling/*=8*/, double distance/*=4000*/, @Cast("bool") boolean drawFirst/*=true*/,
                    @Const @ByRef(nullValue = "Ogre::Quaternion::IDENTITY") Quaternion orientation,
                    int xsegments/*=16*/, int ysegments/*=16*/, int ysegments_keep/*=-1*/,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName);
        public native void setSkyDome(
                    @Cast("bool") boolean enable, @Const @ByRef String materialName);
        public native void _setSkyDome(
                    @Cast("bool") boolean enable, @Const @ByRef String materialName, @Cast("Ogre::uint8") byte renderQueue,
                    double curvature/*=10*/, double tiling/*=8*/, double distance/*=4000*/,
                    @Const @ByRef(nullValue = "Ogre::Quaternion::IDENTITY") Quaternion orientation,
                    int xsegments/*=16*/, int ysegments/*=16*/, int ysegments_keep/*=-1*/,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName);
        public native void _setSkyDome(
                    @Cast("bool") boolean enable, @Const @ByRef String materialName, @Cast("Ogre::uint8") byte renderQueue);


        public native void setSkyDomeEnabled(@Cast("bool") boolean enable);


        public native @Cast("bool") boolean isSkyDomeEnabled();


        public native SceneNode getSkyDomeNode();


        public native @Const @ByRef SkyDomeGenParameters getSkyDomeGenParameters();
        public native void setFog(
                    @Cast("Ogre::FogMode") int mode/*=Ogre::FOG_NONE*/, @Const @ByRef(nullValue = "Ogre::ColourValue::White") ColourValue colour,
                    double expDensity/*=0.001*/, double linearStart/*=0.0*/, double linearEnd/*=1.0*/);
        public native void setFog();



        public native @Cast("Ogre::FogMode") int getFogMode();



        public native @Const @ByRef ColourValue getFogColour();



        public native double getFogStart();



        public native double getFogEnd();



        public native double getFogDensity();
        public native BillboardSet createBillboardSet(@Cast("unsigned int") int poolSize/*=20*/);
        public native BillboardSet createBillboardSet();







        public native void destroyBillboardSet(BillboardSet set);
        public native void destroyAllBillboardSets();
        public native void setDisplaySceneNodes(@Cast("bool") boolean display);

        public native @Cast("bool") boolean getDisplaySceneNodes();
        public native Animation createAnimation(@Const @ByRef String name, double length);




        public native Animation getAnimation(@Const @ByRef String name);


        public native @Cast("bool") boolean hasAnimation(@Const @ByRef String name);






        public native void destroyAnimation(@Const @ByRef String name);


        public native void destroyAllAnimations();
        public native AnimationState createAnimationState(@Const @ByRef String animName);




        public native AnimationState getAnimationState(@Const @ByRef String animName);


        public native @Cast("bool") boolean hasAnimationState(@Const @ByRef String name);






        public native void destroyAnimationState(@Const @ByRef String name);


        public native void destroyAllAnimationStates();
        public native void manualRender(RenderOperation rend, Pass pass, Viewport vp,
                    @Const @ByRef Matrix4 worldMatrix, @Const @ByRef Matrix4 viewMatrix, @Const @ByRef Matrix4 projMatrix,
                    @Cast("bool") boolean doBeginEndFrame/*=false*/);
        public native void manualRender(RenderOperation rend, Pass pass, Viewport vp,
                    @Const @ByRef Matrix4 worldMatrix, @Const @ByRef Matrix4 viewMatrix, @Const @ByRef Matrix4 projMatrix);
        public native void manualRender(Renderable rend, @Const Pass pass, Viewport vp,
                    @Const @ByRef Matrix4 viewMatrix, @Const @ByRef Matrix4 projMatrix, @Cast("bool") boolean doBeginEndFrame/*=false*/,
                    @Cast("bool") boolean lightScissoringClipping/*=true*/, @Cast("bool") boolean doLightIteration/*=true*/);
        public native void manualRender(Renderable rend, @Const Pass pass, Viewport vp,
                    @Const @ByRef Matrix4 viewMatrix, @Const @ByRef Matrix4 projMatrix);




        public native void addRenderQueueListener(RenderQueueListener newListener);


        public native void removeRenderQueueListener(RenderQueueListener delListener);



        public native void addRenderObjectListener(RenderObjectListener newListener);

        public native void removeRenderObjectListener(RenderObjectListener delListener);


        public native void showBoundingBoxes(@Cast("bool") boolean bShow);


        public native @Cast("bool") boolean getShowBoundingBoxes();


  public native void _addAutotrackingSceneNode( SceneNode source, SceneNode target,
              @Const @ByRef Vector3 offset, @Const @ByRef Vector3 localDirection );
  public native void _removeAutotrackingSceneNode( SceneNode source );
        public native AxisAlignedBoxSceneQuery createAABBQuery(@Const @ByRef AxisAlignedBox box, @Cast("Ogre::uint32") int mask/*=Ogre::SceneManager::QUERY_ENTITY_DEFAULT_MASK*/);
        public native AxisAlignedBoxSceneQuery createAABBQuery(@Const @ByRef AxisAlignedBox box);
        public native SphereSceneQuery createSphereQuery(@Const @ByRef Sphere sphere, @Cast("Ogre::uint32") int mask/*=Ogre::SceneManager::QUERY_ENTITY_DEFAULT_MASK*/);
        public native SphereSceneQuery createSphereQuery(@Const @ByRef Sphere sphere);
        public native PlaneBoundedVolumeListSceneQuery createPlaneBoundedVolumeQuery(
                        @Cast("const Ogre::PlaneBoundedVolumeList*") @ByRef PlaneBoundedVolumeVectorRef volumes, @Cast("Ogre::uint32") int mask/*=Ogre::SceneManager::QUERY_ENTITY_DEFAULT_MASK*/);
        public native PlaneBoundedVolumeListSceneQuery createPlaneBoundedVolumeQuery(
                        @Cast("const Ogre::PlaneBoundedVolumeList*") @ByRef PlaneBoundedVolumeVectorRef volumes);
        public native RaySceneQuery createRayQuery(@Const @ByRef Ray ray, @Cast("Ogre::uint32") int mask/*=Ogre::SceneManager::QUERY_ENTITY_DEFAULT_MASK*/);
        public native RaySceneQuery createRayQuery(@Const @ByRef Ray ray);
        public native IntersectionSceneQuery createIntersectionQuery(@Cast("Ogre::uint32") int mask/*=Ogre::SceneManager::QUERY_ENTITY_DEFAULT_MASK*/);
        public native IntersectionSceneQuery createIntersectionQuery();


        public native void destroyQuery(SceneQuery query);



        public native @ByVal @Cast("Ogre::SceneManager::CameraIterator*") TechniquesVectorIteratorRef getCameraIterator();


        public native @Cast("const Ogre::SceneManager::CameraList*") @ByRef CameraPtrVectorRef getCameras();

        public native @ByVal @Cast("Ogre::SceneManager::AnimationIterator*") AnimationStateMapIteratorRef getAnimationIterator();


        public native @Cast("const Ogre::SceneManager::AnimationList*") @ByRef AnimationMapRef getAnimations();

        public native @ByVal @Cast("Ogre::v1::AnimationStateIterator*") AnimationStateMapIteratorRef getAnimationStateIterator();







        public native void setShadowColour(@Const @ByRef ColourValue colour);






        public native @Const @ByRef ColourValue getShadowColour();
        public native void setShadowDirectionalLightExtrusionDistance(double dist);


        public native double getShadowDirectionalLightExtrusionDistance();
        public native void setShadowFarDistance(double distance);



        public native double getShadowFarDistance();
        public native double getShadowFarDistanceSquared();
        public native void setShadowDirLightTextureOffset(double offset);



        public native double getShadowDirLightTextureOffset();







        public native void setShadowTextureFadeStart(double fadeStart);







        public native void setShadowTextureFadeEnd(double fadeEnd);
        public native void setShadowTextureCasterMaterial(@Const @ByRef String name);

        public native void _setCurrentShadowNode( CompositorShadowNode shadowNode, @Cast("bool") boolean isReused );
        public native @Const CompositorShadowNode getCurrentShadowNode();
        public native @Cast("bool") boolean isCurrentShadowNodeReused();






        public native void setLateMaterialResolving(@Cast("bool") boolean isLate);



        public native @Cast("bool") boolean isLateMaterialResolving();



        public native void addListener(Listener s);


        public native void removeListener(Listener s);
        public native StaticGeometry createStaticGeometry(@Const @ByRef String name);



        public native StaticGeometry getStaticGeometry(@Const @ByRef String name);

        public native @Cast("bool") boolean hasStaticGeometry(@Const @ByRef String name);

        public native void destroyStaticGeometry(StaticGeometry geom);

        public native void destroyStaticGeometry(@Const @ByRef String name);

        public native void destroyAllStaticGeometry();
        public native InstanceManager createInstanceManager( @Const @ByRef String customName,
                                                                    @Const @ByRef String meshName,
                                                                    @Const @ByRef String groupName,
                                                                    @ByVal InstancingTechnique technique,
                                                                    @Cast("size_t") long numInstancesPerBatch, @Cast("Ogre::uint16") short flags/*=0*/,
                                                                    @Cast("unsigned short") short subMeshIdx/*=0*/ );
        public native InstanceManager createInstanceManager( @Const @ByRef String customName,
                                                                    @Const @ByRef String meshName,
                                                                    @Const @ByRef String groupName,
                                                                    @ByVal InstancingTechnique technique,
                                                                    @Cast("size_t") long numInstancesPerBatch );




        public native InstanceManager getInstanceManager( @ByVal IdString name );


    public native @Cast("bool") boolean hasInstanceManager( @ByVal IdString managerName );







        public native void destroyInstanceManager( @ByVal IdString name );
        public native void destroyInstanceManager( InstanceManager instanceManager );

        public native void destroyAllInstanceManagers();
        public native @Cast("size_t") long getNumInstancesPerBatch( @Const @ByRef String meshName, @Const @ByRef String groupName,
                                                        @Const @ByRef String materialName,
                                                        @ByVal InstancingTechnique technique,
                                                        @Cast("size_t") long numInstancesPerBatch, @Cast("Ogre::uint16") short flags/*=0*/,
                                                        @Cast("unsigned short") short subMeshIdx/*=0*/ );
        public native @Cast("size_t") long getNumInstancesPerBatch( @Const @ByRef String meshName, @Const @ByRef String groupName,
                                                        @Const @ByRef String materialName,
                                                        @ByVal InstancingTechnique technique,
                                                        @Cast("size_t") long numInstancesPerBatch );
        public native InstancedEntity createInstancedEntity( @Const @ByRef String materialName,
                                                                    @Const @ByRef String managerName );





        public native void destroyInstancedEntity( InstancedEntity instancedEntity );
        public native MovableObject createMovableObject(@Const @ByRef String typeName,
                                                            ObjectMemoryManager objectMemMgr,
                                                            @Cast("const Ogre::NameValuePairList*") SStringMapRef params/*=0*/);
        public native MovableObject createMovableObject(@Const @ByRef String typeName,
                                                            ObjectMemoryManager objectMemMgr);



        public native @Cast("bool") boolean hasMovableObject( MovableObject m );





        public native void destroyMovableObject( MovableObject m, @Const @ByRef String typeName );





        public native void destroyMovableObject(MovableObject m);

        public native void destroyAllMovableObjectsByType(@Const @ByRef String typeName);

        public native void destroyAllMovableObjects();





        public native @ByVal @Cast("Ogre::SceneManager::MovableObjectIterator*") TechniquesVectorIteratorRef getMovableObjectIterator(@Const @ByRef String typeName);
        public native void injectMovableObject(MovableObject m);






        public native void extractMovableObject(MovableObject m);






        public native void extractAllMovableObjectsByType(@Const @ByRef String typeName);







                   public native void setVisibilityMask(@Cast("Ogre::uint32") int vmask);




                   public native @Cast("Ogre::uint32") int getVisibilityMask();




        public native @Cast("Ogre::uint32") int _getCombinedVisibilityMask();







        public native void setFindVisibleObjects(@Cast("bool") boolean find);




        public native @Cast("bool") boolean getFindVisibleObjects();
        public native void setFlipCullingOnNegativeScale(@Cast("bool") boolean n);




        public native @Cast("bool") boolean getFlipCullingOnNegativeScale();

        public native void _renderSingleObject( Renderable pRend, @Const MovableObject pMovableObject,
                                                  @Cast("bool") boolean casterPass, @Cast("bool") boolean dualParaboloid );
        public native void _injectRenderWithPass( Pass pass, Renderable rend, Camera activeCamera/*=0*/,
                                                    @Cast("bool") boolean shadowDerivation/*=true*/,
                                                    @Cast("bool") boolean doLightIteration/*=false*/ );
        public native void _injectRenderWithPass( Pass pass, Renderable rend );
        public native void _suppressRenderStateChanges(@Cast("bool") boolean suppress);




        public native @Cast("bool") boolean _areRenderStateChangesSuppressed();
        public native @Const Pass _setPass(@Const Pass pass,
                    @Cast("bool") boolean evenIfSuppressed/*=false*/, @Cast("bool") boolean shadowDerivation/*=true*/);
        public native @Const Pass _setPass(@Const Pass pass);
        public native void _markGpuParamsDirty(@Cast("Ogre::uint16") short mask);




        public native RenderSystem getDestinationRenderSystem();



        public native Viewport getCurrentViewport();



        public native Camera getCameraInProgress();

        public native @ByVal AxisAlignedBox _calculateCurrentCastersBox( @Cast("Ogre::uint32") int viewportVisibilityMask,
                                                            @Cast("Ogre::uint8") byte firstRq, @Cast("Ogre::uint8") byte lastRq );





        public native @Const @ByRef AxisAlignedBox getCurrentCastersBox();





        public native void getMinMaxDepthRange( @Const Frustum shadowMapCamera, double outMin, double outMax );
        public native void setRelativeOrigin( @Const @ByRef Vector3 relativeOrigin, @Cast("bool") boolean bPermanent );


        public native @ByVal Vector3 getRelativeOrigin();
        public native void addLodListener(LodListener listener);






        public native void removeLodListener(LodListener listener);


        public native void _notifyMovableObjectLodChanged(@ByRef MovableObjectLodChangedEvent evt);


        public native void _notifyEntityMeshLodChanged(@ByRef EntityMeshLodChangedEvent evt);


        public native void _notifyEntityMaterialLodChanged(@ByRef EntityMaterialLodChangedEvent evt);


        public native void _handleLodEvents();

        public native void _setCurrentRenderStage( @Cast("Ogre::SceneManager::IlluminationRenderStage") int stage );
        public native @Cast("Ogre::SceneManager::IlluminationRenderStage") int _getCurrentRenderStage();
        public native void executeUserScalableTask( UniformScalableTask task, @Cast("bool") boolean bBlock );





        public native void waitForPendingUserScalableTask();




        public native @Cast("unsigned long") long _updateWorkerThread( ThreadHandle threadHandle );
    }


    @Namespace("Ogre") public static class DefaultIntersectionSceneQuery extends IntersectionSceneQuery {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public DefaultIntersectionSceneQuery(Pointer p) { super(p); }
    
        public DefaultIntersectionSceneQuery(SceneManager creator) { super((Pointer)null); allocate(creator); }
        private native void allocate(SceneManager creator);


        public native void execute(IntersectionSceneQueryListener listener);
    }


    @Namespace("Ogre") public static class DefaultRaySceneQuery extends RaySceneQuery {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public DefaultRaySceneQuery(Pointer p) { super(p); }
    
        public DefaultRaySceneQuery(SceneManager creator) { super((Pointer)null); allocate(creator); }
        private native void allocate(SceneManager creator);


        public native void execute(RaySceneQueryListener listener);
        public native @Cast("bool") boolean execute( @ByVal ObjectData objData, @Cast("size_t") long numNodes, RaySceneQueryListener listener );
    }

    @Namespace("Ogre") public static class DefaultSphereSceneQuery extends SphereSceneQuery {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public DefaultSphereSceneQuery(Pointer p) { super(p); }
    
        public DefaultSphereSceneQuery(SceneManager creator) { super((Pointer)null); allocate(creator); }
        private native void allocate(SceneManager creator);


        public native void execute(SceneQueryListener listener);
        public native @Cast("bool") boolean execute( @ByVal ObjectData objData, @Cast("size_t") long numNodes, SceneQueryListener listener );
    }

    @Namespace("Ogre") @NoOffset public static class DefaultPlaneBoundedVolumeListSceneQuery extends PlaneBoundedVolumeListSceneQuery {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public DefaultPlaneBoundedVolumeListSceneQuery(Pointer p) { super(p); }
    
        public DefaultPlaneBoundedVolumeListSceneQuery(SceneManager creator) { super((Pointer)null); allocate(creator); }
        private native void allocate(SceneManager creator);


        public native void execute(SceneQueryListener listener);
        public native @Cast("bool") boolean execute(@ByVal ObjectData objData, @Cast("size_t") long numNodes, SceneQueryListener listener);
    }

    @Namespace("Ogre") public static class DefaultAxisAlignedBoxSceneQuery extends AxisAlignedBoxSceneQuery {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public DefaultAxisAlignedBoxSceneQuery(Pointer p) { super(p); }
    
        public DefaultAxisAlignedBoxSceneQuery(SceneManager creator) { super((Pointer)null); allocate(creator); }
        private native void allocate(SceneManager creator);


        public native void execute(SceneQueryListener listener);
        public native @Cast("bool") boolean execute( @ByVal ObjectData objData, @Cast("size_t") long numNodes, SceneQueryListener listener );
    }




    /** enum Ogre::SceneType */
    public static final int
        ST_GENERIC = 1,
        ST_EXTERIOR_CLOSE = 2,
        ST_EXTERIOR_FAR = 4,
        ST_EXTERIOR_REAL_FAR = 8,
        ST_INTERIOR = 16;


    @Namespace("Ogre") public static class SceneManagerMetaData extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public SceneManagerMetaData() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public SceneManagerMetaData(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SceneManagerMetaData(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public SceneManagerMetaData position(long position) {
            return (SceneManagerMetaData)super.position(position);
        }
    

        public native @ByRef String typeName(); public native SceneManagerMetaData typeName(String typeName);

        public native @ByRef String description(); public native SceneManagerMetaData description(String description);

        public native @Cast("Ogre::SceneTypeMask") short sceneTypeMask(); public native SceneManagerMetaData sceneTypeMask(short sceneTypeMask);

        public native @Cast("bool") boolean worldGeometrySupported(); public native SceneManagerMetaData worldGeometrySupported(boolean worldGeometrySupported);
    }




    @Namespace("Ogre") @NoOffset public static class SceneManagerFactory extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SceneManagerFactory(Pointer p) { super(p); }
    

        public native @Const @ByRef SceneManagerMetaData getMetaData();




        public native SceneManager createInstance(@Const @ByRef String instanceName, @Cast("size_t") long numWorkerThreads,
                                                    @Cast("Ogre::InstancingThreadedCullingMethod") int threadedCullingMethod);

        public native void destroyInstance(SceneManager instance);

    }






    @Namespace("Ogre") @NoOffset public static class DefaultSceneManagerFactory extends SceneManagerFactory {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public DefaultSceneManagerFactory(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public DefaultSceneManagerFactory(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public DefaultSceneManagerFactory position(long position) {
            return (DefaultSceneManagerFactory)super.position(position);
        }
    
        public DefaultSceneManagerFactory() { super((Pointer)null); allocate(); }
        private native void allocate();

        @MemberGetter public static native @Const @ByRef String FACTORY_TYPE_NAME();
        public native SceneManager createInstance(@Const @ByRef String instanceName, @Cast("size_t") long numWorkerThreads,
                                            @Cast("Ogre::InstancingThreadedCullingMethod") int threadedCullingMethod);
        public native void destroyInstance(SceneManager instance);
    }

    @Namespace("Ogre") public static class DefaultSceneManager extends SceneManager {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public DefaultSceneManager(Pointer p) { super(p); }
    
        public DefaultSceneManager(@Const @ByRef String name, @Cast("size_t") long numWorkerThreads,
                                    @Cast("Ogre::InstancingThreadedCullingMethod") int threadedCullingMethod) { super((Pointer)null); allocate(name, numWorkerThreads, threadedCullingMethod); }
        private native void allocate(@Const @ByRef String name, @Cast("size_t") long numWorkerThreads,
                                    @Cast("Ogre::InstancingThreadedCullingMethod") int threadedCullingMethod);
        public native @Const @ByRef String getTypeName();
    }
    @Namespace("Ogre") @NoOffset public static class SceneManagerEnumerator extends SceneManagerEnumeratorSgtRef {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SceneManagerEnumerator(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public SceneManagerEnumerator(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public SceneManagerEnumerator position(long position) {
            return (SceneManagerEnumerator)super.position(position);
        }
        public Pointer asPointer() { return asPointer(this); }
        @Namespace public static native @Name("static_cast<SceneMgtAlloc*>") Pointer asPointer(SceneManagerEnumerator pointer);
    
        public SceneManagerEnumerator() { super((Pointer)null); allocate(); }
        private native void allocate();





        public native void addFactory(SceneManagerFactory fact);



        public native void removeFactory(SceneManagerFactory fact);
        public native @Const SceneManagerMetaData getMetaData(@Const @ByRef String typeName);



        public native @ByVal @Cast("Ogre::SceneManagerEnumerator::MetaDataIterator*") NodeTrackIteratorRef getMetaDataIterator();
        public native SceneManager createSceneManager(@Const @ByRef String typeName, @Cast("size_t") long numWorkerThreads,
                    @Cast("Ogre::InstancingThreadedCullingMethod") int threadedCullingMethod,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String instanceName);
        public native SceneManager createSceneManager(@Const @ByRef String typeName, @Cast("size_t") long numWorkerThreads,
                    @Cast("Ogre::InstancingThreadedCullingMethod") int threadedCullingMethod);
        public native SceneManager createSceneManager(@Cast("Ogre::SceneTypeMask") short typeMask, @Cast("size_t") long numWorkerThreads,
                    @Cast("Ogre::InstancingThreadedCullingMethod") int threadedCullingMethod,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String instanceName );
        public native SceneManager createSceneManager(@Cast("Ogre::SceneTypeMask") short typeMask, @Cast("size_t") long numWorkerThreads,
                    @Cast("Ogre::InstancingThreadedCullingMethod") int threadedCullingMethod );


        public native void destroySceneManager(SceneManager sm);





        public native SceneManager getSceneManager(@Const @ByRef String instanceName);




        public native @Cast("bool") boolean hasSceneManager(@Const @ByRef String instanceName);

        public native @ByVal @Cast("Ogre::SceneManagerEnumerator::SceneManagerIterator*") AnimationStateMapIteratorRef getSceneManagerIterator();



        public native void setRenderSystem(RenderSystem rs);


        public native void shutdownAll();
        public static native @ByRef SceneManagerEnumerator getSingleton();
        public static native SceneManagerEnumerator getSingletonPtr();

    }












    @Namespace("Ogre") @Opaque public static class FrameStats extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public FrameStats() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public FrameStats(Pointer p) { super(p); }
    }
    @Namespace("Ogre") @NoOffset public static class Root extends RootSgtRef {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Root(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Root(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Root position(long position) {
            return (Root)super.position(position);
        }
        public Pointer asPointer() { return asPointer(this); }
        @Namespace public static native @Name("static_cast<RootAlloc*>") Pointer asPointer(Root pointer);
    
        public Root(@Const @ByRef(nullValue = "Ogre::String(\"plugins\" \"\" \".cfg\")") String pluginFileName,
                    @Const @ByRef(nullValue = "Ogre::String(\"ogre.cfg\")") String configFileName,
                    @Const @ByRef(nullValue = "Ogre::String(\"Ogre.log\")") String logFileName) { super((Pointer)null); allocate(pluginFileName, configFileName, logFileName); }
        private native void allocate(@Const @ByRef(nullValue = "Ogre::String(\"plugins\" \"\" \".cfg\")") String pluginFileName,
                    @Const @ByRef(nullValue = "Ogre::String(\"ogre.cfg\")") String configFileName,
                    @Const @ByRef(nullValue = "Ogre::String(\"Ogre.log\")") String logFileName);
        public Root() { super((Pointer)null); allocate(); }
        private native void allocate();






        public native void saveConfig();
        public native @Cast("bool") boolean restoreConfig();
        public native @Cast("bool") boolean showConfigDialog();
        public native void addRenderSystem(RenderSystem newRend);







        public native @Cast("const Ogre::RenderSystemList*") @ByRef RenderSystemPtrVectorRef getAvailableRenderers();







        public native RenderSystem getRenderSystemByName(@Const @ByRef String name);
        public native void setRenderSystem(RenderSystem system);



        public native RenderSystem getRenderSystem();


        public native HlmsManager getHlmsManager();

        public native CompositorManager2 getCompositorManager2();
        public native RenderWindow initialise(@Cast("bool") boolean autoCreateWindow, @Const @ByRef(nullValue = "Ogre::String(\"OGRE Render Window\")") String windowTitle,
                                            @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String customCapabilitiesConfig);
        public native RenderWindow initialise(@Cast("bool") boolean autoCreateWindow);


  public native @Cast("bool") boolean isInitialised();






        public native void useCustomRenderSystemCapabilities(RenderSystemCapabilities capabilities);




        public native @Cast("bool") boolean getRemoveRenderQueueStructuresOnClear();




        public native void setRemoveRenderQueueStructuresOnClear(@Cast("bool") boolean r);






        public native void addSceneManagerFactory(SceneManagerFactory fact);



        public native void removeSceneManagerFactory(SceneManagerFactory fact);
        public native @Const SceneManagerMetaData getSceneManagerMetaData(@Const @ByRef String typeName);




        public native @ByVal @Cast("Ogre::SceneManagerEnumerator::MetaDataIterator*") NodeTrackIteratorRef getSceneManagerMetaDataIterator();
        public native SceneManager createSceneManager(@Const @ByRef String typeName, @Cast("size_t") long numWorkerThreads,
                                                @Cast("Ogre::InstancingThreadedCullingMethod") int threadedCullingMethod,
                                                @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String instanceName);
        public native SceneManager createSceneManager(@Const @ByRef String typeName, @Cast("size_t") long numWorkerThreads,
                                                @Cast("Ogre::InstancingThreadedCullingMethod") int threadedCullingMethod);
        public native SceneManager createSceneManager(@Cast("Ogre::SceneTypeMask") short typeMask, @Cast("size_t") long numWorkerThreads,
                                                @Cast("Ogre::InstancingThreadedCullingMethod") int threadedCullingMethod,
                                                @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String instanceName);
        public native SceneManager createSceneManager(@Cast("Ogre::SceneTypeMask") short typeMask, @Cast("size_t") long numWorkerThreads,
                                                @Cast("Ogre::InstancingThreadedCullingMethod") int threadedCullingMethod);


        public native void destroySceneManager(SceneManager sm);





        public native SceneManager getSceneManager(@Const @ByRef String instanceName);




        public native @Cast("bool") boolean hasSceneManager(@Const @ByRef String instanceName);

        public native @ByVal @Cast("Ogre::SceneManagerEnumerator::SceneManagerIterator*") AnimationStateMapIteratorRef getSceneManagerIterator();
        public native TextureManager getTextureManager();






        public native MeshManager getMeshManagerV1();




        public native @ByVal String getErrorDescription(long errorNumber);
        public native void addFrameListener(FrameListener newListener);





        public native void removeFrameListener(FrameListener oldListener);
        public native void queueEndRendering(@Cast("bool") boolean state/*=true*/);
        public native void queueEndRendering();







        public native @Cast("bool") boolean endRenderingQueued();

        public native @Const FrameStats getFrameStats();
        public native void startRendering();






        public native @Cast("bool") boolean renderOneFrame();







        public native @Cast("bool") boolean renderOneFrame(double timeSinceLastFrame);
        public native void shutdown();
        public native void addResourceLocation(@Const @ByRef String name, @Const @ByRef String locType,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName,
                    @Cast("bool") boolean recursive/*=false*/);
        public native void addResourceLocation(@Const @ByRef String name, @Const @ByRef String locType);







        public native void removeResourceLocation(@Const @ByRef String name,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName);
        public native void removeResourceLocation(@Const @ByRef String name);
        public native @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr createFileStream(@Const @ByRef String filename, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName,
                    @Cast("bool") boolean overwrite/*=false*/, @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String locationPattern);
        public native @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr createFileStream(@Const @ByRef String filename);
        public native @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr openFileStream(@Const @ByRef String filename, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)") String groupName,
                    @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String locationPattern);
        public native @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr openFileStream(@Const @ByRef String filename);
        public native void convertColourValue(@Const @ByRef ColourValue colour, @Cast("Ogre::uint32*") IntPointer pDest);
        public native void convertColourValue(@Const @ByRef ColourValue colour, @Cast("Ogre::uint32*") IntBuffer pDest);
        public native void convertColourValue(@Const @ByRef ColourValue colour, @Cast("Ogre::uint32*") int[] pDest);
        public native RenderWindow getAutoCreatedWindow();



        public native RenderWindow createRenderWindow(@Const @ByRef String name, @Cast("unsigned int") int width, @Cast("unsigned int") int height,
                    @Cast("bool") boolean fullScreen, @Cast("const Ogre::NameValuePairList*") SStringMapRef miscParams/*=0*/);
        public native RenderWindow createRenderWindow(@Const @ByRef String name, @Cast("unsigned int") int width, @Cast("unsigned int") int height,
                    @Cast("bool") boolean fullScreen);



        public native @Cast("bool") boolean createRenderWindows(@Cast("const Ogre::RenderWindowDescriptionList*") @ByRef RenderWindowDescriptionVectorRef renderWindowDescriptions,
                    @Cast("Ogre::RenderWindowList*") @ByRef RenderWindowPtrVectorRef createdWindows);






        public native RenderTarget detachRenderTarget( RenderTarget pWin );






        public native RenderTarget detachRenderTarget( @Const @ByRef String name );



        public native void destroyRenderTarget(RenderTarget target);



        public native void destroyRenderTarget(@Const @ByRef String name);



        public native RenderTarget getRenderTarget(@Const @ByRef String name);
        public native void loadPlugin(@Const @ByRef String pluginName);
        public native void unloadPlugin(@Const @ByRef String pluginName);
        public native void installPlugin(Plugin plugin);
        public native void uninstallPlugin(Plugin plugin);


        public native @Cast("const Ogre::Root::PluginInstanceList*") @ByRef PluginPtrVectorRef getInstalledPlugins();


        public native Timer getTimer();
        public native @Cast("bool") boolean _fireFrameStarted(@ByRef FrameEvent evt);
        public native @Cast("bool") boolean _fireFrameRenderingQueued(@ByRef FrameEvent evt);
        public native @Cast("bool") boolean _fireFrameEnded(@ByRef FrameEvent evt);
        public native @Cast("bool") boolean _fireFrameStarted();
        public native @Cast("bool") boolean _fireFrameRenderingQueued();
        public native @Cast("bool") boolean _fireFrameEnded();
        public native @Cast("unsigned long") long getNextFrameNumber();






        public native SceneManager _getCurrentSceneManager();




        public native void _pushCurrentSceneManager(SceneManager sm);




        public native void _popCurrentSceneManager(SceneManager sm);
        public native @Cast("bool") boolean _updateAllRenderTargets();
        public native @Cast("bool") boolean _updateAllRenderTargets(@ByRef FrameEvent evt);
        public static native @ByRef Root getSingleton();
        public static native Root getSingletonPtr();
        public native void clearEventTimes();
        public native void setFrameSmoothingPeriod(double period);

        public native double getFrameSmoothingPeriod();
        public native void addMovableObjectFactory(MovableObjectFactory fact,
                    @Cast("bool") boolean overrideExisting/*=false*/);
        public native void addMovableObjectFactory(MovableObjectFactory fact);







        public native void removeMovableObjectFactory(MovableObjectFactory fact);

        public native @Cast("bool") boolean hasMovableObjectFactory(@Const @ByRef String typeName);

        public native MovableObjectFactory getMovableObjectFactory(@Const @ByRef String typeName);



        public native @ByVal @Cast("Ogre::Root::MovableObjectFactoryIterator*") NumericTrackIteratorRef getMovableObjectFactoryIterator();




        public native @Cast("unsigned int") int getDisplayMonitorCount();







        public native WorkQueue getWorkQueue();
        public native void setWorkQueue(WorkQueue queue);







        public native void setBlendIndicesGpuRedundant(@Cast("bool") boolean redundant);



        public native @Cast("bool") boolean isBlendIndicesGpuRedundant();







        public native void setBlendWeightsGpuRedundant(@Cast("bool") boolean redundant);



        public native @Cast("bool") boolean isBlendWeightsGpuRedundant();





        public native void setDefaultMinPixelSize(double pixelSize);



        public native double getDefaultMinPixelSize();






        public native void setFreqUpdatedBuffersUploadOption(@Cast("Ogre::v1::HardwareBuffer::UploadOptions") int uploadOp);




        public native @Cast("Ogre::v1::HardwareBuffer::UploadOptions") int getFreqUpdatedBuffersUploadOption();

    }



    @Namespace("Ogre::v1") @NoOffset public static class SimpleRenderable extends MovableObject {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SimpleRenderable(Pointer p) { super(p); }
        public Renderable asRenderable() { return asRenderable(this); }
        @Namespace public static native @Name("static_cast<Ogre::Renderable*>") Renderable asRenderable(SimpleRenderable pointer);
    

        public SimpleRenderable( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager ) { super((Pointer)null); allocate(id, objectMemoryManager, manager); }
        private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, SceneManager manager );

        public native void setMaterial( @Const @ByRef String matName );
        public native @Cast("const Ogre::MaterialPtr*") @ByRef RealControllerFunctionSPtr getMaterial();

        public native void setRenderOperation( @Const @ByRef RenderOperation rend );
        public native void getRenderOperation(@ByRef RenderOperation op, @Cast("bool") boolean casterPass);

        public native void setWorldTransform( @Const @ByRef Matrix4 xform );
        public native void getWorldTransforms( Matrix4 xform );

        public native void setBoundingBox( @Const @ByRef AxisAlignedBox box );
        public native @Const @ByRef AxisAlignedBox getBoundingBox();


        public native @Const @ByRef String getMovableType();


        public native @Cast("const Ogre::LightList*") @ByRef HashedVector getLights();

    }




    /** enum Ogre::v1::SkeletonAnimationBlendMode */
    public static final int

        ANIMBLEND_AVERAGE = 0,

        ANIMBLEND_CUMULATIVE = 1;
    @Namespace("Ogre::v1") @NoOffset public static class Skeleton extends Resource {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Skeleton(Pointer p) { super(p); }
        public AnimationContainer asAnimationContainer() { return asAnimationContainer(this); }
        @Namespace public static native @Name("static_cast<Ogre::v1::AnimationContainer*>") AnimationContainer asAnimationContainer(Skeleton pointer);
    





        public Skeleton(ResourceManager creator, @Const @ByRef String name, @Cast("Ogre::ResourceHandle") long handle,
                    @Const @ByRef String group, @Cast("bool") boolean isManual/*=false*/, ManualResourceLoader loader/*=0*/) { super((Pointer)null); allocate(creator, name, handle, group, isManual, loader); }
        private native void allocate(ResourceManager creator, @Const @ByRef String name, @Cast("Ogre::ResourceHandle") long handle,
                    @Const @ByRef String group, @Cast("bool") boolean isManual/*=false*/, ManualResourceLoader loader/*=0*/);
        public Skeleton(ResourceManager creator, @Const @ByRef String name, @Cast("Ogre::ResourceHandle") long handle,
                    @Const @ByRef String group) { super((Pointer)null); allocate(creator, name, handle, group); }
        private native void allocate(ResourceManager creator, @Const @ByRef String name, @Cast("Ogre::ResourceHandle") long handle,
                    @Const @ByRef String group);
        public native OldBone createBone();
        public native OldBone createBone(@Cast("unsigned short") short handle);
        public native OldBone createBone(@Const @ByRef String name);
        public native OldBone createBone(@Const @ByRef String name, @Cast("unsigned short") short handle);


        public native @Cast("unsigned short") short getNumBones();
        public native OldBone getRootBone();

        public native @ByVal @Cast("Ogre::v1::Skeleton::BoneIterator*") TechniquesVectorIteratorRef getRootBoneIterator();

        public native @ByVal @Cast("Ogre::v1::Skeleton::BoneIterator*") TechniquesVectorIteratorRef getBoneIterator();
        public native @ByVal @Cast("Ogre::v1::Skeleton::ConstBoneIterator*") NodeTrackIteratorRef getBoneIteratorConst();


        public native OldBone getBone(@Cast("unsigned short") short handle);


        public native OldBone getBone(@Const @ByRef String name);


        public native @Cast("bool") boolean hasBone(@Const @ByRef String name);




        public native void setBindingPose();
        public native void reset(@Cast("bool") boolean resetManualBones/*=false*/);
        public native void reset();





        public native Animation createAnimation(@Const @ByRef String name, double length);
        public native Animation getAnimation(@Const @ByRef String name,
                    @Cast("const Ogre::v1::LinkedSkeletonAnimationSource**") PointerPointer linker);
        public native Animation getAnimation(@Const @ByRef String name,
                    @Const @ByPtrPtr LinkedSkeletonAnimationSource linker);







        public native Animation getAnimation(@Const @ByRef String name);


        public native Animation _getAnimationImpl(@Const @ByRef String name,
                    @Cast("const Ogre::v1::LinkedSkeletonAnimationSource**") PointerPointer linker/*=0*/);
        public native Animation _getAnimationImpl(@Const @ByRef String name);
        public native Animation _getAnimationImpl(@Const @ByRef String name,
                    @Const @ByPtrPtr LinkedSkeletonAnimationSource linker/*=0*/);



        public native @Cast("bool") boolean hasAnimation(@Const @ByRef String name);


        public native void removeAnimation(@Const @ByRef String name);
        public native void setAnimationState(@Const @ByRef AnimationStateSet animSet);






        public native void _initAnimationState(AnimationStateSet animSet);





        public native void _refreshAnimationState(AnimationStateSet animSet);







        public native void _getBoneMatrices(Matrix4 pMatrices);


        public native @Cast("unsigned short") short getNumAnimations();






        public native Animation getAnimation(@Cast("unsigned short") short index);



        public native @Cast("Ogre::v1::SkeletonAnimationBlendMode") int getBlendMode();

        public native void setBlendMode(@Cast("Ogre::v1::SkeletonAnimationBlendMode") int state);


        public native void _updateTransforms();






        public native void optimiseAllAnimations(@Cast("bool") boolean preservingIdentityNodeTracks/*=false*/);
        public native void optimiseAllAnimations();
        public native void addLinkedSkeletonAnimationSource(@Const @ByRef String skelName,
                    double scale/*=1.0f*/);
        public native void addLinkedSkeletonAnimationSource(@Const @ByRef String skelName);

        public native void removeAllLinkedSkeletonAnimationSources();

        public native @ByVal @Cast("Ogre::v1::Skeleton::LinkedSkeletonAnimSourceIterator*") NodeTrackIteratorRef getLinkedSkeletonAnimationSourceIterator();


        public native void _notifyManualBonesDirty();

        public native void _notifyManualBoneStateChange(OldBone bone);


        public native @Cast("bool") boolean getManualBonesDirty();

        public native @Cast("bool") boolean hasManualBones();
        public native void _mergeSkeletonAnimations(@Const Skeleton source,
                    @Cast("const Ogre::v1::Skeleton::BoneHandleMap*") @ByRef UshortVectorRef boneHandleMap,
                    @Cast("const Ogre::StringVector*") @ByRef(nullValue = "Ogre::StringVector()") StringVectorRef animations);
        public native void _mergeSkeletonAnimations(@Const Skeleton source,
                    @Cast("const Ogre::v1::Skeleton::BoneHandleMap*") @ByRef UshortVectorRef boneHandleMap);





        public native void _buildMapBoneByHandle(@Const Skeleton source,
                    @Cast("Ogre::v1::Skeleton::BoneHandleMap*") @ByRef UshortVectorRef boneHandleMap);





        public native void _buildMapBoneByName(@Const Skeleton source,
                    @Cast("Ogre::v1::Skeleton::BoneHandleMap*") @ByRef UshortVectorRef boneHandleMap);

    }


    @Namespace("Ogre::v1") @NoOffset public static class LinkedSkeletonAnimationSource extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public LinkedSkeletonAnimationSource(Pointer p) { super(p); }
    
        public native @ByRef String skeletonName(); public native LinkedSkeletonAnimationSource skeletonName(String skeletonName);
        public native @ByRef @Cast("Ogre::v1::SkeletonPtr*") RealControllerFunctionSPtr pSkeleton(); public native LinkedSkeletonAnimationSource pSkeleton(RealControllerFunctionSPtr pSkeleton);
        public native double scale(); public native LinkedSkeletonAnimationSource scale(double scale);
        public LinkedSkeletonAnimationSource(@Const @ByRef String skelName, double scl) { super((Pointer)null); allocate(skelName, scl); }
        private native void allocate(@Const @ByRef String skelName, double scl);
            public LinkedSkeletonAnimationSource(@Const @ByRef String skelName, double scl,
                            @ByVal @Cast("Ogre::v1::SkeletonPtr*") RealControllerFunctionSPtr skelPtr) { super((Pointer)null); allocate(skelName, scl, skelPtr); }
            private native void allocate(@Const @ByRef String skelName, double scl,
                            @ByVal @Cast("Ogre::v1::SkeletonPtr*") RealControllerFunctionSPtr skelPtr);
    }




    @Namespace("Ogre::v1") @NoOffset public static class OldSkeletonInstance extends Skeleton {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public OldSkeletonInstance(Pointer p) { super(p); }
    



        public OldSkeletonInstance(@Cast("const Ogre::v1::SkeletonPtr*") @ByRef RealControllerFunctionSPtr masterCopy) { super((Pointer)null); allocate(masterCopy); }
        private native void allocate(@Cast("const Ogre::v1::SkeletonPtr*") @ByRef RealControllerFunctionSPtr masterCopy);


        public native @Cast("unsigned short") short getNumAnimations();


        public native Animation getAnimation(@Cast("unsigned short") short index);

        public native Animation _getAnimationImpl(@Const @ByRef String name,
                    @Cast("const Ogre::v1::LinkedSkeletonAnimationSource**") PointerPointer linker/*=0*/);
        public native Animation _getAnimationImpl(@Const @ByRef String name);
        public native Animation _getAnimationImpl(@Const @ByRef String name,
                    @Const @ByPtrPtr LinkedSkeletonAnimationSource linker/*=0*/);







        public native Animation createAnimation(@Const @ByRef String name, double length);


        public native Animation getAnimation(@Const @ByRef String name,
                    @Cast("const Ogre::v1::LinkedSkeletonAnimationSource**") PointerPointer linker/*=0*/);
        public native Animation getAnimation(@Const @ByRef String name);
        public native Animation getAnimation(@Const @ByRef String name,
                    @Const @ByPtrPtr LinkedSkeletonAnimationSource linker/*=0*/);





        public native void removeAnimation(@Const @ByRef String name);



        public native TagPoint createTagPointOnBone(OldBone bone,
                    @Const @ByRef(nullValue = "Ogre::Quaternion::IDENTITY") Quaternion offsetOrientation,
                    @Const @ByRef(nullValue = "Ogre::Vector3::ZERO") Vector3 offsetPosition);
        public native TagPoint createTagPointOnBone(OldBone bone);


        public native void freeTagPoint(TagPoint tagPoint);


        public native void addLinkedSkeletonAnimationSource(@Const @ByRef String skelName,
                    double scale/*=1.0f*/);
        public native void addLinkedSkeletonAnimationSource(@Const @ByRef String skelName);

        public native void removeAllLinkedSkeletonAnimationSources();

        public native @ByVal LinkedSkeletonAnimSourceIterator getLinkedSkeletonAnimationSourceIterator();


        public native void _initAnimationState(AnimationStateSet animSet);


        public native void _refreshAnimationState(AnimationStateSet animSet);


        public native @Const @ByRef String getName();

        public native @Cast("Ogre::ResourceHandle") long getHandle();

        public native @Const @ByRef String getGroup();

    }





    @Namespace("Ogre::v1") public static class OldSkeletonManager extends ResourceManager {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public OldSkeletonManager(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public OldSkeletonManager(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public OldSkeletonManager position(long position) {
            return (OldSkeletonManager)super.position(position);
        }
        public OldSkeletonManagerSgtRef asOldSkeletonManagerSgtRef() { return asOldSkeletonManagerSgtRef(this); }
        @Namespace public static native @Name("static_cast<Ogre::Singleton<Ogre::v1::OldSkeletonManager>*>") OldSkeletonManagerSgtRef asOldSkeletonManagerSgtRef(OldSkeletonManager pointer);
    

        public OldSkeletonManager() { super((Pointer)null); allocate(); }
        private native void allocate();



        public native @ByVal @Cast("Ogre::v1::SkeletonPtr*") RealControllerFunctionSPtr create(@Const @ByRef String name, @Const @ByRef String group,
                                    @Cast("bool") boolean isManual/*=false*/, ManualResourceLoader loader/*=0*/,
                                    @Cast("const Ogre::NameValuePairList*") SStringMapRef createParams/*=0*/);
        public native @ByVal @Cast("Ogre::v1::SkeletonPtr*") RealControllerFunctionSPtr create(@Const @ByRef String name, @Const @ByRef String group);



        public native @ByVal @Cast("Ogre::v1::SkeletonPtr*") RealControllerFunctionSPtr getByName(@Const @ByRef String name, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME)") String groupName);
        public native @ByVal @Cast("Ogre::v1::SkeletonPtr*") RealControllerFunctionSPtr getByName(@Const @ByRef String name);
        public static native @ByRef OldSkeletonManager getSingleton();
        public static native OldSkeletonManager getSingletonPtr();

    }







    /** enum Ogre::v1::SkeletonVersion */
    public static final int

        SKELETON_VERSION_1_0 = 0,

        SKELETON_VERSION_1_8 = 1,


        SKELETON_VERSION_LATEST = 100;
    @Namespace("Ogre::v1") public static class SkeletonSerializer extends Serializer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SkeletonSerializer(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public SkeletonSerializer(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public SkeletonSerializer position(long position) {
            return (SkeletonSerializer)super.position(position);
        }
    
        public SkeletonSerializer() { super((Pointer)null); allocate(); }
        private native void allocate();
        public native void exportSkeleton(@Const Skeleton pSkeleton, @Const @ByRef String filename,
                    @Cast("Ogre::v1::SkeletonVersion") int ver/*=Ogre::v1::SKELETON_VERSION_LATEST*/, @ByVal(nullValue = "Endian(ENDIAN_NATIVE)") Endian endianMode);
        public native void exportSkeleton(@Const Skeleton pSkeleton, @Const @ByRef String filename);
        public native void exportSkeleton(@Const Skeleton pSkeleton, @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr stream,
                    @Cast("Ogre::v1::SkeletonVersion") int ver/*=Ogre::v1::SKELETON_VERSION_LATEST*/, @ByVal(nullValue = "Endian(ENDIAN_NATIVE)") Endian endianMode);
        public native void exportSkeleton(@Const Skeleton pSkeleton, @ByVal @Cast("Ogre::DataStreamPtr*") RealControllerFunctionSPtr stream);







        public native void importSkeleton(@Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream, Skeleton pDest);




    }




    @Namespace("Ogre::v1") @NoOffset public static class StaticGeometry extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public StaticGeometry(Pointer p) { super(p); }
    
        @NoOffset public static class OptimisedSubMeshGeometry extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public OptimisedSubMeshGeometry(Pointer p) { super(p); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public OptimisedSubMeshGeometry(long size) { super((Pointer)null); allocateArray(size); }
            private native void allocateArray(long size);
            @Override public OptimisedSubMeshGeometry position(long position) {
                return (OptimisedSubMeshGeometry)super.position(position);
            }
        
            public OptimisedSubMeshGeometry() { super((Pointer)null); allocate(); }
            private native void allocate();
            public native VertexData vertexData(); public native OptimisedSubMeshGeometry vertexData(VertexData vertexData);
            public native IndexData indexData(); public native OptimisedSubMeshGeometry indexData(IndexData indexData);
        }


        public static class SubMeshLodGeometryLink extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public SubMeshLodGeometryLink() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public SubMeshLodGeometryLink(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public SubMeshLodGeometryLink(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public SubMeshLodGeometryLink position(long position) {
                return (SubMeshLodGeometryLink)super.position(position);
            }
        
            public native VertexData vertexData(); public native SubMeshLodGeometryLink vertexData(VertexData vertexData);
            public native IndexData indexData(); public native SubMeshLodGeometryLink indexData(IndexData indexData);
        }

        @NoOffset public static class QueuedSubMesh extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public QueuedSubMesh() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public QueuedSubMesh(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public QueuedSubMesh(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public QueuedSubMesh position(long position) {
                return (QueuedSubMesh)super.position(position);
            }
        
            public native SubMesh submesh(); public native QueuedSubMesh submesh(SubMesh submesh);

            public native @Cast("Ogre::v1::StaticGeometry::SubMeshLodGeometryLinkList*") SubMeshLodGeometryLinkVectorRef geometryLodList(); public native QueuedSubMesh geometryLodList(SubMeshLodGeometryLinkVectorRef geometryLodList);
            public native @ByRef String materialName(); public native QueuedSubMesh materialName(String materialName);
            public native @ByRef @Name("position") Vector3 _position(); public native QueuedSubMesh _position(Vector3 _position);
            public native @ByRef Quaternion orientation(); public native QueuedSubMesh orientation(Quaternion orientation);
            public native @ByRef Vector3 scale(); public native QueuedSubMesh scale(Vector3 scale);

            public native @ByRef AxisAlignedBox worldBounds(); public native QueuedSubMesh worldBounds(AxisAlignedBox worldBounds);
        }

        @NoOffset public static class QueuedGeometry extends Pointer {
            static { Loader.load(); }
            /** Default native constructor. */
            public QueuedGeometry() { super((Pointer)null); allocate(); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public QueuedGeometry(long size) { super((Pointer)null); allocateArray(size); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public QueuedGeometry(Pointer p) { super(p); }
            private native void allocate();
            private native void allocateArray(long size);
            @Override public QueuedGeometry position(long position) {
                return (QueuedGeometry)super.position(position);
            }
        
            public native SubMeshLodGeometryLink geometry(); public native QueuedGeometry geometry(SubMeshLodGeometryLink geometry);
            public native @ByRef @Name("position") Vector3 _position(); public native QueuedGeometry _position(Vector3 _position);
            public native @ByRef Quaternion orientation(); public native QueuedGeometry orientation(Quaternion orientation);
            public native @ByRef Vector3 scale(); public native QueuedGeometry scale(Vector3 scale);
        }





        @NoOffset public static class GeometryBucket extends Renderable {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public GeometryBucket(Pointer p) { super(p); }
            public Pointer asPointer() { return asPointer(this); }
            @Namespace public static native @Name("static_cast<BatchedGeometryAlloc*>") Pointer asPointer(StaticGeometry.GeometryBucket pointer);
        
            public GeometryBucket(MaterialBucket parent, @Const @ByRef String formatString,
                            @Const VertexData vData, @Const IndexData iData) { super((Pointer)null); allocate(parent, formatString, vData, iData); }
            private native void allocate(MaterialBucket parent, @Const @ByRef String formatString,
                            @Const VertexData vData, @Const IndexData iData);
            public native MaterialBucket getParent();

            public native @Const VertexData getVertexData();

            public native @Const IndexData getIndexData();

            public native @Cast("const Ogre::MaterialPtr*") @ByRef RealControllerFunctionSPtr getMaterial();
            public native Technique getTechnique();
            public native void getRenderOperation(@ByRef RenderOperation op, @Cast("bool") boolean casterPass);
            public native void getWorldTransforms(Matrix4 xform);
            public native double getSquaredViewDepth(@Const Camera cam);
            public native @Cast("const Ogre::LightList*") @ByRef HashedVector getLights();
            public native @Cast("bool") boolean getCastsShadows();




            public native @Cast("bool") boolean assign(QueuedGeometry qsm);

            public native void build();

            public native void dump(@Cast("std::ofstream*") @ByRef Pointer of);
        }


        @NoOffset public static class MaterialBucket extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public MaterialBucket(Pointer p) { super(p); }
        
            public MaterialBucket(LODBucket parent, @Const @ByRef String materialName) { super((Pointer)null); allocate(parent, materialName); }
            private native void allocate(LODBucket parent, @Const @ByRef String materialName);
            public native LODBucket getParent();

            public native @Const @ByRef String getMaterialName();

            public native void assign(QueuedGeometry qsm);

            public native void build();

            public native void addRenderables(RenderQueue queue, @Cast("Ogre::uint8") byte group,
                            @Cast("size_t") long materialLod);

            public native @Cast("const Ogre::MaterialPtr*") @ByRef RealControllerFunctionSPtr getMaterial();

            public native @ByVal @Cast("Ogre::v1::StaticGeometry::MaterialBucket::GeometryIterator*") TechniquesVectorIteratorRef getGeometryIterator();

            public native Technique getCurrentTechnique();

            public native void dump(@Cast("std::ofstream*") @ByRef Pointer of);
        }





        @NoOffset public static class LODBucket extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public LODBucket(Pointer p) { super(p); }
        
            public LODBucket(Region parent, @Cast("unsigned short") short lod, double lodValue) { super((Pointer)null); allocate(parent, lod, lodValue); }
            private native void allocate(Region parent, @Cast("unsigned short") short lod, double lodValue);
            public native Region getParent();

            public native short getLod();

            public native double getLodValue();

            public native void assign(QueuedSubMesh qsm, short atLod);

            public native void build();

            public native void addRenderables(RenderQueue queue, @Cast("Ogre::uint8") byte group,
                            @Cast("const Ogre::FastArray<unsigned char>*") @ByRef ByteFastArrayRef currentMatLod);

            public native @ByVal @Cast("Ogre::v1::StaticGeometry::LODBucket::MaterialIterator*") AnimationStateMapIteratorRef getMaterialIterator();
            public native @Cast("size_t") long getNumMaterials();

            public native void dump(@Cast("std::ofstream*") @ByRef Pointer of);
            public native EdgeData getEdgeList();
            public native @Cast("bool") boolean isVertexProgramInUse();

        }
        @NoOffset public static class Region extends MovableObject {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public Region(Pointer p) { super(p); }
        
            public Region( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, StaticGeometry parent,
                                SceneManager mgr, @Cast("Ogre::uint32") int regionID, @Const @ByRef Vector3 centre ) { super((Pointer)null); allocate(id, objectMemoryManager, parent, mgr, regionID, centre); }
            private native void allocate( @Cast("Ogre::IdType") int id, ObjectMemoryManager objectMemoryManager, StaticGeometry parent,
                                SceneManager mgr, @Cast("Ogre::uint32") int regionID, @Const @ByRef Vector3 centre );

            public native StaticGeometry getParent();

            public native void assign(QueuedSubMesh qmesh);

            public native void build( @Cast("bool") boolean parentVisible );

            public native @Cast("Ogre::uint32") int getID();

            public native @Const @ByRef Vector3 getCentre();
            public native @Const @ByRef String getMovableType();
            public native void _updateRenderQueue(RenderQueue queue, Camera camera, @Const Camera lodCamera);
            public native @Cast("Ogre::uint32") int getTypeFlags();

            public native @ByVal @Cast("Ogre::v1::StaticGeometry::Region::LODIterator*") TechniquesVectorIteratorRef getLODIterator();

            public native EdgeData getEdgeList();

            public native @Cast("bool") boolean hasEdgeList();


            public native void dump(@Cast("std::ofstream*") @ByRef Pointer of);

        }

        public StaticGeometry(SceneManager owner, @Const @ByRef String name) { super((Pointer)null); allocate(owner, name); }
        private native void allocate(SceneManager owner, @Const @ByRef String name);


        public native @Const @ByRef String getName();
        public native void addEntity(Entity ent, @Const @ByRef Vector3 position,
                    @Const @ByRef(nullValue = "Ogre::Quaternion::IDENTITY") Quaternion orientation,
                    @Const @ByRef(nullValue = "Ogre::Vector3::UNIT_SCALE") Vector3 scale);
        public native void addEntity(Entity ent, @Const @ByRef Vector3 position);
        public native void addSceneNode(@Const SceneNode node);
        public native void build();






        public native void destroy();




        public native void reset();
        public native void setRenderingDistance(double dist);


        public native double getRenderingDistance();


        public native double getSquaredRenderingDistance();


        public native void setVisible(@Cast("bool") boolean visible);


        public native @Cast("bool") boolean isVisible();
        public native void setCastShadows(@Cast("bool") boolean castShadows);

        public native @Cast("bool") boolean getCastShadows();
        public native void setRegionDimensions(@Const @ByRef Vector3 size);

        public native @Const @ByRef Vector3 getRegionDimensions();
        public native void setOrigin(@Const @ByRef Vector3 origin);

        public native @Const @ByRef Vector3 getOrigin();


        public native void setVisibilityFlags(@Cast("Ogre::uint32") int flags);

        public native @Cast("Ogre::uint32") int getVisibilityFlags();
        public native void setRenderQueueGroup(@Cast("Ogre::uint8") byte queueID);


        public native @Cast("Ogre::uint8") byte getRenderQueueGroup();

        public native @ByVal @Cast("Ogre::v1::StaticGeometry::RegionIterator*") AnimationStateMapIteratorRef getRegionIterator();




        public native void dump(@Const @ByRef String filename);


    }





    @Name("Ogre::SubMesh") @NoOffset public static class SubMesh extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public SubMesh(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public SubMesh(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public SubMesh position(long position) {
            return (SubMesh)super.position(position);
        }
    
        public SubMesh() { super((Pointer)null); allocate(); }
        private native void allocate();


        public native @Cast("bool") boolean useSharedVertices(); public native SubMesh useSharedVertices(boolean useSharedVertices);

        public native @Cast("Ogre::uint32") int renderOpMeshIndex(); public native SubMesh renderOpMeshIndex(int renderOpMeshIndex);


        public native @ByRef OperationType operationType(); public native SubMesh operationType(OperationType operationType);
        public native VertexData vertexData(int i); public native SubMesh vertexData(int i, VertexData vertexData);
        @MemberGetter public native @Cast("VertexData**") PointerPointer vertexData();


        public native IndexData indexData(int i); public native SubMesh indexData(int i, IndexData indexData);
        @MemberGetter public native @Cast("IndexData**") PointerPointer indexData();
        public native @ByRef @Cast("Ogre::SubMesh::IndexMap*") UshortFastArrayRef blendIndexToBoneIndexMap(); public native SubMesh blendIndexToBoneIndexMap(UshortFastArrayRef blendIndexToBoneIndexMap);
        public native @ByRef @Cast("Ogre::SubMesh::LODFaceList*") IndexDataPtrVectorRef mLodFaceList(int i); public native SubMesh mLodFaceList(int i, IndexDataPtrVectorRef mLodFaceList);
        @MemberGetter public native @Cast("Ogre::SubMesh::LODFaceList*") IndexDataPtrVectorRef mLodFaceList();
        public native @ByRef @Cast("vector<Ogre::Vector3>::type*") Vector3VectorRef extremityPoints(); public native SubMesh extremityPoints(Vector3VectorRef extremityPoints);


        public native Mesh parent(); public native SubMesh parent(Mesh parent);


        public native void setMaterialName(@Const @ByRef String matName, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME)") String groupName );
        public native void setMaterialName(@Const @ByRef String matName );
        public native @Const @ByRef String getMaterialName();



        public native @Cast("bool") boolean isMatInitialised();







        public native void _getRenderOperation(@ByRef RenderOperation rend, short lodIndex, @Cast("bool") boolean casterPass);
        public native void addBoneAssignment(@Const @ByRef VertexBoneAssignment vertBoneAssign);






        public native void clearBoneAssignments();





        public native @ByVal @Cast("Ogre::SubMesh::BoneAssignmentIterator*") AnimationStateMapIteratorRef getBoneAssignmentIterator();



        public native @Cast("const Ogre::SubMesh::VertexBoneAssignmentList*") @ByRef VertexBoneAssignmentMultimapRef getBoneAssignments();



        public native void _compileBoneAssignments();



        public native @ByVal @Cast("Ogre::SubMesh::AliasTextureIterator*") NumericTrackIteratorRef getAliasTextureIterator();
        public native void addTextureAlias(@Const @ByRef String aliasName, @Const @ByRef String textureName);





        public native void removeTextureAlias(@Const @ByRef String aliasName);


        public native void removeAllTextureAliases();


        public native @Cast("bool") boolean hasTextureAliases();


        public native @Cast("size_t") long getTextureAliasCount();
        public native @Cast("bool") boolean updateMaterialUsingTextureAliases();



        public native @ByVal VertexAnimationType getVertexAnimationType();


        public native @Cast("bool") boolean getVertexAnimationIncludesNormals();






        public native void generateExtremes(@Cast("size_t") long count);



        public native @Cast("bool") boolean isBuildEdgesEnabled();
        public native void setBuildEdgesEnabled(@Cast("bool") boolean b);







        public native SubMesh clone(@Const @ByRef String newName, Mesh parentMesh/*=0*/);
        public native SubMesh clone(@Const @ByRef String newName);


        public native void importFromV2( SubMesh subMesh );

        public native void arrangeEfficient( @Cast("bool") boolean halfPos, @Cast("bool") boolean halfTexCoords, @Cast("bool") boolean qTangents );

        public native void dearrangeToInefficient();
    }





    @Namespace("Ogre") @NoOffset public static class Technique extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Technique(Pointer p) { super(p); }
    



        /** enum Ogre::Technique::IncludeOrExclude */
        public static final int

            INCLUDE = 0,

            EXCLUDE = 1;

        @NoOffset public static class GPUVendorRule extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public GPUVendorRule(Pointer p) { super(p); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public GPUVendorRule(long size) { super((Pointer)null); allocateArray(size); }
            private native void allocateArray(long size);
            @Override public GPUVendorRule position(long position) {
                return (GPUVendorRule)super.position(position);
            }
        
            public native @Cast("Ogre::GPUVendor") int vendor(); public native GPUVendorRule vendor(int vendor);
            public native @Cast("Ogre::Technique::IncludeOrExclude") int includeOrExclude(); public native GPUVendorRule includeOrExclude(int includeOrExclude);
            public GPUVendorRule() { super((Pointer)null); allocate(); }
            private native void allocate();
            public GPUVendorRule(@Cast("Ogre::GPUVendor") int v, @Cast("Ogre::Technique::IncludeOrExclude") int ie) { super((Pointer)null); allocate(v, ie); }
            private native void allocate(@Cast("Ogre::GPUVendor") int v, @Cast("Ogre::Technique::IncludeOrExclude") int ie);
        }

        @NoOffset public static class GPUDeviceNameRule extends Pointer {
            static { Loader.load(); }
            /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
            public GPUDeviceNameRule(Pointer p) { super(p); }
            /** Native array allocator. Access with {@link Pointer#position(long)}. */
            public GPUDeviceNameRule(long size) { super((Pointer)null); allocateArray(size); }
            private native void allocateArray(long size);
            @Override public GPUDeviceNameRule position(long position) {
                return (GPUDeviceNameRule)super.position(position);
            }
        
            public native @ByRef String devicePattern(); public native GPUDeviceNameRule devicePattern(String devicePattern);
            public native @Cast("Ogre::Technique::IncludeOrExclude") int includeOrExclude(); public native GPUDeviceNameRule includeOrExclude(int includeOrExclude);
            public native @Cast("bool") boolean caseSensitive(); public native GPUDeviceNameRule caseSensitive(boolean caseSensitive);
            public GPUDeviceNameRule() { super((Pointer)null); allocate(); }
            private native void allocate();
            public GPUDeviceNameRule(@Const @ByRef String pattern, @Cast("Ogre::Technique::IncludeOrExclude") int ie, @Cast("bool") boolean caseSen) { super((Pointer)null); allocate(pattern, ie, caseSen); }
            private native void allocate(@Const @ByRef String pattern, @Cast("Ogre::Technique::IncludeOrExclude") int ie, @Cast("bool") boolean caseSen);
        }

        public Technique(Material parent) { super((Pointer)null); allocate(parent); }
        private native void allocate(Material parent);

        public Technique(Material parent, @Const @ByRef Technique oth) { super((Pointer)null); allocate(parent, oth); }
        private native void allocate(Material parent, @Const @ByRef Technique oth);





        public native @Cast("bool") boolean isSupported();



        public native @ByVal String _compile(@Cast("bool") boolean autoManageTextureUnits);

        public native @Cast("bool") boolean checkGPURules(@Cast("Ogre::StringStream*") @ByRef StringStream errors);

        public native @Cast("bool") boolean checkHardwareSupport(@Cast("bool") boolean autoManageTextureUnits, @Cast("Ogre::StringStream*") @ByRef StringStream compileErrors);
        public native @Cast("size_t") long calculateSize();
        public native Pass createPass();

        public native Pass getPass(@Cast("unsigned short") short index);



        public native Pass getPass(@Const @ByRef String name);

        public native @Cast("unsigned short") short getNumPasses();

        public native void removePass(@Cast("unsigned short") short index);

        public native void removeAllPasses();



        public native @Cast("bool") boolean movePass(@Cast("const unsigned short") short sourceIndex, @Cast("const unsigned short") short destinationIndex);

        public native @ByVal @Cast("const Ogre::Technique::PassIterator*") TechniquesVectorIteratorRef getPassIterator();

        public native Material getParent();


        public native @ByRef @Name("operator =") Technique put(@Const @ByRef Technique rhs);


        public native @Const @ByRef String getResourceGroup();
        public native @Cast("bool") boolean isTransparent();


        public native void _prepare();

        public native void _unprepare();

        public native void _load();

        public native void _unload();


        public native @Cast("bool") boolean isLoaded();


        public native void _notifyNeedsRecompile();



        public native @ByVal @Cast("Ogre::MaterialPtr*") RealControllerFunctionSPtr getShadowCasterMaterial();


        public native void setShadowCasterMaterial(@ByVal @Cast("Ogre::MaterialPtr*") RealControllerFunctionSPtr val);


        public native void setShadowCasterMaterial(@Cast("const Ogre::Ogre::String*") @ByRef String name);
        public native void setPointSize(double ps);
        public native void setAmbient(double red, double green, double blue);
        public native void setAmbient(@Const @ByRef ColourValue ambient);
        public native void setDiffuse(double red, double green, double blue, double alpha);
        public native void setDiffuse(@Const @ByRef ColourValue diffuse);
        public native void setSpecular(double red, double green, double blue, double alpha);
        public native void setSpecular(@Const @ByRef ColourValue specular);
        public native void setShininess(double val);
        public native void setSelfIllumination(double red, double green, double blue);
        public native void setSelfIllumination(@Const @ByRef ColourValue selfIllum);
        public native void setShadingMode( @Cast("Ogre::ShadeOptions") int mode );
        public native void setFog(
                    @Cast("bool") boolean overrideScene,
                    @Cast("Ogre::FogMode") int mode/*=Ogre::FOG_NONE*/,
                    @Const @ByRef(nullValue = "Ogre::ColourValue::White") ColourValue colour,
                    double expDensity/*=0.001*/, double linearStart/*=0.0*/, double linearEnd/*=1.0*/ );
        public native void setFog(
                    @Cast("bool") boolean overrideScene );
        public native void setSamplerblock( @Const @ByRef HlmsSamplerblock samplerblock );
        public native void setMacroblock( @Const @ByRef HlmsMacroblock macroblock );
        public native void setBlendblock( @Const @ByRef HlmsBlendblock blendblock );
        public native void setLodIndex(@Cast("unsigned short") short index);

        public native @Cast("unsigned short") short getLodIndex();
        public native void setSchemeName(@Const @ByRef String schemeName);



        public native @Const @ByRef String getSchemeName();


        public native @Cast("unsigned short") short _getSchemeIndex();


        public native @Cast("bool") boolean isDepthWriteEnabled();


        public native @Cast("bool") boolean isDepthCheckEnabled();


        public native @Cast("bool") boolean hasColourWriteDisabled();






        public native void setName(@Const @ByRef String name);

        public native @Const @ByRef String getName();
        public native @Cast("bool") boolean applyTextureAliases(@Cast("const Ogre::AliasTextureNamePairList*") @ByRef SStringMapRef aliasList, @Cast("const bool") boolean apply/*=true*/);
        public native @Cast("bool") boolean applyTextureAliases(@Cast("const Ogre::AliasTextureNamePairList*") @ByRef SStringMapRef aliasList);
        public native void addGPUVendorRule(@Cast("Ogre::GPUVendor") int vendor, @Cast("Ogre::Technique::IncludeOrExclude") int includeOrExclude);
        public native void addGPUVendorRule(@Const @ByRef GPUVendorRule rule);



        public native void removeGPUVendorRule(@Cast("Ogre::GPUVendor") int vendor);

        public native @ByVal @Cast("Ogre::Technique::GPUVendorRuleIterator*") NodeTrackIteratorRef getGPUVendorRuleIterator();
        public native void addGPUDeviceNameRule(@Const @ByRef String devicePattern, @Cast("Ogre::Technique::IncludeOrExclude") int includeOrExclude, @Cast("bool") boolean caseSensitive/*=false*/);
        public native void addGPUDeviceNameRule(@Const @ByRef String devicePattern, @Cast("Ogre::Technique::IncludeOrExclude") int includeOrExclude);
        public native void addGPUDeviceNameRule(@Const @ByRef GPUDeviceNameRule rule);



        public native void removeGPUDeviceNameRule(@Const @ByRef String devicePattern);

        public native @ByVal @Cast("Ogre::Technique::GPUDeviceNameRuleIterator*") NodeTrackIteratorRef getGPUDeviceNameRuleIterator();





        public native @ByRef UserObjectBindings getUserObjectBindings();

    }





    @Namespace("Ogre") @NoOffset public static class TextureManager extends ResourceManager {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public TextureManager(Pointer p) { super(p); }
        public TextureManagerSgtRef asTextureManagerSgtRef() { return asTextureManagerSgtRef(this); }
        @Namespace public static native @Name("static_cast<Ogre::Singleton<Ogre::TextureManager>*>") TextureManagerSgtRef asTextureManagerSgtRef(TextureManager pointer);
    




        public native @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr create(@Const @ByRef String name, @Const @ByRef String group,
                                    @Cast("bool") boolean isManual/*=false*/, ManualResourceLoader loader/*=0*/,
                                    @Cast("const Ogre::NameValuePairList*") SStringMapRef createParams/*=0*/);
        public native @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr create(@Const @ByRef String name, @Const @ByRef String group);


        public native @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr getByName(@Const @ByRef String name, @Const @ByRef(nullValue = "Ogre::String(Ogre::ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME)") String groupName);
        public native @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr getByName(@Const @ByRef String name);
        public native @ByVal ResourceCreateOrRetrieveResult createOrRetrieve(
                    @Const @ByRef String name, @Const @ByRef String group, @Cast("bool") boolean isManual/*=false*/,
                    ManualResourceLoader loader/*=0*/, @Cast("const Ogre::NameValuePairList*") SStringMapRef createParams/*=0*/,
                    @Cast("Ogre::TextureType") int texType/*=Ogre::TEX_TYPE_2D*/, int numMipmaps/*=Ogre::MIP_DEFAULT*/,
                    double gamma/*=1.0f*/, @Cast("bool") boolean isAlpha/*=false*/,
                    @Cast("Ogre::PixelFormat") int desiredFormat/*=Ogre::PF_UNKNOWN*/, @Cast("bool") boolean hwGammaCorrection/*=false*/);
        public native @ByVal ResourceCreateOrRetrieveResult createOrRetrieve(
                    @Const @ByRef String name, @Const @ByRef String group);
        public native @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr prepare(
                    @Const @ByRef String name, @Const @ByRef String group,
                    @Cast("Ogre::TextureType") int texType/*=Ogre::TEX_TYPE_2D*/, int numMipmaps/*=Ogre::MIP_DEFAULT*/,
                    double gamma/*=1.0f*/, @Cast("bool") boolean isAlpha/*=false*/,
                    @Cast("Ogre::PixelFormat") int desiredFormat/*=Ogre::PF_UNKNOWN*/, @Cast("bool") boolean hwGammaCorrection/*=false*/);
        public native @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr prepare(
                    @Const @ByRef String name, @Const @ByRef String group);
        public native @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr load(
                    @Const @ByRef String name, @Const @ByRef String group,
                    @Cast("Ogre::TextureType") int texType/*=Ogre::TEX_TYPE_2D*/, int numMipmaps/*=Ogre::MIP_DEFAULT*/,
                    double gamma/*=1.0f*/, @Cast("bool") boolean isAlpha/*=false*/,
                    @Cast("Ogre::PixelFormat") int desiredFormat/*=Ogre::PF_UNKNOWN*/,
                    @Cast("bool") boolean hwGammaCorrection/*=false*/);
        public native @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr load(
                    @Const @ByRef String name, @Const @ByRef String group);
        public native @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr loadImage(
                    @Const @ByRef String name, @Const @ByRef String group, @Const @ByRef Image img,
                    @Cast("Ogre::TextureType") int texType/*=Ogre::TEX_TYPE_2D*/,
                    int numMipmaps/*=Ogre::MIP_DEFAULT*/, double gamma/*=1.0f*/, @Cast("bool") boolean isAlpha/*=false*/,
                    @Cast("Ogre::PixelFormat") int desiredFormat/*=Ogre::PF_UNKNOWN*/, @Cast("bool") boolean hwGammaCorrection/*=false*/);
        public native @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr loadImage(
                    @Const @ByRef String name, @Const @ByRef String group, @Const @ByRef Image img);
        public native @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr loadRawData(@Const @ByRef String name, @Const @ByRef String group,
                    @Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream, short width, short height,
                    @Cast("Ogre::PixelFormat") int format, @Cast("Ogre::TextureType") int texType/*=Ogre::TEX_TYPE_2D*/,
                    int numMipmaps/*=Ogre::MIP_DEFAULT*/, double gamma/*=1.0f*/, @Cast("bool") boolean hwGammaCorrection/*=false*/);
        public native @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr loadRawData(@Const @ByRef String name, @Const @ByRef String group,
                    @Cast("Ogre::DataStreamPtr*") @ByRef RealControllerFunctionSPtr stream, short width, short height,
                    @Cast("Ogre::PixelFormat") int format);
        public native @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr createManual(@Const @ByRef String name, @Const @ByRef String group,
                    @Cast("Ogre::TextureType") int texType, @Cast("Ogre::uint") int width, @Cast("Ogre::uint") int height, @Cast("Ogre::uint") int depth,
                    int numMipmaps, @Cast("Ogre::PixelFormat") int format, int usage/*=Ogre::TU_DEFAULT*/, ManualResourceLoader loader/*=0*/,
                    @Cast("bool") boolean hwGammaCorrection/*=false*/, @Cast("Ogre::uint") int fsaa/*=0*/, @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String fsaaHint,
                    @Cast("bool") boolean explicitResolve/*=false*/, @Cast("bool") boolean shareableDepthBuffer/*=true*/);
        public native @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr createManual(@Const @ByRef String name, @Const @ByRef String group,
                    @Cast("Ogre::TextureType") int texType, @Cast("Ogre::uint") int width, @Cast("Ogre::uint") int height, @Cast("Ogre::uint") int depth,
                    int numMipmaps, @Cast("Ogre::PixelFormat") int format);
        public native @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr createManual(@Const @ByRef String name, @Const @ByRef String group,
                    @Cast("Ogre::TextureType") int texType, @Cast("Ogre::uint") int width, @Cast("Ogre::uint") int height, int numMipmaps,
                    @Cast("Ogre::PixelFormat") int format, int usage/*=Ogre::TU_DEFAULT*/, ManualResourceLoader loader/*=0*/,
                    @Cast("bool") boolean hwGammaCorrection/*=false*/, @Cast("Ogre::uint") int fsaa/*=0*/, @Const @ByRef(nullValue = "Ogre::String(Ogre::BLANKSTRING)") String fsaaHint,
                    @Cast("bool") boolean explicitResolve/*=false*/, @Cast("bool") boolean shareableDepthBuffer/*=true*/);
        public native @ByVal @Cast("Ogre::TexturePtr*") RealControllerFunctionSPtr createManual(@Const @ByRef String name, @Const @ByRef String group,
                    @Cast("Ogre::TextureType") int texType, @Cast("Ogre::uint") int width, @Cast("Ogre::uint") int height, int numMipmaps,
                    @Cast("Ogre::PixelFormat") int format);
        public native void setPreferredIntegerBitDepth(short bits, @Cast("bool") boolean reloadTextures/*=true*/);
        public native void setPreferredIntegerBitDepth(short bits);



        public native short getPreferredIntegerBitDepth();
        public native void setPreferredFloatBitDepth(short bits, @Cast("bool") boolean reloadTextures/*=true*/);
        public native void setPreferredFloatBitDepth(short bits);



        public native short getPreferredFloatBitDepth();
        public native void setPreferredBitDepths(short integerBits, short floatBits, @Cast("bool") boolean reloadTextures/*=true*/);
        public native void setPreferredBitDepths(short integerBits, short floatBits);
        public native @Cast("bool") boolean isFormatSupported(@Cast("Ogre::TextureType") int ttype, @Cast("Ogre::PixelFormat") int format, int usage);




        public native @Cast("bool") boolean isEquivalentFormatSupported(@Cast("Ogre::TextureType") int ttype, @Cast("Ogre::PixelFormat") int format, int usage);




        public native @Cast("Ogre::PixelFormat") int getNativeFormat(@Cast("Ogre::TextureType") int ttype, @Cast("Ogre::PixelFormat") int format, int usage);
        public native @Cast("bool") boolean isHardwareFilteringSupported(@Cast("Ogre::TextureType") int ttype, @Cast("Ogre::PixelFormat") int format, int usage,
                    @Cast("bool") boolean preciseFormatOnly/*=false*/);
        public native @Cast("bool") boolean isHardwareFilteringSupported(@Cast("Ogre::TextureType") int ttype, @Cast("Ogre::PixelFormat") int format, int usage);
        public native void setDefaultNumMipmaps(@Cast("size_t") long num);



        public native @Cast("size_t") long getDefaultNumMipmaps();
        public static native @ByRef TextureManager getSingleton();
        public static native TextureManager getSingletonPtr();
    }




    @Namespace("Ogre") @NoOffset public static class Timer extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Timer(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Timer(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public Timer position(long position) {
            return (Timer)super.position(position);
        }
    
        public Timer() { super((Pointer)null); allocate(); }
        private native void allocate();
        public native @Cast("bool") boolean setOption( @Const @ByRef String strKey, @Const Pointer pValue );


        public native void reset();


        public native @Cast("unsigned long") long getMilliseconds();


        public native @Cast("unsigned long") long getMicroseconds();


        public native @Cast("unsigned long") long getMillisecondsCPU();


        public native @Cast("unsigned long") long getMicrosecondsCPU();
    }

    @Namespace("Ogre") @NoOffset public static class Viewport extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Viewport(Pointer p) { super(p); }
    

        public native @Cast("size_t") long mGlobalIndex(); public native Viewport mGlobalIndex(long mGlobalIndex);
        public Viewport(
                    RenderTarget target,
                    double left, double top,
                    double width, double height ) { super((Pointer)null); allocate(target, left, top, width, height); }
        private native void allocate(
                    RenderTarget target,
                    double left, double top,
                    double width, double height );
        public native void _updateDimensions();



        public native void _updateCullPhase01(Camera camera, @Const Camera lodCamera, @Cast("Ogre::uint8") byte firstRq, @Cast("Ogre::uint8") byte lastRq );
        public native void _updateRenderPhase02( Camera camera, @Const Camera lodCamera,
                                           @Cast("Ogre::uint8") byte firstRq, @Cast("Ogre::uint8") byte lastRq );
        public native void clear(@Cast("unsigned int") int buffers/*=Ogre::FBT_COLOUR | Ogre::FBT_DEPTH*/,
                           @Const @ByRef(nullValue = "Ogre::ColourValue::Black") ColourValue colour,
                           double depth/*=1.0f*/, @Cast("unsigned short") short stencil/*=0*/);
        public native void clear();




        public native void discard( @Cast("unsigned int") int buffers/*=Ogre::FBT_COLOUR | Ogre::FBT_DEPTH*/ );
        public native void discard( );



        public native RenderTarget getTarget();




        public native double getLeft();




        public native double getTop();





        public native double getWidth();




        public native double getHeight();




        public native int getActualLeft();




        public native int getActualTop();



        public native int getActualWidth();



        public native int getActualHeight();

        public native double getScissorLeft();
        public native double getScissorTop();
        public native double getScissorWidth();
        public native double getScissorHeight();

        public native int getScissorActualLeft();
        public native int getScissorActualTop();
        public native int getScissorActualWidth();
        public native int getScissorActualHeight();
        public native void setDimensions( double left, double top, double width, double height, @Cast("bool") boolean overrideScissors/*=true*/ );
        public native void setDimensions( double left, double top, double width, double height );
        public native void setScissors( double left, double top, double width, double height );



        public native void setOrientationMode(@Cast("Ogre::OrientationMode") int orientationMode, @Cast("bool") boolean setDefault/*=true*/);
        public native void setOrientationMode(@Cast("Ogre::OrientationMode") int orientationMode);



        public native @Cast("Ogre::OrientationMode") int getOrientationMode();



        public static native void setDefaultOrientationMode(@Cast("Ogre::OrientationMode") int orientationMode);



        public static native @Cast("Ogre::OrientationMode") int getDefaultOrientationMode();
        public native void setMaterialScheme(@Const @ByRef String schemeName);



        public native @Const @ByRef String getMaterialScheme();



        public native void getActualDimensions(
                    @ByRef IntPointer left, @ByRef IntPointer top, @ByRef IntPointer width, @ByRef IntPointer height );
        public native void getActualDimensions(
                    @ByRef IntBuffer left, @ByRef IntBuffer top, @ByRef IntBuffer width, @ByRef IntBuffer height );
        public native void getActualDimensions(
                    @ByRef int[] left, @ByRef int[] top, @ByRef int[] width, @ByRef int[] height );

        public native @Cast("bool") boolean _isUpdated();
        public native void _clearUpdatedFlag();
        public native void setOverlaysEnabled(@Cast("bool") boolean enabled);



        public native @Cast("bool") boolean getOverlaysEnabled();
        public native void setSkiesEnabled(@Cast("bool") boolean enabled);



        public native @Cast("bool") boolean getSkiesEnabled();
        public native void _setVisibilityMask(@Cast("Ogre::uint32") int mask);




        public native @Cast("Ogre::uint") int getVisibilityMask();

        public native void setColourWrite( @Cast("bool") boolean colourWrite );

        public native @Cast("bool") boolean getColourWrite();


        public native void pointOrientedToScreen(@Const @ByRef Vector2 v, int orientationMode, @ByRef Vector2 outv);
        public native void pointOrientedToScreen(double orientedX, double orientedY, int orientationMode,
                                           double screenX, double screenY);
        public native void setDrawBuffer(@Cast("Ogre::ColourBufferType") int colourBuffer);


        public native @Cast("Ogre::ColourBufferType") int getDrawBuffer();
    }




    @Namespace("Ogre") public static class WindowEventListener extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public WindowEventListener() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public WindowEventListener(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public WindowEventListener(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public WindowEventListener position(long position) {
            return (WindowEventListener)super.position(position);
        }
    







        public native void windowMoved(RenderWindow rw);







        public native void windowResized(RenderWindow rw);
        public native @Cast("bool") boolean windowClosing(RenderWindow rw);
        public native void windowClosed(RenderWindow rw);







        public native void windowFocusChange(RenderWindow rw);
    }





    @Namespace("Ogre") public static class WindowEventUtilities extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public WindowEventUtilities() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public WindowEventUtilities(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public WindowEventUtilities(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public WindowEventUtilities position(long position) {
            return (WindowEventUtilities)super.position(position);
        }
    





        public static native void messagePump();
        public static native void addWindowEventListener( RenderWindow window, WindowEventListener listener );
        public static native void removeWindowEventListener( RenderWindow window, WindowEventListener listener );
        public static native void _addRenderWindow(RenderWindow window);
        public static native void _removeRenderWindow(RenderWindow window);
        public static native @ByRef @Cast("Ogre::WindowEventUtilities::WindowEventListeners*") WindowEventListenerPtrMultiMapRef _msListeners(); public static native void _msListeners(WindowEventListenerPtrMultiMapRef _msListeners);
        public static native @ByRef @Cast("Ogre::RenderWindowList*") RenderWindowPtrVectorRef _msWindows(); public static native void _msWindows(RenderWindowPtrVectorRef _msWindows);
    }



    @Namespace("Ogre") @NoOffset public static class ShadowCameraSetup extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ShadowCameraSetup(Pointer p) { super(p); }
    

        public native void getShadowCamera(@Const SceneManager sm, @Const Camera cam,
                                              @Const Light light, Camera texCam, @Cast("size_t") long iteration);

        public native double getMinDistance();
        public native double getMaxDistance();
    }
    @Namespace("Ogre") public static class DefaultShadowCameraSetup extends ShadowCameraSetup {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public DefaultShadowCameraSetup(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public DefaultShadowCameraSetup(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public DefaultShadowCameraSetup position(long position) {
            return (DefaultShadowCameraSetup)super.position(position);
        }
    

        public DefaultShadowCameraSetup() { super((Pointer)null); allocate(); }
        private native void allocate();


        public native void getShadowCamera(@Const SceneManager sm, @Const Camera cam,
                                              @Const Light light, Camera texCam, @Cast("size_t") long iteration);
    }





    @Namespace("Ogre") public static class FocusedShadowCameraSetup extends DefaultShadowCameraSetup {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public FocusedShadowCameraSetup(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public FocusedShadowCameraSetup(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public FocusedShadowCameraSetup position(long position) {
            return (FocusedShadowCameraSetup)super.position(position);
        }
    




        public FocusedShadowCameraSetup() { super((Pointer)null); allocate(); }
        private native void allocate();



        public native void getShadowCamera(@Const SceneManager sm, @Const Camera cam,
                                            @Const Light light, Camera texCam, @Cast("size_t") long iteration);

    }










}
