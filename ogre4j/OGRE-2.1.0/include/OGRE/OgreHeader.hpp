
namespace Ogre {
typedef unsigned int uint32;
typedef unsigned short uint16;
typedef unsigned char uint8;
typedef int int32;
typedef short int16;
typedef signed char int8;





    typedef unsigned long long uint64;
    typedef long long int64;
}
namespace Ogre {
        typedef float Real;
        typedef uint32 RealAsUint;
    typedef unsigned char uchar;
    typedef unsigned short ushort;
    typedef unsigned int uint;
    typedef unsigned long ulong;
    struct Aabb;
    class Angle;
    class AnimableValue;
    class ArrayMatrix4;
    class ArrayMatrixAf4x3;
    class ArrayQuaternion;
    class ArrayVector3;
    class ArrayMemoryManager;
    class Archive;
    class ArchiveFactory;
    class ArchiveManager;
    class AsyncTicket;
    class AutoParamDataSource;
    class AxisAlignedBox;
    class AxisAlignedBoxSceneQuery;
    class Barrier;
    class Bone;
    class BoneMemoryManager;
    struct BoneTransform;
    class BufferInterface;
    class BufferPacked;
    class Camera;
    struct CbBase;
    struct CbDrawCallIndexed;
    struct CbDrawCallStrip;
    class Codec;
    class ColourValue;
    class CommandBuffer;
    class ConfigDialog;
    class ConstBufferPacked;
    template <typename T> class Controller;
    template <typename T> class ControllerFunction;
    class ControllerManager;
    template <typename T> class ControllerValue;
    class DataStream;
    class DefaultWorkQueue;
    class Degree;
    class DepthBuffer;
    class DynLib;
    class DynLibManager;
    class ErrorDialog;
    class ExternalTextureSourceManager;
    class Factory;
    class Forward3D;
    struct FrameEvent;
    class FrameListener;
    class Frustum;
    struct GpuLogicalBufferStruct;
    struct GpuNamedConstants;
    class GpuProgramParameters;
    class GpuSharedParameters;
    class GpuProgram;
    class GpuProgramManager;
    class GpuProgramUsage;
    class HardwareOcclusionQuery;
    class HighLevelGpuProgram;
    class HighLevelGpuProgramManager;
    class HighLevelGpuProgramFactory;
    class Hlms;
    struct HlmsBlendblock;
    struct HlmsCache;
    class HlmsDatablock;
    class HlmsListener;
    class HlmsLowLevel;
    class HlmsLowLevelDatablock;
    struct HlmsMacroblock;
    class HlmsManager;
    struct HlmsSamplerblock;
    class HlmsTextureManager;
    struct HlmsTexturePack;
    class IndexBufferPacked;
    class IndirectBufferPacked;
    class InstanceBatch;
    class InstanceBatchHW;
    class InstanceBatchHW_VTF;
    class InstanceBatchShader;
    class InstanceBatchVTF;
    class InstanceManager;
    class InstancedEntity;
    class IntersectionSceneQuery;
    class IntersectionSceneQueryListener;
    class Image;
    class Item;
    struct KfTransform;
    class Light;
    class Log;
    class LogManager;
    class LodStrategy;
    class LodStrategyManager;
    class ManualResourceLoader;
    class Material;
    class MaterialManager;
    class Math;
    class Matrix3;
    class Matrix4;
    class MemoryDataStream;
    class MemoryManager;
    class Mesh;
    class MeshManager;
    class ManualObject;
    class MovableObject;
    class MovablePlane;
    class MultiSourceVertexBufferPool;
 class Node;
    class NodeMemoryManager;
    struct ObjectData;
    class ObjectMemoryManager;
    class Particle;
    class ParticleAffector;
    class ParticleAffectorFactory;
    class ParticleEmitter;
    class ParticleEmitterFactory;
    class ParticleSystem;
    class ParticleSystemManager;
    class ParticleSystemRenderer;
    class ParticleSystemRendererFactory;
    class ParticleVisualData;
    class Pass;
    class PixelBox;
    class Plane;
    class PlaneBoundedVolume;
    class Plugin;
    class Profile;
    class Profiler;
    class Quaternion;
    class Radian;
    class Ray;
    class RaySceneQuery;
    class RaySceneQueryListener;
    class Renderable;
    class RenderPriorityGroup;
    class RenderQueue;
    class RenderQueueListener;
    class RenderObjectListener;
    class RenderSystem;
    class RenderSystemCapabilities;
    class RenderSystemCapabilitiesManager;
    class RenderSystemCapabilitiesSerializer;
    class RenderTarget;
    class RenderTargetListener;
    class RenderTexture;
    class MultiRenderTarget;
    class RenderWindow;
    class Resource;
    class ResourceBackgroundQueue;
    class ResourceGroupManager;
    class ResourceManager;
    class Root;
    class SceneManager;
    class SceneManagerEnumerator;
    class SceneNode;
    class SceneQuery;
    class SceneQueryListener;
    class ScriptCompiler;
    class ScriptCompilerManager;
    class ScriptLoader;
    class Serializer;
    class ShadowCameraSetup;
    class ShadowTextureManager;
    class SimpleMatrixAf4x3;
    class SimpleSpline;
    class SkeletonDef;
    class SkeletonInstance;
    class SkeletonManager;
    class Sphere;
    class SphereSceneQuery;
    class StagingBuffer;
    class StreamSerialiser;
    class StringConverter;
    class StringInterface;
    class SubItem;
    class SubMesh;
    class TagPoint;
    class Technique;
    class TempBlendedBufferInfo;
    class TexBufferPacked;
    class ExternalTextureSource;
    class TextureUnitState;
    class Texture;
    class TextureManager;
    struct Transform;
    class Timer;
    class UserObjectBindings;
    class VaoManager;
    class Vector2;
    class Vector3;
    class Vector4;
    class Viewport;
    class VertexAnimationTrack;
    struct VertexArrayObject;
    class VertexBufferPacked;
    class WireBoundingBox;
    class WorkQueue;
    class CompositorManager2;
    class CompositorWorkspace;

    template<typename T> class SharedPtr;
    typedef SharedPtr<AnimableValue> AnimableValuePtr;
    typedef SharedPtr<AsyncTicket> AsyncTicketPtr;
    typedef SharedPtr<DataStream> DataStreamPtr;
    typedef SharedPtr<GpuProgram> GpuProgramPtr;
    typedef SharedPtr<GpuNamedConstants> GpuNamedConstantsPtr;
    typedef SharedPtr<GpuLogicalBufferStruct> GpuLogicalBufferStructPtr;
    typedef SharedPtr<GpuSharedParameters> GpuSharedParametersPtr;
    typedef SharedPtr<GpuProgramParameters> GpuProgramParametersSharedPtr;
    typedef SharedPtr<HighLevelGpuProgram> HighLevelGpuProgramPtr;
    typedef SharedPtr<Material> MaterialPtr;
    typedef SharedPtr<MemoryDataStream> MemoryDataStreamPtr;
    typedef SharedPtr<Mesh> MeshPtr;
    typedef SharedPtr<Resource> ResourcePtr;
    typedef SharedPtr<ShadowCameraSetup> ShadowCameraSetupPtr;
    typedef SharedPtr<SkeletonDef> SkeletonDefPtr;
    typedef SharedPtr<Texture> TexturePtr;

    namespace v1
    {
        class Animation;
        class AnimationState;
        class AnimationStateSet;
        class AnimationTrack;
        class Billboard;
        class BillboardChain;
        class BillboardSet;
        struct CbRenderOp;
        struct CbDrawCallIndexed;
        struct CbDrawCallStrip;
        class EdgeData;
        class EdgeListBuilder;
        class Entity;
        class HardwareIndexBuffer;
        class HardwareVertexBuffer;
        class HardwarePixelBuffer;
        class HardwarePixelBufferSharedPtr;
        class IndexData;
        class InstanceBatch;
        class InstanceBatchHW;
        class InstanceBatchHW_VTF;
        class InstanceBatchShader;
        class InstanceBatchVTF;
        class InstanceManager;
        class InstancedEntity;
        class KeyFrame;
        class ManualObject;
        class Mesh;
        class MeshManager;
        class NumericAnimationTrack;
        class NumericKeyFrame;
        class OldBone;
        class OldNode;
        class OldNodeAnimationTrack;
        class OldSkeletonInstance;
        class OldSkeletonManager;
        class PatchMesh;
        class Pose;
        class RenderOperation;
        class RenderToVertexBuffer;
        class RibbonTrail;
        class SimpleRenderable;
        class Skeleton;
        class StaticGeometry;
        class SubEntity;
        class SubMesh;
        class TagPoint;
        class TransformKeyFrame;
        class VertexBufferBinding;
        class VertexData;
        class VertexDeclaration;
        class VertexMorphKeyFrame;

        typedef SharedPtr<Mesh> MeshPtr;
        typedef SharedPtr<PatchMesh> PatchMeshPtr;
        typedef SharedPtr<RenderToVertexBuffer> RenderToVertexBufferSharedPtr;
        typedef SharedPtr<Skeleton> SkeletonPtr;
    }
}





namespace Ogre
{
    template <typename T> class FastArray
    {
        T *mData;
        size_t mSize;
        size_t mCapacity;
        void growToFit( size_t newElements )
        {
            if( mSize + newElements > mCapacity )
            {
                mCapacity = std::max( mSize + newElements, mCapacity + (mCapacity >> 1) + 1 );
                T *data = (T*)::operator new( mCapacity * sizeof(T) );
                memcpy( data, mData, mSize * sizeof(T) );
                ::operator delete( mData );
                mData = data;
            }
        }

    public:
        typedef T value_type;

        typedef T* iterator;
        typedef const T* const_iterator;

        FastArray() :
            mData( 0 ),
            mSize( 0 ),
            mCapacity( 0 )
        {
        }

        void swap( FastArray<T> &other )
        {
            std::swap( this->mData, other.mData );
            std::swap( this->mSize, other.mSize );
            std::swap( this->mCapacity, other.mCapacity );
        }

        FastArray( const FastArray<T> &copy ) :
                mSize( copy.mSize ),
                mCapacity( copy.mSize )
        {
            mData = (T*)::operator new( mSize * sizeof(T) );
            for( size_t i=0; i<mSize; ++i )
            {
                new (&mData[i]) T( copy.mData[i] );
            }
        }

        void operator = ( const FastArray<T> &copy )
        {
            if( &copy != this )
            {
                for( size_t i=0; i<mSize; ++i )
                    mData[i].~T();
                ::operator delete( mData );

                mSize = copy.mSize;
                mCapacity = copy.mSize;

                mData = (T*)::operator new( mSize * sizeof(T) );
                for( size_t i=0; i<mSize; ++i )
                {
                    new (&mData[i]) T( copy.mData[i] );
                }
            }
        }


        FastArray( size_t reserveAmount ) :
            mSize( 0 ),
            mCapacity( reserveAmount )
        {
            mData = (T*)::operator new( reserveAmount * sizeof(T) );
        }


        FastArray( size_t count, const T &value ) :
            mSize( count ),
            mCapacity( count )
        {
            mData = (T*)::operator new( count * sizeof(T) );
            for( size_t i=0; i<count; ++i )
            {
                new (&mData[i]) T( value );
            }
        }

        ~FastArray()
        {
            for( size_t i=0; i<mSize; ++i )
                mData[i].~T();
            ::operator delete( mData );
        }

        size_t size() const { return mSize; }
        size_t capacity() const { return mCapacity; }

        void push_back( const T& val )
        {
            growToFit( 1 );
            new (&mData[mSize]) T( val );
            ++mSize;
        }

        void pop_back()
        {
            assert( mSize > 0 && "Can't pop a zero-sized array" );
            --mSize;
            mData[mSize].~T();
        }

        iterator insert( iterator where, const T& val )
        {
            size_t idx = (where - mData);

            growToFit( 1 );

            memmove( mData + idx + 1, mData + idx, (mSize - idx) * sizeof(T) );
            new (&mData[idx]) T( val );
            ++mSize;

            return mData + idx;
        }


        iterator insertPOD( iterator where, const_iterator otherBegin, const_iterator otherEnd )
        {
            size_t idx = (where - mData);

            const size_t otherSize = otherEnd - otherBegin;

            growToFit( otherSize );

            memmove( mData + idx + otherSize, mData + idx, (mSize - idx) * sizeof(T) );

            while( otherBegin != otherEnd )
                *where++ = *otherBegin++;
            mSize += otherSize;

            return mData + idx;
        }

        void appendPOD( const_iterator otherBegin, const_iterator otherEnd )
        {
            growToFit( otherEnd - otherBegin );

            memcpy( mData + mSize, otherBegin, (otherEnd - otherBegin) * sizeof(T) );
            mSize += otherEnd - otherBegin;
        }

        iterator erase( iterator toErase )
        {
            size_t idx = (toErase - mData);
            toErase->~T();
            memmove( mData + idx, mData + idx + 1, (mSize - idx - 1) * sizeof(T) );
            --mSize;

            return mData + idx;
        }

        iterator erase( iterator first, iterator last )
        {
            assert( first <= last && last <= end() );

            size_t idx = (first - mData);
            size_t idxNext = (last - mData);
            while( first != last )
            {
                first->~T();
                ++first;
            }
            memmove( mData + idx, mData + idxNext, (mSize - idxNext) * sizeof(T) );
            mSize -= idxNext - idx;

            return mData + idx;
        }

        iterator erasePOD( iterator first, iterator last )
        {
            assert( first <= last && last <= end() );

            size_t idx = (first - mData);
            size_t idxNext = (last - mData);
            memmove( mData + idx, mData + idxNext, (mSize - idxNext) * sizeof(T) );
            mSize -= idxNext - idx;

            return mData + idx;
        }

        void clear()
        {
            for( size_t i=0; i<mSize; ++i )
                mData[i].~T();
            mSize = 0;
        }

        bool empty() const { return mSize == 0; }

        void reserve( size_t reserveAmount )
        {
            if( reserveAmount > mCapacity )
            {


                mCapacity = reserveAmount;
                T *data = (T*)::operator new( mCapacity * sizeof(T) );
                memcpy( data, mData, mSize * sizeof(T) );
                ::operator delete( mData );
                mData = data;
            }
        }

        void resize( size_t newSize, const T &value=T() )
        {
            if( newSize > mSize )
            {
                growToFit( newSize - mSize );
                for( size_t i=mSize; i<newSize; ++i )
                {
                    new (&mData[i]) T( value );
                }
            }

            mSize = newSize;
        }

        T& operator [] ( size_t idx )
        {
            assert( idx < mSize && "Index out of bounds" );
            return mData[idx];
        }

        const T& operator [] ( size_t idx ) const
        {
            assert( idx < mSize && "Index out of bounds" );
            return mData[idx];
        }

        T& back()
        {
            assert( mSize > 0 && "Can't call back with no elements" );
            return mData[mSize-1];
        }

        const T& back() const
        {
            assert( mSize > 0 && "Can't call back with no elements" );
            return mData[mSize-1];
        }

        T& front()
        {
            assert( mSize > 0 && "Can't call front with no elements" );
            return mData[0];
        }

        const T& front() const
        {
            assert( mSize > 0 && "Can't call front with no elements" );
            return mData[0];
        }

        iterator begin() { return mData; }
        const_iterator begin() const { return mData; }
        iterator end() { return mData + mSize; }
        const_iterator end() const { return mData + mSize; }
    };
}
extern "C" {




}
extern "C" {




}
namespace Ogre
{
    template <class Alloc>
    class AllocatedObject
    {
    public:
        explicit AllocatedObject()
        { }

        ~AllocatedObject()
        { }


        void* operator new(size_t sz, const char* file, int line, const char* func)
        {
            return Alloc::allocateBytes(sz, file, line, func);
        }

        void* operator new(size_t sz)
        {
            return Alloc::allocateBytes(sz);
        }


        void* operator new(size_t sz, void* ptr)
        {
            (void) sz;
            return ptr;
        }


        void* operator new[] ( size_t sz, const char* file, int line, const char* func )
        {
            return Alloc::allocateBytes(sz, file, line, func);
        }

        void* operator new[] ( size_t sz )
        {
            return Alloc::allocateBytes(sz);
        }

        void operator delete( void* ptr )
        {
            Alloc::deallocateBytes(ptr);
        }


        void operator delete( void* ptr, void* )
        {
            Alloc::deallocateBytes(ptr);
        }


        void operator delete( void* ptr, const char* , int , const char* )
        {
            Alloc::deallocateBytes(ptr);
        }

        void operator delete[] ( void* ptr )
        {
            Alloc::deallocateBytes(ptr);
        }


        void operator delete[] ( void* ptr, const char* , int , const char* )
        {
            Alloc::deallocateBytes(ptr);
        }
    };





}


namespace Ogre
{
    enum MemoryCategory
    {

        MEMCATEGORY_GENERAL = 0,

        MEMCATEGORY_GEOMETRY = 1,

        MEMCATEGORY_ANIMATION = 2,

        MEMCATEGORY_SCENE_CONTROL = 3,

        MEMCATEGORY_SCENE_OBJECTS = 4,

        MEMCATEGORY_RESOURCE = 5,

        MEMCATEGORY_SCRIPTING = 6,

        MEMCATEGORY_RENDERSYS = 7,



        MEMCATEGORY_COUNT = 8
    };



}




namespace Ogre
{
    template<typename T>
    struct STLAllocatorBase
    {
        typedef T value_type;
    };


    template<typename T>
    struct STLAllocatorBase<const T>
    {
        typedef T value_type;
    };

    template
        <
        typename T,
        typename AllocPolicy
        >
    class STLAllocator : public STLAllocatorBase<T>
    {
    public :

        typedef STLAllocatorBase<T> Base;
        typedef typename Base::value_type value_type;
        typedef value_type* pointer;
        typedef const value_type* const_pointer;
        typedef value_type& reference;
        typedef const value_type& const_reference;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;



        template<typename U>
        struct rebind
        {
            typedef STLAllocator<U, AllocPolicy> other;
        };


        inline explicit STLAllocator()
        { }


        virtual ~STLAllocator()
        { }


        inline STLAllocator( STLAllocator const& )
        { }


        template <typename U>
        inline STLAllocator( STLAllocator<U, AllocPolicy> const& )
        { }


        template <typename U, typename P>
        inline STLAllocator( STLAllocator<U, P> const& )
        { }


        inline pointer allocate( size_type count,
            typename std::allocator<void>::const_pointer ptr = 0 )
        {
                        (void)ptr;

                     size_type sz = count*sizeof( T );
            pointer p = static_cast<pointer>(AllocPolicy::allocateBytes(sz));
            return p;
        }


        inline void deallocate( pointer ptr, size_type )
        {


            AllocPolicy::deallocateBytes(ptr);
        }

        pointer address(reference x) const
        {
            return &x;
        }

        const_pointer address(const_reference x) const
        {
            return &x;
        }

        size_type max_size() const throw()
        {

            return AllocPolicy::getMaxAllocationSize();
        }
        void construct(pointer p, const T& val)
        {

            new(static_cast<void*>(p)) T(val);
        }

        void destroy(pointer p)
        {


            p->~T();
        }
    };



    template<typename T, typename T2, typename P>
    inline bool operator==(STLAllocator<T,P> const&,
        STLAllocator<T2,P> const&)
    {

        return true;
    }



    template<typename T, typename P, typename OtherAllocator>
    inline bool operator==(STLAllocator<T,P> const&,
        OtherAllocator const&)
    {
        return false;
    }


    template<typename T, typename T2, typename P>
    inline bool operator!=(STLAllocator<T,P> const&,
        STLAllocator<T2,P> const&)
    {

        return false;
    }



    template<typename T, typename P, typename OtherAllocator>
    inline bool operator!=(STLAllocator<T,P> const&,
        OtherAllocator const&)
    {
        return true;
    }





}







namespace Ogre
{
    class NedPoolingImpl
    {
    public:
        static __attribute__ ((malloc)) void* allocBytes(size_t count,
            const char* file, int line, const char* func);
        static void deallocBytes(void* ptr);
        static __attribute__ ((malloc)) void* allocBytesAligned(size_t align, size_t count,
            const char* file, int line, const char* func);
        static void deallocBytesAligned(size_t align, void* ptr);

    };
    class NedPoolingPolicy
    {
    public:
        static inline __attribute__ ((malloc)) void* allocateBytes(size_t count,
            const char* file = 0, int line = 0, const char* func = 0)
        {
            return NedPoolingImpl::allocBytes(count, file, line, func);
        }
        static inline void deallocateBytes(void* ptr)
        {
            NedPoolingImpl::deallocBytes(ptr);
        }

        static inline size_t getMaxAllocationSize()
        {
            return std::numeric_limits<size_t>::max();
        }

    private:

        NedPoolingPolicy()
        { }
    };
    template <size_t Alignment = 0>
    class NedPoolingAlignedPolicy
    {
    public:

        typedef int IsValidAlignment
            [Alignment <= 128 && ((Alignment & (Alignment-1)) == 0) ? +1 : -1];

        static inline __attribute__ ((malloc)) void* allocateBytes(size_t count,
            const char* file = 0, int line = 0, const char* func = 0)
        {
            return NedPoolingImpl::allocBytesAligned(Alignment, count, file, line, func);
        }

        static inline void deallocateBytes(void* ptr)
        {
            NedPoolingImpl::deallocBytesAligned(Alignment, ptr);
        }


        static inline size_t getMaxAllocationSize()
        {
            return std::numeric_limits<size_t>::max();
        }
    private:

        NedPoolingAlignedPolicy()
        { }
    };







}


namespace Ogre
{






    template <MemoryCategory Cat> class CategorisedAllocPolicy : public NedPoolingPolicy{};
    template <MemoryCategory Cat, size_t align = 0> class CategorisedAlignAllocPolicy : public NedPoolingAlignedPolicy<align>{};
}
namespace Ogre
{

    typedef CategorisedAllocPolicy<Ogre::MEMCATEGORY_GENERAL> GeneralAllocPolicy;
    typedef CategorisedAllocPolicy<Ogre::MEMCATEGORY_GEOMETRY> GeometryAllocPolicy;
    typedef CategorisedAllocPolicy<Ogre::MEMCATEGORY_ANIMATION> AnimationAllocPolicy;
    typedef CategorisedAllocPolicy<Ogre::MEMCATEGORY_SCENE_CONTROL> SceneCtlAllocPolicy;
    typedef CategorisedAllocPolicy<Ogre::MEMCATEGORY_SCENE_OBJECTS> SceneObjAllocPolicy;
    typedef CategorisedAllocPolicy<Ogre::MEMCATEGORY_RESOURCE> ResourceAllocPolicy;
    typedef CategorisedAllocPolicy<Ogre::MEMCATEGORY_SCRIPTING> ScriptingAllocPolicy;
    typedef CategorisedAllocPolicy<Ogre::MEMCATEGORY_RENDERSYS> RenderSysAllocPolicy;

    typedef CategorisedAlignAllocPolicy<Ogre::MEMCATEGORY_RESOURCE> ResourceSimdAllocPolicy;
    typedef CategorisedAlignAllocPolicy<Ogre::MEMCATEGORY_SCENE_CONTROL> SceneCtlAlignPolicy;


    typedef AllocatedObject<GeneralAllocPolicy> GeneralAllocatedObject;
    typedef AllocatedObject<GeometryAllocPolicy> GeometryAllocatedObject;
    typedef AllocatedObject<AnimationAllocPolicy> AnimationAllocatedObject;
    typedef AllocatedObject<SceneCtlAllocPolicy> SceneCtlAllocatedObject;
    typedef AllocatedObject<SceneObjAllocPolicy> SceneObjAllocatedObject;
    typedef AllocatedObject<ResourceAllocPolicy> ResourceAllocatedObject;
    typedef AllocatedObject<ScriptingAllocPolicy> ScriptingAllocatedObject;
    typedef AllocatedObject<RenderSysAllocPolicy> RenderSysAllocatedObject;

    typedef AllocatedObject<ResourceSimdAllocPolicy> ResourceSimdAllocObject;
    typedef AllocatedObject<SceneCtlAlignPolicy> SceneCtlAlignedObject;






    typedef ScriptingAllocatedObject AbstractNodeAlloc;
    typedef AnimationAllocatedObject AnimableAlloc;
    typedef AnimationAllocatedObject AnimationAlloc;
    typedef GeneralAllocatedObject ArchiveAlloc;
    typedef GeometryAllocatedObject BatchedGeometryAlloc;
    typedef RenderSysAllocatedObject BufferAlloc;
    typedef GeometryAllocatedObject BufferPackedAlloc;
    typedef GeneralAllocatedObject CodecAlloc;
    typedef ResourceAllocatedObject CompositorInstAlloc;
    typedef GeneralAllocatedObject ConfigAlloc;
    typedef GeneralAllocatedObject ControllerAlloc;
    typedef GeometryAllocatedObject DebugGeomAlloc;
    typedef GeneralAllocatedObject DynLibAlloc;
    typedef GeometryAllocatedObject EdgeDataAlloc;
    typedef GeneralAllocatedObject FactoryAlloc;
    typedef SceneObjAllocatedObject FXAlloc;
    typedef GeneralAllocatedObject ImageAlloc;
    typedef GeometryAllocatedObject IndexDataAlloc;
    typedef GeneralAllocatedObject LogAlloc;
    typedef SceneObjAllocatedObject MovableAlloc;
    typedef SceneCtlAllocatedObject NodeAlloc;
    typedef SceneObjAllocatedObject OverlayAlloc;
    typedef RenderSysAllocatedObject GpuParamsAlloc;
    typedef ResourceAllocatedObject PassAlloc;
    typedef ResourceSimdAllocObject HlmsAlloc;
    typedef GeometryAllocatedObject PatchAlloc;
    typedef GeneralAllocatedObject PluginAlloc;
    typedef GeneralAllocatedObject ProfilerAlloc;
    typedef GeometryAllocatedObject ProgMeshAlloc;
    typedef SceneCtlAllocatedObject RenderQueueAlloc;
    typedef RenderSysAllocatedObject RenderSysAlloc;
    typedef GeneralAllocatedObject RootAlloc;
    typedef ResourceAllocatedObject ResourceAlloc;
    typedef GeneralAllocatedObject SerializerAlloc;
    typedef SceneCtlAlignedObject SceneMgtAlignedAlloc;
    typedef SceneCtlAllocatedObject SceneMgtAlloc;
    typedef ScriptingAllocatedObject ScriptCompilerAlloc;
    typedef ScriptingAllocatedObject ScriptTranslatorAlloc;
    typedef SceneCtlAllocatedObject ShadowDataAlloc;
    typedef GeometryAllocatedObject StagingBufferAlloc;
    typedef GeneralAllocatedObject StreamAlloc;
    typedef SceneObjAllocatedObject SubEntityAlloc;
    typedef ResourceAllocatedObject SubMeshAlloc;
    typedef ResourceAllocatedObject TechniqueAlloc;
    typedef GeneralAllocatedObject TimerAlloc;
    typedef ResourceAllocatedObject TextureUnitStateAlloc;
    typedef GeneralAllocatedObject UtilityAlloc;
    typedef GeometryAllocatedObject VertexDataAlloc;
    typedef GeometryAllocatedObject VertexArrayObjectAlloc;
    typedef RenderSysAllocatedObject ViewportAlloc;
    typedef SceneCtlAllocatedObject LodAlloc;
    typedef GeneralAllocatedObject FileSystemLayerAlloc;
    typedef GeneralAllocatedObject StereoDriverAlloc;
}


namespace Ogre
{
    template<typename T>
    T* constructN(T* basePtr, size_t count)
    {
        for (size_t i = 0; i < count; ++i)
        {
            new ((void*)(basePtr+i)) T();
        }
        return basePtr;
    }



}
namespace Ogre
{




    template<typename T>
    void deletePtr(T* ptr)
    {
        delete ptr;
    }
}








namespace Ogre
{
        typedef std::string _StringBase;





        typedef std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > _StringStreamBase;




    typedef _StringBase String;
    typedef _StringStreamBase StringStream;
    typedef StringStream stringstream;

}
namespace Ogre
{
    template <typename T, typename A = STLAllocator<T, GeneralAllocPolicy> >
    struct deque
    {

        typedef typename std::deque<T, A> type;
        typedef typename std::deque<T, A>::iterator iterator;
        typedef typename std::deque<T, A>::const_iterator const_iterator;





    };

    template <typename T, typename A = STLAllocator<T, GeneralAllocPolicy> >
    struct vector
    {

        typedef typename std::vector<T, A> type;
        typedef typename std::vector<T, A>::iterator iterator;
        typedef typename std::vector<T, A>::const_iterator const_iterator;





    };

    template <typename T, typename A = STLAllocator<T, GeneralAllocPolicy> >
    struct list
    {

        typedef typename std::list<T, A> type;
        typedef typename std::list<T, A>::iterator iterator;
        typedef typename std::list<T, A>::const_iterator const_iterator;





    };

    template <typename T, typename P = std::less<T>, typename A = STLAllocator<T, GeneralAllocPolicy> >
    struct set
    {

        typedef typename std::set<T, P, A> type;
        typedef typename std::set<T, P, A>::iterator iterator;
        typedef typename std::set<T, P, A>::const_iterator const_iterator;





    };

    template <typename K, typename V, typename P = std::less<K>, typename A = STLAllocator<std::pair<const K, V>, GeneralAllocPolicy> >
    struct map
    {

        typedef typename std::map<K, V, P, A> type;
        typedef typename std::map<K, V, P, A>::iterator iterator;
        typedef typename std::map<K, V, P, A>::const_iterator const_iterator;





    };

    template <typename K, typename V, typename P = std::less<K>, typename A = STLAllocator<std::pair<const K, V>, GeneralAllocPolicy> >
    struct multimap
    {

        typedef typename std::multimap<K, V, P, A> type;
        typedef typename std::multimap<K, V, P, A>::iterator iterator;
        typedef typename std::multimap<K, V, P, A>::const_iterator const_iterator;





    };

    template <typename K, typename V, typename H = ::std::tr1::hash<K>, typename E = std::equal_to<K>, typename A = STLAllocator<std::pair<const K, V>, GeneralAllocPolicy> >
    struct unordered_map
    {

        typedef typename ::std::tr1::unordered_map<K, V, H, E, A> type;



        typedef typename type::iterator iterator;
        typedef typename type::const_iterator const_iterator;
    };

    template <typename K, typename V, typename H = ::std::tr1::hash<K>, typename E = std::equal_to<K>, typename A = STLAllocator<std::pair<const K, V>, GeneralAllocPolicy> >
    struct unordered_multimap
    {

        typedef typename ::std::tr1::unordered_multimap<K, V, H, E, A> type;



        typedef typename type::iterator iterator;
        typedef typename type::const_iterator const_iterator;
    };

    template <typename K, typename H = ::std::tr1::hash<K>, typename E = std::equal_to<K>, typename A = STLAllocator<K, GeneralAllocPolicy> >
    struct unordered_set
    {

        typedef typename ::std::tr1::unordered_set<K, H, E, A> type;



        typedef typename type::iterator iterator;
        typedef typename type::const_iterator const_iterator;
    };

    template <typename K, typename H = ::std::tr1::hash<K>, typename E = std::equal_to<K>, typename A = STLAllocator<K, GeneralAllocPolicy> >
    struct unordered_multiset
    {

        typedef typename ::std::tr1::unordered_multiset<K, H, E, A> type;



        typedef typename type::iterator iterator;
        typedef typename type::const_iterator const_iterator;
    };

}


namespace Ogre{
template <typename T, typename IteratorType, typename ValType>
class IteratorWrapper
{

    private:

        IteratorWrapper();

    protected:
        IteratorType mBegin;
        IteratorType mCurrent;
        IteratorType mEnd;


    public:


        typedef ValType ValueType;

        typedef ValType* PointerType;
        typedef IteratorType iterator;
        typedef IteratorType const_iterator;






        IteratorWrapper ( IteratorType start, IteratorType last )
        : mBegin( start ), mCurrent ( start ), mEnd ( last )
        {
        }



        bool hasMoreElements ( ) const
        {
            return mCurrent != mEnd;
        }



        void moveNext ( )
        {
            ++mCurrent;
        }


        const IteratorType& begin() {return mBegin;}



        IteratorType& current(){return mCurrent;}


        const IteratorType& end() {return mEnd;}


};
template <typename T, typename IteratorType>
class VectorIteratorWrapper : public IteratorWrapper<T, IteratorType, typename T::value_type>
{

    public:
        typedef typename IteratorWrapper<T, IteratorType, typename T::value_type>::ValueType ValueType ;
        typedef typename IteratorWrapper<T, IteratorType, typename T::value_type>::PointerType PointerType ;
        VectorIteratorWrapper ( IteratorType start, IteratorType last )
        : IteratorWrapper<T, IteratorType, typename T::value_type>( start, last )
        {
        }



        ValueType peekNext ( ) const
        {
            return *(this->mCurrent);
        }


        PointerType peekNextPtr ( ) const
        {
            return &(*(this->mCurrent) );
        }


        ValueType getNext ( )
        {
            return *(this->mCurrent++);
        }

};
template <typename T>
class VectorIterator : public VectorIteratorWrapper<T, typename T::iterator>{
    public:




        VectorIterator( typename T::iterator start, typename T::iterator last )
        : VectorIteratorWrapper<T, typename T::iterator>(start , last )
        {
        }





        explicit VectorIterator( T& c )
        : VectorIteratorWrapper<T, typename T::iterator> ( c.begin(), c.end() )
        {
        }

};
template <typename T>
class ConstVectorIterator : public VectorIteratorWrapper<T, typename T::const_iterator>{
    public:




        ConstVectorIterator( typename T::const_iterator start, typename T::const_iterator last )
        : VectorIteratorWrapper<T, typename T::const_iterator> (start , last )
        {
        }





        explicit ConstVectorIterator ( const T& c )
         : VectorIteratorWrapper<T, typename T::const_iterator> (c.begin() , c.end() )
        {
        }
};
template <typename T, typename IteratorType>
class MapIteratorWrapper : public IteratorWrapper<T, IteratorType, typename T::mapped_type>
{

    public:

        typedef typename IteratorWrapper<T, IteratorType, typename T::mapped_type>::ValueType ValueType ;

        typedef typename IteratorWrapper<T, IteratorType, typename T::mapped_type>::PointerType PointerType ;


        typedef typename T::value_type PairType ;

        typedef typename T::key_type KeyType;





        MapIteratorWrapper ( IteratorType start, IteratorType last )
        : IteratorWrapper<T, IteratorType, typename T::mapped_type>( start, last )
        {
        }


        KeyType peekNextKey(void) const
        {
            return this->mCurrent->first;
        }



        ValueType peekNextValue ( ) const
        {
            return this->mCurrent->second;
        }




        const PointerType peekNextValuePtr ( ) const
        {
            return &(this->mCurrent->second);
        }



        ValueType getNext()
        {
            return ((this->mCurrent++)->second) ;
        }


};
template <typename T>
class MapIterator : public MapIteratorWrapper<T, typename T::iterator>{
    public:





        MapIterator( typename T::iterator start, typename T::iterator last )
        : MapIteratorWrapper<T, typename T::iterator>(start , last )
        {
        }





        explicit MapIterator( T& c )
        : MapIteratorWrapper<T, typename T::iterator> ( c.begin(), c.end() )
        {
        }

};
template <typename T>
class ConstMapIterator : public MapIteratorWrapper<T, typename T::const_iterator>{
    public:





        ConstMapIterator( typename T::const_iterator start, typename T::const_iterator last )
        : MapIteratorWrapper<T, typename T::const_iterator> (start , last )
        {
        }





        explicit ConstMapIterator ( const T& c )
         : MapIteratorWrapper<T, typename T::const_iterator> (c.begin() , c.end() )
        {
        }
};




}





#pragma GCC diagnostic push



#pragma GCC diagnostic ignored "-Wdocumentation"

#pragma GCC diagnostic ignored "-Wshadow"
#pragma GCC diagnostic ignored "-Wpadded"
#pragma GCC diagnostic ignored "-Wweak-vtables"
#pragma GCC diagnostic ignored "-Wall"
#pragma GCC diagnostic ignored "-Wundef"





#pragma GCC diagnostic pop



namespace Ogre {
template <typename T>
class iterator_range{
        public: typedef boost::iterator_range<T> type ;


};
template<typename T>
struct VectorRange : public iterator_range<typename T::iterator>::type
{





    VectorRange( T& c )
    : iterator_range<typename T::iterator>::type( c.begin(), c.end() )
    {}





    VectorRange( typename T::iterator b, typename T::iterator e )
    : iterator_range<typename T::iterator>::type( b, e )
    {}


    bool operator==( const VectorRange& rhs ) const { return equal( rhs) ; }

    bool operator!=( const VectorRange& rhs ) const { return !equal( rhs) ; }




    operator VectorIterator<T>(){return VectorIterator<T>( this->begin(), this->end());}

    operator ConstVectorIterator<T>(){return ConstVectorIterator<T>( this->begin(), this->end());}


};
template<typename T>
struct ConstVectorRange : public iterator_range<typename T::const_iterator>::type
{





    ConstVectorRange( const T& c )
    : iterator_range<typename T::const_iterator>::type( c.begin(), c.end() )
    {}





    ConstVectorRange( typename T::iterator b, typename T::iterator e )
    : iterator_range<typename T::const_iterator>::type( b, e )
    {}





    ConstVectorRange( typename T::const_iterator b, typename T::const_iterator e )
    : iterator_range<typename T::const_iterator>::type( b, e )
    {}





    ConstVectorRange( const VectorRange<T>& rhs )
    : iterator_range<typename T::const_iterator>::type( rhs.begin(), rhs.end() )
    {}


    bool operator==( const ConstVectorRange& rhs ) const { return equal( rhs) ; }

    bool operator!=( const ConstVectorRange& rhs ) const { return !equal( rhs) ; }






    operator ConstVectorIterator<T>(){return ConstVectorIterator<T>( this->begin(),this->end());}


};
template<typename T>
struct MapRange : public iterator_range<typename T::iterator>::type
{




    MapRange( T& c )
    : iterator_range<typename T::iterator>::type( c.begin(), c.end() )
    {}





    MapRange( typename T::iterator b, typename T::iterator e )
    : iterator_range<typename T::iterator>::type( b, e )
    {}


    bool operator==( const MapRange& rhs ) const { return equal( rhs) ; }

    bool operator!=( const MapRange& rhs ) const { return !equal( rhs) ; }




    operator MapIterator<T>(){return MapIterator<T>( this->begin(), this->end());}

    operator ConstMapIterator<T>(){return ConstMapIterator<T>( this->begin(), this->end());}


};
template<typename T>
struct ConstMapRange : public iterator_range<typename T::const_iterator>::type
{





    ConstMapRange( const T& c )
    : iterator_range<typename T::const_iterator>::type( c.begin(), c.end() )
    {}





    ConstMapRange( typename T::iterator b, typename T::iterator e )
    : iterator_range<typename T::const_iterator>::type( b, e )
    {}





    ConstMapRange( typename T::const_iterator b, typename T::const_iterator e )
    : iterator_range<typename T::const_iterator>::type( b, e )
    {}





    ConstMapRange( const MapRange<T>& rhs )
    : iterator_range<typename T::const_iterator>::type( rhs.begin(), rhs.end() )
    {}


    bool operator==( const ConstMapRange& rhs ) const { return equal( rhs) ; }

    bool operator!=( const ConstMapRange& rhs ) const { return !equal( rhs) ; }




    operator ConstMapIterator<T>(){return ConstMapIterator<T>( this->begin(),this->end());}


};



}

namespace Ogre {
    class PlatformInformation
    {
    public:


        enum CpuFeatures
        {

            CPU_FEATURE_SSE = 1 << 0,
            CPU_FEATURE_SSE2 = 1 << 1,
            CPU_FEATURE_SSE3 = 1 << 2,
            CPU_FEATURE_MMX = 1 << 3,
            CPU_FEATURE_MMXEXT = 1 << 4,
            CPU_FEATURE_3DNOW = 1 << 5,
            CPU_FEATURE_3DNOWEXT = 1 << 6,
            CPU_FEATURE_CMOV = 1 << 7,
            CPU_FEATURE_TSC = 1 << 8,
            CPU_FEATURE_FPU = 1 << 9,
            CPU_FEATURE_PRO = 1 << 10,
            CPU_FEATURE_HTT = 1 << 11,







            CPU_FEATURE_NONE = 0
        };






        static const String& getCpuIdentifier(void);






        static uint getCpuFeatures(void);






        static bool hasCpuFeature(CpuFeatures feature);





        static uint32 getNumLogicalCores(void);



        static void log(Log* pLog);

    };



}

namespace Ogre {
    typedef _StringBase String;
    uint32 FastHash (const char * data, int len, uint32 hashSoFar = 0);

    template <typename T>
    uint32 HashCombine (uint32 hashSoFar, const T& data)
    {
        return FastHash((const char*)&data, sizeof(T), hashSoFar);
    }

    enum VertexPass
    {
        VpNormal,
        VpShadow,
        NumVertexPass
    };




    enum CompareFunction
    {
        CMPF_ALWAYS_FAIL,
        CMPF_ALWAYS_PASS,
        CMPF_LESS,
        CMPF_LESS_EQUAL,
        CMPF_EQUAL,
        CMPF_NOT_EQUAL,
        CMPF_GREATER_EQUAL,
        CMPF_GREATER,
        NUM_COMPARE_FUNCTIONS,
    };


    enum StencilOperation
    {

        SOP_KEEP,

        SOP_ZERO,

        SOP_REPLACE,

        SOP_INCREMENT,

        SOP_DECREMENT,

        SOP_INCREMENT_WRAP,

        SOP_DECREMENT_WRAP,

        SOP_INVERT
    };



    enum TextureFilterOptions
    {

        TFO_NONE,

        TFO_BILINEAR,

        TFO_TRILINEAR,

        TFO_ANISOTROPIC
    };

    enum FilterType
    {

        FT_MIN,

        FT_MAG,

        FT_MIP
    };

    enum FilterOptions
    {

        FO_NONE,

        FO_POINT,

        FO_LINEAR,

        FO_ANISOTROPIC
    };


    enum ShadeOptions
    {
        SO_FLAT,
        SO_GOURAUD,
        SO_PHONG
    };


    enum FogMode
    {

        FOG_NONE,

        FOG_EXP,

        FOG_EXP2,

        FOG_LINEAR
    };
    enum CullingMode
    {

        CULL_NONE = 1,

        CULL_CLOCKWISE = 2,

        CULL_ANTICLOCKWISE = 3
    };


    enum WaveformType
    {

        WFT_SINE,

        WFT_TRIANGLE,

        WFT_SQUARE,

        WFT_SAWTOOTH,

        WFT_INVERSE_SAWTOOTH,


        WFT_PWM
    };


    enum PolygonMode
    {

        PM_POINTS = 1,

        PM_WIREFRAME = 2,

        PM_SOLID = 3
    };


    typedef int TrackVertexColourType;
    enum TrackVertexColourEnum {
        TVC_NONE = 0x0,
        TVC_AMBIENT = 0x1,
        TVC_DIFFUSE = 0x2,
        TVC_SPECULAR = 0x4,
        TVC_EMISSIVE = 0x8
    };


    enum SortMode
    {

        SM_DIRECTION,

        SM_DISTANCE
    };


    enum FrameBufferType {
        FBT_COLOUR = 0x1,
        FBT_DEPTH = 0x2,
        FBT_STENCIL = 0x4
    };


    enum ColourBufferType
    {
      CBT_BACK = 0x0,
      CBT_BACK_LEFT,
      CBT_BACK_RIGHT
    };


    enum StereoModeType
    {
      SMT_NONE = 0x0,
      SMT_FRAME_SEQUENTIAL
    };

    enum ShaderType
    {
        VertexShader,
        PixelShader,
        GeometryShader,
        HullShader,
        DomainShader,
        NumShaderTypes
    };


    enum InstanceManagerFlags
    {



        IM_USE16BIT = 0x0001,



        IM_VTFBESTFIT = 0x0002,



        IM_VTFBONEMATRIXLOOKUP = 0x0004,

        IM_USEBONEDUALQUATERNIONS = 0x0008,


        IM_USEONEWEIGHT = 0x0010,


        IM_FORCEONEWEIGHT = 0x0020,

        IM_USEALL = IM_USE16BIT|IM_VTFBESTFIT|IM_USEONEWEIGHT
    };
    enum SceneMemoryMgrTypes
    {
        SCENE_DYNAMIC = 0,
        SCENE_STATIC,
        NUM_SCENE_MEMORY_MANAGER_TYPES
    };



    template <typename T>
    class HashedVector
    {
    public:
        typedef std::vector<T, STLAllocator<T, GeneralAllocPolicy> > VectorImpl;
    protected:
        VectorImpl mList;
        mutable uint32 mListHash;
        mutable bool mListHashDirty;

        void addToHash(const T& newPtr) const
        {
            mListHash = FastHash((const char*)&newPtr, sizeof(T), mListHash);
        }
        void recalcHash() const
        {
            mListHash = 0;
            for (const_iterator i = mList.begin(); i != mList.end(); ++i)
                addToHash(*i);
            mListHashDirty = false;

        }

    public:
        typedef typename VectorImpl::value_type value_type;
        typedef typename VectorImpl::pointer pointer;
        typedef typename VectorImpl::reference reference;
        typedef typename VectorImpl::const_reference const_reference;
        typedef typename VectorImpl::size_type size_type;
        typedef typename VectorImpl::difference_type difference_type;
        typedef typename VectorImpl::iterator iterator;
        typedef typename VectorImpl::const_iterator const_iterator;
        typedef typename VectorImpl::reverse_iterator reverse_iterator;
        typedef typename VectorImpl::const_reverse_iterator const_reverse_iterator;

        void dirtyHash()
        {
            mListHashDirty = true;
        }
        bool isHashDirty() const
        {
            return mListHashDirty;
        }

        iterator begin()
        {

            dirtyHash();
            return mList.begin();
        }
        iterator end() { return mList.end(); }
        const_iterator begin() const { return mList.begin(); }
        const_iterator end() const { return mList.end(); }
        reverse_iterator rbegin()
        {

            dirtyHash();
            return mList.rbegin();
        }
        reverse_iterator rend() { return mList.rend(); }
        const_reverse_iterator rbegin() const { return mList.rbegin(); }
        const_reverse_iterator rend() const { return mList.rend(); }
        size_type size() const { return mList.size(); }
        size_type max_size() const { return mList.max_size(); }
        size_type capacity() const { return mList.capacity(); }
        bool empty() const { return mList.empty(); }
        reference operator[](size_type n)
        {

            dirtyHash();
            return mList[n];
        }
        const_reference operator[](size_type n) const { return mList[n]; }
        reference at(size_type n)
        {

            dirtyHash();
            return mList.const_iterator(n);
        }
        const_reference at(size_type n) const { return mList.at(n); }
        HashedVector() : mListHash(0), mListHashDirty(false) {}
        HashedVector(size_type n) : mList(n), mListHash(0), mListHashDirty(n > 0) {}
        HashedVector(size_type n, const T& t) : mList(n, t), mListHash(0), mListHashDirty(n > 0) {}
        HashedVector(const HashedVector<T>& rhs)
            : mList(rhs.mList), mListHash(rhs.mListHash), mListHashDirty(rhs.mListHashDirty) {}

        template <class InputIterator>
        HashedVector(InputIterator a, InputIterator b)
            : mList(a, b), mListHash(0), mListHashDirty(false)
        {
            dirtyHash();
        }

        ~HashedVector() {}
        HashedVector<T>& operator=(const HashedVector<T>& rhs)
        {
            mList = rhs.mList;
            mListHash = rhs.mListHash;
            mListHashDirty = rhs.mListHashDirty;
            return *this;
        }

        void reserve(size_t t) { mList.reserve(t); }
        reference front()
        {

            dirtyHash();
            return mList.front();
        }
        const_reference front() const { return mList.front(); }
        reference back()
        {

            dirtyHash();
            return mList.back();
        }
        const_reference back() const { return mList.back(); }
        void push_back(const T& t)
        {
            mList.push_back(t);

            if (!isHashDirty())
                addToHash(t);
        }
        void pop_back()
        {
            mList.pop_back();
            dirtyHash();
        }
        void swap(HashedVector<T>& rhs)
        {
            mList.swap(rhs.mList);
            dirtyHash();
        }
        iterator insert(iterator pos, const T& t)
        {
            bool recalc = (pos != end());
            iterator ret = mList.insert(pos, t);
            if (recalc)
                dirtyHash();
            else
                addToHash(t);
            return ret;
        }

        template <class InputIterator>
        void insert(iterator pos,
            InputIterator f, InputIterator l)
        {
            mList.insert(pos, f, l);
            dirtyHash();
        }

        void insert(iterator pos, size_type n, const T& x)
        {
            mList.insert(pos, n, x);
            dirtyHash();
        }

        iterator erase(iterator pos)
        {
            iterator ret = mList.erase(pos);
            dirtyHash();
            return ret;
        }
        iterator erase(iterator first, iterator last)
        {
            iterator ret = mList.erase(first, last);
            dirtyHash();
            return ret;
        }
        void clear()
        {
            mList.clear();
            mListHash = 0;
            mListHashDirty = false;
        }

        void resize(size_type n, const T& t = T())
        {
            bool recalc = false;
            if (n != size())
                recalc = true;

            mList.resize(n, t);
            if (recalc)
                dirtyHash();
        }

        bool operator==(const HashedVector<T>& b)
        { return mListHash == b.mListHash; }

        bool operator<(const HashedVector<T>& b)
        { return mListHash < b.mListHash; }



        uint32 getHash() const
        {
            if (isHashDirty())
                recalcHash();

            return mListHash;
        }
    public:



    };

    class Light;
    typedef FastArray<Light*> LightArray;


    struct LightClosest
    {
        Light const *light;
        size_t globalIndex;
        Real distance;

        LightClosest() : light( 0 ),globalIndex(0),distance( 0.0f ) {}
        LightClosest( Light *_light, size_t _globalIndex, Real _distance ) :
            light( _light ), globalIndex( _globalIndex ),
            distance( _distance ) {}

        inline bool operator < ( const LightClosest &right ) const
        {
            return distance < right.distance;
        }
    };

    struct LightListInfo
    {
        LightArray lights;

        uint32 * __restrict__ visibilityMask;
        Sphere * __restrict__ boundingSphere;

        LightListInfo() : visibilityMask(0), boundingSphere(0) {}
        ~LightListInfo()
        {
            ::Ogre::CategorisedAlignAllocPolicy<MEMCATEGORY_SCENE_CONTROL>::deallocateBytes((void*)visibilityMask);
            ::Ogre::CategorisedAlignAllocPolicy<MEMCATEGORY_SCENE_CONTROL>::deallocateBytes((void*)boundingSphere);
        }
    };
    typedef HashedVector<LightClosest> LightList;
    typedef vector<LightClosest>::type LightClosestVec;
    typedef FastArray<LightClosest> LightClosestArray;


    const String BLANKSTRING;

    typedef map<String, bool>::type UnaryOptionList;
    typedef map<String, String>::type BinaryOptionList;


    typedef map<String, String>::type NameValuePairList;


    typedef map<String, String>::type AliasTextureNamePairList;

        template< typename T > struct TRect
        {
          T left, top, right, bottom;
          TRect() : left(0), top(0), right(0), bottom(0) {}
          TRect( T const & l, T const & t, T const & r, T const & b )
            : left( l ), top( t ), right( r ), bottom( b )
          {
          }
          TRect( TRect const & o )
            : left( o.left ), top( o.top ), right( o.right ), bottom( o.bottom )
          {
          }
          TRect & operator=( TRect const & o )
          {
            left = o.left;
            top = o.top;
            right = o.right;
            bottom = o.bottom;
            return *this;
          }
          T width() const
          {
            return right - left;
          }
          T height() const
          {
            return bottom - top;
          }
          bool isNull() const
          {
              return width() == 0 || height() == 0;
          }
          void setNull()
          {
              left = right = top = bottom = 0;
          }
          TRect & merge(const TRect& rhs)
          {
              if (isNull())
              {
                  *this = rhs;
              }
              else if (!rhs.isNull())
              {
                  left = std::min(left, rhs.left);
                  right = std::max(right, rhs.right);
                  top = std::min(top, rhs.top);
                  bottom = std::max(bottom, rhs.bottom);
              }

              return *this;

          }
          TRect intersect(const TRect& rhs) const
          {
              TRect ret;
              if (isNull() || rhs.isNull())
              {

                  return ret;
              }
              else
              {
                  ret.left = std::max(left, rhs.left);
                  ret.right = std::min(right, rhs.right);
                  ret.top = std::max(top, rhs.top);
                  ret.bottom = std::min(bottom, rhs.bottom);
              }

              if (ret.left > ret.right || ret.top > ret.bottom)
              {

                  ret.left = ret.top = ret.right = ret.bottom = 0;
              }

              return ret;

          }

        };
        template<typename T>
        std::ostream& operator<<(std::ostream& o, const TRect<T>& r)
        {
            o << "TRect<>(l:" << r.left << ", t:" << r.top << ", r:" << r.right << ", b:" << r.bottom << ")";
            return o;
        }



        typedef TRect<float> FloatRect;




        typedef TRect<Real> RealRect;



        typedef TRect< long > Rect;





        struct Box
        {
            uint32 left, top, right, bottom, front, back;

            Box()
                : left(0), top(0), right(1), bottom(1), front(0), back(1)
            {
            }
            Box( uint32 l, uint32 t, uint32 r, uint32 b ):
                left(l),
                top(t),
                right(r),
                bottom(b),
                front(0),
                back(1)
            {
                assert(right >= left && bottom >= top && back >= front);
            }
            Box( uint32 l, uint32 t, uint32 ff, uint32 r, uint32 b, uint32 bb ):
                left(l),
                top(t),
                right(r),
                bottom(b),
                front(ff),
                back(bb)
            {
                assert(right >= left && bottom >= top && back >= front);
            }


            bool contains(const Box &def) const
            {
                return (def.left >= left && def.top >= top && def.front >= front &&
                    def.right <= right && def.bottom <= bottom && def.back <= back);
            }


            uint32 getWidth() const { return right-left; }

            uint32 getHeight() const { return bottom-top; }

            uint32 getDepth() const { return back-front; }
        };
    int findCommandLineOpts(int numargs, char** argv, UnaryOptionList& unaryOptList,
        BinaryOptionList& binOptList);


    enum ClipResult
    {

        CLIPPED_NONE = 0,

        CLIPPED_SOME = 1,

        CLIPPED_ALL = 2
    };


    struct RenderWindowDescription
    {
        String name;
        unsigned int width;
        unsigned int height;
        bool useFullScreen;
        NameValuePairList miscParams;
    };


    typedef vector<RenderWindowDescription>::type RenderWindowDescriptionList;


    typedef vector<RenderWindow*>::type RenderWindowList;
    template<typename T>
    typename T::iterator efficientVectorRemove( T& container, typename T::iterator& iterator )
    {
        const size_t idx = iterator - container.begin();
        *iterator = container.back();
        container.pop_back();

        return container.begin() + idx;
    }
    inline size_t alignToNextMultiple( size_t offset, size_t alignment )
    {
        return ( (offset + alignment - 1) / alignment ) * alignment;
    }




    inline float min( const float &left, const float &right )
    {
        float retVal;
        _mm_store_ss( &retVal, _mm_min_ss( _mm_set_ss( left ), _mm_set_ss( right ) ) );
        return retVal;
    }
    inline float max( const float &left, const float &right )
    {
        float retVal;
        _mm_store_ss( &retVal, _mm_max_ss( _mm_set_ss( left ), _mm_set_ss( right ) ) );
        return retVal;
    }
    inline double min( const double &left, const double &right )
    {
        double retVal;
        _mm_store_sd( &retVal, _mm_min_sd( _mm_set_sd( left ), _mm_set_sd( right ) ) );
        return retVal;
    }
    inline double max( const double &left, const double &right )
    {
        double retVal;
        _mm_store_sd( &retVal, _mm_max_sd( _mm_set_sd( left ), _mm_set_sd( right ) ) );
        return retVal;
    }
}



namespace Ogre
{
    class Radian
    {
        Real mRad;

    public:
        explicit Radian ( Real r=0 ) : mRad(r) {}
        Radian ( const Degree& d );
        Radian& operator = ( const Real& f ) { mRad = f; return *this; }
        Radian& operator = ( const Radian& r ) { mRad = r.mRad; return *this; }
        Radian& operator = ( const Degree& d );

        Real valueDegrees() const;
        Real valueRadians() const { return mRad; }
        Real valueAngleUnits() const;

        const Radian& operator + () const { return *this; }
        Radian operator + ( const Radian& r ) const { return Radian ( mRad + r.mRad ); }
        Radian operator + ( const Degree& d ) const;
        Radian& operator += ( const Radian& r ) { mRad += r.mRad; return *this; }
        Radian& operator += ( const Degree& d );
        Radian operator - () const { return Radian(-mRad); }
        Radian operator - ( const Radian& r ) const { return Radian ( mRad - r.mRad ); }
        Radian operator - ( const Degree& d ) const;
        Radian& operator -= ( const Radian& r ) { mRad -= r.mRad; return *this; }
        Radian& operator -= ( const Degree& d );
        Radian operator * ( Real f ) const { return Radian ( mRad * f ); }
        Radian operator * ( const Radian& f ) const { return Radian ( mRad * f.mRad ); }
        Radian& operator *= ( Real f ) { mRad *= f; return *this; }
        Radian operator / ( Real f ) const { return Radian ( mRad / f ); }
        Radian& operator /= ( Real f ) { mRad /= f; return *this; }

        bool operator < ( const Radian& r ) const { return mRad < r.mRad; }
        bool operator <= ( const Radian& r ) const { return mRad <= r.mRad; }
        bool operator == ( const Radian& r ) const { return mRad == r.mRad; }
        bool operator != ( const Radian& r ) const { return mRad != r.mRad; }
        bool operator >= ( const Radian& r ) const { return mRad >= r.mRad; }
        bool operator > ( const Radian& r ) const { return mRad > r.mRad; }

        inline friend std::ostream& operator <<
            ( std::ostream& o, const Radian& v )
        {
            o << "Radian(" << v.valueRadians() << ")";
            return o;
        }
    };






    class Degree
    {
        Real mDeg;

    public:
        explicit Degree ( Real d=0 ) : mDeg(d) {}
        Degree ( const Radian& r ) : mDeg(r.valueDegrees()) {}
        Degree& operator = ( const Real& f ) { mDeg = f; return *this; }
        Degree& operator = ( const Degree& d ) { mDeg = d.mDeg; return *this; }
        Degree& operator = ( const Radian& r ) { mDeg = r.valueDegrees(); return *this; }

        Real valueDegrees() const { return mDeg; }
        Real valueRadians() const;
        Real valueAngleUnits() const;

        const Degree& operator + () const { return *this; }
        Degree operator + ( const Degree& d ) const { return Degree ( mDeg + d.mDeg ); }
        Degree operator + ( const Radian& r ) const { return Degree ( mDeg + r.valueDegrees() ); }
        Degree& operator += ( const Degree& d ) { mDeg += d.mDeg; return *this; }
        Degree& operator += ( const Radian& r ) { mDeg += r.valueDegrees(); return *this; }
        Degree operator - () const { return Degree(-mDeg); }
        Degree operator - ( const Degree& d ) const { return Degree ( mDeg - d.mDeg ); }
        Degree operator - ( const Radian& r ) const { return Degree ( mDeg - r.valueDegrees() ); }
        Degree& operator -= ( const Degree& d ) { mDeg -= d.mDeg; return *this; }
        Degree& operator -= ( const Radian& r ) { mDeg -= r.valueDegrees(); return *this; }
        Degree operator * ( Real f ) const { return Degree ( mDeg * f ); }
        Degree operator * ( const Degree& f ) const { return Degree ( mDeg * f.mDeg ); }
        Degree& operator *= ( Real f ) { mDeg *= f; return *this; }
        Degree operator / ( Real f ) const { return Degree ( mDeg / f ); }
        Degree& operator /= ( Real f ) { mDeg /= f; return *this; }

        bool operator < ( const Degree& d ) const { return mDeg < d.mDeg; }
        bool operator <= ( const Degree& d ) const { return mDeg <= d.mDeg; }
        bool operator == ( const Degree& d ) const { return mDeg == d.mDeg; }
        bool operator != ( const Degree& d ) const { return mDeg != d.mDeg; }
        bool operator >= ( const Degree& d ) const { return mDeg >= d.mDeg; }
        bool operator > ( const Degree& d ) const { return mDeg > d.mDeg; }

        inline friend std::ostream& operator <<
            ( std::ostream& o, const Degree& v )
        {
            o << "Degree(" << v.valueDegrees() << ")";
            return o;
        }
    };







    class Angle
    {
        Real mAngle;
    public:
        explicit Angle ( Real angle ) : mAngle(angle) {}
        operator Radian() const;
        operator Degree() const;
    };



    inline Radian::Radian ( const Degree& d ) : mRad(d.valueRadians()) {
    }
    inline Radian& Radian::operator = ( const Degree& d ) {
        mRad = d.valueRadians(); return *this;
    }
    inline Radian Radian::operator + ( const Degree& d ) const {
        return Radian ( mRad + d.valueRadians() );
    }
    inline Radian& Radian::operator += ( const Degree& d ) {
        mRad += d.valueRadians();
        return *this;
    }
    inline Radian Radian::operator - ( const Degree& d ) const {
        return Radian ( mRad - d.valueRadians() );
    }
    inline Radian& Radian::operator -= ( const Degree& d ) {
        mRad -= d.valueRadians();
        return *this;
    }
    class Math
    {
    public:





       enum AngleUnit
       {
           AU_DEGREE,
           AU_RADIAN
       };




       class RandomValueProvider
       {
       public:
            virtual ~RandomValueProvider() {}

            virtual Real getRandomUnit() = 0;
       };

    protected:

        static AngleUnit msAngleUnit;


        static int mTrigTableSize;


        static Real mTrigTableFactor;
        static Real* mSinTable;
        static Real* mTanTable;


        static RandomValueProvider* mRandProvider;



        void buildTrigTables();

        static Real SinTable (Real fValue);
        static Real TanTable (Real fValue);
    public:





        Math(unsigned int trigTableSize = 4096);



        ~Math();

        static inline int IAbs (int iValue) { return ( iValue >= 0 ? iValue : -iValue ); }
        static inline int ICeil (float fValue) { return int(ceil(fValue)); }
        static inline int IFloor (float fValue) { return int(floor(fValue)); }
        static int ISign (int iValue);





        static inline Real Abs (Real fValue) { return Real(fabs(fValue)); }





        static inline Degree Abs (const Degree& dValue) { return Degree(fabs(dValue.valueDegrees())); }





        static inline Radian Abs (const Radian& rValue) { return Radian(fabs(rValue.valueRadians())); }





        static Radian ACos (Real fValue);





        static Radian ASin (Real fValue);





        static inline Radian ATan (Real fValue) { return Radian(atan(fValue)); }







        static inline Radian ATan2 (Real fY, Real fX) { return Radian(atan2(fY,fX)); }







        static inline Real Ceil (Real fValue) { return Real(ceil(fValue)); }
        static inline bool isNaN(Real f)
        {


            return f != f;
        }
        static inline Real Cos (const Radian& fValue, bool useTables = false) {
            return (!useTables) ? Real(cos(fValue.valueRadians())) : SinTable(fValue.valueRadians() + HALF_PI);
        }







        static inline Real Cos (Real fValue, bool useTables = false) {
            return (!useTables) ? Real(cos(fValue)) : SinTable(fValue + HALF_PI);
        }

        static inline Real Exp (Real fValue) { return Real(exp(fValue)); }







        static inline Real Floor (Real fValue) { return Real(floor(fValue)); }

        static inline Real Log (Real fValue) { return Real(log(fValue)); }


        static const Real LOG2;

        static inline Real Log2 (Real fValue) { return Real(log(fValue)/LOG2); }

        static inline Real LogN (Real base, Real fValue) { return Real(log(fValue)/log(base)); }

        static inline Real Pow (Real fBase, Real fExponent) { return Real(pow(fBase,fExponent)); }

        static Real Sign (Real fValue);
        static inline Radian Sign ( const Radian& rValue )
        {
            return Radian(Sign(rValue.valueRadians()));
        }
        static inline Degree Sign ( const Degree& dValue )
        {
            return Degree(Sign(dValue.valueDegrees()));
        }


        static inline float saturate(float t)
        {
            float tmp = Ogre::max( t, 0.0f );
            tmp = Ogre::min( tmp, 1.0f );
            return tmp;
        }
        static inline double saturate(double t)
        {
            double tmp = Ogre::max( t, 0.0 );
            tmp = Ogre::min( tmp, 1.0 );
            return tmp;
        }
        template<typename T, typename S> static inline __attribute__((always_inline)) T lerp( const T& a, const T& b, const S& w )
        {
            return a + w * (b - a);
        }
        static inline Real Sin (const Radian& fValue, bool useTables = false) {
            return (!useTables) ? Real(sin(fValue.valueRadians())) : SinTable(fValue.valueRadians());
        }







        static inline Real Sin (Real fValue, bool useTables = false) {
            return (!useTables) ? Real(sin(fValue)) : SinTable(fValue);
        }





        static inline Real Sqr (Real fValue) { return fValue*fValue; }





        static inline Real Sqrt (Real fValue) { return Real(sqrt(fValue)); }







        static inline Radian Sqrt (const Radian& fValue) { return Radian(sqrt(fValue.valueRadians())); }







        static inline Degree Sqrt (const Degree& fValue) { return Degree(sqrt(fValue.valueDegrees())); }






        static Real InvSqrt (Real fValue);





        static Real UnitRandom ();
        static Real RangeRandom (Real fLow, Real fHigh);





        static Real SymmetricRandom ();

        static void SetRandomValueProvider(RandomValueProvider* provider);
        static inline Real Tan (const Radian& fValue, bool useTables = false) {
            return (!useTables) ? Real(tan(fValue.valueRadians())) : TanTable(fValue.valueRadians());
        }







        static inline Real Tan (Real fValue, bool useTables = false) {
            return (!useTables) ? Real(tan(fValue)) : TanTable(fValue);
        }

        static inline Real DegreesToRadians(Real degrees) { return degrees * fDeg2Rad; }
        static inline Real RadiansToDegrees(Real radians) { return radians * fRad2Deg; }







       static void setAngleUnit(AngleUnit unit);

       static AngleUnit getAngleUnit(void);


       static Real AngleUnitsToRadians(Real units);

       static Real RadiansToAngleUnits(Real radians);

       static Real AngleUnitsToDegrees(Real units);

       static Real DegreesToAngleUnits(Real degrees);
        static bool pointInTri2D(const Vector2& p, const Vector2& a,
            const Vector2& b, const Vector2& c);
        static bool pointInTri3D(const Vector3& p, const Vector3& a,
            const Vector3& b, const Vector3& c, const Vector3& normal);

        static std::pair<bool, Real> intersects(const Ray& ray, const Plane& plane);


        static std::pair<bool, Real> intersects(const Ray& ray, const Sphere& sphere,
            bool discardInside = true);


        static std::pair<bool, Real> intersects(const Ray& ray, const AxisAlignedBox& box);
        static bool intersects(const Ray& ray, const AxisAlignedBox& box,
            Real* d1, Real* d2);
        static std::pair<bool, Real> intersects(const Ray& ray, const Vector3& a,
            const Vector3& b, const Vector3& c, const Vector3& normal,
            bool positiveSide = true, bool negativeSide = true);
        static std::pair<bool, Real> intersects(const Ray& ray, const Vector3& a,
            const Vector3& b, const Vector3& c,
            bool positiveSide = true, bool negativeSide = true);






        static bool intersects(const Sphere& sphere, const AxisAlignedBox& box);


        static bool intersects(const Plane& plane, const AxisAlignedBox& box);






        static std::pair<bool, Real> intersects(
            const Ray& ray, const vector<Plane>::type& planeList,
            bool normalIsOutside);





        static std::pair<bool, Real> intersects(
            const Ray& ray, const list<Plane>::type& planeList,
            bool normalIsOutside);




        static bool intersects(const Sphere& sphere, const Plane& plane);



        static bool RealEqual(Real a, Real b,
            Real tolerance = std::numeric_limits<Real>::epsilon());


        static Vector3 calculateTangentSpaceVector(
            const Vector3& position1, const Vector3& position2, const Vector3& position3,
            Real u1, Real v1, Real u2, Real v2, Real u3, Real v3);


        static Matrix4 buildReflectionMatrix(const Plane& p);

        static Vector4 calculateFaceNormal(const Vector3& v1, const Vector3& v2, const Vector3& v3);

        static Vector3 calculateBasicFaceNormal(const Vector3& v1, const Vector3& v2, const Vector3& v3);

        static Vector4 calculateFaceNormalWithoutNormalize(const Vector3& v1, const Vector3& v2, const Vector3& v3);

        static Vector3 calculateBasicFaceNormalWithoutNormalize(const Vector3& v1, const Vector3& v2, const Vector3& v3);




        static Real gaussianDistribution(Real x, Real offset = 0.0f, Real scale = 1.0f);


        template <typename T>
        inline static T Clamp(T val, T minval, T maxval)
        {
            assert (minval <= maxval && "Invalid clamp range");
            return std::max(std::min(val, maxval), minval);
        }

        static Matrix4 makeViewMatrix(const Vector3& position, const Quaternion& orientation,
            const Matrix4* reflectMatrix = 0);


        static Real boundingRadiusFromAABB(const AxisAlignedBox& aabb);



        static const Real POS_INFINITY;
        static const Real NEG_INFINITY;
        static const Real PI;
        static const Real TWO_PI;
        static const Real HALF_PI;
        static const Real fDeg2Rad;
        static const Real fRad2Deg;

    };

    template <>
    inline float Math::Clamp<float>(float val, float minval, float maxval)
    {
        assert (minval <= maxval && "Invalid clamp range");
        return Ogre::max( Ogre::min(val, maxval), minval );
    }
    template <>
    inline double Math::Clamp<double>(double val, double minval, double maxval)
    {
        assert (minval <= maxval && "Invalid clamp range");
        return Ogre::max( Ogre::min(val, maxval), minval );
    }




    inline Real Radian::valueDegrees() const
    {
        return Math::RadiansToDegrees ( mRad );
    }

    inline Real Radian::valueAngleUnits() const
    {
        return Math::RadiansToAngleUnits ( mRad );
    }

    inline Real Degree::valueRadians() const
    {
        return Math::DegreesToRadians ( mDeg );
    }

    inline Real Degree::valueAngleUnits() const
    {
        return Math::DegreesToAngleUnits ( mDeg );
    }

    inline Angle::operator Radian() const
    {
        return Radian(Math::AngleUnitsToRadians(mAngle));
    }

    inline Angle::operator Degree() const
    {
        return Degree(Math::AngleUnitsToDegrees(mAngle));
    }

    inline Radian operator * ( Real a, const Radian& b )
    {
        return Radian ( a * b.valueRadians() );
    }

    inline Radian operator / ( Real a, const Radian& b )
    {
        return Radian ( a / b.valueRadians() );
    }

    inline Degree operator * ( Real a, const Degree& b )
    {
        return Degree ( a * b.valueDegrees() );
    }

    inline Degree operator / ( Real a, const Degree& b )
    {
        return Degree ( a / b.valueDegrees() );
    }


}



namespace Ogre {
    class Quaternion
    {
    public:

        inline Quaternion ()
            : w(1), x(0), y(0), z(0)
        {
        }

        inline Quaternion (
            Real fW,
            Real fX, Real fY, Real fZ)
            : w(fW), x(fX), y(fY), z(fZ)
        {
        }

        inline Quaternion(const Matrix3& rot)
        {
            this->FromRotationMatrix(rot);
        }

        inline Quaternion(const Radian& rfAngle, const Vector3& rkAxis)
        {
            this->FromAngleAxis(rfAngle, rkAxis);
        }

        inline Quaternion(const Vector3& xaxis, const Vector3& yaxis, const Vector3& zaxis)
        {
            this->FromAxes(xaxis, yaxis, zaxis);
        }

        inline Quaternion(const Vector3* akAxis)
        {
            this->FromAxes(akAxis);
        }

        inline Quaternion(Real* valptr)
        {
            memcpy(&w, valptr, sizeof(Real)*4);
        }



        inline void swap(Quaternion& other)
        {
            std::swap(w, other.w);
            std::swap(x, other.x);
            std::swap(y, other.y);
            std::swap(z, other.z);
        }


        inline Real operator [] ( const size_t i ) const
        {
            assert( i < 4 );

            return *(&w+i);
        }


        inline Real& operator [] ( const size_t i )
        {
            assert( i < 4 );

            return *(&w+i);
        }


        inline Real* ptr()
        {
            return &w;
        }


        inline const Real* ptr() const
        {
            return &w;
        }

        void FromRotationMatrix (const Matrix3& kRot);
        void ToRotationMatrix (Matrix3& kRot) const;



        void FromAngleAxis (const Radian& rfAngle, const Vector3& rkAxis);
        void ToAngleAxis (Radian& rfAngle, Vector3& rkAxis) const;
        inline void ToAngleAxis (Degree& dAngle, Vector3& rkAxis) const {
            Radian rAngle;
            ToAngleAxis ( rAngle, rkAxis );
            dAngle = rAngle;
        }



        void FromAxes (const Vector3* akAxis);
        void FromAxes (const Vector3& xAxis, const Vector3& yAxis, const Vector3& zAxis);

        void ToAxes (Vector3* akAxis) const;
        void ToAxes (Vector3& xAxis, Vector3& yAxis, Vector3& zAxis) const;




        Vector3 xAxis(void) const;




        Vector3 yAxis(void) const;




        Vector3 zAxis(void) const;

        inline Quaternion& operator= (const Quaternion& rkQ)
        {
            w = rkQ.w;
            x = rkQ.x;
            y = rkQ.y;
            z = rkQ.z;
            return *this;
        }
        Quaternion operator+ (const Quaternion& rkQ) const;
        Quaternion operator- (const Quaternion& rkQ) const;
        Quaternion operator* (const Quaternion& rkQ) const;
        Quaternion operator* (Real fScalar) const;
                    friend Quaternion operator* (Real fScalar,
            const Quaternion& rkQ);
        Quaternion operator- () const;
        inline bool operator== (const Quaternion& rhs) const
        {
            return (rhs.x == x) && (rhs.y == y) &&
                (rhs.z == z) && (rhs.w == w);
        }
        inline bool operator!= (const Quaternion& rhs) const
        {
            return !operator==(rhs);
        }


        Real Dot (const Quaternion& rkQ) const;



        Real Norm () const;

        Real normalise(void);
        Quaternion Inverse () const;
        Quaternion UnitInverse () const;
        Quaternion Exp () const;
        Quaternion Log () const;


        Vector3 operator* (const Vector3& rkVector) const;
        Radian getRoll(bool reprojectAxis = true) const;
        Radian getPitch(bool reprojectAxis = true) const;
        Radian getYaw(bool reprojectAxis = true) const;





        bool equals(const Quaternion& rhs, const Radian& tolerance) const;
        inline bool orientationEquals( const Quaternion& other, Real tolerance = 1e-3 ) const
        {
            Real d = this->Dot(other);
            return 1 - d*d < tolerance;
        }
        static Quaternion Slerp (Real fT, const Quaternion& rkP,
            const Quaternion& rkQ, bool shortestPath = false);





        static Quaternion SlerpExtraSpins (Real fT,
            const Quaternion& rkP, const Quaternion& rkQ,
            int iExtraSpins);


        static void Intermediate (const Quaternion& rkQ0,
            const Quaternion& rkQ1, const Quaternion& rkQ2,
            Quaternion& rka, Quaternion& rkB);


        static Quaternion Squad (Real fT, const Quaternion& rkP,
            const Quaternion& rkA, const Quaternion& rkB,
            const Quaternion& rkQ, bool shortestPath = false);
        static Quaternion nlerp(Real fT, const Quaternion& rkP,
            const Quaternion& rkQ, bool shortestPath = false);


        static const Real msEpsilon;


        static const Quaternion ZERO;
        static const Quaternion IDENTITY;

        Real w, x, y, z;


        inline bool isNaN() const
        {
            return Math::isNaN(x) || Math::isNaN(y) || Math::isNaN(z) || Math::isNaN(w);
        }




        inline friend std::ostream& operator <<
            ( std::ostream& o, const Quaternion& q )
        {
            o << "Quaternion(" << q.w << ", " << q.x << ", " << q.y << ", " << q.z << ")";
            return o;
        }

    };



}

namespace Ogre
{
    class Vector3
    {
    public:
        Real x, y, z;

    public:




        inline Vector3()
        {
        }

        inline Vector3( const Real fX, const Real fY, const Real fZ )
            : x( fX ), y( fY ), z( fZ )
        {
        }

        inline explicit Vector3( const Real afCoordinate[3] )
            : x( afCoordinate[0] ),
              y( afCoordinate[1] ),
              z( afCoordinate[2] )
        {
        }

        inline explicit Vector3( const int afCoordinate[3] )
        {
            x = (Real)afCoordinate[0];
            y = (Real)afCoordinate[1];
            z = (Real)afCoordinate[2];
        }

        inline explicit Vector3( Real* const r )
            : x( r[0] ), y( r[1] ), z( r[2] )
        {
        }

        inline explicit Vector3( const Real scaler )
            : x( scaler )
            , y( scaler )
            , z( scaler )
        {
        }




        inline void swap(Vector3& other)
        {
            std::swap(x, other.x);
            std::swap(y, other.y);
            std::swap(z, other.z);
        }

        inline Real operator [] ( const size_t i ) const
        {
            assert( i < 3 );

            return *(&x+i);
        }

        inline Real& operator [] ( const size_t i )
        {
            assert( i < 3 );

            return *(&x+i);
        }

        inline Real* ptr()
        {
            return &x;
        }

        inline const Real* ptr() const
        {
            return &x;
        }





        inline Vector3& operator = ( const Vector3& rkVector )
        {
            x = rkVector.x;
            y = rkVector.y;
            z = rkVector.z;

            return *this;
        }

        inline Vector3& operator = ( const Real fScaler )
        {
            x = fScaler;
            y = fScaler;
            z = fScaler;

            return *this;
        }

        inline bool operator == ( const Vector3& rkVector ) const
        {
            return ( x == rkVector.x && y == rkVector.y && z == rkVector.z );
        }

        inline bool operator != ( const Vector3& rkVector ) const
        {
            return ( x != rkVector.x || y != rkVector.y || z != rkVector.z );
        }


        inline Vector3 operator + ( const Vector3& rkVector ) const
        {
            return Vector3(
                x + rkVector.x,
                y + rkVector.y,
                z + rkVector.z);
        }

        inline Vector3 operator - ( const Vector3& rkVector ) const
        {
            return Vector3(
                x - rkVector.x,
                y - rkVector.y,
                z - rkVector.z);
        }

        inline Vector3 operator * ( const Real fScalar ) const
        {
            return Vector3(
                x * fScalar,
                y * fScalar,
                z * fScalar);
        }

        inline Vector3 operator * ( const Vector3& rhs) const
        {
            return Vector3(
                x * rhs.x,
                y * rhs.y,
                z * rhs.z);
        }

        inline Vector3 operator / ( const Real fScalar ) const
        {
            assert( fScalar != 0.0 );

            Real fInv = 1.0f / fScalar;

            return Vector3(
                x * fInv,
                y * fInv,
                z * fInv);
        }

        inline Vector3 operator / ( const Vector3& rhs) const
        {
            return Vector3(
                x / rhs.x,
                y / rhs.y,
                z / rhs.z);
        }

        inline const Vector3& operator + () const
        {
            return *this;
        }

        inline Vector3 operator - () const
        {
            return Vector3(-x, -y, -z);
        }


        inline friend Vector3 operator * ( const Real fScalar, const Vector3& rkVector )
        {
            return Vector3(
                fScalar * rkVector.x,
                fScalar * rkVector.y,
                fScalar * rkVector.z);
        }

        inline friend Vector3 operator / ( const Real fScalar, const Vector3& rkVector )
        {
            return Vector3(
                fScalar / rkVector.x,
                fScalar / rkVector.y,
                fScalar / rkVector.z);
        }

        inline friend Vector3 operator + (const Vector3& lhs, const Real rhs)
        {
            return Vector3(
                lhs.x + rhs,
                lhs.y + rhs,
                lhs.z + rhs);
        }

        inline friend Vector3 operator + (const Real lhs, const Vector3& rhs)
        {
            return Vector3(
                lhs + rhs.x,
                lhs + rhs.y,
                lhs + rhs.z);
        }

        inline friend Vector3 operator - (const Vector3& lhs, const Real rhs)
        {
            return Vector3(
                lhs.x - rhs,
                lhs.y - rhs,
                lhs.z - rhs);
        }

        inline friend Vector3 operator - (const Real lhs, const Vector3& rhs)
        {
            return Vector3(
                lhs - rhs.x,
                lhs - rhs.y,
                lhs - rhs.z);
        }


        inline Vector3& operator += ( const Vector3& rkVector )
        {
            x += rkVector.x;
            y += rkVector.y;
            z += rkVector.z;

            return *this;
        }

        inline Vector3& operator += ( const Real fScalar )
        {
            x += fScalar;
            y += fScalar;
            z += fScalar;
            return *this;
        }

        inline Vector3& operator -= ( const Vector3& rkVector )
        {
            x -= rkVector.x;
            y -= rkVector.y;
            z -= rkVector.z;

            return *this;
        }

        inline Vector3& operator -= ( const Real fScalar )
        {
            x -= fScalar;
            y -= fScalar;
            z -= fScalar;
            return *this;
        }

        inline Vector3& operator *= ( const Real fScalar )
        {
            x *= fScalar;
            y *= fScalar;
            z *= fScalar;
            return *this;
        }

        inline Vector3& operator *= ( const Vector3& rkVector )
        {
            x *= rkVector.x;
            y *= rkVector.y;
            z *= rkVector.z;

            return *this;
        }

        inline Vector3& operator /= ( const Real fScalar )
        {
            assert( fScalar != 0.0 );

            Real fInv = 1.0f / fScalar;

            x *= fInv;
            y *= fInv;
            z *= fInv;

            return *this;
        }

        inline Vector3& operator /= ( const Vector3& rkVector )
        {
            x /= rkVector.x;
            y /= rkVector.y;
            z /= rkVector.z;

            return *this;
        }
        inline Real length () const
        {
            return Math::Sqrt( x * x + y * y + z * z );
        }
        inline Real squaredLength () const
        {
            return x * x + y * y + z * z;
        }
        inline Real distance(const Vector3& rhs) const
        {
            return (*this - rhs).length();
        }
        inline Real squaredDistance(const Vector3& rhs) const
        {
            return (*this - rhs).squaredLength();
        }
        inline Real dotProduct(const Vector3& vec) const
        {
            return x * vec.x + y * vec.y + z * vec.z;
        }
        inline Real absDotProduct(const Vector3& vec) const
        {
            return Math::Abs(x * vec.x) + Math::Abs(y * vec.y) + Math::Abs(z * vec.z);
        }
        inline Real normalise()
        {
            Real fLength = Math::Sqrt( x * x + y * y + z * z );




            if ( fLength > Real(0.0f) )
            {
                Real fInvLength = 1.0f / fLength;
                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
            }

            return fLength;
        }
        inline Vector3 crossProduct( const Vector3& rkVector ) const
        {
            return Vector3(
                y * rkVector.z - z * rkVector.y,
                z * rkVector.x - x * rkVector.z,
                x * rkVector.y - y * rkVector.x);
        }




        inline Vector3 midPoint( const Vector3& vec ) const
        {
            return Vector3(
                ( x + vec.x ) * 0.5f,
                ( y + vec.y ) * 0.5f,
                ( z + vec.z ) * 0.5f );
        }




        inline bool operator < ( const Vector3& rhs ) const
        {
            if( x < rhs.x && y < rhs.y && z < rhs.z )
                return true;
            return false;
        }




        inline bool operator > ( const Vector3& rhs ) const
        {
            if( x > rhs.x && y > rhs.y && z > rhs.z )
                return true;
            return false;
        }
        inline void makeFloor( const Vector3& cmp )
        {
            x = Ogre::min( x, cmp.x );
            y = Ogre::min( y, cmp.y );
            z = Ogre::min( z, cmp.z );
        }
        inline void makeCeil( const Vector3& cmp )
        {
            x = Ogre::max( x, cmp.x );
            y = Ogre::max( y, cmp.y );
            z = Ogre::max( z, cmp.z );
        }


        inline void makeAbs()
        {
            x = Math::Abs( x );
            y = Math::Abs( y );
            z = Math::Abs( z );
        }
        inline Vector3 perpendicular(void) const
        {
            static const Real fSquareZero = (Real)(1e-06 * 1e-06);

            Vector3 perp = this->crossProduct( Vector3::UNIT_X );


            if( perp.squaredLength() < fSquareZero )
            {



                perp = this->crossProduct( Vector3::UNIT_Y );
            }
            perp.normalise();

            return perp;
        }
        inline Vector3 randomDeviant(
            const Radian& angle,
            const Vector3& up = Vector3::ZERO ) const
        {
            Vector3 newUp;

            if (up == Vector3::ZERO)
            {

                newUp = this->perpendicular();
            }
            else
            {
                newUp = up;
            }


            Quaternion q;
            q.FromAngleAxis( Radian(Math::UnitRandom() * Math::TWO_PI), *this );
            newUp = q * newUp;


            q.FromAngleAxis( angle, newUp );
            return q * (*this);
        }





        inline Radian angleBetween(const Vector3& dest) const
        {
            Real lenProduct = length() * dest.length();


            if(lenProduct < 1e-6f)
                lenProduct = 1e-6f;

            Real f = dotProduct(dest) / lenProduct;

            f = Math::Clamp(f, (Real)-1.0, (Real)1.0);
            return Math::ACos(f);

        }
        Quaternion getRotationTo(const Vector3& dest,
            const Vector3& fallbackAxis = Vector3::ZERO) const
        {

            Quaternion q;

            Vector3 v0 = *this;
            Vector3 v1 = dest;
            v0.normalise();
            v1.normalise();

            Real d = v0.dotProduct(v1);

            if (d >= 1.0f)
            {
                return Quaternion::IDENTITY;
            }
            if (d < (1e-6f - 1.0f))
            {
                if (fallbackAxis != Vector3::ZERO)
                {

                    q.FromAngleAxis(Radian(Math::PI), fallbackAxis);
                }
                else
                {

                    Vector3 axis = Vector3::UNIT_X.crossProduct(*this);
                    if (axis.isZeroLength())
                        axis = Vector3::UNIT_Y.crossProduct(*this);
                    axis.normalise();
                    q.FromAngleAxis(Radian(Math::PI), axis);
                }
            }
            else
            {
                Real s = Math::Sqrt( (1+d)*2 );
                Real invs = 1 / s;

                Vector3 c = v0.crossProduct(v1);

                q.x = c.x * invs;
                q.y = c.y * invs;
                q.z = c.z * invs;
                q.w = s * 0.5f;
                q.normalise();
            }
            return q;
        }


        inline bool isZeroLength(void) const
        {
            Real sqlen = (x * x) + (y * y) + (z * z);
            return (sqlen < (1e-06 * 1e-06));

        }



        inline Vector3 normalisedCopy(void) const
        {
            Vector3 ret = *this;
            ret.normalise();
            return ret;
        }




        inline Vector3 reflect(const Vector3& normal) const
        {
            return Vector3( *this - ( 2 * this->dotProduct(normal) * normal ) );
        }







        inline bool positionEquals(const Vector3& rhs, Real tolerance = 1e-03) const
        {
            return Math::RealEqual(x, rhs.x, tolerance) &&
                Math::RealEqual(y, rhs.y, tolerance) &&
                Math::RealEqual(z, rhs.z, tolerance);

        }







        inline bool positionCloses(const Vector3& rhs, Real tolerance = 1e-03f) const
        {
            return squaredDistance(rhs) <=
                (squaredLength() + rhs.squaredLength()) * tolerance;
        }
        inline bool directionEquals(const Vector3& rhs,
            const Radian& tolerance) const
        {
            Real dot = dotProduct(rhs);
            Radian angle = Math::ACos(dot);

            return Math::Abs(angle.valueRadians()) <= tolerance.valueRadians();

        }


        inline bool isNaN() const
        {
            return Math::isNaN(x) || Math::isNaN(y) || Math::isNaN(z);
        }


        inline Vector3 primaryAxis() const
        {
            Real absx = Math::Abs(x);
            Real absy = Math::Abs(y);
            Real absz = Math::Abs(z);
            if (absx > absy)
                if (absx > absz)
                    return x > 0 ? Vector3::UNIT_X : Vector3::NEGATIVE_UNIT_X;
                else
                    return z > 0 ? Vector3::UNIT_Z : Vector3::NEGATIVE_UNIT_Z;
            else
                if (absy > absz)
                    return y > 0 ? Vector3::UNIT_Y : Vector3::NEGATIVE_UNIT_Y;
                else
                    return z > 0 ? Vector3::UNIT_Z : Vector3::NEGATIVE_UNIT_Z;


        }


        static const Vector3 ZERO;
        static const Vector3 UNIT_X;
        static const Vector3 UNIT_Y;
        static const Vector3 UNIT_Z;
        static const Vector3 NEGATIVE_UNIT_X;
        static const Vector3 NEGATIVE_UNIT_Y;
        static const Vector3 NEGATIVE_UNIT_Z;
        static const Vector3 UNIT_SCALE;



        inline friend std::ostream& operator <<
            ( std::ostream& o, const Vector3& v )
        {
            o << "Vector3(" << v.x << ", " << v.y << ", " << v.z << ")";
            return o;
        }
    };



}
namespace Ogre
{
    class Matrix3
    {
    public:




        inline Matrix3 () {}
        inline explicit Matrix3 (const Real arr[3][3])
        {
            memcpy(m,arr,9*sizeof(Real));
        }
        inline Matrix3 (const Matrix3& rkMatrix)
        {
            memcpy(m,rkMatrix.m,9*sizeof(Real));
        }
        Matrix3 (Real fEntry00, Real fEntry01, Real fEntry02,
                    Real fEntry10, Real fEntry11, Real fEntry12,
                    Real fEntry20, Real fEntry21, Real fEntry22)
        {
            m[0][0] = fEntry00;
            m[0][1] = fEntry01;
            m[0][2] = fEntry02;
            m[1][0] = fEntry10;
            m[1][1] = fEntry11;
            m[1][2] = fEntry12;
            m[2][0] = fEntry20;
            m[2][1] = fEntry21;
            m[2][2] = fEntry22;
        }



        inline void swap(Matrix3& other)
        {
            std::swap(m[0][0], other.m[0][0]);
            std::swap(m[0][1], other.m[0][1]);
            std::swap(m[0][2], other.m[0][2]);
            std::swap(m[1][0], other.m[1][0]);
            std::swap(m[1][1], other.m[1][1]);
            std::swap(m[1][2], other.m[1][2]);
            std::swap(m[2][0], other.m[2][0]);
            std::swap(m[2][1], other.m[2][1]);
            std::swap(m[2][2], other.m[2][2]);
        }


        inline const Real* operator[] (size_t iRow) const
        {
            return m[iRow];
        }

        inline Real* operator[] (size_t iRow)
        {
            return m[iRow];
        }







        Vector3 GetColumn (size_t iCol) const;
        void SetColumn(size_t iCol, const Vector3& vec);
        void FromAxes(const Vector3& xAxis, const Vector3& yAxis, const Vector3& zAxis);


        inline Matrix3& operator= (const Matrix3& rkMatrix)
        {
            memcpy(m,rkMatrix.m,9*sizeof(Real));
            return *this;
        }



        bool operator== (const Matrix3& rkMatrix) const;



        inline bool operator!= (const Matrix3& rkMatrix) const
        {
            return !operator==(rkMatrix);
        }




        Matrix3 operator+ (const Matrix3& rkMatrix) const;



        Matrix3 operator- (const Matrix3& rkMatrix) const;



        Matrix3 operator* (const Matrix3& rkMatrix) const;
        Matrix3 operator- () const;


        Vector3 operator* (const Vector3& rkVector) const;


                    friend Vector3 operator* (const Vector3& rkVector,
            const Matrix3& rkMatrix);


        Matrix3 operator* (Real fScalar) const;


                    friend Matrix3 operator* (Real fScalar, const Matrix3& rkMatrix);


        Matrix3 Transpose () const;
        bool Inverse (Matrix3& rkInverse, Real fTolerance = 1e-06) const;
        Matrix3 Inverse (Real fTolerance = 1e-06) const;
        Real Determinant () const;


        void SingularValueDecomposition (Matrix3& rkL, Vector3& rkS,
            Matrix3& rkR) const;
        void SingularValueComposition (const Matrix3& rkL,
            const Vector3& rkS, const Matrix3& rkR);


        void Orthonormalize ();


        void QDUDecomposition (Matrix3& rkQ, Vector3& rkD,
            Vector3& rkU) const;

        Real SpectralNorm () const;


        void ToAngleAxis (Vector3& rkAxis, Radian& rfAngle) const;
        inline void ToAngleAxis (Vector3& rkAxis, Degree& rfAngle) const {
            Radian r;
            ToAngleAxis ( rkAxis, r );
            rfAngle = r;
        }
        void FromAngleAxis (const Vector3& rkAxis, const Radian& fRadians);




        bool ToEulerAnglesXYZ (Radian& rfYAngle, Radian& rfPAngle,
            Radian& rfRAngle) const;
        bool ToEulerAnglesXZY (Radian& rfYAngle, Radian& rfPAngle,
            Radian& rfRAngle) const;
        bool ToEulerAnglesYXZ (Radian& rfYAngle, Radian& rfPAngle,
            Radian& rfRAngle) const;
        bool ToEulerAnglesYZX (Radian& rfYAngle, Radian& rfPAngle,
            Radian& rfRAngle) const;
        bool ToEulerAnglesZXY (Radian& rfYAngle, Radian& rfPAngle,
            Radian& rfRAngle) const;
        bool ToEulerAnglesZYX (Radian& rfYAngle, Radian& rfPAngle,
            Radian& rfRAngle) const;
        void FromEulerAnglesXYZ (const Radian& fYAngle, const Radian& fPAngle, const Radian& fRAngle);
        void FromEulerAnglesXZY (const Radian& fYAngle, const Radian& fPAngle, const Radian& fRAngle);
        void FromEulerAnglesYXZ (const Radian& fYAngle, const Radian& fPAngle, const Radian& fRAngle);
        void FromEulerAnglesYZX (const Radian& fYAngle, const Radian& fPAngle, const Radian& fRAngle);
        void FromEulerAnglesZXY (const Radian& fYAngle, const Radian& fPAngle, const Radian& fRAngle);
        void FromEulerAnglesZYX (const Radian& fYAngle, const Radian& fPAngle, const Radian& fRAngle);

        void EigenSolveSymmetric (Real afEigenvalue[3],
            Vector3 akEigenvector[3]) const;

        static void TensorProduct (const Vector3& rkU, const Vector3& rkV,
            Matrix3& rkProduct);


        inline bool hasScale() const
        {

            Real t = m[0][0] * m[0][0] + m[1][0] * m[1][0] + m[2][0] * m[2][0];
            if (!Math::RealEqual(t, 1.0, (Real)1e-04))
                return true;
            t = m[0][1] * m[0][1] + m[1][1] * m[1][1] + m[2][1] * m[2][1];
            if (!Math::RealEqual(t, 1.0, (Real)1e-04))
                return true;
            t = m[0][2] * m[0][2] + m[1][2] * m[1][2] + m[2][2] * m[2][2];
            if (!Math::RealEqual(t, 1.0, (Real)1e-04))
                return true;

            return false;
        }



        inline friend std::ostream& operator <<
            ( std::ostream& o, const Matrix3& mat )
        {
            o << "Matrix3(" << mat[0][0] << ", " << mat[0][1] << ", " << mat[0][2] << ", "
                            << mat[1][0] << ", " << mat[1][1] << ", " << mat[1][2] << ", "
                            << mat[2][0] << ", " << mat[2][1] << ", " << mat[2][2] << ")";
            return o;
        }

        static const Real EPSILON;
        static const Matrix3 ZERO;
        static const Matrix3 IDENTITY;

    protected:

        void Tridiagonal (Real afDiag[3], Real afSubDiag[3]);
        bool QLAlgorithm (Real afDiag[3], Real afSubDiag[3]);


        static const Real msSvdEpsilon;
        static const unsigned int msSvdMaxIterations;
        static void Bidiagonalize (Matrix3& kA, Matrix3& kL,
            Matrix3& kR);
        static void GolubKahanStep (Matrix3& kA, Matrix3& kL,
            Matrix3& kR);


        static Real MaxCubicRoot (Real afCoeff[3]);

        Real m[3][3];


        friend class Matrix4;
    };


}
namespace Ogre
{
    class Vector4
    {
    public:
        Real x, y, z, w;

    public:




        inline Vector4()
        {
        }

        inline Vector4( const Real fX, const Real fY, const Real fZ, const Real fW )
            : x( fX ), y( fY ), z( fZ ), w( fW )
        {
        }

        inline explicit Vector4( const Real afCoordinate[4] )
            : x( afCoordinate[0] ),
              y( afCoordinate[1] ),
              z( afCoordinate[2] ),
              w( afCoordinate[3] )
        {
        }

        inline explicit Vector4( const int afCoordinate[4] )
        {
            x = (Real)afCoordinate[0];
            y = (Real)afCoordinate[1];
            z = (Real)afCoordinate[2];
            w = (Real)afCoordinate[3];
        }

        inline explicit Vector4( Real* const r )
            : x( r[0] ), y( r[1] ), z( r[2] ), w( r[3] )
        {
        }

        inline explicit Vector4( const Real scaler )
            : x( scaler )
            , y( scaler )
            , z( scaler )
            , w( scaler )
        {
        }

        inline explicit Vector4(const Vector3& rhs)
            : x(rhs.x), y(rhs.y), z(rhs.z), w(1.0f)
        {
        }



        inline void swap(Vector4& other)
        {
            std::swap(x, other.x);
            std::swap(y, other.y);
            std::swap(z, other.z);
            std::swap(w, other.w);
        }

        inline Real operator [] ( const size_t i ) const
        {
            assert( i < 4 );

            return *(&x+i);
        }

        inline Real& operator [] ( const size_t i )
        {
            assert( i < 4 );

            return *(&x+i);
        }


        inline Real* ptr()
        {
            return &x;
        }

        inline const Real* ptr() const
        {
            return &x;
        }





        inline Vector4& operator = ( const Vector4& rkVector )
        {
            x = rkVector.x;
            y = rkVector.y;
            z = rkVector.z;
            w = rkVector.w;

            return *this;
        }

        inline Vector4& operator = ( const Real fScalar)
        {
            x = fScalar;
            y = fScalar;
            z = fScalar;
            w = fScalar;
            return *this;
        }

        inline bool operator == ( const Vector4& rkVector ) const
        {
            return ( x == rkVector.x &&
                y == rkVector.y &&
                z == rkVector.z &&
                w == rkVector.w );
        }

        inline bool operator != ( const Vector4& rkVector ) const
        {
            return ( x != rkVector.x ||
                y != rkVector.y ||
                z != rkVector.z ||
                w != rkVector.w );
        }

        inline Vector4& operator = (const Vector3& rhs)
        {
            x = rhs.x;
            y = rhs.y;
            z = rhs.z;
            w = 1.0f;
            return *this;
        }


        inline Vector4 operator + ( const Vector4& rkVector ) const
        {
            return Vector4(
                x + rkVector.x,
                y + rkVector.y,
                z + rkVector.z,
                w + rkVector.w);
        }

        inline Vector4 operator - ( const Vector4& rkVector ) const
        {
            return Vector4(
                x - rkVector.x,
                y - rkVector.y,
                z - rkVector.z,
                w - rkVector.w);
        }

        inline Vector4 operator * ( const Real fScalar ) const
        {
            return Vector4(
                x * fScalar,
                y * fScalar,
                z * fScalar,
                w * fScalar);
        }

        inline Vector4 operator * ( const Vector4& rhs) const
        {
            return Vector4(
                rhs.x * x,
                rhs.y * y,
                rhs.z * z,
                rhs.w * w);
        }

        inline Vector4 operator / ( const Real fScalar ) const
        {
            assert( fScalar != 0.0 );

            Real fInv = 1.0f / fScalar;

            return Vector4(
                x * fInv,
                y * fInv,
                z * fInv,
                w * fInv);
        }

        inline Vector4 operator / ( const Vector4& rhs) const
        {
            return Vector4(
                x / rhs.x,
                y / rhs.y,
                z / rhs.z,
                w / rhs.w);
        }

        inline const Vector4& operator + () const
        {
            return *this;
        }

        inline Vector4 operator - () const
        {
            return Vector4(-x, -y, -z, -w);
        }

        inline friend Vector4 operator * ( const Real fScalar, const Vector4& rkVector )
        {
            return Vector4(
                fScalar * rkVector.x,
                fScalar * rkVector.y,
                fScalar * rkVector.z,
                fScalar * rkVector.w);
        }

        inline friend Vector4 operator / ( const Real fScalar, const Vector4& rkVector )
        {
            return Vector4(
                fScalar / rkVector.x,
                fScalar / rkVector.y,
                fScalar / rkVector.z,
                fScalar / rkVector.w);
        }

        inline friend Vector4 operator + (const Vector4& lhs, const Real rhs)
        {
            return Vector4(
                lhs.x + rhs,
                lhs.y + rhs,
                lhs.z + rhs,
                lhs.w + rhs);
        }

        inline friend Vector4 operator + (const Real lhs, const Vector4& rhs)
        {
            return Vector4(
                lhs + rhs.x,
                lhs + rhs.y,
                lhs + rhs.z,
                lhs + rhs.w);
        }

        inline friend Vector4 operator - (const Vector4& lhs, Real rhs)
        {
            return Vector4(
                lhs.x - rhs,
                lhs.y - rhs,
                lhs.z - rhs,
                lhs.w - rhs);
        }

        inline friend Vector4 operator - (const Real lhs, const Vector4& rhs)
        {
            return Vector4(
                lhs - rhs.x,
                lhs - rhs.y,
                lhs - rhs.z,
                lhs - rhs.w);
        }


        inline Vector4& operator += ( const Vector4& rkVector )
        {
            x += rkVector.x;
            y += rkVector.y;
            z += rkVector.z;
            w += rkVector.w;

            return *this;
        }

        inline Vector4& operator -= ( const Vector4& rkVector )
        {
            x -= rkVector.x;
            y -= rkVector.y;
            z -= rkVector.z;
            w -= rkVector.w;

            return *this;
        }

        inline Vector4& operator *= ( const Real fScalar )
        {
            x *= fScalar;
            y *= fScalar;
            z *= fScalar;
            w *= fScalar;
            return *this;
        }

        inline Vector4& operator += ( const Real fScalar )
        {
            x += fScalar;
            y += fScalar;
            z += fScalar;
            w += fScalar;
            return *this;
        }

        inline Vector4& operator -= ( const Real fScalar )
        {
            x -= fScalar;
            y -= fScalar;
            z -= fScalar;
            w -= fScalar;
            return *this;
        }

        inline Vector4& operator *= ( const Vector4& rkVector )
        {
            x *= rkVector.x;
            y *= rkVector.y;
            z *= rkVector.z;
            w *= rkVector.w;

            return *this;
        }

        inline Vector4& operator /= ( const Real fScalar )
        {
            assert( fScalar != 0.0 );

            Real fInv = 1.0f / fScalar;

            x *= fInv;
            y *= fInv;
            z *= fInv;
            w *= fInv;

            return *this;
        }

        inline Vector4& operator /= ( const Vector4& rkVector )
        {
            x /= rkVector.x;
            y /= rkVector.y;
            z /= rkVector.z;
            w /= rkVector.w;

            return *this;
        }
        inline Real dotProduct(const Vector4& vec) const
        {
            return x * vec.x + y * vec.y + z * vec.z + w * vec.w;
        }

        inline bool isNaN() const
        {
            return Math::isNaN(x) || Math::isNaN(y) || Math::isNaN(z) || Math::isNaN(w);
        }


        inline friend std::ostream& operator <<
            ( std::ostream& o, const Vector4& v )
        {
            o << "Vector4(" << v.x << ", " << v.y << ", " << v.z << ", " << v.w << ")";
            return o;
        }

        static const Vector4 ZERO;
    };



}
namespace Ogre {
    class Plane
    {
    public:


        Plane ();
        Plane (const Plane& rhs);

        Plane (const Vector3& rkNormal, Real fConstant);

        Plane (Real a, Real b, Real c, Real d);
        Plane (const Vector3& rkNormal, const Vector3& rkPoint);
        Plane (const Vector3& rkPoint0, const Vector3& rkPoint1,
            const Vector3& rkPoint2);





        enum Side
        {
            NO_SIDE,
            POSITIVE_SIDE,
            NEGATIVE_SIDE,
            BOTH_SIDE
        };

        Side getSide (const Vector3& rkPoint) const;





        Side getSide (const AxisAlignedBox& rkBox) const;
        Side getSide (const Vector3& centre, const Vector3& halfSize) const;
        Real getDistance (const Vector3& rkPoint) const;


        void redefine(const Vector3& rkPoint0, const Vector3& rkPoint1,
            const Vector3& rkPoint2);


        void redefine(const Vector3& rkNormal, const Vector3& rkPoint);
        Vector3 projectVector(const Vector3& v) const;
        Real normalise(void);

        Vector3 normal;
        Real d;


        bool operator==(const Plane& rhs) const
        {
            return (rhs.d == d && rhs.normal == normal);
        }
        bool operator!=(const Plane& rhs) const
        {
            return (rhs.d != d || rhs.normal != normal);
        }

                    friend std::ostream& operator<< (std::ostream& o, const Plane& p);
    };

    typedef vector<Plane>::type PlaneList;



}
namespace Ogre
{
    class Matrix4
    {
    protected:
        friend class ArrayMatrix4;
        friend class ArrayMatrixAf4x3;
        friend class SimpleMatrix4;
        friend class SimpleMatrixAf4x3;

        union {


            Real m[4][4];
            Real _m[16];
        };
    public:




        inline Matrix4()
        {
        }

        inline Matrix4(
            Real m00, Real m01, Real m02, Real m03,
            Real m10, Real m11, Real m12, Real m13,
            Real m20, Real m21, Real m22, Real m23,
            Real m30, Real m31, Real m32, Real m33 )
        {
            m[0][0] = m00;
            m[0][1] = m01;
            m[0][2] = m02;
            m[0][3] = m03;
            m[1][0] = m10;
            m[1][1] = m11;
            m[1][2] = m12;
            m[1][3] = m13;
            m[2][0] = m20;
            m[2][1] = m21;
            m[2][2] = m22;
            m[2][3] = m23;
            m[3][0] = m30;
            m[3][1] = m31;
            m[3][2] = m32;
            m[3][3] = m33;
        }




        inline Matrix4(const Matrix3& m3x3)
        {
          operator=(IDENTITY);
          operator=(m3x3);
        }




        inline Matrix4(const Quaternion& rot)
        {
          Matrix3 m3x3;
          rot.ToRotationMatrix(m3x3);
          operator=(IDENTITY);
          operator=(m3x3);
        }




        inline void swap(Matrix4& other)
        {
            std::swap(m[0][0], other.m[0][0]);
            std::swap(m[0][1], other.m[0][1]);
            std::swap(m[0][2], other.m[0][2]);
            std::swap(m[0][3], other.m[0][3]);
            std::swap(m[1][0], other.m[1][0]);
            std::swap(m[1][1], other.m[1][1]);
            std::swap(m[1][2], other.m[1][2]);
            std::swap(m[1][3], other.m[1][3]);
            std::swap(m[2][0], other.m[2][0]);
            std::swap(m[2][1], other.m[2][1]);
            std::swap(m[2][2], other.m[2][2]);
            std::swap(m[2][3], other.m[2][3]);
            std::swap(m[3][0], other.m[3][0]);
            std::swap(m[3][1], other.m[3][1]);
            std::swap(m[3][2], other.m[3][2]);
            std::swap(m[3][3], other.m[3][3]);
        }

        inline Real* operator [] ( size_t iRow )
        {
            assert( iRow < 4 );
            return m[iRow];
        }

        inline const Real *operator [] ( size_t iRow ) const
        {
            assert( iRow < 4 );
            return m[iRow];
        }
        inline Matrix4 concatenate(const Matrix4 &m2) const
        {
            Matrix4 r;
            r.m[0][0] = m[0][0] * m2.m[0][0] + m[0][1] * m2.m[1][0] + m[0][2] * m2.m[2][0] + m[0][3] * m2.m[3][0];
            r.m[0][1] = m[0][0] * m2.m[0][1] + m[0][1] * m2.m[1][1] + m[0][2] * m2.m[2][1] + m[0][3] * m2.m[3][1];
            r.m[0][2] = m[0][0] * m2.m[0][2] + m[0][1] * m2.m[1][2] + m[0][2] * m2.m[2][2] + m[0][3] * m2.m[3][2];
            r.m[0][3] = m[0][0] * m2.m[0][3] + m[0][1] * m2.m[1][3] + m[0][2] * m2.m[2][3] + m[0][3] * m2.m[3][3];

            r.m[1][0] = m[1][0] * m2.m[0][0] + m[1][1] * m2.m[1][0] + m[1][2] * m2.m[2][0] + m[1][3] * m2.m[3][0];
            r.m[1][1] = m[1][0] * m2.m[0][1] + m[1][1] * m2.m[1][1] + m[1][2] * m2.m[2][1] + m[1][3] * m2.m[3][1];
            r.m[1][2] = m[1][0] * m2.m[0][2] + m[1][1] * m2.m[1][2] + m[1][2] * m2.m[2][2] + m[1][3] * m2.m[3][2];
            r.m[1][3] = m[1][0] * m2.m[0][3] + m[1][1] * m2.m[1][3] + m[1][2] * m2.m[2][3] + m[1][3] * m2.m[3][3];

            r.m[2][0] = m[2][0] * m2.m[0][0] + m[2][1] * m2.m[1][0] + m[2][2] * m2.m[2][0] + m[2][3] * m2.m[3][0];
            r.m[2][1] = m[2][0] * m2.m[0][1] + m[2][1] * m2.m[1][1] + m[2][2] * m2.m[2][1] + m[2][3] * m2.m[3][1];
            r.m[2][2] = m[2][0] * m2.m[0][2] + m[2][1] * m2.m[1][2] + m[2][2] * m2.m[2][2] + m[2][3] * m2.m[3][2];
            r.m[2][3] = m[2][0] * m2.m[0][3] + m[2][1] * m2.m[1][3] + m[2][2] * m2.m[2][3] + m[2][3] * m2.m[3][3];

            r.m[3][0] = m[3][0] * m2.m[0][0] + m[3][1] * m2.m[1][0] + m[3][2] * m2.m[2][0] + m[3][3] * m2.m[3][0];
            r.m[3][1] = m[3][0] * m2.m[0][1] + m[3][1] * m2.m[1][1] + m[3][2] * m2.m[2][1] + m[3][3] * m2.m[3][1];
            r.m[3][2] = m[3][0] * m2.m[0][2] + m[3][1] * m2.m[1][2] + m[3][2] * m2.m[2][2] + m[3][3] * m2.m[3][2];
            r.m[3][3] = m[3][0] * m2.m[0][3] + m[3][1] * m2.m[1][3] + m[3][2] * m2.m[2][3] + m[3][3] * m2.m[3][3];

            return r;
        }




        inline Matrix4 operator * ( const Matrix4 &m2 ) const
        {
            return concatenate( m2 );
        }
        inline Vector3 operator * ( const Vector3 &v ) const
        {
            Vector3 r;

            Real fInvW = 1.0f / ( m[3][0] * v.x + m[3][1] * v.y + m[3][2] * v.z + m[3][3] );

            r.x = ( m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z + m[0][3] ) * fInvW;
            r.y = ( m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z + m[1][3] ) * fInvW;
            r.z = ( m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z + m[2][3] ) * fInvW;

            return r;
        }
        inline Vector4 operator * (const Vector4& v) const
        {
            return Vector4(
                m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z + m[0][3] * v.w,
                m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z + m[1][3] * v.w,
                m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z + m[2][3] * v.w,
                m[3][0] * v.x + m[3][1] * v.y + m[3][2] * v.z + m[3][3] * v.w
                );
        }
        inline Plane operator * (const Plane& p) const
        {
            Plane ret;
            Matrix4 invTrans = inverse().transpose();
            Vector4 v4( p.normal.x, p.normal.y, p.normal.z, p.d );
            v4 = invTrans * v4;
            ret.normal.x = v4.x;
            ret.normal.y = v4.y;
            ret.normal.z = v4.z;
            ret.d = v4.w / ret.normal.normalise();

            return ret;
        }




        inline Matrix4 operator + ( const Matrix4 &m2 ) const
        {
            Matrix4 r;

            r.m[0][0] = m[0][0] + m2.m[0][0];
            r.m[0][1] = m[0][1] + m2.m[0][1];
            r.m[0][2] = m[0][2] + m2.m[0][2];
            r.m[0][3] = m[0][3] + m2.m[0][3];

            r.m[1][0] = m[1][0] + m2.m[1][0];
            r.m[1][1] = m[1][1] + m2.m[1][1];
            r.m[1][2] = m[1][2] + m2.m[1][2];
            r.m[1][3] = m[1][3] + m2.m[1][3];

            r.m[2][0] = m[2][0] + m2.m[2][0];
            r.m[2][1] = m[2][1] + m2.m[2][1];
            r.m[2][2] = m[2][2] + m2.m[2][2];
            r.m[2][3] = m[2][3] + m2.m[2][3];

            r.m[3][0] = m[3][0] + m2.m[3][0];
            r.m[3][1] = m[3][1] + m2.m[3][1];
            r.m[3][2] = m[3][2] + m2.m[3][2];
            r.m[3][3] = m[3][3] + m2.m[3][3];

            return r;
        }



        inline Matrix4 operator - ( const Matrix4 &m2 ) const
        {
            Matrix4 r;
            r.m[0][0] = m[0][0] - m2.m[0][0];
            r.m[0][1] = m[0][1] - m2.m[0][1];
            r.m[0][2] = m[0][2] - m2.m[0][2];
            r.m[0][3] = m[0][3] - m2.m[0][3];

            r.m[1][0] = m[1][0] - m2.m[1][0];
            r.m[1][1] = m[1][1] - m2.m[1][1];
            r.m[1][2] = m[1][2] - m2.m[1][2];
            r.m[1][3] = m[1][3] - m2.m[1][3];

            r.m[2][0] = m[2][0] - m2.m[2][0];
            r.m[2][1] = m[2][1] - m2.m[2][1];
            r.m[2][2] = m[2][2] - m2.m[2][2];
            r.m[2][3] = m[2][3] - m2.m[2][3];

            r.m[3][0] = m[3][0] - m2.m[3][0];
            r.m[3][1] = m[3][1] - m2.m[3][1];
            r.m[3][2] = m[3][2] - m2.m[3][2];
            r.m[3][3] = m[3][3] - m2.m[3][3];

            return r;
        }



        inline bool operator == ( const Matrix4& m2 ) const
        {
            if(
                m[0][0] != m2.m[0][0] || m[0][1] != m2.m[0][1] || m[0][2] != m2.m[0][2] || m[0][3] != m2.m[0][3] ||
                m[1][0] != m2.m[1][0] || m[1][1] != m2.m[1][1] || m[1][2] != m2.m[1][2] || m[1][3] != m2.m[1][3] ||
                m[2][0] != m2.m[2][0] || m[2][1] != m2.m[2][1] || m[2][2] != m2.m[2][2] || m[2][3] != m2.m[2][3] ||
                m[3][0] != m2.m[3][0] || m[3][1] != m2.m[3][1] || m[3][2] != m2.m[3][2] || m[3][3] != m2.m[3][3] )
                return false;
            return true;
        }



        inline bool operator != ( const Matrix4& m2 ) const
        {
            if(
                m[0][0] != m2.m[0][0] || m[0][1] != m2.m[0][1] || m[0][2] != m2.m[0][2] || m[0][3] != m2.m[0][3] ||
                m[1][0] != m2.m[1][0] || m[1][1] != m2.m[1][1] || m[1][2] != m2.m[1][2] || m[1][3] != m2.m[1][3] ||
                m[2][0] != m2.m[2][0] || m[2][1] != m2.m[2][1] || m[2][2] != m2.m[2][2] || m[2][3] != m2.m[2][3] ||
                m[3][0] != m2.m[3][0] || m[3][1] != m2.m[3][1] || m[3][2] != m2.m[3][2] || m[3][3] != m2.m[3][3] )
                return true;
            return false;
        }



        inline void operator = ( const Matrix3& mat3 )
        {
            m[0][0] = mat3.m[0][0]; m[0][1] = mat3.m[0][1]; m[0][2] = mat3.m[0][2];
            m[1][0] = mat3.m[1][0]; m[1][1] = mat3.m[1][1]; m[1][2] = mat3.m[1][2];
            m[2][0] = mat3.m[2][0]; m[2][1] = mat3.m[2][1]; m[2][2] = mat3.m[2][2];
        }

        inline Matrix4 transpose(void) const
        {
            return Matrix4(m[0][0], m[1][0], m[2][0], m[3][0],
                           m[0][1], m[1][1], m[2][1], m[3][1],
                           m[0][2], m[1][2], m[2][2], m[3][2],
                           m[0][3], m[1][3], m[2][3], m[3][3]);
        }
        inline void setTrans( const Vector3& v )
        {
            m[0][3] = v.x;
            m[1][3] = v.y;
            m[2][3] = v.z;
        }



        inline Vector3 getTrans() const
        {
          return Vector3(m[0][3], m[1][3], m[2][3]);
        }




        inline void makeTrans( const Vector3& v )
        {
            m[0][0] = 1.0; m[0][1] = 0.0; m[0][2] = 0.0; m[0][3] = v.x;
            m[1][0] = 0.0; m[1][1] = 1.0; m[1][2] = 0.0; m[1][3] = v.y;
            m[2][0] = 0.0; m[2][1] = 0.0; m[2][2] = 1.0; m[2][3] = v.z;
            m[3][0] = 0.0; m[3][1] = 0.0; m[3][2] = 0.0; m[3][3] = 1.0;
        }

        inline void makeTrans( Real tx, Real ty, Real tz )
        {
            m[0][0] = 1.0; m[0][1] = 0.0; m[0][2] = 0.0; m[0][3] = tx;
            m[1][0] = 0.0; m[1][1] = 1.0; m[1][2] = 0.0; m[1][3] = ty;
            m[2][0] = 0.0; m[2][1] = 0.0; m[2][2] = 1.0; m[2][3] = tz;
            m[3][0] = 0.0; m[3][1] = 0.0; m[3][2] = 0.0; m[3][3] = 1.0;
        }



        inline static Matrix4 getTrans( const Vector3& v )
        {
            Matrix4 r;

            r.m[0][0] = 1.0; r.m[0][1] = 0.0; r.m[0][2] = 0.0; r.m[0][3] = v.x;
            r.m[1][0] = 0.0; r.m[1][1] = 1.0; r.m[1][2] = 0.0; r.m[1][3] = v.y;
            r.m[2][0] = 0.0; r.m[2][1] = 0.0; r.m[2][2] = 1.0; r.m[2][3] = v.z;
            r.m[3][0] = 0.0; r.m[3][1] = 0.0; r.m[3][2] = 0.0; r.m[3][3] = 1.0;

            return r;
        }



        inline static Matrix4 getTrans( Real t_x, Real t_y, Real t_z )
        {
            Matrix4 r;

            r.m[0][0] = 1.0; r.m[0][1] = 0.0; r.m[0][2] = 0.0; r.m[0][3] = t_x;
            r.m[1][0] = 0.0; r.m[1][1] = 1.0; r.m[1][2] = 0.0; r.m[1][3] = t_y;
            r.m[2][0] = 0.0; r.m[2][1] = 0.0; r.m[2][2] = 1.0; r.m[2][3] = t_z;
            r.m[3][0] = 0.0; r.m[3][1] = 0.0; r.m[3][2] = 0.0; r.m[3][3] = 1.0;

            return r;
        }
        inline void setScale( const Vector3& v )
        {
            m[0][0] = v.x;
            m[1][1] = v.y;
            m[2][2] = v.z;
        }



        inline static Matrix4 getScale( const Vector3& v )
        {
            Matrix4 r;
            r.m[0][0] = v.x; r.m[0][1] = 0.0; r.m[0][2] = 0.0; r.m[0][3] = 0.0;
            r.m[1][0] = 0.0; r.m[1][1] = v.y; r.m[1][2] = 0.0; r.m[1][3] = 0.0;
            r.m[2][0] = 0.0; r.m[2][1] = 0.0; r.m[2][2] = v.z; r.m[2][3] = 0.0;
            r.m[3][0] = 0.0; r.m[3][1] = 0.0; r.m[3][2] = 0.0; r.m[3][3] = 1.0;

            return r;
        }



        inline static Matrix4 getScale( Real s_x, Real s_y, Real s_z )
        {
            Matrix4 r;
            r.m[0][0] = s_x; r.m[0][1] = 0.0; r.m[0][2] = 0.0; r.m[0][3] = 0.0;
            r.m[1][0] = 0.0; r.m[1][1] = s_y; r.m[1][2] = 0.0; r.m[1][3] = 0.0;
            r.m[2][0] = 0.0; r.m[2][1] = 0.0; r.m[2][2] = s_z; r.m[2][3] = 0.0;
            r.m[3][0] = 0.0; r.m[3][1] = 0.0; r.m[3][2] = 0.0; r.m[3][3] = 1.0;

            return r;
        }




        inline void extract3x3Matrix(Matrix3& m3x3) const
        {
            m3x3.m[0][0] = m[0][0];
            m3x3.m[0][1] = m[0][1];
            m3x3.m[0][2] = m[0][2];
            m3x3.m[1][0] = m[1][0];
            m3x3.m[1][1] = m[1][1];
            m3x3.m[1][2] = m[1][2];
            m3x3.m[2][0] = m[2][0];
            m3x3.m[2][1] = m[2][1];
            m3x3.m[2][2] = m[2][2];

        }


        inline bool hasScale() const
        {

            Real t = m[0][0] * m[0][0] + m[1][0] * m[1][0] + m[2][0] * m[2][0];
            if (!Math::RealEqual(t, 1.0, (Real)1e-04))
                return true;
            t = m[0][1] * m[0][1] + m[1][1] * m[1][1] + m[2][1] * m[2][1];
            if (!Math::RealEqual(t, 1.0, (Real)1e-04))
                return true;
            t = m[0][2] * m[0][2] + m[1][2] * m[1][2] + m[2][2] * m[2][2];
            if (!Math::RealEqual(t, 1.0, (Real)1e-04))
                return true;

            return false;
        }


        inline bool hasNegativeScale() const
        {
            return determinant() < 0;
        }



        inline Quaternion extractQuaternion() const
        {
          Matrix3 m3x3;
          extract3x3Matrix(m3x3);
          return Quaternion(m3x3);
        }

    static const Matrix4 ZERO;
    static const Matrix4 ZEROAFFINE;
    static const Matrix4 IDENTITY;


        static const Matrix4 CLIPSPACE2DTOIMAGESPACE;

        inline Matrix4 operator*(Real scalar) const
        {
            return Matrix4(
                scalar*m[0][0], scalar*m[0][1], scalar*m[0][2], scalar*m[0][3],
                scalar*m[1][0], scalar*m[1][1], scalar*m[1][2], scalar*m[1][3],
                scalar*m[2][0], scalar*m[2][1], scalar*m[2][2], scalar*m[2][3],
                scalar*m[3][0], scalar*m[3][1], scalar*m[3][2], scalar*m[3][3]);
        }



        inline friend std::ostream& operator <<
            ( std::ostream& o, const Matrix4& mat )
        {
            o << "Matrix4(";
            for (size_t i = 0; i < 4; ++i)
            {
                o << " row" << (unsigned)i << "{";
                for(size_t j = 0; j < 4; ++j)
                {
                    o << mat[i][j] << " ";
                }
                o << "}";
            }
            o << ")";
            return o;
        }

        Matrix4 adjoint() const;
        Real determinant() const;
        Matrix4 inverse() const;







        void makeTransform(const Vector3& position, const Vector3& scale, const Quaternion& orientation);






        void makeInverseTransform(const Vector3& position, const Vector3& scale, const Quaternion& orientation);



        void decomposition(Vector3& position, Vector3& scale, Quaternion& orientation) const;






        inline bool isAffine(void) const
        {
            return m[3][0] == 0 && m[3][1] == 0 && m[3][2] == 0 && m[3][3] == 1;
        }





        Matrix4 inverseAffine(void) const;





        inline Matrix4 concatenateAffine(const Matrix4 &m2) const
        {
            assert(isAffine() && m2.isAffine());

            return Matrix4(
                m[0][0] * m2.m[0][0] + m[0][1] * m2.m[1][0] + m[0][2] * m2.m[2][0],
                m[0][0] * m2.m[0][1] + m[0][1] * m2.m[1][1] + m[0][2] * m2.m[2][1],
                m[0][0] * m2.m[0][2] + m[0][1] * m2.m[1][2] + m[0][2] * m2.m[2][2],
                m[0][0] * m2.m[0][3] + m[0][1] * m2.m[1][3] + m[0][2] * m2.m[2][3] + m[0][3],

                m[1][0] * m2.m[0][0] + m[1][1] * m2.m[1][0] + m[1][2] * m2.m[2][0],
                m[1][0] * m2.m[0][1] + m[1][1] * m2.m[1][1] + m[1][2] * m2.m[2][1],
                m[1][0] * m2.m[0][2] + m[1][1] * m2.m[1][2] + m[1][2] * m2.m[2][2],
                m[1][0] * m2.m[0][3] + m[1][1] * m2.m[1][3] + m[1][2] * m2.m[2][3] + m[1][3],

                m[2][0] * m2.m[0][0] + m[2][1] * m2.m[1][0] + m[2][2] * m2.m[2][0],
                m[2][0] * m2.m[0][1] + m[2][1] * m2.m[1][1] + m[2][2] * m2.m[2][1],
                m[2][0] * m2.m[0][2] + m[2][1] * m2.m[1][2] + m[2][2] * m2.m[2][2],
                m[2][0] * m2.m[0][3] + m[2][1] * m2.m[1][3] + m[2][2] * m2.m[2][3] + m[2][3],

                0, 0, 0, 1);
        }
        inline Vector3 transformAffine(const Vector3& v) const
        {
            assert(isAffine());

            return Vector3(
                    m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z + m[0][3],
                    m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z + m[1][3],
                    m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z + m[2][3]);
        }





        inline Vector4 transformAffine(const Vector4& v) const
        {
            assert(isAffine());

            return Vector4(
                m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z + m[0][3] * v.w,
                m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z + m[1][3] * v.w,
                m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z + m[2][3] * v.w,
                v.w);
        }
    };





    inline Vector4 operator * (const Vector4& v, const Matrix4& mat)
    {
        return Vector4(
            v.x*mat[0][0] + v.y*mat[1][0] + v.z*mat[2][0] + v.w*mat[3][0],
            v.x*mat[0][1] + v.y*mat[1][1] + v.z*mat[2][1] + v.w*mat[3][1],
            v.x*mat[0][2] + v.y*mat[1][2] + v.z*mat[2][2] + v.w*mat[3][2],
            v.x*mat[0][3] + v.y*mat[1][3] + v.z*mat[2][3] + v.w*mat[3][3]
            );
    }


}

namespace Ogre {
    class SimpleSpline
    {
    public:
        SimpleSpline();
        ~SimpleSpline();


        void addPoint(const Vector3& p);


        const Vector3& getPoint(unsigned short index) const;


        unsigned short getNumPoints(void) const;


        void clear(void);





        void updatePoint(unsigned short index, const Vector3& value);







        Vector3 interpolate(Real t) const;





        Vector3 interpolate(unsigned int fromIndex, Real t) const;
        void setAutoCalculate(bool autoCalc);






        void recalcTangents(void);

    protected:

        bool mAutoCalc;

        vector<Vector3>::type mPoints;
        vector<Vector3>::type mTangents;


        Matrix4 mCoeffs;



    };



}



namespace Ogre {
    class RotationalSpline
    {
    public:
        RotationalSpline();
        ~RotationalSpline();


        void addPoint(const Quaternion& p);


        const Quaternion& getPoint(unsigned short index) const;


        unsigned short getNumPoints(void) const;


        void clear(void);





        void updatePoint(unsigned short index, const Quaternion& value);
        Quaternion interpolate(Real t, bool useShortestPath=true);






        Quaternion interpolate(unsigned int fromIndex, Real t, bool useShortestPath=true);
        void setAutoCalculate(bool autoCalc);






        void recalcTangents(void);

    protected:

        bool mAutoCalc;



        vector<Quaternion>::type mPoints;
        vector<Quaternion>::type mTangents;

    };




}


namespace Ogre {
    class StringUtil
    {
    public:
        static void trim( String& str, bool left = true, bool right = true );
        static vector<String>::type split( const String& str, const String& delims = "\t\n ", unsigned int maxSplits = 0, bool preserveDelims = false);
        static vector<String>::type tokenise( const String& str, const String& delims = "\t\n ", const String& doubleDelims = "\"", unsigned int maxSplits = 0);



        static void toLowerCase( String& str );



        static void toUpperCase( String& str );



        static void toTitleCase( String& str );







        static bool startsWith(const String& str, const String& pattern, bool lowerCase = true);






        static bool endsWith(const String& str, const String& pattern, bool lowerCase = true);



        static String standardisePath( const String &init);
        static String normalizeFilePath(const String& init, bool makeLowerCase = true);







        static void splitFilename(const String& qualifiedName,
                                  String& outBasename, String& outPath);






        static void splitFullFilename(const Ogre::String& qualifiedName,
                                      Ogre::String& outBasename, Ogre::String& outExtention,
                                      Ogre::String& outPath);




        static void splitBaseFilename(const Ogre::String& fullName,
                                      Ogre::String& outBasename, Ogre::String& outExtention);







        static bool match(const String& str, const String& pattern, bool caseSensitive = true);
        static const String replaceAll(const String& source, const String& replaceWhat, const String& replaceWithWhat);
    };
    typedef ::std::tr1::hash< _StringBase > _StringHash;
}



namespace Ogre {
    class Exception : public std::exception
    {
    protected:
        long line;
        int number;
        String typeName;
        String description;
        String source;
        String file;
        mutable String fullDesc;
    public:





        enum ExceptionCodes {
            ERR_CANNOT_WRITE_TO_FILE,
            ERR_INVALID_STATE,
            ERR_INVALIDPARAMS,
            ERR_RENDERINGAPI_ERROR,
            ERR_DUPLICATE_ITEM,
            ERR_ITEM_NOT_FOUND,
            ERR_FILE_NOT_FOUND,
            ERR_INTERNAL_ERROR,
            ERR_RT_ASSERTION_FAILED,
            ERR_NOT_IMPLEMENTED,
            ERR_INVALID_CALL
        };



        Exception( int number, const String& description, const String& source );



        Exception( int number, const String& description, const String& source, const char* type, const char* file, long line );



        Exception(const Exception& rhs);


        ~Exception() throw() {}



        Exception & operator = (const Exception& rhs);
        virtual const String& getFullDescription(void) const;



        virtual int getNumber(void) const throw();



        virtual const String &getSource() const { return source; }



        virtual const String &getFile() const { return file; }



        virtual long getLine() const { return line; }





        virtual const String &getDescription(void) const { return description; }


        const char* what() const throw() { return getFullDescription().c_str(); }

    };
    class UnimplementedException : public Exception
    {
    public:
        UnimplementedException(int inNumber, const String& inDescription, const String& inSource, const char* inFile, long inLine)
            : Exception(inNumber, inDescription, inSource, "UnimplementedException", inFile, inLine) {}
    };
    class FileNotFoundException : public Exception
    {
    public:
        FileNotFoundException(int inNumber, const String& inDescription, const String& inSource, const char* inFile, long inLine)
            : Exception(inNumber, inDescription, inSource, "FileNotFoundException", inFile, inLine) {}
    };
    class IOException : public Exception
    {
    public:
        IOException(int inNumber, const String& inDescription, const String& inSource, const char* inFile, long inLine)
            : Exception(inNumber, inDescription, inSource, "IOException", inFile, inLine) {}
    };
    class InvalidStateException : public Exception
    {
    public:
        InvalidStateException(int inNumber, const String& inDescription, const String& inSource, const char* inFile, long inLine)
            : Exception(inNumber, inDescription, inSource, "InvalidStateException", inFile, inLine) {}
    };
    class InvalidParametersException : public Exception
    {
    public:
        InvalidParametersException(int inNumber, const String& inDescription, const String& inSource, const char* inFile, long inLine)
            : Exception(inNumber, inDescription, inSource, "InvalidParametersException", inFile, inLine) {}
    };
    class ItemIdentityException : public Exception
    {
    public:
        ItemIdentityException(int inNumber, const String& inDescription, const String& inSource, const char* inFile, long inLine)
            : Exception(inNumber, inDescription, inSource, "ItemIdentityException", inFile, inLine) {}
    };
    class InternalErrorException : public Exception
    {
    public:
        InternalErrorException(int inNumber, const String& inDescription, const String& inSource, const char* inFile, long inLine)
            : Exception(inNumber, inDescription, inSource, "InternalErrorException", inFile, inLine) {}
    };
    class RenderingAPIException : public Exception
    {
    public:
        RenderingAPIException(int inNumber, const String& inDescription, const String& inSource, const char* inFile, long inLine)
            : Exception(inNumber, inDescription, inSource, "RenderingAPIException", inFile, inLine) {}
    };
    class RuntimeAssertionException : public Exception
    {
    public:
        RuntimeAssertionException(int inNumber, const String& inDescription, const String& inSource, const char* inFile, long inLine)
            : Exception(inNumber, inDescription, inSource, "RuntimeAssertionException", inFile, inLine) {}
    };
    class InvalidCallException : public Exception
    {
    public:
        InvalidCallException(int inNumber, const String& inDescription, const String& inSource, const char* inFile, long inLine)
            : Exception(inNumber, inDescription, inSource, "InvalidCallException", inFile, inLine) {}
    };
    class ExceptionFactory
    {
    private:

        ExceptionFactory() {}
    public:
        static __attribute__((noreturn)) void throwException(
            Exception::ExceptionCodes code, int number,
            const String& desc,
            const String& src, const char* file, long line)
        {
            switch (code)
            {
            case Exception::ERR_CANNOT_WRITE_TO_FILE: throw IOException(number, desc, src, file, line);
            case Exception::ERR_INVALID_STATE: throw InvalidStateException(number, desc, src, file, line);
            case Exception::ERR_INVALIDPARAMS: throw InvalidParametersException(number, desc, src, file, line);
            case Exception::ERR_RENDERINGAPI_ERROR: throw RenderingAPIException(number, desc, src, file, line);
            case Exception::ERR_DUPLICATE_ITEM: throw ItemIdentityException(number, desc, src, file, line);
            case Exception::ERR_ITEM_NOT_FOUND: throw ItemIdentityException(number, desc, src, file, line);
            case Exception::ERR_FILE_NOT_FOUND: throw FileNotFoundException(number, desc, src, file, line);
            case Exception::ERR_INTERNAL_ERROR: throw InternalErrorException(number, desc, src, file, line);
            case Exception::ERR_RT_ASSERTION_FAILED: throw RuntimeAssertionException(number, desc, src, file, line);
            case Exception::ERR_NOT_IMPLEMENTED: throw UnimplementedException(number, desc, src, file, line);
            case Exception::ERR_INVALID_CALL: throw InvalidCallException(number, desc, src, file, line);
            default: throw Exception(number, desc, src, "Exception", file, line);
            }
        }

    };
}



namespace Ogre {
namespace v1 {
    class HardwareBuffer : public BufferAlloc
    {

        public:

            enum Usage
            {



                HBU_STATIC = 1,





                HBU_DYNAMIC = 2,






                HBU_WRITE_ONLY = 4,
                HBU_DISCARDABLE = 8,

                HBU_STATIC_WRITE_ONLY = 5,





                HBU_DYNAMIC_WRITE_ONLY = 6,

                HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE = 14


            };

            enum LockOptions
            {

                HBL_NORMAL,




                HBL_DISCARD,



                HBL_READ_ONLY,



                HBL_NO_OVERWRITE,

                HBL_WRITE_ONLY

            };




            enum UploadOptions
            {



                HBU_DEFAULT = 0x0000,




                HBU_ON_DEMAND = 0x0001
            };

        protected:
            size_t mSizeInBytes;
            Usage mUsage;
            bool mIsLocked;
            size_t mLockStart;
            size_t mLockSize;
            UploadOptions mLockUploadOption;
            bool mSystemMemory;
            bool mUseShadowBuffer;
            HardwareBuffer* mShadowBuffer;
            bool mShadowUpdated;
            bool mSuppressHardwareUpdate;


            virtual void* lockImpl(size_t offset, size_t length, LockOptions options) = 0;

            virtual void unlockImpl(void) = 0;

    public:

            HardwareBuffer(Usage usage, bool systemMemory, bool useShadowBuffer)
                : mSizeInBytes(0), mUsage(usage), mIsLocked(false), mLockStart(0), mLockSize(0), mSystemMemory(systemMemory),
                mUseShadowBuffer(useShadowBuffer), mShadowBuffer(NULL), mShadowUpdated(false),
                mSuppressHardwareUpdate(false)
            {

                if (useShadowBuffer && usage == HBU_DYNAMIC)
                {
                    mUsage = HBU_DYNAMIC_WRITE_ONLY;
                }
                else if (useShadowBuffer && usage == HBU_STATIC)
                {
                    mUsage = HBU_STATIC_WRITE_ONLY;
                }
            }
            virtual ~HardwareBuffer() {}






            virtual void* lock(size_t offset, size_t length, LockOptions options, UploadOptions uploadOpt = HBU_DEFAULT)
            {
                assert(!isLocked() && "Cannot lock this buffer, it is already locked!");

                void* ret = NULL;
                if ((length + offset) > mSizeInBytes)
                {
                    Ogre::ExceptionFactory::throwException(Exception::ERR_INVALIDPARAMS, Exception::ERR_INVALIDPARAMS, "Lock request out of bounds.", "HardwareBuffer::lock", "./OgreHardwareBuffer.h", 211);


                }
                else if (mUseShadowBuffer)
                {
                    if (options != HBL_READ_ONLY)
                    {


                        mShadowUpdated = true;
                    }

                    ret = mShadowBuffer->lock(offset, length, options, uploadOpt);
                }
                else
                {

                    ret = lockImpl(offset, length, options);
                    mIsLocked = true;
                }
                mLockStart = offset;
                mLockSize = length;
                mLockUploadOption = uploadOpt;
                return ret;
            }





            void* lock(LockOptions options, UploadOptions uploadOpt = HBU_DEFAULT)
            {
                return this->lock(0, mSizeInBytes, options, uploadOpt);
            }
            virtual void unlock(void)
            {
                assert(isLocked() && "Cannot unlock this buffer, it is not locked!");


                if (mUseShadowBuffer && mShadowBuffer->isLocked())
                {
                    mShadowBuffer->unlock();

                    _updateFromShadow();
                }
                else
                {

                    unlockImpl();
                    mIsLocked = false;
                }

            }







            virtual void readData(size_t offset, size_t length, void* pDest) = 0;
            virtual void writeData(size_t offset, size_t length, const void* pSource,
                    bool discardWholeBuffer = false) = 0;
            virtual void copyData(HardwareBuffer& srcBuffer, size_t srcOffset,
                size_t dstOffset, size_t length, bool discardWholeBuffer = false)
            {
                const void *srcData = srcBuffer.lock(
                    srcOffset, length, HBL_READ_ONLY);
                this->writeData(dstOffset, length, srcData, discardWholeBuffer);
                srcBuffer.unlock();
            }






            virtual void copyData(HardwareBuffer& srcBuffer)
            {
                size_t sz = std::min(getSizeInBytes(), srcBuffer.getSizeInBytes());
                copyData(srcBuffer, 0, 0, sz, true);
            }


            virtual void _updateFromShadow(void)
            {
                if (mUseShadowBuffer && mShadowUpdated && !mSuppressHardwareUpdate)
                {

                    const void *srcData = mShadowBuffer->lockImpl(
                        mLockStart, mLockSize, HBL_READ_ONLY);

                    LockOptions lockOpt;
                    if (mLockStart == 0 && mLockSize == mSizeInBytes)
                        lockOpt = HBL_DISCARD;
                    else
                        lockOpt = HBL_NORMAL;

                    void *destData = this->lockImpl(
                        mLockStart, mLockSize, lockOpt);

                    memcpy(destData, srcData, mLockSize);
                    this->unlockImpl();
                    mShadowBuffer->unlockImpl();
                    mShadowUpdated = false;
                }
            }


            size_t getSizeInBytes(void) const { return mSizeInBytes; }

            Usage getUsage(void) const { return mUsage; }

            bool isSystemMemory(void) const { return mSystemMemory; }

            bool hasShadowBuffer(void) const { return mUseShadowBuffer; }

            bool isLocked(void) const {
                return mIsLocked || (mUseShadowBuffer && mShadowBuffer->isLocked());
            }

            void suppressHardwareUpdate(bool suppress) {
                mSuppressHardwareUpdate = suppress;
                if (!suppress)
                    _updateFromShadow();
            }





    };




    template <typename T> struct HardwareBufferLockGuard
    {
        HardwareBufferLockGuard(const T& p, HardwareBuffer::LockOptions options)
            : pBuf(p)
        {
            pData = pBuf->lock(options);
        }
        HardwareBufferLockGuard(const T& p, size_t offset, size_t length, HardwareBuffer::LockOptions options)
            : pBuf(p)
        {
            pData = pBuf->lock(offset, length, options);
        }
        ~HardwareBufferLockGuard()
        {
            pBuf->unlock();
        }

        const T& pBuf;
        void* pData;
    };
}
}

namespace Ogre {







    template <class T> class AtomicScalar {

        public:

        AtomicScalar (const T &initial)
            : mField(initial)
        { }

        AtomicScalar (const AtomicScalar<T> &cousin)
            : mField(cousin.mField)
        { }

        AtomicScalar ()
        { }

        void operator= (const AtomicScalar<T> &cousin)
        {
            mField = cousin.mField;
        }

        T get (void) const
        {



            return mField;
        }

        void set (const T &v)
        {
            mField = v;
        }

        bool cas (const T &old, const T &nu)
        {
                                ;
            if (mField != old) return false;
            mField = nu;
            return true;
        }

        T operator++ (void)
        {
                                ;
            return ++mField;
        }

        T operator-- (void)
        {
                                ;
            return --mField;
        }

        T operator++ (int)
        {
                                ;
            return mField++;
        }

        T operator-- (int)
        {
                                ;
            return mField--;
        }

        T operator+=(const T &add)
        {
                                ;
            mField += add;
            return mField;
        }

        T operator-=(const T &sub)
        {
                                ;
            mField -= sub;
            return mField;
        }

        protected:

                       ;

        volatile T mField;

    };



}

namespace Ogre {
    enum SharedPtrFreeMethod
    {

        SPFM_DELETE,

        SPFM_DELETE_T,

        SPFM_FREE,

        SPFM_NONE
    };

    struct SharedPtrInfo {
        inline SharedPtrInfo()
            : useCount(1)
        {}

        virtual ~SharedPtrInfo() {}

        AtomicScalar<unsigned> useCount;
    };

    struct SharedPtrInfoNone : public SharedPtrInfo
    {
    };

    template <class T>
    class SharedPtrInfoDelete : public SharedPtrInfo
    {
        T* mObject;
    public:
        inline SharedPtrInfoDelete(T* o) : mObject(o) {}

        virtual ~SharedPtrInfoDelete()
        {
            delete mObject;
        }
    };

    template <class T>
    class SharedPtrInfoDeleteT : public SharedPtrInfo
    {
        T* mObject;
    public:
        inline SharedPtrInfoDeleteT(T* o) : mObject(o) {}

        virtual ~SharedPtrInfoDeleteT()
        {
            if(mObject){(mObject)->~T(); ::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GENERAL>::deallocateBytes((void*)mObject);};
        }
    };

    template <class T>
    class SharedPtrInfoFree : public SharedPtrInfo
    {
        T* mObject;
    public:
        inline SharedPtrInfoFree(T* o) : mObject(o) {}

        virtual ~SharedPtrInfoFree()
        {
            ::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GENERAL>::deallocateBytes((void*)mObject);
        }
    };
    template<class T> class SharedPtr
    {
        template<typename Y> friend class SharedPtr;
    protected:
        T* pRep;
        SharedPtrInfo* pInfo;

        SharedPtr(T* rep, SharedPtrInfo* info) : pRep(rep), pInfo(info)
        {
        }

    public:




        SharedPtr() : pRep(0), pInfo(0)
        {}

    private:
        static SharedPtrInfo* createInfoForMethod(T* rep, SharedPtrFreeMethod method)
        {
            switch(method) {
                case SPFM_DELETE: return new (::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GENERAL>::allocateBytes(sizeof(SharedPtrInfoDelete<T>))) SharedPtrInfoDelete<T> (rep);
                case SPFM_DELETE_T: return new (::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GENERAL>::allocateBytes(sizeof(SharedPtrInfoDeleteT<T>))) SharedPtrInfoDeleteT<T> (rep);
                case SPFM_FREE: return new (::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GENERAL>::allocateBytes(sizeof(SharedPtrInfoFree<T>))) SharedPtrInfoFree<T> (rep);
                case SPFM_NONE: return new (::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GENERAL>::allocateBytes(sizeof(SharedPtrInfoNone))) SharedPtrInfoNone ();
            }
            assert(!"Bad method");
            return 0;
        }
    public:





        template< class Y>
        explicit SharedPtr(Y* rep, SharedPtrFreeMethod inFreeMethod = SPFM_DELETE)
            : pRep(rep)
            , pInfo(rep ? createInfoForMethod(rep, inFreeMethod) : 0)
        {
        }

        SharedPtr(const SharedPtr& r)
            : pRep(r.pRep)
            , pInfo(r.pInfo)
        {
            if (pRep)
            {
                ++pInfo->useCount;
            }
        }

        SharedPtr& operator=(const SharedPtr& r)
        {

            assert(pRep != r.pRep || pInfo == r.pInfo || dynamic_cast<SharedPtrInfoNone*>(pInfo) || dynamic_cast<SharedPtrInfoNone*>(r.pInfo));
            if(pInfo == r.pInfo)
                return *this;



            SharedPtr<T> tmp(r);
            swap(tmp);
            return *this;
        }







        template<class Y,
            class = typename std::enable_if<std::is_convertible<Y*, T*>::value>::type>



        SharedPtr(const SharedPtr<Y>& r)
            : pRep(r.getPointer())
            , pInfo(r.pInfo)
        {
            if (pRep)
            {
                ++pInfo->useCount;
            }
        }



        template<class Y,
                 class = typename std::enable_if<std::is_assignable<T*, Y*>::value>::type>



        SharedPtr& operator=(const SharedPtr<Y>& r)
        {

            assert(pRep != r.pRep || pInfo == r.pInfo || dynamic_cast<SharedPtrInfoNone*>(pInfo) || dynamic_cast<SharedPtrInfoNone*>(r.pInfo));
            if(pInfo == r.pInfo)
                return *this;



            SharedPtr<T> tmp(r);
            swap(tmp);
            return *this;
        }

        ~SharedPtr() {
            release();
        }


        template<typename Y>
        inline SharedPtr<Y> staticCast() const
        {
            if(pRep) {
                ++pInfo->useCount;
                return SharedPtr<Y>(static_cast<Y*>(pRep), pInfo);
            } else return SharedPtr<Y>();
        }

        template<typename Y>
        inline SharedPtr<Y> dynamicCast() const
        {
            Y* rep = dynamic_cast<Y*>(pRep);
            if(rep) {
                ++pInfo->useCount;
                return SharedPtr<Y>(rep, pInfo);
            } else return SharedPtr<Y>();
        }

        inline T& operator*() const { assert(pRep); return *pRep; }
        inline T* operator->() const { assert(pRep); return pRep; }
        inline T* get() const { return pRep; }
        void bind(T* rep, SharedPtrFreeMethod inFreeMethod = SPFM_DELETE) {
            assert(!pRep && !pInfo);
            pInfo = createInfoForMethod(rep, inFreeMethod);
            pRep = rep;
        }

        inline bool unique() const { assert(pInfo && pInfo->useCount.get()); return pInfo->useCount.get() == 1; }
        inline unsigned int useCount() const { assert(pInfo && pInfo->useCount.get()); return pInfo->useCount.get(); }
        inline void setUseCount(unsigned value) { assert(pInfo); pInfo->useCount = value; }

        inline T* getPointer() const { return pRep; }

        inline bool isNull(void) const { return pRep == 0; }

        inline void setNull(void) {
            if (pRep)
            {
                release();
            }
        }

    protected:

        inline void release(void)
        {
            if (pRep)
            {
                assert(pInfo);
                if(--pInfo->useCount == 0)
                    destroy();
            }

            pRep = 0;
            pInfo = 0;
        }





        inline void destroy(void)
        {
            assert(pRep && pInfo);
            if(pInfo){(pInfo)->~SharedPtrInfo(); ::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GENERAL>::deallocateBytes((void*)pInfo);};
        }

        inline void swap(SharedPtr<T> &other)
        {
            std::swap(pRep, other.pRep);
            std::swap(pInfo, other.pInfo);
        }
    };

    template<class T, class U> inline bool operator==(SharedPtr<T> const& a, SharedPtr<U> const& b)
    {
        return a.get() == b.get();
    }

    template<class T, class U> inline bool operator!=(SharedPtr<T> const& a, SharedPtr<U> const& b)
    {
        return a.get() != b.get();
    }

    template<class T, class U> inline bool operator<(SharedPtr<T> const& a, SharedPtr<U> const& b)
    {
        return std::less<const void*>()(a.get(), b.get());
    }


}

namespace std
{




        template < typename T >
        struct hash< Ogre::SharedPtr< T > > : hash< T* >
        {
            typedef hash< T* > MyBase;
            typedef Ogre::SharedPtr< T > argument_type;
            typedef size_t result_type;

            result_type operator()( const argument_type& k ) const
            {
                return MyBase::operator()( k.get() );
            }
        };



}
namespace Ogre {







    typedef uint32 RGBA;
    typedef uint32 ARGB;
    typedef uint32 ABGR;
    typedef uint32 BGRA;
    class ColourValue
    {
    public:
        static const ColourValue ZERO;
        static const ColourValue Black;
        static const ColourValue White;
        static const ColourValue Red;
        static const ColourValue Green;
        static const ColourValue Blue;

        explicit ColourValue( float red = 1.0f,
                    float green = 1.0f,
                    float blue = 1.0f,
                    float alpha = 1.0f ) : r(red), g(green), b(blue), a(alpha)
        { }

        bool operator==(const ColourValue& rhs) const;
        bool operator!=(const ColourValue& rhs) const;

        float r,g,b,a;



        RGBA getAsRGBA(void) const;



        ARGB getAsARGB(void) const;



        BGRA getAsBGRA(void) const;


        ABGR getAsABGR(void) const;



        void setAsRGBA(const RGBA val);



        void setAsARGB(const ARGB val);



        void setAsBGRA(const BGRA val);



        void setAsABGR(const ABGR val);



        void saturate(void)
        {
            if (r < 0)
                r = 0;
            else if (r > 1)
                r = 1;

            if (g < 0)
                g = 0;
            else if (g > 1)
                g = 1;

            if (b < 0)
                b = 0;
            else if (b > 1)
                b = 1;

            if (a < 0)
                a = 0;
            else if (a > 1)
                a = 1;
        }



        ColourValue saturateCopy(void) const
        {
            ColourValue ret = *this;
            ret.saturate();
            return ret;
        }


        inline float operator [] ( const size_t i ) const
        {
            assert( i < 4 );

            return *(&r+i);
        }


        inline float& operator [] ( const size_t i )
        {
            assert( i < 4 );

            return *(&r+i);
        }


        inline float* ptr()
        {
            return &r;
        }

        inline const float* ptr() const
        {
            return &r;
        }



        inline ColourValue operator + ( const ColourValue& rkVector ) const
        {
            ColourValue kSum;

            kSum.r = r + rkVector.r;
            kSum.g = g + rkVector.g;
            kSum.b = b + rkVector.b;
            kSum.a = a + rkVector.a;

            return kSum;
        }

        inline ColourValue operator - ( const ColourValue& rkVector ) const
        {
            ColourValue kDiff;

            kDiff.r = r - rkVector.r;
            kDiff.g = g - rkVector.g;
            kDiff.b = b - rkVector.b;
            kDiff.a = a - rkVector.a;

            return kDiff;
        }

        inline ColourValue operator * (const float fScalar ) const
        {
            ColourValue kProd;

            kProd.r = fScalar*r;
            kProd.g = fScalar*g;
            kProd.b = fScalar*b;
            kProd.a = fScalar*a;

            return kProd;
        }

        inline ColourValue operator * ( const ColourValue& rhs) const
        {
            ColourValue kProd;

            kProd.r = rhs.r * r;
            kProd.g = rhs.g * g;
            kProd.b = rhs.b * b;
            kProd.a = rhs.a * a;

            return kProd;
        }

        inline ColourValue operator / ( const ColourValue& rhs) const
        {
            ColourValue kProd;

            kProd.r = r / rhs.r;
            kProd.g = g / rhs.g;
            kProd.b = b / rhs.b;
            kProd.a = a / rhs.a;

            return kProd;
        }

        inline ColourValue operator / (const float fScalar ) const
        {
            assert( fScalar != 0.0 );

            ColourValue kDiv;

            float fInv = 1.0f / fScalar;
            kDiv.r = r * fInv;
            kDiv.g = g * fInv;
            kDiv.b = b * fInv;
            kDiv.a = a * fInv;

            return kDiv;
        }

        inline friend ColourValue operator * (const float fScalar, const ColourValue& rkVector )
        {
            ColourValue kProd;

            kProd.r = fScalar * rkVector.r;
            kProd.g = fScalar * rkVector.g;
            kProd.b = fScalar * rkVector.b;
            kProd.a = fScalar * rkVector.a;

            return kProd;
        }


        inline ColourValue& operator += ( const ColourValue& rkVector )
        {
            r += rkVector.r;
            g += rkVector.g;
            b += rkVector.b;
            a += rkVector.a;

            return *this;
        }

        inline ColourValue& operator -= ( const ColourValue& rkVector )
        {
            r -= rkVector.r;
            g -= rkVector.g;
            b -= rkVector.b;
            a -= rkVector.a;

            return *this;
        }

        inline ColourValue& operator *= (const float fScalar )
        {
            r *= fScalar;
            g *= fScalar;
            b *= fScalar;
            a *= fScalar;
            return *this;
        }

        inline ColourValue& operator /= (const float fScalar )
        {
            assert( fScalar != 0.0 );

            float fInv = 1.0f / fScalar;

            r *= fInv;
            g *= fInv;
            b *= fInv;
            a *= fInv;

            return *this;
        }






        void setHSB(Real hue, Real saturation, Real brightness);






        void getHSB(Real* hue, Real* saturation, Real* brightness) const;





        inline friend std::ostream& operator <<
            ( std::ostream& o, const ColourValue& c )
        {
            o << "ColourValue(" << c.r << ", " << c.g << ", " << c.b << ", " << c.a << ")";
            return o;
        }

    };


}
namespace Ogre
{
    enum BufferType
    {


        BT_IMMUTABLE,
        BT_DEFAULT,






        BT_DYNAMIC_DEFAULT,


        BT_DYNAMIC_PERSISTENT,


        BT_DYNAMIC_PERSISTENT_COHERENT,
    };

    enum MappingState
    {
        MS_UNMAPPED,
        MS_MAPPED,
        NUM_MAPPING_STATE
    };

    enum UnmapOptions
    {

        UO_UNMAP_ALL,



        UO_KEEP_PERSISTENT
    };

    enum BufferPackedTypes
    {
        BP_TYPE_VERTEX,
        BP_TYPE_INDEX,
        BP_TYPE_CONST,
        BP_TYPE_TEX,
        BP_TYPE_INDIRECT,
        NUM_BUFFER_PACKED_TYPES
    };
    struct FreeOnDestructor
    {
        void *ptr;
        FreeOnDestructor( void *_ptr ) : ptr( _ptr ) {}
        ~FreeOnDestructor()
        {
            if( ptr )
                ::Ogre::CategorisedAlignAllocPolicy<MEMCATEGORY_GEOMETRY>::deallocateBytes((void*)ptr);
        }
    };

    class BufferPacked : public BufferPackedAlloc
    {
        friend class BufferInterface;
        friend class D3D11BufferInterface;
        friend class D3D11CompatBufferInterface;
        friend class GL3PlusBufferInterface;
        friend class NULLBufferInterface;

    protected:
        size_t mInternalBufferStart;
        size_t mFinalBufferStart;
        size_t mNumElements;
        uint32 mBytesPerElement;

        BufferType mBufferType;
        VaoManager *mVaoManager;

        MappingState mMappingState;

        BufferInterface *mBufferInterface;



        size_t mLastMappingStart;
        size_t mLastMappingCount;

        void *mShadowCopy;



        uint32 mLastFrameMapped;
        uint32 mLastFrameMappedAndAdvanced;


    public:
        BufferPacked( size_t internalBufferStartBytes, size_t numElements, uint32 bytesPerElement,
                      BufferType bufferType, void *initialData, bool keepAsShadow,
                      VaoManager *vaoManager, BufferInterface *bufferInterface );
        virtual ~BufferPacked();


        virtual BufferPackedTypes getBufferPackedType(void) const = 0;

        BufferType getBufferType(void) const { return mBufferType; }
        BufferInterface* getBufferInterface(void) const { return mBufferInterface; }



        AsyncTicketPtr readRequest( size_t elementStart, size_t elementCount );
        virtual void upload( const void *data, size_t elementStart, size_t elementCount );
        __attribute__ ((malloc)) void* map( size_t elementStart, size_t elementCount, bool bAdvanceFrame=true );
        void unmap( UnmapOptions unmapOption, size_t flushStartElem = 0, size_t flushSizeElem = 0 );



        void advanceFrame(void);




        void regressFrame(void);





        MappingState getMappingState(void) const { return mMappingState; }




        bool isCurrentlyMapped(void) const;

        uint32 getNumElements(void) const { return mNumElements; }
        uint32 getBytesPerElement(void) const { return mBytesPerElement; }
        uint32 getTotalSizeBytes(void) const { return mNumElements * mBytesPerElement; }

        size_t _getInternalBufferStart(void) const { return mInternalBufferStart; }
        size_t _getFinalBufferStart(void) const { return mFinalBufferStart; }

        const void* getShadowCopy(void) const { return mShadowCopy; }
    };

    typedef vector<BufferPacked*>::type BufferPackedVec;
    typedef unordered_set<BufferPacked*>::type BufferPackedSet;
}

namespace Ogre
{

    enum VertexElementSemantic
    {

        VES_POSITION = 1,

        VES_BLEND_WEIGHTS = 2,

        VES_BLEND_INDICES = 3,

        VES_NORMAL = 4,

        VES_DIFFUSE = 5,

        VES_SPECULAR = 6,


        VES_TEXTURE_COORDINATES = 7,

        VES_BINORMAL = 8,

        VES_TANGENT = 9,

        VES_BLEND_WEIGHTS2 = 10,

        VES_BLEND_INDICES2 = 11,

        VES_COUNT = 11,
    };




    enum VertexElementType
    {
        VET_FLOAT1 = 0,
        VET_FLOAT2 = 1,
        VET_FLOAT3 = 2,
        VET_FLOAT4 = 3,

        VET_COLOUR = 4,

        VET_SHORT2 = 6,

        VET_SHORT4 = 8,
        VET_UBYTE4 = 9,

        VET_COLOUR_ARGB = 10,

        VET_COLOUR_ABGR = 11,
        VET_DOUBLE1 = 12,
        VET_DOUBLE2 = 13,
        VET_DOUBLE3 = 14,
        VET_DOUBLE4 = 15,
        VET_USHORT1_DEPRECATED = 16,
        VET_USHORT2 = 17,
        VET_USHORT3_DEPRECATED = 18,
        VET_USHORT4 = 19,
        VET_INT1 = 20,
        VET_INT2 = 21,
        VET_INT3 = 22,
        VET_INT4 = 23,
        VET_UINT1 = 24,
        VET_UINT2 = 25,
        VET_UINT3 = 26,
        VET_UINT4 = 27,
        VET_BYTE4 = 28,
        VET_BYTE4_SNORM = 29,
        VET_UBYTE4_NORM = 30,
        VET_SHORT2_SNORM = 31,
        VET_SHORT4_SNORM = 32,
        VET_USHORT2_NORM = 33,
        VET_USHORT4_NORM = 34,
        VET_HALF2 = 35,
        VET_HALF4 = 36
    };
}



namespace Ogre
{
    struct VertexElement2
    {

        VertexElementType mType;

        VertexElementSemantic mSemantic;

        VertexElement2( VertexElementType type, VertexElementSemantic semantic ) :
            mType( type ), mSemantic( semantic ) {}

        bool operator == ( const VertexElement2 _r ) const
        {
            return mType == _r.mType && mSemantic == _r.mSemantic;
        }

        bool operator == ( VertexElementSemantic semantic ) const
        {
            return mSemantic == semantic;
        }
    };

    typedef vector<VertexElement2>::type VertexElement2Vec;
    typedef vector<VertexElement2Vec>::type VertexElement2VecVec;

    class VertexBufferPacked : public BufferPacked
    {
    protected:
        VertexElement2Vec mVertexElements;
        size_t mMultiSourceId;
        MultiSourceVertexBufferPool *mMultiSourcePool;
        uint8 mSourceIdx;

    public:
        VertexBufferPacked( size_t internalBufferStartBytes, size_t numElements, uint32 bytesPerElement,
                            BufferType bufferType, void *initialData, bool keepAsShadow,
                            VaoManager *vaoManager, BufferInterface *bufferInterface,
                            const VertexElement2Vec &vertexElements, size_t multiSourceId,
                            MultiSourceVertexBufferPool *multiSourcePool, uint8 sourceIdx );
        ~VertexBufferPacked();

        virtual BufferPackedTypes getBufferPackedType(void) const { return BP_TYPE_VERTEX; }

        const VertexElement2Vec& getVertexElements(void) const { return mVertexElements; }

        size_t getMultiSourceId(void) { return mMultiSourceId; }


        MultiSourceVertexBufferPool* getMultiSourcePool(void) { return mMultiSourcePool; }






        uint8 _getSourceIndex(void) const { return mSourceIdx; }
    };

    typedef vector<VertexBufferPacked*>::type VertexBufferPackedVec;
}

namespace Ogre {
namespace v1 {
    class HardwareBufferManagerBase;
    class HardwareVertexBuffer : public HardwareBuffer
    {
        protected:

            HardwareBufferManagerBase* mMgr;
            size_t mNumVertices;
            size_t mVertexSize;
            bool mIsInstanceData;
            size_t mInstanceDataStepRate;

            virtual bool checkIfVertexInstanceDataIsSupported();

        public:

            HardwareVertexBuffer(HardwareBufferManagerBase* mgr, size_t vertexSize, size_t numVertices,
                HardwareBuffer::Usage usage, bool useSystemMemory, bool useShadowBuffer);
            ~HardwareVertexBuffer();

            HardwareBufferManagerBase* getManager() const { return mMgr; }

            size_t getVertexSize(void) const { return mVertexSize; }

            size_t getNumVertices(void) const { return mNumVertices; }

            bool getIsInstanceData() const { return mIsInstanceData; }

            void setIsInstanceData(const bool val);

            size_t getInstanceDataStepRate() const;

            void setInstanceDataStepRate(const size_t val);




    };


    class HardwareVertexBufferSharedPtr : public SharedPtr<HardwareVertexBuffer>
    {
    public:
        HardwareVertexBufferSharedPtr() : SharedPtr<HardwareVertexBuffer>() {}
        explicit HardwareVertexBufferSharedPtr(HardwareVertexBuffer* buf);


    };


    typedef HardwareBufferLockGuard<HardwareVertexBufferSharedPtr> HardwareVertexBufferLockGuard;
}

namespace v1 {
    class VertexElement : public VertexDataAlloc
    {
    protected:

        unsigned short mSource;

        size_t mOffset;

        VertexElementType mType;

        VertexElementSemantic mSemantic;

        unsigned short mIndex;
    public:

        VertexElement() {}

        VertexElement(unsigned short source, size_t offset, VertexElementType theType,
            VertexElementSemantic semantic, unsigned short index = 0);

        unsigned short getSource(void) const { return mSource; }

        size_t getOffset(void) const { return mOffset; }

        VertexElementType getType(void) const { return mType; }

        VertexElementSemantic getSemantic(void) const { return mSemantic; }

        unsigned short getIndex(void) const { return mIndex; }

        size_t getSize(void) const;

        static size_t getTypeSize(VertexElementType etype);

        static unsigned short getTypeCount(VertexElementType etype);

        static bool isTypeNormalized(VertexElementType etype);



        static VertexElementType multiplyTypeCount(VertexElementType baseType, unsigned short count);



        static VertexElementType getBaseType(VertexElementType multiType);







        static void convertColourValue(VertexElementType srcType,
            VertexElementType dstType, uint32* ptr);






        static uint32 convertColourValue(const ColourValue& src,
            VertexElementType dst);


        static VertexElementType getBestColourVertexElementType(void);

        inline bool operator== (const VertexElement& rhs) const
        {
            if (mType != rhs.mType ||
                mIndex != rhs.mIndex ||
                mOffset != rhs.mOffset ||
                mSemantic != rhs.mSemantic ||
                mSource != rhs.mSource)
                return false;
            else
                return true;

        }







        inline void baseVertexPointerToElement(void* pBase, void** pElem) const
        {


            *pElem = static_cast<void*>(
                static_cast<unsigned char*>(pBase) + mOffset);
        }







        inline void baseVertexPointerToElement(void* pBase, float** pElem) const
        {



            *pElem = static_cast<float*>(
                static_cast<void*>(
                    static_cast<unsigned char*>(pBase) + mOffset));
        }
        inline void baseVertexPointerToElement(void* pBase, RGBA** pElem) const
        {
            *pElem = static_cast<RGBA*>(
                static_cast<void*>(
                    static_cast<unsigned char*>(pBase) + mOffset));
        }







        inline void baseVertexPointerToElement(void* pBase, unsigned char** pElem) const
        {
            *pElem = static_cast<unsigned char*>(pBase) + mOffset;
        }
        inline void baseVertexPointerToElement(void* pBase, unsigned short** pElem) const
        {
            *pElem = static_cast<unsigned short*>(
                static_cast<void*>(
                    static_cast<unsigned char*>(pBase) + mOffset));
        }


    };
    class VertexDeclaration : public VertexDataAlloc
    {
    public:

        typedef list<VertexElement>::type VertexElementList;

        static bool vertexElementLess(const VertexElement& e1, const VertexElement& e2);
        static bool vertexElementLessForV2(const VertexElement& e1, const VertexElement& e2);
    protected:
        VertexElementList mElementList;
    public:

        VertexDeclaration();
        virtual ~VertexDeclaration();


        size_t getElementCount(void) const { return mElementList.size(); }

        const VertexElementList& getElements(void) const;

        const VertexElement* getElement(unsigned short index) const;
        void sort(void);

        void sortForV2(void);
        void closeGapsInSource(void);
        VertexDeclaration* getAutoOrganisedDeclaration(bool skeletalAnimation,
            bool vertexAnimation, bool vertexAnimationNormals) const;


        unsigned short getMaxSource(void) const;
        virtual const VertexElement& addElement(unsigned short source, size_t offset, VertexElementType theType,
            VertexElementSemantic semantic, unsigned short index = 0);
        virtual const VertexElement& insertElement(unsigned short atPosition,
            unsigned short source, size_t offset, VertexElementType theType,
            VertexElementSemantic semantic, unsigned short index = 0);


        virtual void removeElement(unsigned short elem_index);







        virtual void removeElement(VertexElementSemantic semantic, unsigned short index = 0);


        virtual void removeAllElements(void);






        virtual void modifyElement(unsigned short elem_index, unsigned short source, size_t offset, VertexElementType theType,
            VertexElementSemantic semantic, unsigned short index = 0);






        virtual const VertexElement* findElementBySemantic(VertexElementSemantic sem, unsigned short index = 0) const;
        virtual VertexElementList findElementsBySource(unsigned short source) const;


        virtual size_t getVertexSize(unsigned short source) const;




        virtual unsigned short getNextFreeTextureCoordinate() const;





        virtual VertexDeclaration* clone(HardwareBufferManagerBase* mgr = 0) const;

        VertexElement2VecVec convertToV2(void);
        void convertFromV2( const VertexElement2Vec &v2Decl );
        void convertFromV2( const VertexElement2VecVec &v2Decl );

        inline bool operator== (const VertexDeclaration& rhs) const
        {
            if (mElementList.size() != rhs.mElementList.size())
                return false;

            VertexElementList::const_iterator i, iend, rhsi, rhsiend;
            iend = mElementList.end();
            rhsiend = rhs.mElementList.end();
            rhsi = rhs.mElementList.begin();
            for (i = mElementList.begin(); i != iend && rhsi != rhsiend; ++i, ++rhsi)
            {
                if ( !(*i == *rhsi) )
                    return false;
            }

            return true;
        }
        inline bool operator!= (const VertexDeclaration& rhs) const
        {
            return !(*this == rhs);
        }

    };
    class VertexBufferBinding : public VertexDataAlloc
    {
    public:

        typedef map<unsigned short, HardwareVertexBufferSharedPtr>::type VertexBufferBindingMap;
    protected:
        VertexBufferBindingMap mBindingMap;
        mutable unsigned short mHighIndex;
    public:

        VertexBufferBinding();
        virtual ~VertexBufferBinding();
        virtual void setBinding(unsigned short index, const HardwareVertexBufferSharedPtr& buffer);

        virtual void unsetBinding(unsigned short index);


        virtual void unsetAllBindings(void);


        virtual const VertexBufferBindingMap& getBindings(void) const;


        virtual const HardwareVertexBufferSharedPtr& getBuffer(unsigned short index) const;

        virtual bool isBufferBound(unsigned short index) const;

        virtual size_t getBufferCount(void) const { return mBindingMap.size(); }






        virtual unsigned short getNextIndex(void) const { return mHighIndex++; }



        virtual unsigned short getLastBoundIndex(void) const;

        typedef map<ushort, ushort>::type BindingIndexMap;



        virtual bool hasGaps(void) const;
        virtual void closeGaps(BindingIndexMap& bindingIndexMap);


        virtual bool getHasInstanceData() const;


    };




}
}




namespace Ogre {
namespace v1 {
    class Pose : public AnimationAlloc
    {
    public:





        Pose(ushort target, const String& name = BLANKSTRING);
        virtual ~Pose();

        const String& getName(void) const { return mName; }

        ushort getTarget(void) const { return mTarget; }

        typedef map<size_t, Vector3>::type VertexOffsetMap;

        typedef MapIterator<VertexOffsetMap> VertexOffsetIterator;

        typedef ConstMapIterator<VertexOffsetMap> ConstVertexOffsetIterator;

        typedef map<size_t, Vector3>::type NormalsMap;

        typedef MapIterator<NormalsMap> NormalsIterator;

        typedef ConstMapIterator<NormalsMap> ConstNormalsIterator;

        bool getIncludesNormals() const { return !mNormalsMap.empty(); }





        void addVertex(size_t index, const Vector3& offset);





        void addVertex(size_t index, const Vector3& offset, const Vector3& normal);


        void removeVertex(size_t index);


        void clearVertices(void);


        ConstVertexOffsetIterator getVertexOffsetIterator(void) const;

        VertexOffsetIterator getVertexOffsetIterator(void);

        const VertexOffsetMap& getVertexOffsets(void) const { return mVertexOffsetMap; }


        ConstNormalsIterator getNormalsIterator(void) const;

        NormalsIterator getNormalsIterator(void);

        const NormalsMap& getNormals(void) const { return mNormalsMap; }


        const HardwareVertexBufferSharedPtr& _getHardwareVertexBuffer(const VertexData* origData) const;




        Pose* clone(void) const;
    protected:

        ushort mTarget;

        String mName;

        VertexOffsetMap mVertexOffsetMap;

        NormalsMap mNormalsMap;

        mutable HardwareVertexBufferSharedPtr mBuffer;
    };
    typedef vector<Pose*>::type PoseList;




}
}


namespace Ogre
{
namespace v1
{
    class VertexPoseKeyFrame;
    class KeyFrame;
    class TimeIndex
    {
    protected:


        Real mTimePos;





        uint mKeyIndex;



        static const uint INVALID_KEY_INDEX = (uint)-1;

    public:


        TimeIndex(Real timePos)
            : mTimePos(timePos)
            , mKeyIndex(INVALID_KEY_INDEX)
        {
        }






        TimeIndex(Real timePos, uint keyIndex)
            : mTimePos(timePos)
            , mKeyIndex(keyIndex)
        {
        }

        bool hasKeyIndex(void) const
        {
            return mKeyIndex != INVALID_KEY_INDEX;
        }

        Real getTimePos(void) const
        {
            return mTimePos;
        }

        uint getKeyIndex(void) const
        {
            return mKeyIndex;
        }
    };
    class AnimationTrack : public AnimationAlloc
    {
    public:




        class Listener
        {
        public:
            virtual ~Listener() {}




            virtual bool getInterpolatedKeyFrame(const AnimationTrack* t, const TimeIndex& timeIndex, KeyFrame* kf) = 0;
        };


        AnimationTrack(Animation* parent, unsigned short handle);

        virtual ~AnimationTrack();


        unsigned short getHandle(void) const { return mHandle; }


        virtual unsigned short getNumKeyFrames(void) const;


        virtual KeyFrame* getKeyFrame(unsigned short index) const;
        virtual Real getKeyFramesAtTime(const TimeIndex& timeIndex, KeyFrame** keyFrame1, KeyFrame** keyFrame2,
            unsigned short* firstKeyIndex = 0) const;
        virtual KeyFrame* createKeyFrame(Real timePos);


        virtual void removeKeyFrame(unsigned short index);


        virtual void removeAllKeyFrames(void);
        virtual void getInterpolatedKeyFrame(const TimeIndex& timeIndex, KeyFrame* kf) const = 0;
        virtual void apply(const TimeIndex& timeIndex, Real weight = 1.0, Real scale = 1.0f) = 0;



        virtual void _keyFrameDataChanged(void) const {}





        virtual bool hasNonZeroKeyFrames(void) const { return true; }


        virtual void optimise(void) {}


        virtual void _collectKeyFrameTimes(vector<Real>::type& keyFrameTimes);



        virtual void _buildKeyFrameIndexMap(const vector<Real>::type& keyFrameTimes);


        virtual void _applyBaseKeyFrame(const KeyFrame* base);


        virtual void setListener(Listener* l) { mListener = l; }


        Animation *getParent() const { return mParent; }
    protected:
        typedef vector<KeyFrame*>::type KeyFrameList;
        KeyFrameList mKeyFrames;
  Animation* mParent;
  unsigned short mHandle;
        Listener* mListener;


        typedef vector<ushort>::type KeyFrameIndexMap;
        KeyFrameIndexMap mKeyFrameIndexMap;


        virtual KeyFrame* createKeyFrameImpl(Real time) = 0;


        virtual void populateClone(AnimationTrack* clone) const;



    };



    class NumericAnimationTrack : public AnimationTrack
    {
    public:

        NumericAnimationTrack(Animation* parent, unsigned short handle);

        NumericAnimationTrack(Animation* parent, unsigned short handle,
            AnimableValuePtr& target);
        virtual NumericKeyFrame* createNumericKeyFrame(Real timePos);


        virtual void getInterpolatedKeyFrame(const TimeIndex& timeIndex, KeyFrame* kf) const;


        virtual void apply(const TimeIndex& timeIndex, Real weight = 1.0, Real scale = 1.0f);
        void applyToAnimable(const AnimableValuePtr& anim, const TimeIndex& timeIndex,
            Real weight = 1.0, Real scale = 1.0f);


        virtual const AnimableValuePtr& getAssociatedAnimable(void) const;



        virtual void setAssociatedAnimable(const AnimableValuePtr& val);


        NumericKeyFrame* getNumericKeyFrame(unsigned short index) const;


        NumericAnimationTrack* _clone(Animation* newParent) const;


    protected:

        AnimableValuePtr mTargetAnim;


        KeyFrame* createKeyFrameImpl(Real time);


    };



 class NodeAnimationTrack : public AnimationTrack
 {
 public:

  NodeAnimationTrack(Animation* parent, unsigned short handle);

  NodeAnimationTrack(Animation* parent, unsigned short handle, Node* targetNode);

  virtual ~NodeAnimationTrack();







  virtual TransformKeyFrame* createNodeKeyFrame(Real timePos);






        void getInitialState(Vector3* outPosition, Quaternion* outOrientation, Vector3* outScale);
        void setInitialState(const Vector3& position, const Quaternion& orientation, const Vector3& scale);





  void resetNodeToInitialState(void);


  Node* getAssociatedNode(void) const;


  void setAssociatedNode(Node* node);


  void applyToNode(Node* node, const TimeIndex& timeIndex, Real weight = 1.0, Real scale = 1.0f);


  virtual void setUseShortestRotationPath(bool useShortestPath);


  virtual bool getUseShortestRotationPath() const;


  virtual void getInterpolatedKeyFrame(const TimeIndex& timeIndex, KeyFrame* kf) const;


  virtual void apply(const TimeIndex& timeIndex, Real weight = 1.0, Real scale = 1.0f);


  void _keyFrameDataChanged(void) const;


  virtual TransformKeyFrame* getNodeKeyFrame(unsigned short index) const;






  virtual bool hasNonZeroKeyFrames(void) const;


  virtual void optimise(void);


  NodeAnimationTrack* _clone(Animation* newParent) const;

  void _applyBaseKeyFrame(const KeyFrame* base);

 protected:

  KeyFrame* createKeyFrameImpl(Real time);

  virtual void buildInterpolationSplines(void) const;


  struct Splines
  {
   SimpleSpline positionSpline;
   SimpleSpline scaleSpline;
   RotationalSpline rotationSpline;
  };

  Node* mTargetNode;







  Vector3 mInitialPosition;
  Quaternion mInitialOrientation;
  Vector3 mInitialScale;


  mutable Splines* mSplines;
  mutable bool mSplineBuildNeeded;

  mutable bool mUseShortestRotationPath;
 };



 class OldNodeAnimationTrack : public AnimationTrack
    {
    public:

  OldNodeAnimationTrack(Animation* parent, unsigned short handle);

  OldNodeAnimationTrack(Animation* parent, unsigned short handle,
            OldNode* targetNode);

  virtual ~OldNodeAnimationTrack();







        virtual TransformKeyFrame* createNodeKeyFrame(Real timePos);

  OldNode* getAssociatedNode(void) const;


  void setAssociatedNode(OldNode* node);


  void applyToNode(OldNode* node, const TimeIndex& timeIndex, Real weight = 1.0,
            Real scale = 1.0f);


        virtual void setUseShortestRotationPath(bool useShortestPath);


        virtual bool getUseShortestRotationPath() const;


        virtual void getInterpolatedKeyFrame(const TimeIndex& timeIndex, KeyFrame* kf) const;


        virtual void apply(const TimeIndex& timeIndex, Real weight = 1.0, Real scale = 1.0f);


        void _keyFrameDataChanged(void) const;


        virtual TransformKeyFrame* getNodeKeyFrame(unsigned short index) const;






        virtual bool hasNonZeroKeyFrames(void) const;


        virtual void optimise(void);


  OldNodeAnimationTrack* _clone(Animation* newParent) const;

        void _applyBaseKeyFrame(const KeyFrame* base);

    protected:

        KeyFrame* createKeyFrameImpl(Real time);

        virtual void buildInterpolationSplines(void) const;


        struct Splines
        {
            SimpleSpline positionSpline;
            SimpleSpline scaleSpline;
            RotationalSpline rotationSpline;
        };

        OldNode* mTargetNode;

        mutable Splines* mSplines;
        mutable bool mSplineBuildNeeded;

        mutable bool mUseShortestRotationPath ;
    };
    enum VertexAnimationType
    {

        VAT_NONE = 0,

        VAT_MORPH = 1,

        VAT_POSE = 2
    };




    class VertexAnimationTrack : public AnimationTrack
    {
    public:

        enum TargetMode
        {

            TM_SOFTWARE,


            TM_HARDWARE
        };

        VertexAnimationTrack(Animation* parent, unsigned short handle, VertexAnimationType animType);

        VertexAnimationTrack(Animation* parent, unsigned short handle, VertexAnimationType animType,
            VertexData* targetData, TargetMode target = TM_SOFTWARE);


        VertexAnimationType getAnimationType(void) const { return mAnimationType; }


        bool getVertexAnimationIncludesNormals() const;
        virtual VertexMorphKeyFrame* createVertexMorphKeyFrame(Real timePos);



        virtual VertexPoseKeyFrame* createVertexPoseKeyFrame(Real timePos);



        virtual void getInterpolatedKeyFrame(const TimeIndex& timeIndex, KeyFrame* kf) const;


        virtual void apply(const TimeIndex& timeIndex, Real weight = 1.0, Real scale = 1.0f);



        virtual void applyToVertexData(VertexData* data,
            const TimeIndex& timeIndex, Real weight = 1.0,
            const PoseList* poseList = 0);



        VertexMorphKeyFrame* getVertexMorphKeyFrame(unsigned short index) const;


        VertexPoseKeyFrame* getVertexPoseKeyFrame(unsigned short index) const;


        void setAssociatedVertexData(VertexData* data) { mTargetVertexData = data; }

        VertexData* getAssociatedVertexData(void) const { return mTargetVertexData; }


        void setTargetMode(TargetMode m) { mTargetMode = m; }

        TargetMode getTargetMode(void) const { return mTargetMode; }





        virtual bool hasNonZeroKeyFrames(void) const;


        virtual void optimise(void);


        VertexAnimationTrack* _clone(Animation* newParent) const;

        void _applyBaseKeyFrame(const KeyFrame* base);

    protected:

        VertexAnimationType mAnimationType;

        VertexData* mTargetVertexData;

        TargetMode mTargetMode;


        KeyFrame* createKeyFrameImpl(Real time);


        void applyPoseToVertexData(const Pose* pose, VertexData* data, Real influence);


    };


}
}

namespace Ogre {
    template <typename T>
    class ControllerFunction : public ControllerAlloc
    {
    protected:

        bool mDeltaInput;
        T mDeltaCount;



        T getAdjustedInput(T input)
        {
            if (mDeltaInput)
            {
                mDeltaCount += input;

                while (mDeltaCount >= 1.0)
                    mDeltaCount -= 1.0;
                while (mDeltaCount < 0.0)
                    mDeltaCount += 1.0;

                return mDeltaCount;
            }
            else
            {
                return input;
            }
        }

    public:





        ControllerFunction(bool deltaInput)
        {
            mDeltaInput = deltaInput;
            mDeltaCount = 0;
        }

        virtual ~ControllerFunction() {}

        virtual T calculate(T sourceValue) = 0;
    };




    template <typename T>
    class ControllerValue : public ControllerAlloc
    {

    public:
        virtual ~ControllerValue() { }
        virtual T getValue(void) const = 0;
        virtual void setValue(T value) = 0;

    };
    template <typename T>
    class Controller : public ControllerAlloc
    {
    protected:

        SharedPtr< ControllerValue<T> > mSource;

        SharedPtr< ControllerValue<T> > mDest;

        SharedPtr< ControllerFunction<T> > mFunc;

        bool mEnabled;


    public:






        Controller(const SharedPtr< ControllerValue<T> >& src,
            const SharedPtr< ControllerValue<T> >& dest, const SharedPtr< ControllerFunction<T> >& func)
            : mSource(src), mDest(dest), mFunc(func)
        {
            mEnabled = true;
        }



        virtual ~Controller() {}



        void setSource(const SharedPtr< ControllerValue<T> >& src)
        {
            mSource = src;
        }

        const SharedPtr< ControllerValue<T> >& getSource(void) const
        {
            return mSource;
        }

        void setDestination(const SharedPtr< ControllerValue<T> >& dest)
        {
            mDest = dest;
        }


        const SharedPtr< ControllerValue<T> >& getDestination(void) const
        {
            return mDest;
        }


        bool getEnabled(void) const
        {
            return mEnabled;
        }


        void setEnabled(bool enabled)
        {
            mEnabled = enabled;
        }



        void setFunction(const SharedPtr< ControllerFunction<T> >& func)
        {
            mFunc = func;
        }



        const SharedPtr< ControllerFunction<T> >& getFunction(void) const
        {
            return mFunc;
        }






        void update(void)
        {
            if(mEnabled)
                mDest->setValue(mFunc->calculate(mSource->getValue()));
        }

    };




}



namespace Ogre {
namespace v1 {
    class AnimationState : public AnimationAlloc
    {
    public:


        typedef vector<float>::type BoneBlendMask;
        AnimationState(const String& animName, AnimationStateSet *parent,
            Real timePos, Real length, Real weight = 1.0, bool enabled = false);

        AnimationState(AnimationStateSet* parent, const AnimationState &rhs);
        virtual ~AnimationState();


        const String& getAnimationName() const;

        Real getTimePosition(void) const;

        void setTimePosition(Real timePos);

        Real getLength() const;

        void setLength(Real len);

        Real getWeight(void) const;

        void setWeight(Real weight);





        void addTime(Real offset);


        bool hasEnded(void) const;


        bool getEnabled(void) const;

        void setEnabled(bool enabled);


        bool operator==(const AnimationState& rhs) const;

        bool operator!=(const AnimationState& rhs) const;




        void setLoop(bool loop) { mLoop = loop; }

        bool getLoop(void) const { return mLoop; }





        void copyStateFrom(const AnimationState& animState);


        AnimationStateSet* getParent(void) const { return mParent; }
      void createBlendMask(size_t blendMaskSizeHint, float initialWeight = 1.0f);

      void destroyBlendMask();







      void _setBlendMaskData(const float* blendMaskData);







      void _setBlendMask(const BoneBlendMask* blendMask);

      const BoneBlendMask* getBlendMask() const {return mBlendMask;}

      bool hasBlendMask() const {return mBlendMask != 0;}

      void setBlendMaskEntry(size_t boneHandle, float weight);

      inline float getBlendMaskEntry(size_t boneHandle) const
      {
          assert(mBlendMask && mBlendMask->size() > boneHandle);
          return (*mBlendMask)[boneHandle];
      }
    protected:

        BoneBlendMask* mBlendMask;

        String mAnimationName;
        AnimationStateSet* mParent;
        Real mTimePos;
        Real mLength;
        Real mWeight;
        bool mEnabled;
        bool mLoop;

    };


    typedef map<String, AnimationState*>::type AnimationStateMap;
    typedef MapIterator<AnimationStateMap> AnimationStateIterator;
    typedef ConstMapIterator<AnimationStateMap> ConstAnimationStateIterator;

    typedef list<AnimationState*>::type EnabledAnimationStateList;
    typedef ConstVectorIterator<EnabledAnimationStateList> ConstEnabledAnimationStateIterator;



    class AnimationStateSet : public AnimationAlloc
    {
    public:

                           ;

        AnimationStateSet();

        AnimationStateSet(const AnimationStateSet& rhs);

        ~AnimationStateSet();
        AnimationState* createAnimationState(const String& animName,
            Real timePos, Real length, Real weight = 1.0, bool enabled = false);

        AnimationState* getAnimationState(const String& name) const;

        bool hasAnimationState(const String& name) const;

        void removeAnimationState(const String& name);

        void removeAllAnimationStates(void);







        AnimationStateIterator getAnimationStateIterator(void);






        ConstAnimationStateIterator getAnimationStateIterator(void) const;

        void copyMatchingState(AnimationStateSet* target) const;

        void _notifyDirty(void);

        unsigned long getDirtyFrameNumber(void) const { return mDirtyFrameNumber; }


        void _notifyAnimationStateEnabled(AnimationState* target, bool enabled);

        bool hasEnabledAnimationState(void) const { return !mEnabledAnimationStates.empty(); }






        ConstEnabledAnimationStateIterator getEnabledAnimationStateIterator(void) const;

    protected:
        unsigned long mDirtyFrameNumber;
        AnimationStateMap mAnimationStates;
        EnabledAnimationStateList mEnabledAnimationStates;

    };
    class AnimationStateControllerValue : public ControllerValue<Real>
    {
    protected:
        AnimationState* mTargetAnimationState;
    public:

        AnimationStateControllerValue(AnimationState* targetAnimationState)
            : mTargetAnimationState(targetAnimationState) {}

        ~AnimationStateControllerValue() {}

        Real getValue(void) const;


        void setValue(Real value);

    };



}
}



namespace Ogre {
namespace v1 {
    class Animation;
    class AnimationContainer
    {
    public:
        virtual ~AnimationContainer() {}


        virtual unsigned short getNumAnimations(void) const = 0;


        virtual Animation* getAnimation(unsigned short index) const = 0;


        virtual Animation* getAnimation(const String& name) const = 0;


        virtual Animation* createAnimation(const String& name, Real length) = 0;


        virtual bool hasAnimation(const String& name) const = 0;


        virtual void removeAnimation(const String& name) = 0;

    };
    class Animation : public AnimationAlloc
    {

    public:

        enum InterpolationMode
        {

            IM_LINEAR,

            IM_SPLINE
        };


        enum RotationInterpolationMode
        {



            RIM_LINEAR,



            RIM_SPHERICAL
        };




        Animation(const String& name, Real length);
        virtual ~Animation();


        const String& getName(void) const;


        Real getLength(void) const;





        void setLength(Real len);





  NodeAnimationTrack* createNodeTrack(void);





  OldNodeAnimationTrack* createOldNodeTrack(unsigned short handle);





        NumericAnimationTrack* createNumericTrack(unsigned short handle);
        VertexAnimationTrack* createVertexTrack(unsigned short handle, VertexAnimationType animType);
  NodeAnimationTrack* createNodeTrack(Node* node);
  OldNodeAnimationTrack* createOldNodeTrack(unsigned short handle, OldNode* node);






        NumericAnimationTrack* createNumericTrack(unsigned short handle,
            const AnimableValuePtr& anim);







        VertexAnimationTrack* createVertexTrack(unsigned short handle,
            VertexData* data, VertexAnimationType animType);


  size_t getNumNodeTracks(void) const;


  NodeAnimationTrack* getNodeTrack( size_t handle ) const;


  size_t getNumOldNodeTracks(void) const;


  OldNodeAnimationTrack* getOldNodeTrack(unsigned short handle) const;


  bool hasOldNodeTrack(unsigned short handle) const;


        unsigned short getNumNumericTracks(void) const;


        NumericAnimationTrack* getNumericTrack(unsigned short handle) const;


        bool hasNumericTrack(unsigned short handle) const;


        unsigned short getNumVertexTracks(void) const;


        VertexAnimationTrack* getVertexTrack(unsigned short handle) const;


        bool hasVertexTrack(unsigned short handle) const;


  void destroyOldNodeTrack(unsigned short handle);


        void destroyNumericTrack(unsigned short handle);


        void destroyVertexTrack(unsigned short handle);


        void destroyAllTracks(void);


        void destroyAllNodeTracks(void);
  void destroyAllOldNodeTracks(void);

        void destroyAllNumericTracks(void);

        void destroyAllVertexTracks(void);
        void apply(Real timePos, Real weight = 1.0, Real scale = 1.0f);
        void applyToNode(OldNode* node, Real timePos, Real weight = 1.0, Real scale = 1.0f);
        void apply(Skeleton* skeleton, Real timePos, Real weight = 1.0, Real scale = 1.0f);
        void apply(Skeleton* skeleton, Real timePos, float weight,
          const AnimationState::BoneBlendMask* blendMask, Real scale);
        void apply(Entity* entity, Real timePos, Real weight, bool software,
            bool hardware);
        void applyToAnimable(const AnimableValuePtr& anim, Real timePos, Real weight = 1.0, Real scale = 1.0f);
        void applyToVertexData(VertexData* data, Real timePos, Real weight = 1.0);
        void setInterpolationMode(InterpolationMode im);





        InterpolationMode getInterpolationMode(void) const;
        void setRotationInterpolationMode(RotationInterpolationMode im);





        RotationInterpolationMode getRotationInterpolationMode(void) const;
        static void setDefaultInterpolationMode(InterpolationMode im);


        static InterpolationMode getDefaultInterpolationMode(void);







        static void setDefaultRotationInterpolationMode(RotationInterpolationMode im);


        static RotationInterpolationMode getDefaultRotationInterpolationMode(void);

  typedef vector<NodeAnimationTrack*>::type NodeTrackList;
  typedef ConstVectorIterator<NodeTrackList> NodeTrackIterator;

  typedef map<unsigned short, OldNodeAnimationTrack*>::type OldNodeTrackList;
  typedef ConstMapIterator<OldNodeTrackList> OldNodeTrackIterator;

        typedef map<unsigned short, NumericAnimationTrack*>::type NumericTrackList;
        typedef ConstMapIterator<NumericTrackList> NumericTrackIterator;

        typedef map<unsigned short, VertexAnimationTrack*>::type VertexTrackList;
        typedef ConstMapIterator<VertexTrackList> VertexTrackIterator;


        const NodeTrackList& _getNodeTrackList(void) const;

  const OldNodeTrackList& _getOldNodeTrackList(void) const;


        NodeTrackIterator getNodeTrackIterator(void) const
        { return NodeTrackIterator(mNodeTrackList.begin(), mNodeTrackList.end()); }


  OldNodeTrackIterator getOldNodeTrackIterator(void) const
  { return OldNodeTrackIterator(mOldNodeTrackList.begin(), mOldNodeTrackList.end()); }


        const NumericTrackList& _getNumericTrackList(void) const;


        NumericTrackIterator getNumericTrackIterator(void) const
        { return NumericTrackIterator(mNumericTrackList.begin(), mNumericTrackList.end()); }


        const VertexTrackList& _getVertexTrackList(void) const;


        VertexTrackIterator getVertexTrackIterator(void) const
        { return VertexTrackIterator(mVertexTrackList.begin(), mVertexTrackList.end()); }
        void optimise(bool discardIdentityNodeTracks = true);


        typedef set<ushort>::type TrackHandleList;
  void _collectIdentityOldNodeTracks(TrackHandleList& tracks) const;



  void _destroyOldNodeTracks(const TrackHandleList& tracks);







        Animation* clone(const String& newName) const;



        void _keyFrameListChanged(void) { mKeyFrameTimesDirty = true; }
        TimeIndex _getTimeIndex(Real timePos) const;
        void setUseBaseKeyFrame(bool useBaseKeyFrame, Real keyframeTime = 0.0f, const String& baseAnimName = BLANKSTRING);

        bool getUseBaseKeyFrame() const;

        Real getBaseKeyFrameTime() const;

        const String& getBaseKeyFrameAnimationName() const;


        void _applyBaseKeyFrame();

        void _notifyContainer(AnimationContainer* c);

        AnimationContainer* getContainer();

    protected:

        NodeTrackList mNodeTrackList;

  OldNodeTrackList mOldNodeTrackList;

        NumericTrackList mNumericTrackList;

        VertexTrackList mVertexTrackList;
        String mName;

        Real mLength;

        InterpolationMode mInterpolationMode;
        RotationInterpolationMode mRotationInterpolationMode;

        static InterpolationMode msDefaultInterpolationMode;
        static RotationInterpolationMode msDefaultRotationInterpolationMode;


        typedef vector<Real>::type KeyFrameTimeList;
        mutable KeyFrameTimeList mKeyFrameTimes;

        mutable bool mKeyFrameTimesDirty;

        bool mUseBaseKeyFrame;
        Real mBaseKeyFrameTime;
        String mBaseKeyFrameAnimationName;
        AnimationContainer* mContainer;

  void optimiseOldNodeTracks(bool discardIdentityTracks);
        void optimiseVertexTracks(void);


        void buildKeyFrameTimeList(void) const;
    };



}
}





namespace Ogre
{
    class Any
    {
    public:

        Any()
          : mContent(0)
        {
        }

        template<typename ValueType>
        explicit Any(const ValueType & value)
          : mContent(new (::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GENERAL>::allocateBytes(sizeof(holder<ValueType>))) holder<ValueType>(value))
        {
        }

        Any(const Any & other)
          : mContent(other.mContent ? other.mContent->clone() : 0)
        {
        }

        virtual ~Any()
        {
            destroy();
        }

    public:

        Any& swap(Any & rhs)
        {
            std::swap(mContent, rhs.mContent);
            return *this;
        }

        template<typename ValueType>
        Any& operator=(const ValueType & rhs)
        {
            Any(rhs).swap(*this);
            return *this;
        }

        Any & operator=(const Any & rhs)
        {
            Any(rhs).swap(*this);
            return *this;
        }

    public:

        bool isEmpty() const
        {
            return !mContent;
        }

        const std::type_info& getType() const
        {
            return mContent ? mContent->getType() : typeid(void);
        }

        inline friend std::ostream& operator <<
            ( std::ostream& o, const Any& v )
        {
            if (v.mContent)
                v.mContent->writeToStream(o);
            return o;
        }

        void destroy()
        {
            if(mContent){(mContent)->~placeholder(); ::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GENERAL>::deallocateBytes((void*)mContent);};
            mContent = NULL;
        }

    protected:

        class placeholder
        {
        public:

            virtual ~placeholder()
            {
            }

        public:

            virtual const std::type_info& getType() const = 0;

            virtual placeholder * clone() const = 0;

            virtual void writeToStream(std::ostream& o) = 0;

        };

        template<typename ValueType>
        class holder : public placeholder
        {
        public:

            holder(const ValueType & value)
              : held(value)
            {
            }

        public:

            virtual const std::type_info & getType() const
            {
                return typeid(ValueType);
            }

            virtual placeholder * clone() const
            {
                return new (::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GENERAL>::allocateBytes(sizeof(holder))) holder(held);
            }

            virtual void writeToStream(std::ostream& o)
            {
                o << held;
            }


        public:

            ValueType held;

        };



    protected:
        placeholder * mContent;

        template<typename ValueType>
        friend ValueType * any_cast(Any *);


    public:

        template<typename ValueType>
        ValueType operator()() const
        {
            if (!mContent)
            {
                Ogre::ExceptionFactory::throwException(Exception::ERR_INVALIDPARAMS, Exception::ERR_INVALIDPARAMS, "Bad cast from uninitialised Any", "Any::operator()", "./OgreAny.h", 198);


            }
            else if(getType() == typeid(ValueType))
            {
                return static_cast<Any::holder<ValueType> *>(mContent)->held;
            }
            else
            {
                StringStream str;
                str << "Bad cast from type '" << getType().name() << "' "
                    << "to '" << typeid(ValueType).name() << "'";
                Ogre::ExceptionFactory::throwException(Exception::ERR_INVALIDPARAMS, Exception::ERR_INVALIDPARAMS, str.str(), "Any::operator()", "./OgreAny.h", 211);


            }
        }

        template <typename ValueType>
        ValueType get(void) const
        {
            if (!mContent)
            {
                Ogre::ExceptionFactory::throwException(Exception::ERR_INVALIDPARAMS, Exception::ERR_INVALIDPARAMS, "Bad cast from uninitialised Any", "Any::operator()", "./OgreAny.h", 222);


            }
            else if(getType() == typeid(ValueType))
            {
                return static_cast<Any::holder<ValueType> *>(mContent)->held;
            }
            else
            {
                StringStream str;
                str << "Bad cast from type '" << getType().name() << "' "
                    << "to '" << typeid(ValueType).name() << "'";
                Ogre::ExceptionFactory::throwException(Exception::ERR_INVALIDPARAMS, Exception::ERR_INVALIDPARAMS, str.str(), "Any::operator()", "./OgreAny.h", 235);


            }
        }

    };





    class AnyNumeric : public Any
    {
    public:
        AnyNumeric()
        : Any()
        {
        }

        template<typename ValueType>
        AnyNumeric(const ValueType & value)

        {
            mContent = new (::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GENERAL>::allocateBytes(sizeof(numholder<ValueType>))) numholder<ValueType>(value);
        }

        AnyNumeric(const AnyNumeric & other)
            : Any()
        {
            mContent = other.mContent ? other.mContent->clone() : 0;
        }

    protected:
        class numplaceholder : public Any::placeholder
        {
        public:

            ~numplaceholder()
            {
            }
            virtual placeholder* add(placeholder* rhs) = 0;
            virtual placeholder* subtract(placeholder* rhs) = 0;
            virtual placeholder* multiply(placeholder* rhs) = 0;
            virtual placeholder* multiply(Real factor) = 0;
            virtual placeholder* divide(placeholder* rhs) = 0;
        };

        template<typename ValueType>
        class numholder : public numplaceholder
        {
        public:

            numholder(const ValueType & value)
                : held(value)
            {
            }

        public:

            virtual const std::type_info & getType() const
            {
                return typeid(ValueType);
            }

            virtual placeholder * clone() const
            {
                return new (::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GENERAL>::allocateBytes(sizeof(numholder))) numholder(held);
            }

            virtual placeholder* add(placeholder* rhs)
            {
                return new (::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GENERAL>::allocateBytes(sizeof(numholder))) numholder(held + static_cast<numholder*>(rhs)->held);
            }
            virtual placeholder* subtract(placeholder* rhs)
            {
                return new (::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GENERAL>::allocateBytes(sizeof(numholder))) numholder(held - static_cast<numholder*>(rhs)->held);
            }
            virtual placeholder* multiply(placeholder* rhs)
            {
                return new (::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GENERAL>::allocateBytes(sizeof(numholder))) numholder(held * static_cast<numholder*>(rhs)->held);
            }
            virtual placeholder* multiply(Real factor)
            {
                return new (::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GENERAL>::allocateBytes(sizeof(numholder))) numholder(held * factor);
            }
            virtual placeholder* divide(placeholder* rhs)
            {
                return new (::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GENERAL>::allocateBytes(sizeof(numholder))) numholder(held / static_cast<numholder*>(rhs)->held);
            }
            virtual void writeToStream(std::ostream& o)
            {
                o << held;
            }

        public:

            ValueType held;

        };


        AnyNumeric(placeholder* pholder)
        {
            mContent = pholder;
        }

    public:
        AnyNumeric & operator=(const AnyNumeric & rhs)
        {
            AnyNumeric(rhs).swap(*this);
            return *this;
        }
        AnyNumeric operator+(const AnyNumeric& rhs) const
        {
            return AnyNumeric(
                static_cast<numplaceholder*>(mContent)->add(rhs.mContent));
        }
        AnyNumeric operator-(const AnyNumeric& rhs) const
        {
            return AnyNumeric(
                static_cast<numplaceholder*>(mContent)->subtract(rhs.mContent));
        }
        AnyNumeric operator*(const AnyNumeric& rhs) const
        {
            return AnyNumeric(
                static_cast<numplaceholder*>(mContent)->multiply(rhs.mContent));
        }
        AnyNumeric operator*(Real factor) const
        {
            return AnyNumeric(
                static_cast<numplaceholder*>(mContent)->multiply(factor));
        }
        AnyNumeric operator/(const AnyNumeric& rhs) const
        {
            return AnyNumeric(
                static_cast<numplaceholder*>(mContent)->divide(rhs.mContent));
        }
        AnyNumeric& operator+=(const AnyNumeric& rhs)
        {
            *this = AnyNumeric(
                static_cast<numplaceholder*>(mContent)->add(rhs.mContent));
            return *this;
        }
        AnyNumeric& operator-=(const AnyNumeric& rhs)
        {
            *this = AnyNumeric(
                static_cast<numplaceholder*>(mContent)->subtract(rhs.mContent));
            return *this;
        }
        AnyNumeric& operator*=(const AnyNumeric& rhs)
        {
            *this = AnyNumeric(
                static_cast<numplaceholder*>(mContent)->multiply(rhs.mContent));
            return *this;
        }
        AnyNumeric& operator/=(const AnyNumeric& rhs)
        {
            *this = AnyNumeric(
                static_cast<numplaceholder*>(mContent)->divide(rhs.mContent));
            return *this;
        }




    };


    template<typename ValueType>
    ValueType * any_cast(Any * operand)
    {
        return operand && (std::strcmp(operand->getType().name(), typeid(ValueType).name()) == 0)
                    ? &static_cast<Any::holder<ValueType> *>(operand->mContent)->held
                    : 0;
    }

    template<typename ValueType>
    const ValueType * any_cast(const Any * operand)
    {
        return any_cast<ValueType>(const_cast<Any *>(operand));
    }

    template<typename ValueType>
    ValueType any_cast(const Any & operand)
    {
        const ValueType * result = any_cast<ValueType>(&operand);
        if(!result)
        {
            StringStream str;
            str << "Bad cast from type '" << operand.getType().name() << "' "
                << "to '" << typeid(ValueType).name() << "'";
            Ogre::ExceptionFactory::throwException(Exception::ERR_INVALIDPARAMS, Exception::ERR_INVALIDPARAMS, str.str(), "Ogre::any_cast", "./OgreAny.h", 427);


        }
        return *result;
    }




}



namespace Ogre {

    typedef _StringBase String;



    template <size_t cacheSize>
    class StaticCache
    {
    protected:

        char mBuffer[cacheSize];


        size_t mValidBytes;

        size_t mPos;

    public:

        StaticCache()
        {
            mValidBytes = 0;
            mPos = 0;
            memset(mBuffer, 0, cacheSize);
        }



        size_t cacheData(const void* buf, size_t count)
        {
            assert(avail() == 0 && "It is assumed that you cache data only after you have read everything.");

            if (count < cacheSize)
            {

                if (count + mValidBytes <= cacheSize)
                {

                    memcpy(mBuffer + mValidBytes, buf, count);
                    mValidBytes += count;
                }
                else
                {
                    size_t begOff = count - (cacheSize - mValidBytes);

                    memmove(mBuffer, mBuffer + begOff, mValidBytes - begOff);

                    memcpy(mBuffer + cacheSize - count, buf, count);
                    mValidBytes = cacheSize;
                }
                mPos = mValidBytes;
                return count;
            }
            else
            {

                memcpy(mBuffer, (const char*)buf + count - cacheSize, cacheSize);
                mValidBytes = mPos = cacheSize;
                return cacheSize;
            }
        }

        size_t read(void* buf, size_t count)
        {
            size_t rb = avail();
            rb = (rb < count) ? rb : count;
            memcpy(buf, mBuffer + mPos, rb);
            mPos += rb;
            return rb;
        }


        bool rewind(size_t count)
        {
            if (mPos < count)
            {
                clear();
                return false;
            }
            else
            {
                mPos -= count;
                return true;
            }
        }

        bool ff(size_t count)
        {
            if (avail() < count)
            {
                clear();
                return false;
            }
            else
            {
                mPos += count;
                return true;
            }
        }


        size_t avail() const
        {
            return mValidBytes - mPos;
        }


        void clear()
        {
            mValidBytes = 0;
            mPos = 0;
        }
    };
    class DataStream : public StreamAlloc
    {
    public:
        enum AccessMode
        {
            READ = 1,
            WRITE = 2
        };
    protected:

        String mName;

        size_t mSize;

        uint16 mAccess;


    public:

        DataStream(uint16 accessMode = READ) : mSize(0), mAccess(accessMode) {}

        DataStream(const String& name, uint16 accessMode = READ)
            : mName(name), mSize(0), mAccess(accessMode) {}

        const String& getName(void) { return mName; }

        uint16 getAccessMode() const { return mAccess; }

        virtual bool isReadable() const { return (mAccess & READ) != 0; }

        virtual bool isWriteable() const { return (mAccess & WRITE) != 0; }
        virtual ~DataStream() {}

        template<typename T> DataStream& operator>>(T& val);






        virtual size_t read(void* buf, size_t count) = 0;






        virtual size_t write(const void* buf, size_t count)
        {
                        (void)buf;
                        (void)count;

            return 0;
        }
        virtual size_t readLine(char* buf, size_t maxCount, const String& delim = "\n");
        virtual String getLine( bool trimAfter = true );






        virtual String getAsString(void);
        virtual size_t skipLine(const String& delim = "\n");



        virtual void skip(long count) = 0;



        virtual void seek( size_t pos ) = 0;


        virtual size_t tell(void) const = 0;



        virtual bool eof(void) const = 0;




        size_t size(void) const { return mSize; }


        virtual void close(void) = 0;


    };


    typedef list<DataStreamPtr>::type DataStreamList;

    typedef SharedPtr<DataStreamList> DataStreamListPtr;



    class MemoryDataStream : public DataStream
    {
    protected:

        uchar* mData;

        uchar* mPos;

        uchar* mEnd;

        bool mFreeOnClose;
    public:
        MemoryDataStream(void* pMem, size_t size, bool freeOnClose = false, bool readOnly = false);
        MemoryDataStream(const String& name, void* pMem, size_t size,
                bool freeOnClose = false, bool readOnly = false);
        MemoryDataStream(DataStream& sourceStream,
                bool freeOnClose = true, bool readOnly = false);
        MemoryDataStream(DataStreamPtr& sourceStream,
                bool freeOnClose = true, bool readOnly = false);
        MemoryDataStream(const String& name, DataStream& sourceStream,
                bool freeOnClose = true, bool readOnly = false);
        MemoryDataStream(const String& name, const DataStreamPtr& sourceStream,
            bool freeOnClose = true, bool readOnly = false);







        MemoryDataStream(size_t size, bool freeOnClose = true, bool readOnly = false);







        MemoryDataStream(const String& name, size_t size,
                bool freeOnClose = true, bool readOnly = false);

        ~MemoryDataStream();


        uchar* getPtr(void) { return mData; }


        uchar* getCurrentPtr(void) { return mPos; }



        size_t read(void* buf, size_t count);



        size_t write(const void* buf, size_t count);



        size_t readLine(char* buf, size_t maxCount, const String& delim = "\n");



        size_t skipLine(const String& delim = "\n");



        void skip(long count);



        void seek( size_t pos );



        size_t tell(void) const;



        bool eof(void) const;



        void close(void);


        void setFreeOnClose(bool free) { mFreeOnClose = free; }
    };




    class FileStreamDataStream : public DataStream
    {
    protected:

        std::istream* mInStream;

        std::ifstream* mFStreamRO;

        std::fstream* mFStream;
        bool mFreeOnClose;

        void determineAccess();
    public:





        FileStreamDataStream(std::ifstream* s,
            bool freeOnClose = true);





        FileStreamDataStream(std::fstream* s,
            bool freeOnClose = true);







        FileStreamDataStream(const String& name,
            std::ifstream* s,
            bool freeOnClose = true);







        FileStreamDataStream(const String& name,
            std::fstream* s,
            bool freeOnClose = true);
        FileStreamDataStream(const String& name,
            std::ifstream* s,
            size_t size,
            bool freeOnClose = true);
        FileStreamDataStream(const String& name,
            std::fstream* s,
            size_t size,
            bool freeOnClose = true);

        ~FileStreamDataStream();



        size_t read(void* buf, size_t count);



        size_t write(const void* buf, size_t count);



        size_t readLine(char* buf, size_t maxCount, const String& delim = "\n");



        void skip(long count);



        void seek( size_t pos );



        size_t tell(void) const;



        bool eof(void) const;



        void close(void);


    };
    class FileHandleDataStream : public DataStream
    {
    protected:
        FILE* mFileHandle;
    public:

        FileHandleDataStream(FILE* handle, uint16 accessMode = READ);

        FileHandleDataStream(const String& name, FILE* handle, uint16 accessMode = READ);
        ~FileHandleDataStream();



        size_t read(void* buf, size_t count);



        size_t write(const void* buf, size_t count);



        void skip(long count);



        void seek( size_t pos );



        size_t tell(void) const;



        bool eof(void) const;



        void close(void);

    };


}


namespace Ogre {
    typedef _StringBase String;
    typedef vector<String>::type StringVector;
    typedef SharedPtr<StringVector> StringVectorPtr;




}



namespace Ogre {
    struct FileInfo {


        Archive* archive;

        String filename;

        String path;

        String basename;

        size_t compressedSize;

        size_t uncompressedSize;
    };

    typedef vector<FileInfo>::type FileInfoList;
    typedef SharedPtr<FileInfoList> FileInfoListPtr;
    class Archive : public ArchiveAlloc
    {
    protected:

        String mName;

        String mType;

        bool mReadOnly;
    public:




        Archive( const String& name, const String& archType )
            : mName(name), mType(archType), mReadOnly(true) {}



        virtual ~Archive() {}


        const String& getName(void) const { return mName; }


        virtual bool isCaseSensitive(void) const = 0;
        virtual void load() = 0;






        virtual void unload() = 0;




        virtual bool isReadOnly() const { return mReadOnly; }
        virtual DataStreamPtr open(const String& filename, bool readOnly = true) = 0;







        virtual DataStreamPtr create(const String& filename);





        virtual void remove(const String& filename);
        virtual StringVectorPtr list(bool recursive = true, bool dirs = false) = 0;
        virtual FileInfoListPtr listFileInfo(bool recursive = true, bool dirs = false) = 0;
        virtual StringVectorPtr find(const String& pattern, bool recursive = true,
            bool dirs = false) = 0;


        virtual bool exists(const String& filename) = 0;


        virtual time_t getModifiedTime(const String& filename) = 0;
        virtual FileInfoListPtr findFileInfo(const String& pattern,
            bool recursive = true, bool dirs = false) = 0;


        const String& getType(void) const { return mType; }

    };

    typedef vector<Archive*>::type ArchiveVec;




}


namespace Ogre {
    template <typename T> class Singleton
    {
    private:

        Singleton(const Singleton<T> &);


        Singleton& operator=(const Singleton<T> &);

    protected:

        static T* msSingleton;

    public:
        Singleton( void )
        {
            assert( !msSingleton );




        msSingleton = static_cast< T* >( this );

        }
        ~Singleton( void )
            { assert( msSingleton ); msSingleton = 0; }
        static T& getSingleton( void )
        { assert( msSingleton ); return ( *msSingleton ); }
        static T* getSingletonPtr( void )
        { return msSingleton; }
    };



}


namespace Ogre {
    class ArchiveManager : public Singleton<ArchiveManager>, public ArchiveAlloc
    {
    protected:
        typedef map<String, ArchiveFactory*>::type ArchiveFactoryMap;

        ArchiveFactoryMap mArchFactories;

        typedef map<String, Archive*>::type ArchiveMap;
        ArchiveMap mArchives;

    public:


        ArchiveManager();


        virtual ~ArchiveManager();
        Archive* load( const String& filename, const String& archiveType, bool readOnly);





        void unload(Archive* arch);




        void unload(const String& filename);
        typedef MapIterator<ArchiveMap> ArchiveMapIterator;

        ArchiveMapIterator getArchiveIterator(void);







        void addArchiveFactory(ArchiveFactory* factory);
        static ArchiveManager& getSingleton(void);
        static ArchiveManager* getSingletonPtr(void);
    };



}


namespace Ogre {
    class AxisAlignedBox
    {
    public:
        enum Extent
        {
            EXTENT_NULL,
            EXTENT_FINITE,
            EXTENT_INFINITE
        };
    protected:

        Vector3 mMinimum;
        Vector3 mMaximum;
        Extent mExtent;
        mutable Vector3* mCorners;

    public:
        typedef enum {
            FAR_LEFT_BOTTOM = 0,
            FAR_LEFT_TOP = 1,
            FAR_RIGHT_TOP = 2,
            FAR_RIGHT_BOTTOM = 3,
            NEAR_RIGHT_BOTTOM = 7,
            NEAR_LEFT_BOTTOM = 6,
            NEAR_LEFT_TOP = 5,
            NEAR_RIGHT_TOP = 4
        } CornerEnum;
        inline AxisAlignedBox() : mMinimum(Vector3::ZERO), mMaximum(Vector3::UNIT_SCALE), mCorners(0)
        {

            setMinimum( -0.5, -0.5, -0.5 );
            setMaximum( 0.5, 0.5, 0.5 );
            mExtent = EXTENT_NULL;
        }
        inline AxisAlignedBox(Extent e) : mMinimum(Vector3::ZERO), mMaximum(Vector3::UNIT_SCALE), mCorners(0)
        {
            setMinimum( -0.5, -0.5, -0.5 );
            setMaximum( 0.5, 0.5, 0.5 );
            mExtent = e;
        }

        inline AxisAlignedBox(const AxisAlignedBox & rkBox) : mMinimum(Vector3::ZERO), mMaximum(Vector3::UNIT_SCALE), mCorners(0)

        {
            if (rkBox.isNull())
                setNull();
            else if (rkBox.isInfinite())
                setInfinite();
            else
                setExtents( rkBox.mMinimum, rkBox.mMaximum );
        }

        inline AxisAlignedBox( const Vector3& min, const Vector3& max ) : mMinimum(Vector3::ZERO), mMaximum(Vector3::UNIT_SCALE), mCorners(0)
        {
            setExtents( min, max );
        }

        inline AxisAlignedBox(
            Real mx, Real my, Real mz,
            Real Mx, Real My, Real Mz ) : mMinimum(Vector3::ZERO), mMaximum(Vector3::UNIT_SCALE), mCorners(0)
        {
            setExtents( mx, my, mz, Mx, My, Mz );
        }

        AxisAlignedBox& operator=(const AxisAlignedBox& rhs)
        {

            if (rhs.isNull())
                setNull();
            else if (rhs.isInfinite())
                setInfinite();
            else
                setExtents(rhs.mMinimum, rhs.mMaximum);

            return *this;
        }

        ~AxisAlignedBox()
        {
            if (mCorners)
                ::Ogre::CategorisedAllocPolicy<MEMCATEGORY_SCENE_CONTROL>::deallocateBytes((void*)mCorners);
        }




        inline const Vector3& getMinimum(void) const
        {
            return mMinimum;
        }




        inline Vector3& getMinimum(void)
        {
            return mMinimum;
        }



        inline const Vector3& getMaximum(void) const
        {
            return mMaximum;
        }




        inline Vector3& getMaximum(void)
        {
            return mMaximum;
        }




        inline void setMinimum( const Vector3& vec )
        {
            mExtent = EXTENT_FINITE;
            mMinimum = vec;
        }

        inline void setMinimum( Real x, Real y, Real z )
        {
            mExtent = EXTENT_FINITE;
            mMinimum.x = x;
            mMinimum.y = y;
            mMinimum.z = z;
        }




        inline void setMinimumX(Real x)
        {
            mMinimum.x = x;
        }

        inline void setMinimumY(Real y)
        {
            mMinimum.y = y;
        }

        inline void setMinimumZ(Real z)
        {
            mMinimum.z = z;
        }



        inline void setMaximum( const Vector3& vec )
        {
            mExtent = EXTENT_FINITE;
            mMaximum = vec;
        }

        inline void setMaximum( Real x, Real y, Real z )
        {
            mExtent = EXTENT_FINITE;
            mMaximum.x = x;
            mMaximum.y = y;
            mMaximum.z = z;
        }




        inline void setMaximumX( Real x )
        {
            mMaximum.x = x;
        }

        inline void setMaximumY( Real y )
        {
            mMaximum.y = y;
        }

        inline void setMaximumZ( Real z )
        {
            mMaximum.z = z;
        }



        inline void setExtents( const Vector3& min, const Vector3& max )
        {
            assert( (min.x <= max.x && min.y <= max.y && min.z <= max.z) &&
                "The minimum corner of the box must be less than or equal to maximum corner" );

            mExtent = EXTENT_FINITE;
            mMinimum = min;
            mMaximum = max;
        }

        inline void setExtents(
            Real mx, Real my, Real mz,
            Real Mx, Real My, Real Mz )
        {
            assert( (mx <= Mx && my <= My && mz <= Mz) &&
                "The minimum corner of the box must be less than or equal to maximum corner" );

            mExtent = EXTENT_FINITE;

            mMinimum.x = mx;
            mMinimum.y = my;
            mMinimum.z = mz;

            mMaximum.x = Mx;
            mMaximum.y = My;
            mMaximum.z = Mz;

        }
        inline const Vector3* getAllCorners(void) const
        {
            assert( (mExtent == EXTENT_FINITE) && "Can't get corners of a null or infinite AAB" );







            if (!mCorners)
                mCorners = static_cast<Vector3*>(::Ogre::CategorisedAllocPolicy<MEMCATEGORY_SCENE_CONTROL>::allocateBytes(sizeof(Vector3)*(8)));

            mCorners[0] = mMinimum;
            mCorners[1].x = mMinimum.x; mCorners[1].y = mMaximum.y; mCorners[1].z = mMinimum.z;
            mCorners[2].x = mMaximum.x; mCorners[2].y = mMaximum.y; mCorners[2].z = mMinimum.z;
            mCorners[3].x = mMaximum.x; mCorners[3].y = mMinimum.y; mCorners[3].z = mMinimum.z;

            mCorners[4] = mMaximum;
            mCorners[5].x = mMinimum.x; mCorners[5].y = mMaximum.y; mCorners[5].z = mMaximum.z;
            mCorners[6].x = mMinimum.x; mCorners[6].y = mMinimum.y; mCorners[6].z = mMaximum.z;
            mCorners[7].x = mMaximum.x; mCorners[7].y = mMinimum.y; mCorners[7].z = mMaximum.z;

            return mCorners;
        }



        Vector3 getCorner(CornerEnum cornerToGet) const
        {
            switch(cornerToGet)
            {
            case FAR_LEFT_BOTTOM:
                return mMinimum;
            case FAR_LEFT_TOP:
                return Vector3(mMinimum.x, mMaximum.y, mMinimum.z);
            case FAR_RIGHT_TOP:
                return Vector3(mMaximum.x, mMaximum.y, mMinimum.z);
            case FAR_RIGHT_BOTTOM:
                return Vector3(mMaximum.x, mMinimum.y, mMinimum.z);
            case NEAR_RIGHT_BOTTOM:
                return Vector3(mMaximum.x, mMinimum.y, mMaximum.z);
            case NEAR_LEFT_BOTTOM:
                return Vector3(mMinimum.x, mMinimum.y, mMaximum.z);
            case NEAR_LEFT_TOP:
                return Vector3(mMinimum.x, mMaximum.y, mMaximum.z);
            case NEAR_RIGHT_TOP:
                return mMaximum;
            default:
                return Vector3();
            }
        }

                    friend std::ostream& operator<<( std::ostream& o, const AxisAlignedBox &aab )
        {
            switch (aab.mExtent)
            {
            case EXTENT_NULL:
                o << "AxisAlignedBox(null)";
                return o;

            case EXTENT_FINITE:
                o << "AxisAlignedBox(min=" << aab.mMinimum << ", max=" << aab.mMaximum << ")";
                return o;

            case EXTENT_INFINITE:
                o << "AxisAlignedBox(infinite)";
                return o;

            default:
                assert( false && "Never reached" );
                return o;
            }
        }




        void merge( const AxisAlignedBox& rhs )
        {

            if ((rhs.mExtent == EXTENT_NULL) || (mExtent == EXTENT_INFINITE))
            {
                return;
            }

            else if (rhs.mExtent == EXTENT_INFINITE)
            {
                mExtent = EXTENT_INFINITE;
            }

            else if (mExtent == EXTENT_NULL)
            {
                setExtents(rhs.mMinimum, rhs.mMaximum);
            }

            else
            {
                Vector3 min = mMinimum;
                Vector3 max = mMaximum;
                max.makeCeil(rhs.mMaximum);
                min.makeFloor(rhs.mMinimum);

                setExtents(min, max);
            }

        }



        inline void merge( const Vector3& point )
        {
            switch (mExtent)
            {
            case EXTENT_NULL:
                setExtents(point, point);
                return;

            case EXTENT_FINITE:
                mMaximum.makeCeil(point);
                mMinimum.makeFloor(point);
                return;

            case EXTENT_INFINITE:
                return;
            }

            assert( false && "Never reached" );
        }
        inline void transform( const Matrix4& matrix )
        {

            if( mExtent != EXTENT_FINITE )
                return;

            Vector3 oldMin, oldMax, currentCorner;


            oldMin = mMinimum;
            oldMax = mMaximum;


            setNull();
            currentCorner = oldMin;
            merge( matrix * currentCorner );


            currentCorner.z = oldMax.z;
            merge( matrix * currentCorner );


            currentCorner.y = oldMax.y;
            merge( matrix * currentCorner );


            currentCorner.z = oldMin.z;
            merge( matrix * currentCorner );


            currentCorner.x = oldMax.x;
            merge( matrix * currentCorner );


            currentCorner.z = oldMax.z;
            merge( matrix * currentCorner );


            currentCorner.y = oldMin.y;
            merge( matrix * currentCorner );


            currentCorner.z = oldMin.z;
            merge( matrix * currentCorner );
        }
        void transformAffine(const Matrix4& m)
        {
            assert(m.isAffine());


            if ( mExtent != EXTENT_FINITE )
                return;

            Vector3 centre = getCenter();
            Vector3 halfSize = getHalfSize();

            Vector3 newCentre = m.transformAffine(centre);
            Vector3 newHalfSize(
                Math::Abs(m[0][0]) * halfSize.x + Math::Abs(m[0][1]) * halfSize.y + Math::Abs(m[0][2]) * halfSize.z,
                Math::Abs(m[1][0]) * halfSize.x + Math::Abs(m[1][1]) * halfSize.y + Math::Abs(m[1][2]) * halfSize.z,
                Math::Abs(m[2][0]) * halfSize.x + Math::Abs(m[2][1]) * halfSize.y + Math::Abs(m[2][2]) * halfSize.z);

            setExtents(newCentre - newHalfSize, newCentre + newHalfSize);
        }



        inline void setNull()
        {
            mExtent = EXTENT_NULL;
        }



        inline bool isNull(void) const
        {
            return (mExtent == EXTENT_NULL);
        }



        bool isFinite(void) const
        {
            return (mExtent == EXTENT_FINITE);
        }



        inline void setInfinite()
        {
            mExtent = EXTENT_INFINITE;
        }



        bool isInfinite(void) const
        {
            return (mExtent == EXTENT_INFINITE);
        }


        inline bool intersects(const AxisAlignedBox& b2) const
        {

            if (this->isNull() || b2.isNull())
                return false;


            if (this->isInfinite() || b2.isInfinite())
                return true;


            if (mMaximum.x < b2.mMinimum.x)
                return false;
            if (mMaximum.y < b2.mMinimum.y)
                return false;
            if (mMaximum.z < b2.mMinimum.z)
                return false;

            if (mMinimum.x > b2.mMaximum.x)
                return false;
            if (mMinimum.y > b2.mMaximum.y)
                return false;
            if (mMinimum.z > b2.mMaximum.z)
                return false;


            return true;

        }


        inline AxisAlignedBox intersection(const AxisAlignedBox& b2) const
        {
            if (this->isNull() || b2.isNull())
            {
                return AxisAlignedBox();
            }
            else if (this->isInfinite())
            {
                return b2;
            }
            else if (b2.isInfinite())
            {
                return *this;
            }

            Vector3 intMin = mMinimum;
            Vector3 intMax = mMaximum;

            intMin.makeCeil(b2.getMinimum());
            intMax.makeFloor(b2.getMaximum());


            if (intMin.x < intMax.x &&
                intMin.y < intMax.y &&
                intMin.z < intMax.z)
            {
                return AxisAlignedBox(intMin, intMax);
            }

            return AxisAlignedBox();
        }


        Real volume(void) const
        {
            switch (mExtent)
            {
            case EXTENT_NULL:
                return 0.0f;

            case EXTENT_FINITE:
                {
                    Vector3 diff = mMaximum - mMinimum;
                    return diff.x * diff.y * diff.z;
                }

            case EXTENT_INFINITE:
                return Math::POS_INFINITY;

            default:
                assert( false && "Never reached" );
                return 0.0f;
            }
        }


        inline void scale(const Vector3& s)
        {

            if (mExtent != EXTENT_FINITE)
                return;


            Vector3 min = mMinimum * s;
            Vector3 max = mMaximum * s;
            setExtents(min, max);
        }


        bool intersects(const Sphere& s) const
        {
            return Math::intersects(s, *this);
        }

        bool intersects(const Plane& p) const
        {
            return Math::intersects(p, *this);
        }

        bool intersects(const Vector3& v) const
        {
            switch (mExtent)
            {
            case EXTENT_NULL:
                return false;

            case EXTENT_FINITE:
                return(v.x >= mMinimum.x && v.x <= mMaximum.x &&
                    v.y >= mMinimum.y && v.y <= mMaximum.y &&
                    v.z >= mMinimum.z && v.z <= mMaximum.z);

            case EXTENT_INFINITE:
                return true;

            default:
                assert( false && "Never reached" );
                return false;
            }
        }

        Vector3 getCenter(void) const
        {
            assert( (mExtent == EXTENT_FINITE) && "Can't get center of a null or infinite AAB" );

            return Vector3(
                (mMaximum.x + mMinimum.x) * 0.5f,
                (mMaximum.y + mMinimum.y) * 0.5f,
                (mMaximum.z + mMinimum.z) * 0.5f);
        }

        Vector3 getSize(void) const
        {
            switch (mExtent)
            {
            case EXTENT_NULL:
                return Vector3::ZERO;

            case EXTENT_FINITE:
                return mMaximum - mMinimum;

            case EXTENT_INFINITE:
                return Vector3(
                    Math::POS_INFINITY,
                    Math::POS_INFINITY,
                    Math::POS_INFINITY);

            default:
                assert( false && "Never reached" );
                return Vector3::ZERO;
            }
        }

        Vector3 getHalfSize(void) const
        {
            switch (mExtent)
            {
            case EXTENT_NULL:
                return Vector3::ZERO;

            case EXTENT_FINITE:
                return (mMaximum - mMinimum) * 0.5;

            case EXTENT_INFINITE:
                return Vector3(
                    Math::POS_INFINITY,
                    Math::POS_INFINITY,
                    Math::POS_INFINITY);

            default:
                assert( false && "Never reached" );
                return Vector3::ZERO;
            }
        }



        bool contains(const Vector3& v) const
        {
            if (isNull())
                return false;
            if (isInfinite())
                return true;

            return mMinimum.x <= v.x && v.x <= mMaximum.x &&
                   mMinimum.y <= v.y && v.y <= mMaximum.y &&
                   mMinimum.z <= v.z && v.z <= mMaximum.z;
        }



        Real squaredDistance(const Vector3& v) const
        {

            if (this->contains(v))
                return 0;
            else
            {
                Vector3 maxDist(0,0,0);

                if (v.x < mMinimum.x)
                    maxDist.x = mMinimum.x - v.x;
                else if (v.x > mMaximum.x)
                    maxDist.x = v.x - mMaximum.x;

                if (v.y < mMinimum.y)
                    maxDist.y = mMinimum.y - v.y;
                else if (v.y > mMaximum.y)
                    maxDist.y = v.y - mMaximum.y;

                if (v.z < mMinimum.z)
                    maxDist.z = mMinimum.z - v.z;
                else if (v.z > mMaximum.z)
                    maxDist.z = v.z - mMaximum.z;

                return maxDist.squaredLength();
            }
        }


        Real distance (const Vector3& v) const
        {
            return Ogre::Math::Sqrt(squaredDistance(v));
        }



        bool contains(const AxisAlignedBox& other) const
        {
            if (other.isNull() || this->isInfinite())
                return true;

            if (this->isNull() || other.isInfinite())
                return false;

            return this->mMinimum.x <= other.mMinimum.x &&
                   this->mMinimum.y <= other.mMinimum.y &&
                   this->mMinimum.z <= other.mMinimum.z &&
                   other.mMaximum.x <= this->mMaximum.x &&
                   other.mMaximum.y <= this->mMaximum.y &&
                   other.mMaximum.z <= this->mMaximum.z;
        }



        bool operator== (const AxisAlignedBox& rhs) const
        {
            if (this->mExtent != rhs.mExtent)
                return false;

            if (!this->isFinite())
                return true;

            return this->mMinimum == rhs.mMinimum &&
                   this->mMaximum == rhs.mMaximum;
        }



        bool operator!= (const AxisAlignedBox& rhs) const
        {
            return !(*this == rhs);
        }


        static const AxisAlignedBox BOX_NULL;
        static const AxisAlignedBox BOX_INFINITE;


    };



}

namespace Ogre {
namespace v1 {
    class Billboard : public FXAlloc
    {
        friend class BillboardSet;
        friend class BillboardParticleRenderer;
    protected:
        bool mOwnDimensions;
        bool mUseTexcoordRect;
        uint16 mTexcoordIndex;
        FloatRect mTexcoordRect;
        Real mWidth;
        Real mHeight;
    public:


        Vector3 mPosition;

        Vector3 mDirection;
        BillboardSet* mParentSet;
        ColourValue mColour;
        Radian mRotation;



        Billboard();



        ~Billboard();



        Billboard(const Vector3& position, BillboardSet* owner, const ColourValue& colour = ColourValue::White);





        const Radian& getRotation(void) const { return mRotation; }





        void setRotation(const Radian& rotation);






        void setPosition(const Vector3& position);






        void setPosition(Real x, Real y, Real z);






        const Vector3& getPosition(void) const;
        void setDimensions(Real width, Real height);


        void resetDimensions(void) { mOwnDimensions = false; }






        void setColour(const ColourValue& colour);



        const ColourValue& getColour(void) const;






        bool hasOwnDimensions(void) const;


        Real getOwnWidth(void) const;


        Real getOwnHeight(void) const;



        void _notifyOwner(BillboardSet* owner);
        bool isUseTexcoordRect(void) const { return mUseTexcoordRect; }
        void setTexcoordIndex(uint16 texcoordIndex);






        uint16 getTexcoordIndex(void) const { return mTexcoordIndex; }






        void setTexcoordRect(const FloatRect& texcoordRect);






        void setTexcoordRect(Real u0, Real v0, Real u1, Real v1);





        const FloatRect& getTexcoordRect(void) const { return mTexcoordRect; }
    };




}
}


namespace Ogre {
    class Sphere
    {
    protected:
        Real mRadius;
        Vector3 mCenter;
    public:

        Sphere() : mRadius(1.0), mCenter(Vector3::ZERO) {}




        Sphere(const Vector3& center, Real radius)
            : mRadius(radius), mCenter(center) {}


        Real getRadius(void) const { return mRadius; }


        void setRadius(Real radius) { mRadius = radius; }


        const Vector3& getCenter(void) const { return mCenter; }


        void setCenter(const Vector3& center) { mCenter = center; }


        bool intersects(const Sphere& s) const
        {
            return (s.mCenter - mCenter).squaredLength() <=
                Math::Sqr(s.mRadius + mRadius);
        }

        bool intersects(const AxisAlignedBox& box) const
        {
            return Math::intersects(*this, box);
        }

        bool intersects(const Plane& plane) const
        {
            return Math::intersects(*this, plane);
        }

        bool intersects(const Vector3& v) const
        {
            return ((v - mCenter).squaredLength() <= Math::Sqr(mRadius));
        }

        void merge(const Sphere& oth)
        {
            Vector3 diff = oth.getCenter() - mCenter;
            Real lengthSq = diff.squaredLength();
            Real radiusDiff = oth.getRadius() - mRadius;


            if (Math::Sqr(radiusDiff) >= lengthSq)
            {

                if (radiusDiff <= 0.0f)
                    return;
                else
                {
                    mCenter = oth.getCenter();
                    mRadius = oth.getRadius();
                    return;
                }
            }

            Real length = Math::Sqrt(lengthSq);
            Real t = (length + radiusDiff) / (2.0f * length);
            mCenter = mCenter + diff * t;
            mRadius = 0.5f * (length + mRadius + oth.getRadius());
        }


    };



}
namespace Ogre
{
    class Vector2
    {
    public:
        Real x, y;

    public:




        inline Vector2()
        {
        }

        inline Vector2(const Real fX, const Real fY )
            : x( fX ), y( fY )
        {
        }

        inline explicit Vector2( const Real scaler )
            : x( scaler), y( scaler )
        {
        }

        inline explicit Vector2( const Real afCoordinate[2] )
            : x( afCoordinate[0] ),
              y( afCoordinate[1] )
        {
        }

        inline explicit Vector2( const int afCoordinate[2] )
        {
            x = (Real)afCoordinate[0];
            y = (Real)afCoordinate[1];
        }

        inline explicit Vector2( Real* const r )
            : x( r[0] ), y( r[1] )
        {
        }



        inline void swap(Vector2& other)
        {
            std::swap(x, other.x);
            std::swap(y, other.y);
        }

        inline Real operator [] ( const size_t i ) const
        {
            assert( i < 2 );

            return *(&x+i);
        }

        inline Real& operator [] ( const size_t i )
        {
            assert( i < 2 );

            return *(&x+i);
        }


        inline Real* ptr()
        {
            return &x;
        }

        inline const Real* ptr() const
        {
            return &x;
        }





        inline Vector2& operator = ( const Vector2& rkVector )
        {
            x = rkVector.x;
            y = rkVector.y;

            return *this;
        }

        inline Vector2& operator = ( const Real fScalar)
        {
            x = fScalar;
            y = fScalar;

            return *this;
        }

        inline bool operator == ( const Vector2& rkVector ) const
        {
            return ( x == rkVector.x && y == rkVector.y );
        }

        inline bool operator != ( const Vector2& rkVector ) const
        {
            return ( x != rkVector.x || y != rkVector.y );
        }


        inline Vector2 operator + ( const Vector2& rkVector ) const
        {
            return Vector2(
                x + rkVector.x,
                y + rkVector.y);
        }

        inline Vector2 operator - ( const Vector2& rkVector ) const
        {
            return Vector2(
                x - rkVector.x,
                y - rkVector.y);
        }

        inline Vector2 operator * ( const Real fScalar ) const
        {
            return Vector2(
                x * fScalar,
                y * fScalar);
        }

        inline Vector2 operator * ( const Vector2& rhs) const
        {
            return Vector2(
                x * rhs.x,
                y * rhs.y);
        }

        inline Vector2 operator / ( const Real fScalar ) const
        {
            assert( fScalar != 0.0 );

            Real fInv = 1.0f / fScalar;

            return Vector2(
                x * fInv,
                y * fInv);
        }

        inline Vector2 operator / ( const Vector2& rhs) const
        {
            return Vector2(
                x / rhs.x,
                y / rhs.y);
        }

        inline const Vector2& operator + () const
        {
            return *this;
        }

        inline Vector2 operator - () const
        {
            return Vector2(-x, -y);
        }


        inline friend Vector2 operator * ( const Real fScalar, const Vector2& rkVector )
        {
            return Vector2(
                fScalar * rkVector.x,
                fScalar * rkVector.y);
        }

        inline friend Vector2 operator / ( const Real fScalar, const Vector2& rkVector )
        {
            return Vector2(
                fScalar / rkVector.x,
                fScalar / rkVector.y);
        }

        inline friend Vector2 operator + (const Vector2& lhs, const Real rhs)
        {
            return Vector2(
                lhs.x + rhs,
                lhs.y + rhs);
        }

        inline friend Vector2 operator + (const Real lhs, const Vector2& rhs)
        {
            return Vector2(
                lhs + rhs.x,
                lhs + rhs.y);
        }

        inline friend Vector2 operator - (const Vector2& lhs, const Real rhs)
        {
            return Vector2(
                lhs.x - rhs,
                lhs.y - rhs);
        }

        inline friend Vector2 operator - (const Real lhs, const Vector2& rhs)
        {
            return Vector2(
                lhs - rhs.x,
                lhs - rhs.y);
        }


        inline Vector2& operator += ( const Vector2& rkVector )
        {
            x += rkVector.x;
            y += rkVector.y;

            return *this;
        }

        inline Vector2& operator += ( const Real fScaler )
        {
            x += fScaler;
            y += fScaler;

            return *this;
        }

        inline Vector2& operator -= ( const Vector2& rkVector )
        {
            x -= rkVector.x;
            y -= rkVector.y;

            return *this;
        }

        inline Vector2& operator -= ( const Real fScaler )
        {
            x -= fScaler;
            y -= fScaler;

            return *this;
        }

        inline Vector2& operator *= ( const Real fScalar )
        {
            x *= fScalar;
            y *= fScalar;

            return *this;
        }

        inline Vector2& operator *= ( const Vector2& rkVector )
        {
            x *= rkVector.x;
            y *= rkVector.y;

            return *this;
        }

        inline Vector2& operator /= ( const Real fScalar )
        {
            assert( fScalar != 0.0 );

            Real fInv = 1.0f / fScalar;

            x *= fInv;
            y *= fInv;

            return *this;
        }

        inline Vector2& operator /= ( const Vector2& rkVector )
        {
            x /= rkVector.x;
            y /= rkVector.y;

            return *this;
        }
        inline Real length () const
        {
            return Math::Sqrt( x * x + y * y );
        }
        inline Real squaredLength () const
        {
            return x * x + y * y;
        }
        inline Real distance(const Vector2& rhs) const
        {
            return (*this - rhs).length();
        }
        inline Real squaredDistance(const Vector2& rhs) const
        {
            return (*this - rhs).squaredLength();
        }
        inline Real dotProduct(const Vector2& vec) const
        {
            return x * vec.x + y * vec.y;
        }
        inline Real normalise()
        {
            Real fLength = Math::Sqrt( x * x + y * y);




            if ( fLength > Real(0.0f) )
            {
                Real fInvLength = 1.0f / fLength;
                x *= fInvLength;
                y *= fInvLength;
            }

            return fLength;
        }




        inline Vector2 midPoint( const Vector2& vec ) const
        {
            return Vector2(
                ( x + vec.x ) * 0.5f,
                ( y + vec.y ) * 0.5f );
        }




        inline bool operator < ( const Vector2& rhs ) const
        {
            if( x < rhs.x && y < rhs.y )
                return true;
            return false;
        }




        inline bool operator > ( const Vector2& rhs ) const
        {
            if( x > rhs.x && y > rhs.y )
                return true;
            return false;
        }
        inline void makeFloor( const Vector2& cmp )
        {
            if( cmp.x < x ) x = cmp.x;
            if( cmp.y < y ) y = cmp.y;
        }
        inline void makeCeil( const Vector2& cmp )
        {
            if( cmp.x > x ) x = cmp.x;
            if( cmp.y > y ) y = cmp.y;
        }
        inline Vector2 perpendicular(void) const
        {
            return Vector2 (-y, x);
        }




        inline Real crossProduct( const Vector2& rkVector ) const
        {
            return x * rkVector.y - y * rkVector.x;
        }
        inline Vector2 randomDeviant(Radian angle) const
        {
            angle *= Math::RangeRandom(-1, 1);
            Real cosa = Math::Cos(angle);
            Real sina = Math::Sin(angle);
            return Vector2(cosa * x - sina * y,
                           sina * x + cosa * y);
        }


        inline bool isZeroLength(void) const
        {
            Real sqlen = (x * x) + (y * y);
            return (sqlen < (1e-06 * 1e-06));

        }



        inline Vector2 normalisedCopy(void) const
        {
            Vector2 ret = *this;
            ret.normalise();
            return ret;
        }




        inline Vector2 reflect(const Vector2& normal) const
        {
            return Vector2( *this - ( 2 * this->dotProduct(normal) * normal ) );
        }


        inline bool isNaN() const
        {
            return Math::isNaN(x) || Math::isNaN(y);
        }





        inline Ogre::Radian angleBetween(const Ogre::Vector2& other) const
        {
            Ogre::Real lenProduct = length() * other.length();

            if(lenProduct < 1e-6f)
                lenProduct = 1e-6f;

            Ogre::Real f = dotProduct(other) / lenProduct;

            f = Ogre::Math::Clamp(f, (Ogre::Real)-1.0, (Ogre::Real)1.0);
            return Ogre::Math::ACos(f);
        }






        inline Ogre::Radian angleTo(const Ogre::Vector2& other) const
        {
            Ogre::Radian angle = angleBetween(other);

            if (crossProduct(other)<0)
                angle = (Ogre::Radian)Ogre::Math::TWO_PI - angle;

            return angle;
        }


        static const Vector2 ZERO;
        static const Vector2 UNIT_X;
        static const Vector2 UNIT_Y;
        static const Vector2 NEGATIVE_UNIT_X;
        static const Vector2 NEGATIVE_UNIT_Y;
        static const Vector2 UNIT_SCALE;



        inline friend std::ostream& operator <<
            ( std::ostream& o, const Vector2& v )
        {
            o << "Vector2(" << v.x << ", " << v.y << ")";
            return o;
        }
    };


}





namespace Ogre {

    class Any;
    class AnimableValue : public AnimableAlloc
    {
    public:

        enum ValueType
        {
            INT,
            REAL,
            VECTOR2,
            VECTOR3,
            VECTOR4,
            QUATERNION,
            COLOUR,
            RADIAN,
            DEGREE
        };
    protected:

        ValueType mType;


        union
        {
            int mBaseValueInt;
            Real mBaseValueReal[4];
        };


        virtual void setAsBaseValue(int val) { mBaseValueInt = val; }

        virtual void setAsBaseValue(Real val) { mBaseValueReal[0] = val; }

        virtual void setAsBaseValue(const Vector2& val)
        { memcpy(mBaseValueReal, val.ptr(), sizeof(Real)*2); }

        virtual void setAsBaseValue(const Vector3& val)
        { memcpy(mBaseValueReal, val.ptr(), sizeof(Real)*3); }

        virtual void setAsBaseValue(const Vector4& val)
        { memcpy(mBaseValueReal, val.ptr(), sizeof(Real)*4); }

        virtual void setAsBaseValue(const Quaternion& val)
        { memcpy(mBaseValueReal, val.ptr(), sizeof(Real)*4); }

        virtual void setAsBaseValue(const Any& val);

        virtual void setAsBaseValue(const ColourValue& val)
        {
            mBaseValueReal[0] = val.r;
            mBaseValueReal[1] = val.g;
            mBaseValueReal[2] = val.b;
            mBaseValueReal[3] = val.a;
        }

        virtual void setAsBaseValue(const Radian& val)
        {
            mBaseValueReal[0] = val.valueRadians();
        }

        virtual void setAsBaseValue(const Degree& val)
        {
            mBaseValueReal[0] = val.valueRadians();
        }


    public:
        AnimableValue(ValueType t) : mType(t) {}
        virtual ~AnimableValue() {}


        ValueType getType(void) const { return mType; }


        virtual void setCurrentStateAsBaseValue(void) = 0;


        virtual void setValue(int) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 149);
        }

        virtual void setValue(Real) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 153);
        }

        virtual void setValue(const Vector2&) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 157);
        }

        virtual void setValue(const Vector3&) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 161);
        }

        virtual void setValue(const Vector4&) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 165);
        }

        virtual void setValue(const Quaternion&) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 169);
        }

        virtual void setValue(const ColourValue&) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 173);
        }

        virtual void setValue(const Radian&) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 177);
        }

        virtual void setValue(const Degree&) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 181);
        }

        virtual void setValue(const Any& val);


        virtual void resetToBaseValue(void);


        virtual void applyDeltaValue(int) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 191);
        }

        virtual void applyDeltaValue(Real) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 195);
        }

        virtual void applyDeltaValue(const Vector2&) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 199);
        }

        virtual void applyDeltaValue(const Vector3&) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 203);
        }

        virtual void applyDeltaValue(const Vector4&) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 207);
        }

        virtual void applyDeltaValue(const Quaternion&) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 211);
        }

        virtual void applyDeltaValue(const ColourValue&) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 215);
        }

        virtual void applyDeltaValue(const Degree&) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 219);
        }

        virtual void applyDeltaValue(const Radian&) {
            Ogre::ExceptionFactory::throwException(Exception::ERR_NOT_IMPLEMENTED, Exception::ERR_NOT_IMPLEMENTED, "", "", "./OgreAnimable.h", 223);
        }

        virtual void applyDeltaValue(const Any& val);


    };




    class AnimableObject
    {
    protected:
        typedef map<String, StringVector>::type AnimableDictionaryMap;

        static AnimableDictionaryMap msAnimableDictionary;





        virtual const String& getAnimableDictionaryName(void) const
        { return BLANKSTRING; }



        void createAnimableDictionary(void) const
        {
            if (msAnimableDictionary.find(getAnimableDictionaryName())
                == msAnimableDictionary.end())
            {
                StringVector vec;
                initialiseAnimableDictionary(vec);
                msAnimableDictionary[getAnimableDictionaryName()] = vec;
            }

        }


        StringVector& _getAnimableValueNames(void)
        {
            AnimableDictionaryMap::iterator i =
                msAnimableDictionary.find(getAnimableDictionaryName());
            if (i != msAnimableDictionary.end())
            {
                return i->second;
            }
            else
            {
                Ogre::ExceptionFactory::throwException(Exception::ERR_ITEM_NOT_FOUND, Exception::ERR_ITEM_NOT_FOUND, "Animable value list not found for " + getAnimableDictionaryName(), "AnimableObject::getAnimableValueNames", "./OgreAnimable.h", 275);


            }

        }




        virtual void initialiseAnimableDictionary(StringVector&) const {}


    public:
        AnimableObject() {}
        virtual ~AnimableObject() {}


        const StringVector& getAnimableValueNames(void) const
        {
            createAnimableDictionary();

            AnimableDictionaryMap::iterator i =
                msAnimableDictionary.find(getAnimableDictionaryName());
            if (i != msAnimableDictionary.end())
            {
                return i->second;
            }
            else
            {
                Ogre::ExceptionFactory::throwException(Exception::ERR_ITEM_NOT_FOUND, Exception::ERR_ITEM_NOT_FOUND, "Animable value list not found for " + getAnimableDictionaryName(), "AnimableObject::getAnimableValueNames", "./OgreAnimable.h", 305);


            }

        }







        virtual AnimableValuePtr createAnimableValue(const String& valueName)
        {
            Ogre::ExceptionFactory::throwException(Exception::ERR_ITEM_NOT_FOUND, Exception::ERR_ITEM_NOT_FOUND, "No animable value named '" + valueName + "' present.", "AnimableObject::createAnimableValue", "./OgreAnimable.h", 320);


        }



    };




}


namespace Ogre
{
    void MurmurHash3_x86_32 ( const void * key, int len, uint32_t seed, void * out );

    void MurmurHash3_x86_128 ( const void * key, int len, uint32_t seed, void * out );

    void MurmurHash3_x64_128 ( const void * key, int len, uint32_t seed, void * out );
}
namespace Ogre
{
    struct IdString
    {
        static const uint32_t Seed = 0x3A8EFA67;

        uint32 mHash;


        char mDebugString[32];


        IdString() : mHash( 0 )
        {

            mDebugString[0] = '\0';

        }

        IdString( const char *string ) : mHash( 0 )
        {
            MurmurHash3_x86_32( string, static_cast<int>(strlen( string )), Seed, &mHash );
            OGRE_COPY_DEBUG_STRING( string );
        }

        IdString( const std::string &string ) : mHash( 0 )
        {
            MurmurHash3_x86_32( string.c_str(), static_cast<int>(string.size()), Seed, &mHash );
            OGRE_COPY_DEBUG_STRING( string );
        }

        IdString( uint32 value ) : mHash( 0 )
        {
            MurmurHash3_x86_32( &value, sizeof( value ), Seed, &mHash );
            OGRE_COPY_DEBUG_STRING( value );
        }







        void OGRE_COPY_DEBUG_STRING( const char *string )
        {
            size_t strLength = strlen( string );
            if( strLength > 32 -1 )
            {

                strncpy( mDebugString, string + strLength - (32 -1),
                         32 );
            }
            else
            {
                strncpy( mDebugString, string, 32 );
            }
            mDebugString[32 -1] = '\0';
        }

        void OGRE_COPY_DEBUG_STRING( const std::string &string )
        {
            size_t strLength = string.size();
            if( strLength > 32 -1 )
            {

                strncpy( mDebugString, string.c_str() + strLength - (32 -1),
                         32 );
            }
            else
            {
                strncpy( mDebugString, string.c_str(), 32 );
            }
            mDebugString[32 -1] = '\0';
        }

        void OGRE_COPY_DEBUG_STRING( uint32 value )
        {
            sprintf( mDebugString, "[Value 0x%.8x]", value );
            mDebugString[32 -1] = '\0';
        }

        void OGRE_APPEND_DEBUG_STRING( const char *string )
        {
            size_t strLen0 = strlen( mDebugString );
            size_t strLen1 = strlen( string );

            if( strLen0 + strLen1 < 32 )
            {
                strcat( mDebugString, string );
                mDebugString[32 -1] = '\0';
            }
            else
            {
                size_t newStart0 = (strLen0 >> 1);
                size_t newLen0 = strLen0 - newStart0;
                memmove( mDebugString, mDebugString + newStart0, newLen0 );

                size_t newStart1 = 0;
                size_t newLen1 = strLen1;
                if( newLen0 + strLen1 >= 32 )
                {
                    newLen1 = 32 - newLen0 - 1;
                    newStart1 = strLen1 - newLen1;
                }

                memcpy( mDebugString + newLen0, string + newStart1, newLen1 );
                mDebugString[32 -1] = '\0';
            }
        }






        void operator += ( IdString idString )
        {
            uint32 doubleHash[2];
            doubleHash[0] = mHash;
            doubleHash[1] = idString.mHash;

            MurmurHash3_x86_32( &doubleHash, sizeof( doubleHash ), Seed, &mHash );
            OGRE_APPEND_DEBUG_STRING( idString.mDebugString );
        }

        IdString operator + ( IdString idString ) const
        {
            IdString retVal( *this );
            retVal += idString;
            return retVal;
        }

        bool operator < ( IdString idString ) const
        {






            return mHash < idString.mHash;
        }

        bool operator == ( IdString idString ) const
        {

            assert( !(mHash == idString.mHash &&
                    strcmp( mDebugString, idString.mDebugString ) != 0) &&
                    "Collision detected!" );

            return mHash == idString.mHash;
        }

        bool operator != ( IdString idString ) const
        {

            assert( !(mHash == idString.mHash &&
                    strcmp( mDebugString, idString.mDebugString ) != 0) &&
                    "Collision detected!" );

            return mHash != idString.mHash;
        }


        std::string getFriendlyText() const
        {

            return std::string( mDebugString );
        }


        std::string getReleaseText() const
        {





            char tmp[(32 >> 2)+10];
            sprintf( tmp, "[Hash 0x%.8x]", mHash );
            tmp[(32 >> 2)+10-1] = '\0';
            return std::string( tmp );




        }
    };
}

namespace Ogre {
    enum ParameterType
    {
        PT_BOOL,
        PT_REAL,
        PT_INT,
        PT_UNSIGNED_INT,
        PT_SHORT,
        PT_UNSIGNED_SHORT,
        PT_LONG,
        PT_UNSIGNED_LONG,
        PT_STRING,
        PT_VECTOR3,
        PT_MATRIX3,
        PT_MATRIX4,
        PT_QUATERNION,
        PT_COLOURVALUE
    };


    class ParameterDef
    {
    public:
        String name;
        String description;
        ParameterType paramType;
        ParameterDef(const String& newName, const String& newDescription, ParameterType newType)
            : name(newName), description(newDescription), paramType(newType) {}
    };
    typedef vector<ParameterDef>::type ParameterList;


    class ParamCommand
    {
    public:
        virtual String doGet(const void* target) const = 0;
        virtual void doSet(void* target, const String& val) = 0;

        virtual ~ParamCommand() { }
    };
    typedef map<String, ParamCommand* >::type ParamCommandMap;


    class ParamDictionary
    {
        friend class StringInterface;
    protected:

        ParameterList mParamDefs;


        ParamCommandMap mParamCommands;


        ParamCommand* getParamCommand(const String& name)
        {
            ParamCommandMap::iterator i = mParamCommands.find(name);
            if (i != mParamCommands.end())
            {
                return i->second;
            }
            else
            {
                return 0;
            }
        }

        const ParamCommand* getParamCommand(const String& name) const
        {
            ParamCommandMap::const_iterator i = mParamCommands.find(name);
            if (i != mParamCommands.end())
            {
                return i->second;
            }
            else
            {
                return 0;
            }
        }
    public:
        ParamDictionary() {}






        void addParameter(const ParameterDef& paramDef, ParamCommand* paramCmd)
        {
            mParamDefs.push_back(paramDef);
            mParamCommands[paramDef.name] = paramCmd;
        }





        const ParameterList& getParameters(void) const
        {
            return mParamDefs;
        }



    };
    typedef map<String, ParamDictionary>::type ParamDictionaryMap;
    class StringInterface
    {
    private:
                                              ;


        static ParamDictionaryMap msDictionary;


        String mParamDictName;
        ParamDictionary* mParamDict;

    protected:
        bool createParamDictionary(const String& className)
        {
                                                ;

            ParamDictionaryMap::iterator it = msDictionary.find(className);

            if ( it == msDictionary.end() )
            {
                mParamDict = &msDictionary.insert( std::make_pair( className, ParamDictionary() ) ).first->second;
                mParamDictName = className;
                return true;
            }
            else
            {
                mParamDict = &it->second;
                mParamDictName = className;
                return false;
            }
        }

    public:
        StringInterface() : mParamDict(NULL) { }


        virtual ~StringInterface() {}
        ParamDictionary* getParamDictionary(void)
        {
            return mParamDict;
        }

        const ParamDictionary* getParamDictionary(void) const
        {
            return mParamDict;
        }






        const ParameterList& getParameters(void) const;
        virtual bool setParameter(const String& name, const String& value);
        virtual void setParameterList(const NameValuePairList& paramList);
        virtual String getParameter(const String& name) const
        {

            const ParamDictionary* dict = getParamDictionary();

            if (dict)
            {

                const ParamCommand* cmd = dict->getParamCommand(name);

                if (cmd)
                {
                    return cmd->doGet(this);
                }
            }


            return "";
        }
        virtual void copyParametersTo(StringInterface* dest) const
        {

            const ParamDictionary* dict = getParamDictionary();

            if (dict)
            {

                ParameterList::const_iterator i;

                for (i = dict->mParamDefs.begin();
                i != dict->mParamDefs.end(); ++i)
                {
                    dest->setParameter(i->name, getParameter(i->name));
                }
            }


        }




        static void cleanupDictionary () ;

    };




}




namespace Ogre {

    typedef unsigned long long int ResourceHandle;



    class ManualResourceLoader;
    class Resource : public StringInterface, public ResourceAlloc
    {
    public:
                       ;
        class Listener
        {
        public:
            Listener() {}
            virtual ~Listener() {}
            virtual void loadingComplete(Resource*) {}
            virtual void preparingComplete(Resource*) {}


            virtual void unloadingComplete(Resource*) {}
        };


        enum LoadingState
        {

            LOADSTATE_UNLOADED,

            LOADSTATE_LOADING,

            LOADSTATE_LOADED,

            LOADSTATE_UNLOADING,

            LOADSTATE_PREPARED,

            LOADSTATE_PREPARING
        };
    protected:

        ResourceManager* mCreator;

        String mName;

        String mGroup;

        ResourceHandle mHandle;

        AtomicScalar<LoadingState> mLoadingState;

        volatile bool mIsBackgroundLoaded;

        size_t mSize;

        bool mIsManual;

        String mOrigin;

        ManualResourceLoader* mLoader;

        size_t mStateCount;

        typedef set<Listener*>::type ListenerList;
        ListenerList mListenerList;
                                      ;



        Resource()
            : mCreator(0), mHandle(0), mLoadingState(LOADSTATE_UNLOADED),
            mIsBackgroundLoaded(false), mSize(0), mIsManual(0), mLoader(0), mStateCount(0)
        {
        }







        virtual void preLoadImpl(void) {}






        virtual void postLoadImpl(void) {}




        virtual void preUnloadImpl(void) {}




        virtual void postUnloadImpl(void) {}



        virtual void prepareImpl(void) {}




        virtual void unprepareImpl(void) {}



        virtual void loadImpl(void) = 0;



        virtual void unloadImpl(void) = 0;

    public:
        Resource(ResourceManager* creator, const String& name, ResourceHandle handle,
            const String& group, bool isManual = false, ManualResourceLoader* loader = 0);






        virtual ~Resource();
        virtual void prepare(bool backgroundThread = false);
        virtual void load(bool backgroundThread = false);






        virtual void reload(void);



        virtual bool isReloadable(void) const
        {
            return !mIsManual || mLoader;
        }



        virtual bool isManuallyLoaded(void) const
        {
            return mIsManual;
        }



        virtual void setManuallyLoaded(bool isManual)
        {
            mIsManual = isManual;
        }





        virtual void unload(void);



        virtual size_t getSize(void) const
        {
            return mSize;
        }



        virtual void touch(void);



        virtual const String& getName(void) const
        {
            return mName;
        }

        virtual ResourceHandle getHandle(void) const
        {
            return mHandle;
        }



        virtual bool isPrepared(void) const
        {

            return (mLoadingState.get() == LOADSTATE_PREPARED);
        }



        virtual bool isLoaded(void) const
        {

            return (mLoadingState.get() == LOADSTATE_LOADED);
        }



        virtual void setToLoaded(void)
        {

            mLoadingState.set(LOADSTATE_LOADED);
        }




        virtual bool isLoading() const
        {
            return (mLoadingState.get() == LOADSTATE_LOADING);
        }



        virtual LoadingState getLoadingState() const
        {
            return mLoadingState.get();
        }
        virtual bool isBackgroundLoaded(void) const { return mIsBackgroundLoaded; }
        virtual void setBackgroundLoaded(bool bl) { mIsBackgroundLoaded = bl; }
        virtual void escalateLoading();




        virtual void addListener(Listener* lis);




        virtual void removeListener(Listener* lis);


        virtual const String& getGroup(void) const { return mGroup; }
        virtual void changeGroupOwnership(const String& newGroup);


        virtual ResourceManager* getCreator(void) { return mCreator; }






        virtual const String& getOrigin(void) const { return mOrigin; }

        virtual void _notifyOrigin(const String& origin) { mOrigin = origin; }
        virtual size_t getStateCount() const { return mStateCount; }






        virtual void _dirtyState();
        virtual void _fireLoadingComplete(bool wasBackgroundLoaded);
        virtual void _firePreparingComplete(bool wasBackgroundLoaded);
        virtual void _fireUnloadingComplete(void);


        virtual size_t calculateSize(void) const;

    };
    class ManualResourceLoader
    {
    public:
        ManualResourceLoader() {}
        virtual ~ManualResourceLoader() {}







        virtual void prepareResource(Resource* resource)
                { (void)resource; }




        virtual void loadResource(Resource* resource) = 0;
    };



}







namespace Ogre {
    class Serializer : public SerializerAlloc
    {
    public:
        Serializer();
        virtual ~Serializer();


        enum Endian
        {

            ENDIAN_NATIVE,

            ENDIAN_BIG,

            ENDIAN_LITTLE
        };


    protected:

        uint32 mCurrentstreamLen;
        DataStreamPtr mStream;
        String mVersion;
        bool mFlipEndian;


        virtual void writeFileHeader(void);
        virtual void writeChunkHeader(uint16 id, size_t size);
        virtual size_t calcChunkHeaderSize();
        size_t calcStringSize(const String& string);

        void writeFloats(const float* const pfloat, size_t count);
        void writeFloats(const double* const pfloat, size_t count);
        void writeShorts(const uint16* const pShort, size_t count);
        void writeInts(const uint32* const pInt, size_t count);
        void writeBools(const bool* const pLong, size_t count);
        void writeObject(const Vector3& vec);
        void writeObject(const Quaternion& q);

        void writeString(const String& string);
        void writeData(const void* const buf, size_t size, size_t count);

        virtual void readFileHeader(DataStreamPtr& stream);
        virtual unsigned short readChunk(DataStreamPtr& stream);

        void readChar(DataStreamPtr& stream, uint8* pDest);
        void readBools(DataStreamPtr& stream, bool* pDest, size_t count);
        void readFloats(DataStreamPtr& stream, float* pDest, size_t count);
        void readFloats(DataStreamPtr& stream, double* pDest, size_t count);
        void readShorts(DataStreamPtr& stream, uint16* pDest, size_t count);
        void readInts(DataStreamPtr& stream, uint32* pDest, size_t count);
        void readObject(DataStreamPtr& stream, Vector3& pDest);
        void readObject(DataStreamPtr& stream, Quaternion& pDest);

        String readString(DataStreamPtr& stream);
        String readString(DataStreamPtr& stream, size_t numChars);

        virtual void flipToLittleEndian(void* pData, size_t size, size_t count = 1);
        virtual void flipFromLittleEndian(void* pData, size_t size, size_t count = 1);


        virtual void determineEndianness(DataStreamPtr& stream);

        virtual void determineEndianness(Endian requestedEndian);






        virtual void pushInnerChunk(const DataStreamPtr& stream);
        virtual void popInnerChunk(const DataStreamPtr& stream);
        virtual void backpedalChunkHeader(DataStreamPtr& stream);
    };



}





namespace Ogre {
    enum BaseConstantType
    {
        BCT_FLOAT = 1,
        BCT_INT = 2,
        BCT_DOUBLE = 3,
        BCT_UINT = 4,
        BCT_BOOL = 5,
        BCT_SAMPLER = 6,
        BCT_SUBROUTINE = 7,
        BCT_UNKNOWN = 99
    };






    enum GpuConstantType
    {
        GCT_FLOAT1 = 1,
        GCT_FLOAT2 = 2,
        GCT_FLOAT3 = 3,
        GCT_FLOAT4 = 4,
        GCT_SAMPLER1D = 5,
        GCT_SAMPLER2D = 6,
        GCT_SAMPLER3D = 7,
        GCT_SAMPLERCUBE = 8,
        GCT_SAMPLERRECT = 9,
        GCT_SAMPLER1DSHADOW = 10,
        GCT_SAMPLER2DSHADOW = 11,
        GCT_SAMPLER2DARRAY = 12,
        GCT_MATRIX_2X2 = 13,
        GCT_MATRIX_2X3 = 14,
        GCT_MATRIX_2X4 = 15,
        GCT_MATRIX_3X2 = 16,
        GCT_MATRIX_3X3 = 17,
        GCT_MATRIX_3X4 = 18,
        GCT_MATRIX_4X2 = 19,
        GCT_MATRIX_4X3 = 20,
        GCT_MATRIX_4X4 = 21,
        GCT_INT1 = 22,
        GCT_INT2 = 23,
        GCT_INT3 = 24,
        GCT_INT4 = 25,
        GCT_SUBROUTINE = 26,
        GCT_DOUBLE1 = 27,
        GCT_DOUBLE2 = 28,
        GCT_DOUBLE3 = 29,
        GCT_DOUBLE4 = 30,
        GCT_MATRIX_DOUBLE_2X2 = 31,
        GCT_MATRIX_DOUBLE_2X3 = 32,
        GCT_MATRIX_DOUBLE_2X4 = 33,
        GCT_MATRIX_DOUBLE_3X2 = 34,
        GCT_MATRIX_DOUBLE_3X3 = 35,
        GCT_MATRIX_DOUBLE_3X4 = 36,
        GCT_MATRIX_DOUBLE_4X2 = 37,
        GCT_MATRIX_DOUBLE_4X3 = 38,
        GCT_MATRIX_DOUBLE_4X4 = 39,
        GCT_UINT1 = 40,
        GCT_UINT2 = 41,
        GCT_UINT3 = 42,
        GCT_UINT4 = 43,
        GCT_BOOL1 = 44,
        GCT_BOOL2 = 45,
        GCT_BOOL3 = 46,
        GCT_BOOL4 = 47,
        GCT_SAMPLER_WRAPPER1D = 48,
        GCT_SAMPLER_WRAPPER2D = 49,
        GCT_SAMPLER_WRAPPER3D = 50,
        GCT_SAMPLER_WRAPPERCUBE = 51,
        GCT_SAMPLER_STATE = 52,
        GCT_UNKNOWN = 99
    };




    enum GpuParamVariability
    {

        GPV_GLOBAL = 1,

        GPV_PER_OBJECT = 2,

        GPV_LIGHTS = 4,

        GPV_PASS_ITERATION_NUMBER = 8,



        GPV_ALL = 0xFFFF
    };





    struct GpuConstantDefinition
    {

        GpuConstantType constType;

        size_t physicalIndex;

        size_t logicalIndex;


        size_t elementSize;

        size_t arraySize;

        mutable uint16 variability;







        bool isFloat() const
        {
            return isFloat(constType);
        }

        static bool isFloat(GpuConstantType c)
        {
            switch(c)
            {
            case GCT_FLOAT1:
            case GCT_FLOAT2:
            case GCT_FLOAT3:
            case GCT_FLOAT4:
            case GCT_MATRIX_2X2:
            case GCT_MATRIX_2X3:
            case GCT_MATRIX_2X4:
            case GCT_MATRIX_3X2:
            case GCT_MATRIX_3X3:
            case GCT_MATRIX_3X4:
            case GCT_MATRIX_4X2:
            case GCT_MATRIX_4X3:
            case GCT_MATRIX_4X4:
                return true;
            default:
                return false;
            };
        }

        bool isDouble() const
        {
            return isDouble(constType);
        }

        static bool isDouble(GpuConstantType c)
        {
            switch(c)
            {
            case GCT_DOUBLE1:
            case GCT_DOUBLE2:
            case GCT_DOUBLE3:
            case GCT_DOUBLE4:
            case GCT_MATRIX_DOUBLE_2X2:
            case GCT_MATRIX_DOUBLE_2X3:
            case GCT_MATRIX_DOUBLE_2X4:
            case GCT_MATRIX_DOUBLE_3X2:
            case GCT_MATRIX_DOUBLE_3X3:
            case GCT_MATRIX_DOUBLE_3X4:
            case GCT_MATRIX_DOUBLE_4X2:
            case GCT_MATRIX_DOUBLE_4X3:
            case GCT_MATRIX_DOUBLE_4X4:
                return true;
            default:
                return false;
            };
        }

        bool isInt() const
        {
            return isInt(constType);
        }

        static bool isInt(GpuConstantType c)
        {
            switch(c)
            {
            case GCT_INT1:
            case GCT_INT2:
            case GCT_INT3:
            case GCT_INT4:
                return true;
            default:
                return false;
            };
        }

        bool isUnsignedInt() const
        {
            return isUnsignedInt(constType);
        }

        static bool isUnsignedInt(GpuConstantType c)
        {
            switch(c)
            {
            case GCT_UINT1:
            case GCT_UINT2:
            case GCT_UINT3:
            case GCT_UINT4:
                return true;
            default:
                return false;
            };
        }

        bool isBool() const
        {
            return isBool(constType);
        }

        static bool isBool(GpuConstantType c)
        {
            switch(c)
            {
            case GCT_BOOL1:
            case GCT_BOOL2:
            case GCT_BOOL3:
            case GCT_BOOL4:
                return true;
            default:
                return false;
            };
        }

        bool isSampler() const
        {
            return isSampler(constType);
        }

        static bool isSampler(GpuConstantType c)
        {
            switch(c)
            {
            case GCT_SAMPLER1D:
            case GCT_SAMPLER2D:
            case GCT_SAMPLER2DARRAY:
            case GCT_SAMPLER3D:
            case GCT_SAMPLERCUBE:
            case GCT_SAMPLER1DSHADOW:
            case GCT_SAMPLER2DSHADOW:
                return true;
            default:
                return false;
            };

        }

        bool isSubroutine() const
        {
            return isSubroutine(constType);
        }

        static bool isSubroutine(GpuConstantType c)
        {
            return c == GCT_SUBROUTINE;
        }

        static BaseConstantType getBaseType(GpuConstantType ctype)
        {
            if (isFloat(ctype))
                return BCT_FLOAT;
            else if (isDouble(ctype))
                return BCT_DOUBLE;
            else if (isInt(ctype))
                return BCT_INT;
            else if (isUnsignedInt(ctype))
                return BCT_UINT;
            else if (isBool(ctype))
                return BCT_BOOL;
            else if (isSampler(ctype))
                return BCT_SAMPLER;
            else if (isSubroutine(ctype))
                return BCT_SUBROUTINE;
            else
                return BCT_UNKNOWN;
        }




        static size_t getElementSize(GpuConstantType ctype, bool padToMultiplesOf4)
        {
            if (padToMultiplesOf4)
            {
                switch(ctype)
                {
                case GCT_FLOAT1:
                case GCT_INT1:
                case GCT_UINT1:
                case GCT_BOOL1:
                case GCT_SAMPLER1D:
                case GCT_SAMPLER2D:
                case GCT_SAMPLER2DARRAY:
                case GCT_SAMPLER3D:
                case GCT_SAMPLERCUBE:
                case GCT_SAMPLER1DSHADOW:
                case GCT_SAMPLER2DSHADOW:
                case GCT_FLOAT2:
                case GCT_INT2:
                case GCT_UINT2:
                case GCT_BOOL2:
                case GCT_FLOAT3:
                case GCT_INT3:
                case GCT_UINT3:
                case GCT_BOOL3:
                case GCT_FLOAT4:
                case GCT_INT4:
                case GCT_UINT4:
                case GCT_BOOL4:
                    return 4;
                case GCT_MATRIX_2X2:
                case GCT_MATRIX_2X3:
                case GCT_MATRIX_2X4:
                case GCT_DOUBLE1:
                case GCT_DOUBLE2:
                case GCT_DOUBLE3:
                case GCT_DOUBLE4:
                    return 8;
                case GCT_MATRIX_3X2:
                case GCT_MATRIX_3X3:
                case GCT_MATRIX_3X4:
                    return 12;
                case GCT_MATRIX_4X2:
                case GCT_MATRIX_4X3:
                case GCT_MATRIX_4X4:
                case GCT_MATRIX_DOUBLE_2X2:
                case GCT_MATRIX_DOUBLE_2X3:
                case GCT_MATRIX_DOUBLE_2X4:
                    return 16;
                case GCT_MATRIX_DOUBLE_3X2:
                case GCT_MATRIX_DOUBLE_3X3:
                case GCT_MATRIX_DOUBLE_3X4:
                    return 24;
                case GCT_MATRIX_DOUBLE_4X2:
                case GCT_MATRIX_DOUBLE_4X3:
                case GCT_MATRIX_DOUBLE_4X4:
                    return 32;
                default:
                    return 4;
                };
            }
            else
            {
                switch(ctype)
                {
                case GCT_INT1:
                case GCT_FLOAT1:
                case GCT_DOUBLE1:
                case GCT_UINT1:
                case GCT_BOOL1:
                case GCT_SAMPLER1D:
                case GCT_SAMPLER2D:
                case GCT_SAMPLER2DARRAY:
                case GCT_SAMPLER3D:
                case GCT_SAMPLERCUBE:
                case GCT_SAMPLER1DSHADOW:
                case GCT_SAMPLER2DSHADOW:
                    return 1;
                case GCT_FLOAT2:
                case GCT_INT2:
                case GCT_DOUBLE2:
                case GCT_UINT2:
                case GCT_BOOL2:
                    return 2;
                case GCT_FLOAT3:
                case GCT_INT3:
                case GCT_DOUBLE3:
                case GCT_UINT3:
                case GCT_BOOL3:
                    return 3;
                case GCT_FLOAT4:
                case GCT_INT4:
                case GCT_DOUBLE4:
                case GCT_UINT4:
                case GCT_BOOL4:
                    return 4;
                case GCT_MATRIX_2X2:
                case GCT_MATRIX_DOUBLE_2X2:
                    return 4;
                case GCT_MATRIX_2X3:
                case GCT_MATRIX_3X2:
                case GCT_MATRIX_DOUBLE_2X3:
                case GCT_MATRIX_DOUBLE_3X2:
                    return 6;
                case GCT_MATRIX_2X4:
                case GCT_MATRIX_4X2:
                case GCT_MATRIX_DOUBLE_2X4:
                case GCT_MATRIX_DOUBLE_4X2:
                    return 8;
                case GCT_MATRIX_3X3:
                case GCT_MATRIX_DOUBLE_3X3:
                    return 9;
                case GCT_MATRIX_3X4:
                case GCT_MATRIX_4X3:
                case GCT_MATRIX_DOUBLE_3X4:
                case GCT_MATRIX_DOUBLE_4X3:
                    return 12;
                case GCT_MATRIX_4X4:
                case GCT_MATRIX_DOUBLE_4X4:
                    return 16;
                default:
                    return 4;
                };

            }
        }

    GpuConstantDefinition()
        : constType(GCT_UNKNOWN)
            , physicalIndex((std::numeric_limits<size_t>::max)())
            , logicalIndex(0)
            , elementSize(0)
            , arraySize(1)
            , variability(GPV_GLOBAL) {}
    };
    typedef map<String, GpuConstantDefinition>::type GpuConstantDefinitionMap;
    typedef ConstMapIterator<GpuConstantDefinitionMap> GpuConstantDefinitionIterator;


    struct GpuNamedConstants : public GpuParamsAlloc
    {

        size_t floatBufferSize;

        size_t doubleBufferSize;

        size_t intBufferSize;

        size_t uintBufferSize;



        GpuConstantDefinitionMap map;

    GpuNamedConstants() : floatBufferSize(0), doubleBufferSize(0),
            intBufferSize(0), uintBufferSize(0) { }
        void generateConstantDefinitionArrayEntries(const String& paramName,
                                                    const GpuConstantDefinition& baseDef);


        static bool getGenerateAllConstantDefinitionArrayEntries();







        static void setGenerateAllConstantDefinitionArrayEntries(bool generateAll);




        void save(const String& filename) const;



        void load(DataStreamPtr& stream);

        size_t calculateSize(void) const;

    protected:






        static bool msGenerateAllConstantDefinitionArrayEntries;
    };


    class GpuNamedConstantsSerializer : public Serializer
    {
    public:
        GpuNamedConstantsSerializer();
        virtual ~GpuNamedConstantsSerializer();
        void exportNamedConstants(const GpuNamedConstants* pConsts, const String& filename,
                                  Endian endianMode = ENDIAN_NATIVE);
        void exportNamedConstants(const GpuNamedConstants* pConsts, DataStreamPtr stream,
                                  Endian endianMode = ENDIAN_NATIVE);
        void importNamedConstants(DataStreamPtr& stream, GpuNamedConstants* pDest);
    };




    struct GpuLogicalIndexUse
    {

        size_t physicalIndex;

        size_t currentSize;

        mutable uint16 variability;

    GpuLogicalIndexUse()
        : physicalIndex(99999), currentSize(0), variability(GPV_GLOBAL) {}
    GpuLogicalIndexUse(size_t bufIdx, size_t curSz, uint16 v)
        : physicalIndex(bufIdx), currentSize(curSz), variability(v) {}
    };
    typedef map<size_t, GpuLogicalIndexUse>::type GpuLogicalIndexUseMap;

    struct GpuLogicalBufferStruct : public GpuParamsAlloc
    {
                         ;


        GpuLogicalIndexUseMap map;

        size_t bufferSize;
    GpuLogicalBufferStruct() : bufferSize(0) {}
    };





    typedef vector<float>::type FloatConstantList;




    typedef vector<double>::type DoubleConstantList;




    typedef vector<int>::type IntConstantList;




    typedef vector<uint>::type UnsignedIntConstantList;
    class GpuSharedParameters : public GpuParamsAlloc
    {
    protected:

        String mName;


        GpuNamedConstants mNamedConstants;


        FloatConstantList mFloatConstants;

        DoubleConstantList mDoubleConstants;

        IntConstantList mIntConstants;

        UnsignedIntConstantList mUnsignedIntConstants;



        mutable Any mRenderSystemData;


        size_t mFrameLastUpdated;


        unsigned long mVersion;

        bool mDirty;

    public:
        GpuSharedParameters(const String& name);
        virtual ~GpuSharedParameters();


        const String& getName() { return mName; }
        void addConstantDefinition(const String& name, GpuConstantType constType, size_t arraySize = 1);



        void removeConstantDefinition(const String& name);



        void removeAllConstantDefinitions();




        unsigned long getVersion() const { return mVersion; }




        size_t calculateSize(void) const;




        bool isDirty() const { return mDirty; }







        void _markClean();
        void _markDirty();


        size_t getFrameLastUpdated() const { return mFrameLastUpdated; }




        GpuConstantDefinitionIterator getConstantDefinitionIterator(void) const;



        const GpuConstantDefinition& getConstantDefinition(const String& name) const;



        const GpuNamedConstants& getConstantDefinitions() const;


        void setNamedConstant(const String& name, Real val);

        void setNamedConstant(const String& name, int val);

        void setNamedConstant(const String& name, uint val);



        void setNamedConstant(const String& name, const Vector4& vec);

        void setNamedConstant(const String& name, const Vector3& vec);

        void setNamedConstant(const String& name, const Vector2& vec);

        void setNamedConstant(const String& name, const Matrix4& m);

        void setNamedConstant(const String& name, const Matrix4* m, size_t numEntries);

        void setNamedConstant(const String& name, const float *val, size_t count);

        void setNamedConstant(const String& name, const double *val, size_t count);

        void setNamedConstant(const String& name, const ColourValue& colour);

        void setNamedConstant(const String& name, const int *val, size_t count);

        void setNamedConstant(const String& name, const uint *val, size_t count);




        float* getFloatPointer(size_t pos) { _markDirty(); return &mFloatConstants[pos]; }

        const float* getFloatPointer(size_t pos) const { return &mFloatConstants[pos]; }

        double* getDoublePointer(size_t pos) { _markDirty(); return &mDoubleConstants[pos]; }

        const double* getDoublePointer(size_t pos) const { return &mDoubleConstants[pos]; }

        int* getIntPointer(size_t pos) { _markDirty(); return &mIntConstants[pos]; }

        const int* getIntPointer(size_t pos) const { return &mIntConstants[pos]; }

        uint* getUnsignedIntPointer(size_t pos) { _markDirty(); return &mUnsignedIntConstants[pos]; }

        const uint* getUnsignedIntPointer(size_t pos) const { return &mUnsignedIntConstants[pos]; }






        const FloatConstantList& getFloatConstantList() const { return mFloatConstants; }

        const DoubleConstantList& getDoubleConstantList() const { return mDoubleConstants; }

        const IntConstantList& getIntConstantList() const { return mIntConstants; }

        const UnsignedIntConstantList& getUnsignedIntConstantList() const { return mUnsignedIntConstants; }




        void _setRenderSystemData(const Any& data) const { mRenderSystemData = data; }

        const Any& _getRenderSystemData() const { return mRenderSystemData; }

    };

    class GpuProgramParameters;




    class GpuSharedParametersUsage : public GpuParamsAlloc
    {
    protected:
        GpuSharedParametersPtr mSharedParams;

        GpuProgramParameters* mParams;

        struct CopyDataEntry
        {
            const GpuConstantDefinition* srcDefinition;
            const GpuConstantDefinition* dstDefinition;
        };
        typedef vector<CopyDataEntry>::type CopyDataList;

        CopyDataList mCopyDataList;


        mutable Any mRenderSystemData;


        unsigned long mCopyDataVersion;

        void initCopyData();


    public:

        GpuSharedParametersUsage(GpuSharedParametersPtr sharedParams,
                                 GpuProgramParameters* params);
        void _copySharedParamsToTargetParams();


        const String& getName() const { return mSharedParams->getName(); }

        GpuSharedParametersPtr getSharedParams() const { return mSharedParams; }
        GpuProgramParameters* getTargetParams() const { return mParams; }


        void _setRenderSystemData(const Any& data) const { mRenderSystemData = data; }

        const Any& _getRenderSystemData() const { return mRenderSystemData; }


    };
    class GpuProgramParameters : public GpuParamsAlloc
    {
    public:



        enum AutoConstantType
        {

            ACT_WORLD_MATRIX,

            ACT_INVERSE_WORLD_MATRIX,



            ACT_TRANSPOSE_WORLD_MATRIX,

            ACT_INVERSE_TRANSPOSE_WORLD_MATRIX,


            ACT_WORLD_MATRIX_ARRAY_3x4,

            ACT_WORLD_MATRIX_ARRAY,

            ACT_WORLD_DUALQUATERNION_ARRAY_2x4,

            ACT_WORLD_SCALE_SHEAR_MATRIX_ARRAY_3x4,


            ACT_VIEW_MATRIX,

            ACT_INVERSE_VIEW_MATRIX,



            ACT_TRANSPOSE_VIEW_MATRIX,



            ACT_INVERSE_TRANSPOSE_VIEW_MATRIX,



            ACT_PROJECTION_MATRIX,



            ACT_INVERSE_PROJECTION_MATRIX,



            ACT_TRANSPOSE_PROJECTION_MATRIX,



            ACT_INVERSE_TRANSPOSE_PROJECTION_MATRIX,



            ACT_VIEWPROJ_MATRIX,



            ACT_INVERSE_VIEWPROJ_MATRIX,



            ACT_TRANSPOSE_VIEWPROJ_MATRIX,



            ACT_INVERSE_TRANSPOSE_VIEWPROJ_MATRIX,



            ACT_WORLDVIEW_MATRIX,

            ACT_INVERSE_WORLDVIEW_MATRIX,



            ACT_TRANSPOSE_WORLDVIEW_MATRIX,

            ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX,




            ACT_WORLDVIEWPROJ_MATRIX,



            ACT_INVERSE_WORLDVIEWPROJ_MATRIX,



            ACT_TRANSPOSE_WORLDVIEWPROJ_MATRIX,



            ACT_INVERSE_TRANSPOSE_WORLDVIEWPROJ_MATRIX,






            ACT_RENDER_TARGET_FLIPPING,



            ACT_VERTEX_WINDING,


            ACT_FOG_COLOUR,

            ACT_FOG_PARAMS,



            ACT_SURFACE_AMBIENT_COLOUR,

            ACT_SURFACE_DIFFUSE_COLOUR,

            ACT_SURFACE_SPECULAR_COLOUR,

            ACT_SURFACE_EMISSIVE_COLOUR,

            ACT_SURFACE_SHININESS,

            ACT_SURFACE_ALPHA_REJECTION_VALUE,



            ACT_LIGHT_COUNT,



            ACT_AMBIENT_LIGHT_COLOUR,


            ACT_LIGHT_DIFFUSE_COLOUR,

            ACT_LIGHT_SPECULAR_COLOUR,

            ACT_LIGHT_ATTENUATION,





            ACT_SPOTLIGHT_PARAMS,

            ACT_LIGHT_POSITION,

            ACT_LIGHT_POSITION_OBJECT_SPACE,

            ACT_LIGHT_POSITION_VIEW_SPACE,

            ACT_LIGHT_DIRECTION,

            ACT_LIGHT_DIRECTION_OBJECT_SPACE,

            ACT_LIGHT_DIRECTION_VIEW_SPACE,




            ACT_LIGHT_DISTANCE_OBJECT_SPACE,

            ACT_LIGHT_POWER_SCALE,

            ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED,

            ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED,

            ACT_LIGHT_DIFFUSE_COLOUR_ARRAY,

            ACT_LIGHT_SPECULAR_COLOUR_ARRAY,

            ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED_ARRAY,

            ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED_ARRAY,

            ACT_LIGHT_ATTENUATION_ARRAY,

            ACT_LIGHT_POSITION_ARRAY,

            ACT_LIGHT_POSITION_OBJECT_SPACE_ARRAY,

            ACT_LIGHT_POSITION_VIEW_SPACE_ARRAY,

            ACT_LIGHT_DIRECTION_ARRAY,

            ACT_LIGHT_DIRECTION_OBJECT_SPACE_ARRAY,

            ACT_LIGHT_DIRECTION_VIEW_SPACE_ARRAY,




            ACT_LIGHT_DISTANCE_OBJECT_SPACE_ARRAY,



            ACT_LIGHT_POWER_SCALE_ARRAY,






            ACT_SPOTLIGHT_PARAMS_ARRAY,





            ACT_DERIVED_AMBIENT_LIGHT_COLOUR,




            ACT_DERIVED_SCENE_COLOUR,






            ACT_DERIVED_LIGHT_DIFFUSE_COLOUR,





            ACT_DERIVED_LIGHT_SPECULAR_COLOUR,


            ACT_DERIVED_LIGHT_DIFFUSE_COLOUR_ARRAY,

            ACT_DERIVED_LIGHT_SPECULAR_COLOUR_ARRAY,

            ACT_LIGHT_CASTS_SHADOWS,

            ACT_LIGHT_CASTS_SHADOWS_ARRAY,





            ACT_SHADOW_EXTRUSION_DISTANCE,

            ACT_CAMERA_POSITION,

            ACT_CAMERA_POSITION_OBJECT_SPACE,

            ACT_TEXTURE_VIEWPROJ_MATRIX,

            ACT_TEXTURE_VIEWPROJ_MATRIX_ARRAY,



            ACT_TEXTURE_WORLDVIEWPROJ_MATRIX,

            ACT_TEXTURE_WORLDVIEWPROJ_MATRIX_ARRAY,

            ACT_SPOTLIGHT_VIEWPROJ_MATRIX,

            ACT_SPOTLIGHT_VIEWPROJ_MATRIX_ARRAY,



            ACT_SPOTLIGHT_WORLDVIEWPROJ_MATRIX,



            ACT_SPOTLIGHT_WORLDVIEWPROJ_MATRIX_ARRAY,

            ACT_CUSTOM,


            ACT_TIME,



            ACT_TIME_0_X,

            ACT_COSTIME_0_X,

            ACT_SINTIME_0_X,

            ACT_TANTIME_0_X,



            ACT_TIME_0_X_PACKED,




            ACT_TIME_0_1,

            ACT_COSTIME_0_1,

            ACT_SINTIME_0_1,

            ACT_TANTIME_0_1,



            ACT_TIME_0_1_PACKED,




            ACT_TIME_0_2PI,

            ACT_COSTIME_0_2PI,

            ACT_SINTIME_0_2PI,

            ACT_TANTIME_0_2PI,



            ACT_TIME_0_2PI_PACKED,

            ACT_FRAME_TIME,

            ACT_FPS,




            ACT_VIEWPORT_WIDTH,



            ACT_VIEWPORT_HEIGHT,



            ACT_INVERSE_VIEWPORT_WIDTH,



            ACT_INVERSE_VIEWPORT_HEIGHT,



            ACT_VIEWPORT_SIZE,





            ACT_VIEW_DIRECTION,



            ACT_VIEW_SIDE_VECTOR,



            ACT_VIEW_UP_VECTOR,



            ACT_FOV,



            ACT_NEAR_CLIP_DISTANCE,



            ACT_FAR_CLIP_DISTANCE,




            ACT_PASS_NUMBER,





            ACT_PASS_ITERATION_NUMBER,





            ACT_ANIMATION_PARAMETRIC,






            ACT_TEXEL_OFFSETS,





            ACT_SCENE_DEPTH_RANGE,






            ACT_SHADOW_SCENE_DEPTH_RANGE,






            ACT_SHADOW_SCENE_DEPTH_RANGE_ARRAY,




            ACT_SHADOW_COLOUR,



            ACT_TEXTURE_SIZE,



            ACT_INVERSE_TEXTURE_SIZE,



            ACT_PACKED_TEXTURE_SIZE,




            ACT_TEXTURE_MATRIX,






            ACT_LOD_CAMERA_POSITION,





            ACT_LOD_CAMERA_POSITION_OBJECT_SPACE,

            ACT_LIGHT_CUSTOM,




            ACT_PSSM_SPLITS,

            ACT_UNKNOWN = 999
        };




        enum ACDataType {

            ACDT_NONE,

            ACDT_INT,

            ACDT_REAL




        };



        enum ElementType {
            ET_INT,

            ET_REAL


        };




        struct AutoConstantDefinition
        {
            AutoConstantType acType;
            String name;
            size_t elementCount;

            ElementType elementType;

            ACDataType dataType;

        AutoConstantDefinition(AutoConstantType _acType, const String& _name,
                               size_t _elementCount, ElementType _elementType,
                               ACDataType _dataType)
        :acType(_acType), name(_name), elementCount(_elementCount),
                elementType(_elementType), dataType(_dataType)
            {

            }
        };


        class AutoConstantEntry
        {
        public:

            AutoConstantType paramType;

            size_t physicalIndex;



            size_t elementCount;

            union{
                size_t data;
                Real fData;
            };

            uint16 variability;

        AutoConstantEntry(AutoConstantType theType, size_t theIndex, size_t theData,
                          uint16 theVariability, size_t theElemCount = 4)
            : paramType(theType), physicalIndex(theIndex), elementCount(theElemCount),
                data(theData), variability(theVariability) {}

        AutoConstantEntry(AutoConstantType theType, size_t theIndex, Real theData,
                          uint16 theVariability, size_t theElemCount = 4)
            : paramType(theType), physicalIndex(theIndex), elementCount(theElemCount),
                fData(theData), variability(theVariability) {}

        };

        typedef vector<AutoConstantEntry>::type AutoConstantList;

        typedef vector<GpuSharedParametersUsage>::type GpuSharedParamUsageList;


        typedef unordered_map<unsigned int, String>::type SubroutineMap;
        typedef unordered_map<unsigned int, String>::const_iterator SubroutineIterator;

    protected:
        SubroutineMap mSubroutineMap;

        static AutoConstantDefinition AutoConstantDictionary[];


        FloatConstantList mFloatConstants;

        DoubleConstantList mDoubleConstants;

        IntConstantList mIntConstants;

        UnsignedIntConstantList mUnsignedIntConstants;




        GpuLogicalBufferStructPtr mFloatLogicalToPhysical;


        GpuLogicalBufferStructPtr mDoubleLogicalToPhysical;


        GpuLogicalBufferStructPtr mIntLogicalToPhysical;


        GpuLogicalBufferStructPtr mUnsignedIntLogicalToPhysical;


        GpuLogicalBufferStructPtr mBoolLogicalToPhysical;


        GpuLogicalIndexUse* _getFloatConstantLogicalIndexUse(size_t logicalIndex, size_t requestedSize, uint16 variability);


        GpuLogicalIndexUse* _getDoubleConstantLogicalIndexUse(size_t logicalIndex, size_t requestedSize, uint16 variability);


        GpuLogicalIndexUse* _getIntConstantLogicalIndexUse(size_t logicalIndex, size_t requestedSize, uint16 variability);


        GpuLogicalIndexUse* _getUnsignedIntConstantLogicalIndexUse(size_t logicalIndex, size_t requestedSize, uint16 variability);





        GpuNamedConstantsPtr mNamedConstants;

        AutoConstantList mAutoConstants;

        uint16 mCombinedVariability;

        bool mTransposeMatrices;

        bool mIgnoreMissingParams;

        size_t mActivePassIterationIndex;


        uint16 deriveVariability(AutoConstantType act);

        void copySharedParamSetUsage(const GpuSharedParamUsageList& srcList);

        GpuSharedParamUsageList mSharedParamSets;


        mutable Any mRenderSystemData;


    public:
        GpuProgramParameters();
        ~GpuProgramParameters() {}


        GpuProgramParameters(const GpuProgramParameters& oth);

        GpuProgramParameters& operator=(const GpuProgramParameters& oth);


        void _setNamedConstants(const GpuNamedConstantsPtr& constantmap);


        void _setLogicalIndexes(const GpuLogicalBufferStructPtr& floatIndexMap, const GpuLogicalBufferStructPtr& doubleIndexMap,
                                const GpuLogicalBufferStructPtr& intIndexMap, const GpuLogicalBufferStructPtr& uintIndexMap,
                                const GpuLogicalBufferStructPtr& boolIndexMap);



        bool hasNamedParameters() const { return !mNamedConstants.isNull(); }





        bool hasLogicalIndexedParameters() const { return !mFloatLogicalToPhysical.isNull(); }






        void setConstant(size_t index, const Vector4& vec);







        void setConstant(size_t index, Real val);







        void setConstant(size_t index, const Vector3& vec);







        void setConstant(size_t index, const Vector2& vec);






        void setConstant(size_t index, const Matrix4& m);







        void setConstant(size_t index, const Matrix4* m, size_t numEntries);





        void setConstant(size_t index, const ColourValue& colour);






        void setConstant(size_t index, const float *val, size_t count);






        void setConstant(size_t index, const double *val, size_t count);
        void setConstant(size_t index, const int *val, size_t count);
        void setConstant(size_t index, const uint *val, size_t count);
        void setConstant(size_t index, const bool *val, size_t count);







        void _writeRawConstants(size_t physicalIndex, const float* val, size_t count);






        void _writeRawConstants(size_t physicalIndex, const double* val, size_t count);






        void _writeRawConstants(size_t physicalIndex, const int* val, size_t count);






        void _writeRawConstants(size_t physicalIndex, const uint* val, size_t count);
        void _readRawConstants(size_t physicalIndex, size_t count, float* dest);






        void _readRawConstants(size_t physicalIndex, size_t count, int* dest);
        void _writeRawConstant(size_t physicalIndex, const Vector4& vec,
                               size_t count = 4);







        void _writeRawConstant(size_t physicalIndex, Real val);







        void _writeRawConstant(size_t physicalIndex, Real val, size_t count);







        void _writeRawConstant(size_t physicalIndex, int val);







        void _writeRawConstant(size_t physicalIndex, uint val);







        void _writeRawConstant(size_t physicalIndex, bool val);







        void _writeRawConstant(size_t physicalIndex, const Vector3& vec);







        void _writeRawConstant(size_t physicalIndex, const Vector2& vec);
        void _writeRawConstant(size_t physicalIndex, const Matrix4& m, size_t elementCount);







        void _writeRawConstant(size_t physicalIndex, const Matrix4* m, size_t numEntries);
        void _writeRawConstant(size_t physicalIndex, const ColourValue& colour,
                               size_t count = 4);







        GpuConstantDefinitionIterator getConstantDefinitionIterator(void) const;





        const GpuConstantDefinition& getConstantDefinition(const String& name) const;





        const GpuNamedConstants& getConstantDefinitions() const;






        const GpuLogicalBufferStructPtr& getFloatLogicalBufferStruct() const { return mFloatLogicalToPhysical; }





        const GpuLogicalBufferStructPtr& getDoubleLogicalBufferStruct() const { return mDoubleLogicalToPhysical; }





        const GpuLogicalBufferStructPtr& getIntLogicalBufferStruct() const { return mIntLogicalToPhysical; }





        const GpuLogicalBufferStructPtr& getUnsignedIntLogicalBufferStruct() const { return mUnsignedIntLogicalToPhysical; }





        const GpuLogicalBufferStructPtr& getBoolLogicalBufferStruct() const { return mBoolLogicalToPhysical; }






        size_t getFloatLogicalIndexForPhysicalIndex(size_t physicalIndex);





        size_t getDoubleLogicalIndexForPhysicalIndex(size_t physicalIndex);





        size_t getIntLogicalIndexForPhysicalIndex(size_t physicalIndex);





        size_t getUnsignedIntLogicalIndexForPhysicalIndex(size_t physicalIndex);





        size_t getBoolLogicalIndexForPhysicalIndex(size_t physicalIndex);



        const FloatConstantList& getFloatConstantList() const { return mFloatConstants; }

        float* getFloatPointer(size_t pos) { return &mFloatConstants[pos]; }

        const float* getFloatPointer(size_t pos) const { return &mFloatConstants[pos]; }

        const DoubleConstantList& getDoubleConstantList() const { return mDoubleConstants; }

        double* getDoublePointer(size_t pos) { return &mDoubleConstants[pos]; }

        const double* getDoublePointer(size_t pos) const { return &mDoubleConstants[pos]; }

        const IntConstantList& getIntConstantList() const { return mIntConstants; }

        int* getIntPointer(size_t pos) { return &mIntConstants[pos]; }

        const int* getIntPointer(size_t pos) const { return &mIntConstants[pos]; }

        const UnsignedIntConstantList& getUnsignedIntConstantList() const { return mUnsignedIntConstants; }

        uint* getUnsignedIntPointer(size_t pos) { return &mUnsignedIntConstants[pos]; }

        const uint* getUnsignedIntPointer(size_t pos) const { return &mUnsignedIntConstants[pos]; }
        const AutoConstantList& getAutoConstantList() const { return mAutoConstants; }
        void setAutoConstant(size_t index, AutoConstantType acType, size_t extraInfo = 0);
        void setAutoConstantReal(size_t index, AutoConstantType acType, Real rData);
        void setAutoConstant(size_t index, AutoConstantType acType, uint16 extraInfo1, uint16 extraInfo2);




        void _setRawAutoConstant(size_t physicalIndex, AutoConstantType acType, size_t extraInfo,
                                 uint16 variability, size_t elementSize = 4);



        void _setRawAutoConstantReal(size_t physicalIndex, AutoConstantType acType, Real rData,
                                     uint16 variability, size_t elementSize = 4);



        void clearAutoConstant(size_t index);





        void setConstantFromTime(size_t index, Real factor);


        void clearAutoConstants(void);
        typedef ConstVectorIterator<AutoConstantList> AutoConstantIterator;

        AutoConstantIterator getAutoConstantIterator(void) const;

        size_t getAutoConstantCount(void) const { return mAutoConstants.size(); }




        AutoConstantEntry* getAutoConstantEntry(const size_t index);

        bool hasAutoConstants(void) const { return !(mAutoConstants.empty()); }




        const AutoConstantEntry* findFloatAutoConstantEntry(size_t logicalIndex);




        const AutoConstantEntry* findDoubleAutoConstantEntry(size_t logicalIndex);




        const AutoConstantEntry* findIntAutoConstantEntry(size_t logicalIndex);




        const AutoConstantEntry* findUnsignedIntAutoConstantEntry(size_t logicalIndex);
        const AutoConstantEntry* findAutoConstantEntry(const String& paramName);



        const AutoConstantEntry* _findRawAutoConstantEntryFloat(size_t physicalIndex);



        const AutoConstantEntry* _findRawAutoConstantEntryDouble(size_t physicalIndex);



        const AutoConstantEntry* _findRawAutoConstantEntryInt(size_t physicalIndex);



        const AutoConstantEntry* _findRawAutoConstantEntryUnsignedInt(size_t physicalIndex);



        const AutoConstantEntry* _findRawAutoConstantEntryBool(size_t physicalIndex);





        void _updateAutoParams(const AutoParamDataSource* source, uint16 variabilityMask);



        void setIgnoreMissingParams(bool state) { mIgnoreMissingParams = state; }
        void setNamedConstant(const String& name, Real val);
        void setNamedConstant(const String& name, int val);
        void setNamedConstant(const String& name, uint val);
        void setNamedConstant(const String& name, const Vector4& vec);
        void setNamedConstant(const String& name, const Vector3& vec);




        void setNamedConstant(const String& name, const Vector2& vec);




        void setNamedConstant(const String& name, const Matrix4& m);







        void setNamedConstant(const String& name, const Matrix4* m, size_t numEntries);




        void setNamedConstant(const String& name, const ColourValue& colour);
        void setNamedConstant(const String& name, const float *val, size_t count,
                              size_t multiple = 4);
        void setNamedConstant(const String& name, const double *val, size_t count,
                              size_t multiple = 4);
        void setNamedConstant(const String& name, const int *val, size_t count,
                              size_t multiple = 4);
        void setNamedConstant(const String& name, const uint *val, size_t count,
                              size_t multiple = 4);
        void setNamedAutoConstant(const String& name, AutoConstantType acType, size_t extraInfo = 0);
        void setNamedAutoConstantReal(const String& name, AutoConstantType acType, Real rData);
        void setNamedAutoConstant(const String& name, AutoConstantType acType, uint16 extraInfo1, uint16 extraInfo2);
        void setNamedConstantFromTime(const String& name, Real factor);


        void clearNamedAutoConstant(const String& name);
        const GpuConstantDefinition* _findNamedConstantDefinition(
            const String& name, bool throwExceptionIfMissing = false) const;






        size_t _getFloatConstantPhysicalIndex(size_t logicalIndex, size_t requestedSize, uint16 variability);






        size_t _getDoubleConstantPhysicalIndex(size_t logicalIndex, size_t requestedSize, uint16 variability);






        size_t _getIntConstantPhysicalIndex(size_t logicalIndex, size_t requestedSize, uint16 variability);






        size_t _getUnsignedIntConstantPhysicalIndex(size_t logicalIndex, size_t requestedSize, uint16 variability);
        void setTransposeMatrices(bool val) { mTransposeMatrices = val; }

        bool getTransposeMatrices(void) const { return mTransposeMatrices; }







        void copyConstantsFrom(const GpuProgramParameters& source);
        void copyMatchingNamedConstantsFrom(const GpuProgramParameters& source);




        static const AutoConstantDefinition* getAutoConstantDefinition(const String& name);




        static const AutoConstantDefinition* getAutoConstantDefinition(const size_t idx);


        static size_t getNumAutoConstantDefinitions(void);




        void incPassIterationNumber(void);

        bool hasPassIterationNumber() const
        { return mActivePassIterationIndex != (std::numeric_limits<size_t>::max)(); }

        size_t getPassIterationNumberIndex() const
        { return mActivePassIterationIndex; }







        void addSharedParameters(GpuSharedParametersPtr sharedParams);
        void addSharedParameters(const String& sharedParamsName);


        bool isUsingSharedParameters(const String& sharedParamsName) const;


        void removeSharedParameters(const String& sharedParamsName);


        void removeAllSharedParameters();


        const GpuSharedParamUsageList& getSharedParameters() const;


        void _setRenderSystemData(const Any& data) const { mRenderSystemData = data; }

        const Any& _getRenderSystemData() const { return mRenderSystemData; }
        void _copySharedParams();

        size_t calculateSize(void) const;



        void setNamedSubroutine(const String& subroutineSlot, const String& subroutine);



        void setSubroutine(size_t index, const String& subroutine);



        const SubroutineMap& getSubroutineMap() const { return mSubroutineMap; }
    };



}





namespace Ogre {
    enum GpuProgramType
    {
        GPT_VERTEX_PROGRAM,
        GPT_FRAGMENT_PROGRAM,
        GPT_GEOMETRY_PROGRAM,
        GPT_HULL_PROGRAM,
        GPT_DOMAIN_PROGRAM,
        GPT_COMPUTE_PROGRAM
    };
    class GpuProgram : public Resource
    {
    protected:

        class CmdType : public ParamCommand
    {
    public:
        String doGet(const void* target) const;
        void doSet(void* target, const String& val);
    };
    class CmdSyntax : public ParamCommand
    {
    public:
        String doGet(const void* target) const;
        void doSet(void* target, const String& val);
    };
    class CmdSkeletal : public ParamCommand
    {
    public:
        String doGet(const void* target) const;
        void doSet(void* target, const String& val);
    };
    class CmdMorph : public ParamCommand
    {
    public:
        String doGet(const void* target) const;
        void doSet(void* target, const String& val);
    };
    class CmdPose : public ParamCommand
    {
    public:
        String doGet(const void* target) const;
        void doSet(void* target, const String& val);
    };
    class CmdVTF : public ParamCommand
    {
    public:
        String doGet(const void* target) const;
        void doSet(void* target, const String& val);
    };
    class CmdManualNamedConstsFile : public ParamCommand
    {
    public:
        String doGet(const void* target) const;
        void doSet(void* target, const String& val);
    };
    class CmdAdjacency : public ParamCommand
    {
    public:
        String doGet(const void* target) const;
        void doSet(void* target, const String& val);
    };
    class CmdComputeGroupDims : public ParamCommand
    {
    public:
        String doGet(const void* target) const;
        void doSet(void* target, const String& val);
    };

    static CmdType msTypeCmd;
    static CmdSyntax msSyntaxCmd;
    static CmdSkeletal msSkeletalCmd;
    static CmdMorph msMorphCmd;
    static CmdPose msPoseCmd;
    static CmdVTF msVTFCmd;
    static CmdManualNamedConstsFile msManNamedConstsFileCmd;
    static CmdAdjacency msAdjacencyCmd;
    static CmdComputeGroupDims msComputeGroupDimsCmd;

    GpuProgramType mType;

    String mFilename;

    String mSource;

    bool mLoadFromFile;

    String mSyntaxCode;

    bool mSkeletalAnimation;

    bool mMorphAnimation;

    ushort mPoseAnimation;

    bool mVertexTextureFetch;

    bool mNeedsAdjacencyInfo;

    Vector3 mComputeGroupDimensions;

    GpuProgramParametersSharedPtr mDefaultParams;

    bool mCompileError;




    mutable GpuLogicalBufferStructPtr mFloatLogicalToPhysical;




    mutable GpuLogicalBufferStructPtr mDoubleLogicalToPhysical;




    mutable GpuLogicalBufferStructPtr mIntLogicalToPhysical;




    mutable GpuLogicalBufferStructPtr mUIntLogicalToPhysical;




    mutable GpuLogicalBufferStructPtr mBoolLogicalToPhysical;




    mutable GpuNamedConstantsPtr mConstantDefs;

    String mManualNamedConstantsFile;
    bool mLoadedManualNamedConstants;
    void setupBaseParamDictionary(void);



    bool isRequiredCapabilitiesSupported(void) const;


    void loadImpl(void);


    void createParameterMappingStructures(bool recreateIfExists = true) const;

    void createLogicalParameterMappingStructures(bool recreateIfExists = true) const;

    void createNamedParameterMappingStructures(bool recreateIfExists = true) const;

    public:

    GpuProgram(ResourceManager* creator, const String& name, ResourceHandle handle,
               const String& group, bool isManual = false, ManualResourceLoader* loader = 0);

    virtual ~GpuProgram() {}





    virtual void setSourceFile(const String& filename);





    virtual void setSource(const String& source);
    virtual void setSource(const String& source, const String &debugFilename);


    virtual const String& getSyntaxCode(void) const { return mSyntaxCode; }


    virtual void setSyntaxCode(const String& syntax);


    virtual const String& getSourceFile(void) const { return mFilename; }

    virtual const String& getSource(void) const { return mSource; }

    virtual void setType(GpuProgramType t);

    virtual GpuProgramType getType(void) const { return mType; }





    virtual GpuProgram* _getBindingDelegate(void) { return this; }


    virtual bool isSupported(void) const;
    virtual GpuProgramParametersSharedPtr createParameters(void);







    virtual void setSkeletalAnimationIncluded(bool included)
    { mSkeletalAnimation = included; }







    virtual bool isSkeletalAnimationIncluded(void) const { return mSkeletalAnimation; }







    virtual void setMorphAnimationIncluded(bool included)
    { mMorphAnimation = included; }
    virtual void setPoseAnimationIncluded(ushort poseCount)
    { mPoseAnimation = poseCount; }







    virtual bool isMorphAnimationIncluded(void) const { return mMorphAnimation; }







    virtual bool isPoseAnimationIncluded(void) const { return mPoseAnimation > 0; }



    virtual ushort getNumberOfPosesIncluded(void) const { return mPoseAnimation; }



    virtual void setVertexTextureFetchRequired(bool r) { mVertexTextureFetch = r; }



    virtual bool isVertexTextureFetchRequired(void) const { return mVertexTextureFetch; }




    virtual void setAdjacencyInfoRequired(bool r) { mNeedsAdjacencyInfo = r; }



    virtual bool isAdjacencyInfoRequired(void) const { return mNeedsAdjacencyInfo; }



    virtual void setComputeGroupDimensions(Vector3 dimensions) { mComputeGroupDimensions = dimensions; }



    virtual Vector3 getComputeGroupDimensions(void) const { return mComputeGroupDimensions; }
    virtual GpuProgramParametersSharedPtr getDefaultParameters(void);



    virtual bool hasDefaultParameters(void) const { return !mDefaultParams.isNull(); }







    virtual bool getPassSurfaceAndLightStates(void) const { return false; }
    virtual bool getPassFogStates(void) const { return true; }







    virtual bool getPassTransformStates(void) const { return false; }




    virtual const String& getLanguage(void) const;



    virtual bool hasCompileError(void) const { return mCompileError; }



    virtual void resetCompileError(void) { mCompileError = false; }
    virtual void setManualNamedConstants(const GpuNamedConstants& namedConstants);
    virtual void setManualNamedConstantsFile(const String& paramDefFile);




    virtual const String& getManualNamedConstantsFile() const { return mManualNamedConstantsFile; }






    virtual const GpuNamedConstants& getConstantDefinitions() const { return *mConstantDefs.get(); }


    virtual size_t calculateSize(void) const;

    protected:

    virtual void loadFromSource(void) = 0;

    };


}




namespace Ogre {
    enum LayerBlendType
    {
        LBT_COLOUR,
        LBT_ALPHA
    };
    enum LayerBlendOperation {

        LBO_REPLACE,

        LBO_ADD,

        LBO_MODULATE,

        LBO_ALPHA_BLEND

    };







    enum LayerBlendOperationEx {

        LBX_SOURCE1,

        LBX_SOURCE2,

        LBX_MODULATE,

        LBX_MODULATE_X2,

        LBX_MODULATE_X4,

        LBX_ADD,

        LBX_ADD_SIGNED,

        LBX_ADD_SMOOTH,

        LBX_SUBTRACT,

        LBX_BLEND_DIFFUSE_ALPHA,

        LBX_BLEND_TEXTURE_ALPHA,

        LBX_BLEND_CURRENT_ALPHA,

        LBX_BLEND_MANUAL,

        LBX_DOTPRODUCT,

        LBX_BLEND_DIFFUSE_COLOUR
    };





    enum LayerBlendSource
    {

        LBS_CURRENT,

        LBS_TEXTURE,

        LBS_DIFFUSE,

        LBS_SPECULAR,

        LBS_MANUAL
    };
    class LayerBlendModeEx
    {
    public:

        LayerBlendType blendType;

        LayerBlendOperationEx operation;

        LayerBlendSource source1;

        LayerBlendSource source2;


        ColourValue colourArg1;

        ColourValue colourArg2;

        Real alphaArg1;

        Real alphaArg2;

        Real factor;

        bool operator==(const LayerBlendModeEx& rhs) const
        {
            if (blendType != rhs.blendType) return false;

            if (blendType == LBT_COLOUR)
            {

                if (operation == rhs.operation &&
                    source1 == rhs.source1 &&
                    source2 == rhs.source2 &&
                    colourArg1 == rhs.colourArg1 &&
                    colourArg2 == rhs.colourArg2 &&
                    factor == rhs.factor)
                {
                    return true;
                }
            }
            else
            {
                if (operation == rhs.operation &&
                    source1 == rhs.source1 &&
                    source2 == rhs.source2 &&
                    alphaArg1 == rhs.alphaArg1 &&
                    alphaArg2 == rhs.alphaArg2 &&
                    factor == rhs.factor)
                {
                    return true;
                }
            }
            return false;
        }

        bool operator!=(const LayerBlendModeEx& rhs) const
        {
            return !(*this == rhs);
        }



    };
    enum SceneBlendType
    {

        SBT_TRANSPARENT_ALPHA,

        SBT_TRANSPARENT_COLOUR,

        SBT_ADD,

        SBT_MODULATE,

        SBT_REPLACE

    };





    enum SceneBlendFactor
    {
        SBF_ONE,
        SBF_ZERO,
        SBF_DEST_COLOUR,
        SBF_SOURCE_COLOUR,
        SBF_ONE_MINUS_DEST_COLOUR,
        SBF_ONE_MINUS_SOURCE_COLOUR,
        SBF_DEST_ALPHA,
        SBF_SOURCE_ALPHA,
        SBF_ONE_MINUS_DEST_ALPHA,
        SBF_ONE_MINUS_SOURCE_ALPHA

    };





    enum SceneBlendOperation
    {
        SBO_ADD,
        SBO_SUBTRACT,
        SBO_REVERSE_SUBTRACT,
        SBO_MIN,
        SBO_MAX
    };



}


namespace Ogre {
    class Material : public Resource
    {
        friend class SceneManager;
        friend class MaterialManager;

    public:

        typedef FastArray<Real> LodValueArray;
        typedef ConstVectorIterator<LodValueArray> LodValueIterator;
    protected:




        void applyDefaults(void);

        typedef vector<Technique*>::type Techniques;

        Techniques mTechniques;

        Techniques mSupportedTechniques;
        typedef map<unsigned short, Technique*>::type LodTechniques;
        typedef map<unsigned short, LodTechniques*>::type BestTechniquesBySchemeList;




        BestTechniquesBySchemeList mBestTechniquesBySchemeList;

        LodValueArray mUserLodValues;
        LodValueArray mLodValues;
        bool mReceiveShadows;
        bool mTransparencyCastsShadows;

        bool mCompilationRequired;

        String mUnsupportedReasons;


        void insertSupportedTechnique(Technique* t);



        void clearBestTechniqueList(void);



        void prepareImpl(void);



        void unprepareImpl(void);



        void loadImpl(void);





        void unloadImpl(void);

        size_t calculateSize(void) const;
    public:



        Material(ResourceManager* creator, const String& name, ResourceHandle handle,
            const String& group, bool isManual = false, ManualResourceLoader* loader = 0);

        ~Material();


        Material& operator=( const Material& rhs );




        bool isTransparent(void) const;
        void setReceiveShadows(bool enabled) { mReceiveShadows = enabled; }

        bool getReceiveShadows(void) const { return mReceiveShadows; }
        void setTransparencyCastsShadows(bool enabled) { mTransparencyCastsShadows = enabled; }

        bool getTransparencyCastsShadows(void) const { return mTransparencyCastsShadows; }
        Technique* createTechnique(void);

        Technique* getTechnique(unsigned short index);



        Technique* getTechnique(const String& name);

        unsigned short getNumTechniques(void) const;

        void removeTechnique(unsigned short index);

        void removeAllTechniques(void);
        typedef VectorIterator<Techniques> TechniqueIterator;

        TechniqueIterator getTechniqueIterator(void);






        TechniqueIterator getSupportedTechniqueIterator(void);


        Technique* getSupportedTechnique(unsigned short index);

        unsigned short getNumSupportedTechniques(void) const;

        const String& getUnsupportedTechniquesExplanation() const { return mUnsupportedReasons; }






        unsigned short getNumLodLevels(unsigned short schemeIndex) const;





        unsigned short getNumLodLevels(const String& schemeName) const;
        Technique* getBestTechnique(unsigned short lodIndex = 0, const Renderable* rend = 0);







        MaterialPtr clone(const String& newName, bool changeGroup = false,
            const String& newGroup = BLANKSTRING) const;





        void copyDetailsTo(MaterialPtr& mat) const;
        void compile(bool autoManageTextureUnits = true);
        void setPointSize(Real ps);
        void setAmbient(Real red, Real green, Real blue);
        void setAmbient(const ColourValue& ambient);
        void setDiffuse(Real red, Real green, Real blue, Real alpha);
        void setDiffuse(const ColourValue& diffuse);
        void setSpecular(Real red, Real green, Real blue, Real alpha);
        void setSpecular(const ColourValue& specular);
        void setShininess(Real val);
        void setSelfIllumination(Real red, Real green, Real blue);
        void setSelfIllumination(const ColourValue& selfIllum);
        void setMacroblock( const HlmsMacroblock &macroblock );
        void setColourWriteEnabled(bool enabled);
        void setShadingMode( ShadeOptions mode );
        void setFog(
            bool overrideScene,
            FogMode mode = FOG_NONE,
            const ColourValue& colour = ColourValue::White,
            Real expDensity = 0.001, Real linearStart = 0.0, Real linearEnd = 1.0 );
        void setSamplerblock( const HlmsSamplerblock &samplerblock );
        void setBlendblock( const HlmsBlendblock &blendblock );


        void _notifyNeedsRecompile(void);
        void setLodLevels(const LodValueArray& lodValues);

        const LodValueArray* _getLodValues(void) const { return &mLodValues; }
        LodValueIterator getLodValueIterator(void) const;
        LodValueIterator getUserLodValueIterator(void) const;



        void touch(void)
        {
            if (mCompilationRequired)
                compile();

            Resource::touch();
        }
        bool applyTextureAliases(const AliasTextureNamePairList& aliasList, const bool apply = true) const;




        bool getCompilationRequired() const
        {
            return mCompilationRequired;
        }


    };


}






namespace Ogre {
    class UserObjectBindings : public GeneralAllocatedObject
    {
    public:

        UserObjectBindings();


        virtual ~UserObjectBindings();
        void setUserAny(const Any& anything);



        const Any& getUserAny(void) const;
        void setUserAny(const String& key, const Any& anything);






        const Any& getUserAny(const String& key) const;




        void eraseUserAny(const String& key);


        void clear() const;



        static const Any& getEmptyUserAny() { return msEmptyAny; }


    protected:
        typedef map<String, Any>::type UserObjectsMap;
        typedef UserObjectsMap::iterator UserObjectsMapIterator;
        typedef UserObjectsMap::const_iterator UserObjectsMapConstIterator;



        class Attributes : public GeneralAllocatedObject
        {
        public:

            Attributes() : mUserObjectsMap(NULL) {}


            ~Attributes()
            {
                if (mUserObjectsMap != NULL)
                {
                    delete mUserObjectsMap;
                    mUserObjectsMap = NULL;
                }
            }

            Any mKeylessAny;
            UserObjectsMap* mUserObjectsMap;
        };


    private:
        static Any msEmptyAny;
        mutable Attributes* mAttributes;

    };



}


namespace Ogre
{
    namespace v1
    {






    typedef struct VertexBoneAssignment_s
    {
        unsigned int vertexIndex;
        unsigned short boneIndex;
        Real weight;

    } VertexBoneAssignment;
    }


    struct VertexBoneAssignment
    {
        uint32 vertexIndex;
        uint16 boneIndex;
        Real weight;

        VertexBoneAssignment( uint32 _vertexIndex, uint16 _boneIndex, Real _weight ) :
            vertexIndex( _vertexIndex ), boneIndex( _boneIndex ), weight( _weight )
        {
        }

        VertexBoneAssignment( const v1::VertexBoneAssignment &c ) :
            vertexIndex( c.vertexIndex ),
            boneIndex( c.boneIndex ),
            weight( c.weight )
        {
        }

        bool operator < ( const VertexBoneAssignment &_r ) const
        {
            if( vertexIndex < _r.vertexIndex )
                return true;

            if( vertexIndex == _r.vertexIndex && weight > _r.weight )
                return true;

            return false;
        }

        friend bool operator < ( const VertexBoneAssignment &_l, uint32 _vertexIndex );
        friend bool operator < ( uint32 _vertexIndex, const VertexBoneAssignment &_r );
    };

    inline bool operator < ( const VertexBoneAssignment &_l, uint32 _vertexIndex )
    {
        return _l.vertexIndex < _vertexIndex;
    }

    inline bool operator < ( uint32 _vertexIndex, const VertexBoneAssignment &_r )
    {
        return _vertexIndex < _r.vertexIndex;
    }




}





namespace Ogre {

    class LodStrategy;
namespace v1 {
    struct MeshLodUsage;
    class Mesh: public Resource, public AnimationContainer
    {
        friend class SubMesh;
        friend class MeshSerializerImpl;
        friend class MeshSerializerImpl_v1_10;
        friend class MeshSerializerImpl_v1_8;
        friend class MeshSerializerImpl_v1_4;
        friend class MeshSerializerImpl_v1_3;
        friend class MeshSerializerImpl_v1_2;
        friend class MeshSerializerImpl_v1_1;

    public:
        typedef FastArray<Real> LodValueArray;
        typedef vector<MeshLodUsage>::type MeshLodUsageList;

        typedef multimap<size_t, VertexBoneAssignment>::type VertexBoneAssignmentList;
        typedef MapIterator<VertexBoneAssignmentList> BoneAssignmentIterator;
        typedef vector<SubMesh*>::type SubMeshList;
        typedef FastArray<unsigned short> IndexMap;

    protected:






        SubMeshList mSubMeshList;


        void organiseTangentsBuffer(VertexData *vertexData,
            VertexElementSemantic targetSemantic, unsigned short index,
            unsigned short sourceTexCoordSet);

    public:



        typedef unordered_map<String, ushort>::type SubMeshNameMap ;


    protected:

        DataStreamPtr mFreshFromDisk;

        SubMeshNameMap mSubMeshNameMap ;


        AxisAlignedBox mAABB;

        Real mBoundRadius;

        Real mBoneBoundingRadius;


        String mSkeletonName;
        SkeletonPtr mOldSkeleton;
        SkeletonDefPtr mSkeleton;


        VertexBoneAssignmentList mBoneAssignments;


        bool mBoneAssignmentsOutOfDate;


        void buildIndexMap(const VertexBoneAssignmentList& boneAssignments,
            IndexMap& boneIndexToBlendIndexMap, IndexMap& blendIndexToBoneIndexMap);

        void compileBoneAssignments(const VertexBoneAssignmentList& boneAssignments,
            unsigned short numBlendWeightsPerVertex,
            IndexMap& blendIndexToBoneIndexMap,
            VertexData* targetVertexData);

        String mLodStrategyName;
        bool mHasManualLodLevel;
        ushort mNumLods;
        MeshLodUsageList mMeshLodUsageList;
        LodValueArray mLodValues;

        HardwareBuffer::Usage mVertexBufferUsage;
        HardwareBuffer::Usage mIndexBufferUsage;
        bool mVertexBufferShadowBuffer;
        bool mIndexBufferShadowBuffer;

        bool mPreparedForShadowVolumes;
        bool mEdgeListsBuilt;
        bool mAutoBuildEdgeLists;


        typedef map<String, Animation*>::type AnimationList;
        AnimationList mAnimationsList;

        mutable VertexAnimationType mSharedVertexDataAnimationType;

        mutable bool mSharedVertexDataAnimationIncludesNormals;

        mutable bool mAnimationTypesDirty;


        PoseList mPoseList;
        mutable bool mPosesIncludeNormals;







        void prepareImpl(void);


        void unprepareImpl(void);

        void loadImpl(void);

        void postLoadImpl(void);

        void unloadImpl(void);

        size_t calculateSize(void) const;

        void mergeAdjacentTexcoords( unsigned short finalTexCoordSet,
                                     unsigned short texCoordSetToDestroy, VertexData *vertexData );

        void destroyShadowMappingGeom(void);

    public:




        Mesh(ResourceManager* creator, const String& name, ResourceHandle handle,
            const String& group, bool isManual = false, ManualResourceLoader* loader = 0);
        ~Mesh();
        SubMesh* createSubMesh(void);



        SubMesh* createSubMesh(const String& name);



        void nameSubMesh(const String& name, ushort index);



        void unnameSubMesh(const String& name);






        ushort _getSubMeshIndex(const String& name) const;



        unsigned short getNumSubMeshes(void) const;



        SubMesh* getSubMesh(unsigned short index) const;



        SubMesh* getSubMesh(const String& name) const ;







        void destroySubMesh(unsigned short index);







        void destroySubMesh(const String& name);

        typedef VectorIterator<SubMeshList> SubMeshIterator;

        SubMeshIterator getSubMeshIterator(void)
        { return SubMeshIterator(mSubMeshList.begin(), mSubMeshList.end()); }


        void importV2( Ogre::Mesh *mesh );
        void arrangeEfficient( bool halfPos, bool halfTexCoords, bool qTangents );




        void dearrangeToInefficient(void);
        VertexData *sharedVertexData[NumVertexPass];
        IndexMap sharedBlendIndexToBoneIndexMap;
        MeshPtr clone(const String& newName, const String& newGroup = BLANKSTRING);



        const AxisAlignedBox& getBounds(void) const;


        Real getBoundingSphereRadius(void) const;


        Real getBoneBoundingRadius() const;
        void _setBounds(const AxisAlignedBox& bounds, bool pad = true);
        void _setBoundingSphereRadius(Real radius);





        void _setBoneBoundingRadius(Real radius);






        void _computeBoneBoundingRadius();
        void _updateBoundsFromVertexBuffers(bool pad = false);







        void _calcBoundsFromVertexBuffer(VertexData* vertexData, AxisAlignedBox& outAABB, Real& outRadius, bool updateOnly = false);
        void setSkeletonName(const String& skelName);


        bool hasSkeleton(void) const;



        bool hasVertexAnimation(void) const;





        const SkeletonPtr& getOldSkeleton(void) const;
        const SkeletonDefPtr& getSkeleton(void) const { return mSkeleton; }


        const String& getSkeletonName(void) const;




        void _initAnimationState(AnimationStateSet* animSet);





        void _refreshAnimationState(AnimationStateSet* animSet);
        void addBoneAssignment(const VertexBoneAssignment& vertBoneAssign);






        void clearBoneAssignments(void);







        void _notifySkeleton(SkeletonPtr& pSkel);




        BoneAssignmentIterator getBoneAssignmentIterator(void);



        const VertexBoneAssignmentList& getBoneAssignments() const { return mBoneAssignments; }

        void setLodStrategyName( const String &name ) { mLodStrategyName = name; }


        const String& getLodStrategyName(void) const { return mLodStrategyName; }





        ushort getNumLodLevels(void) const;

        const MeshLodUsage& getLodLevel(ushort index) const;







        ushort getLodIndex(Real value) const;






        bool hasManualLodLevel(void) const { return mHasManualLodLevel; }
        void updateManualLodLevel(ushort index, const String& meshName);


        void _setLodInfo(unsigned short numLevels);

        void _setLodUsage(unsigned short level, const MeshLodUsage& usage);

        void _setSubMeshLodFaceList( unsigned short subIdx, unsigned short level, IndexData* facedata,
                                     bool casterPass );

        bool _isManualLodLevel(unsigned short level) const;


        void removeLodLevels(void);
        void setVertexBufferPolicy(HardwareBuffer::Usage usage, bool shadowBuffer = false);
        void setIndexBufferPolicy(HardwareBuffer::Usage usage, bool shadowBuffer = false);

        HardwareBuffer::Usage getVertexBufferUsage(void) const { return mVertexBufferUsage; }

        HardwareBuffer::Usage getIndexBufferUsage(void) const { return mIndexBufferUsage; }

        bool isVertexBufferShadowed(void) const { return mVertexBufferShadowBuffer; }

        bool isIndexBufferShadowed(void) const { return mIndexBufferShadowBuffer; }
        unsigned short _rationaliseBoneAssignments(size_t vertexCount, VertexBoneAssignmentList& assignments);
        void _compileBoneAssignments(void);






        void _updateCompiledBoneAssignments(void);
        void mergeAdjacentTexcoords( unsigned short finalTexCoordSet, unsigned short texCoordSetToDestroy );


        static bool msOptimizeForShadowMapping;

        void prepareForShadowMapping( bool forceSameBuffers );



        bool hasValidShadowMappingBuffers(void) const;



        bool hasIndependentShadowMappingBuffers(void) const;
        void buildTangentVectors(VertexElementSemantic targetSemantic = VES_TANGENT,
            unsigned short sourceTexCoordSet = 0, unsigned short index = 0,
            bool splitMirrored = false, bool splitRotated = false, bool storeParityInW = false);
        bool suggestTangentVectorBuildParams(VertexElementSemantic targetSemantic,
            unsigned short& outSourceCoordSet, unsigned short& outIndex);




        void buildEdgeList(void);

        void freeEdgeList(void);
        void prepareForShadowVolume(void);
        EdgeData* getEdgeList(unsigned short lodIndex = 0);
        const EdgeData* getEdgeList(unsigned short lodIndex = 0) const;



        bool isPreparedForShadowVolumes(void) const { return mPreparedForShadowVolumes; }


        bool isEdgeListBuilt(void) const { return mEdgeListsBuilt; }
        static void prepareMatricesForVertexBlend(const Matrix4** blendMatrices,
            const Matrix4* boneMatrices, const IndexMap& indexMap);
        static void softwareVertexBlend(const VertexData* sourceVertexData,
            const VertexData* targetVertexData,
            const Matrix4* const* blendMatrices, size_t numMatrices,
            bool blendNormals);
        static void softwareVertexMorph(Real t,
            const HardwareVertexBufferSharedPtr& b1,
            const HardwareVertexBufferSharedPtr& b2,
            VertexData* targetVertexData);
        static void softwareVertexPoseBlend(Real weight,
            const map<size_t, Vector3>::type& vertexOffsetMap,
            const map<size_t, Vector3>::type& normalsMap,
            VertexData* targetVertexData);

        const SubMeshNameMap& getSubMeshNameMap(void) const { return mSubMeshNameMap; }
        void setAutoBuildEdgeLists(bool autobuild) { mAutoBuildEdgeLists = autobuild; }




        bool getAutoBuildEdgeLists(void) const { return mAutoBuildEdgeLists; }



        virtual VertexAnimationType getSharedVertexDataAnimationType(void) const;


        bool getSharedVertexDataAnimationIncludesNormals() const { return mSharedVertexDataAnimationIncludesNormals; }







        virtual Animation* createAnimation(const String& name, Real length);





        virtual Animation* getAnimation(const String& name) const;






        virtual Animation* _getAnimationImpl(const String& name) const;


        virtual bool hasAnimation(const String& name) const;


        virtual void removeAnimation(const String& name);


        virtual unsigned short getNumAnimations(void) const;



        virtual Animation* getAnimation(unsigned short index) const;


        virtual void removeAllAnimations(void);





        VertexData* getVertexDataByTrackHandle(unsigned short handle);
        void updateMaterialForAllSubMeshes(void);





        void _determineAnimationTypes(void) const;

        bool _getAnimationTypesDirty(void) const { return mAnimationTypesDirty; }
        Pose* createPose(ushort target, const String& name = BLANKSTRING);

        size_t getPoseCount(void) const { return mPoseList.size(); }

        Pose* getPose(ushort index);

        Pose* getPose(const String& name);




        void removePose(ushort index);




        void removePose(const String& name);

        void removeAllPoses(void);

        typedef VectorIterator<PoseList> PoseIterator;
        typedef ConstVectorIterator<PoseList> ConstPoseIterator;


        PoseIterator getPoseIterator(void);

        ConstPoseIterator getPoseIterator(void) const;

        const PoseList& getPoseList(void) const;

        const LodValueArray* _getLodValueArray(void) const { return &mLodValues; }

        void createAzdoBuffers(void);

    };


    struct MeshLodUsage
    {




        Real userValue;






        Real value;



        String manualName;

        mutable MeshPtr manualMesh;

        mutable EdgeData* edgeData;

        MeshLodUsage() : userValue(0.0), value(0.0), edgeData(0) {}
    };




}
}



            namespace Ogre {
                typedef __m128 ArrayReal;
                typedef __m128 ArrayMaskR;





                class ArrayRadian;
            }
        namespace Ogre {
            typedef __m128i ArrayInt;
            typedef __m128i ArrayMaskI;
        }

namespace Ogre {
    class LodStrategy : public LodAlloc
    {
    protected:

        String mName;


        virtual Real getValueImpl(const MovableObject *movableObject, const Camera *camera) const = 0;

    public:

        LodStrategy(const String& name);


        virtual ~LodStrategy();


        virtual Real getBaseValue() const = 0;


        virtual Real transformBias(Real factor) const = 0;

        virtual void lodUpdateImpl( const size_t numNodes, ObjectData t,
                                    const Camera *camera, Real bias ) const = 0;


        inline static void lodSet( ObjectData &t, Real lodValues[4] );
        virtual Real transformUserValue(Real userValue) const;


        Real getValue(const MovableObject *movableObject, const Camera *camera) const;


        static ushort getIndex(Real value, const v1::Mesh::MeshLodUsageList& meshLodUsageList);


        static ushort getIndex(Real value, const Material::LodValueArray& materialLodValueArray);


        static void sort(v1::Mesh::MeshLodUsageList& meshLodUsageList);


        static bool isSorted(const v1::Mesh::LodValueArray& values);


        static void assertSorted(const v1::Mesh::LodValueArray& values);


        const String& getName() const { return mName; }
    };



}



namespace Ogre {

    typedef FastArray<VertexArrayObject*> VertexArrayObjectArray;
    class Renderable
    {
    public:
        Renderable();


        virtual ~Renderable();


        void setMaterialName( const String& name, const String& groupName );


        virtual void setMaterial( const MaterialPtr& material );




        MaterialPtr getMaterial(void) const;



        virtual void getRenderOperation(v1::RenderOperation& op, bool casterPass) = 0;
        virtual bool preRender(SceneManager* sm, RenderSystem* rsys)
                { (void)sm; (void)rsys; return true; }



        virtual void postRender(SceneManager* sm, RenderSystem* rsys)
                { (void)sm; (void)rsys; }
        virtual void getWorldTransforms(Matrix4* xform) const = 0;
        virtual unsigned short getNumWorldTransforms(void) const { return 1; }

        bool hasSkeletonAnimation(void) const { return mHasSkeletonAnimation; }
        virtual bool getUseIdentityWorldMatrix(void) const { return false; }
        virtual bool getUseIdentityViewProjMatrixIsDynamic(void) const { return false; }
        void setUseIdentityProjection(bool useIdentityProjection)
        {
            mUseIdentityProjection = useIdentityProjection;
        }
        bool getUseIdentityProjection(void) const { return mUseIdentityProjection; }
        void setUseIdentityView(bool useIdentityView)
        {
            mUseIdentityView = useIdentityView;
        }
        bool getUseIdentityView(void) const { return mUseIdentityView; }





        virtual const LightList& getLights(void) const = 0;







        virtual bool getCastsShadows(void) const { return false; }
        void setCustomParameter(size_t index, const Vector4& value)
        {
            mCustomParameters[index] = value;
        }





        void removeCustomParameter(size_t index)
        {
            mCustomParameters.erase(index);
        }





        bool hasCustomParameter(size_t index) const
        {
            return mCustomParameters.find(index) != mCustomParameters.end();
        }





        const Vector4& getCustomParameter(size_t index) const
        {
            CustomParameterMap::const_iterator i = mCustomParameters.find(index);
            if (i != mCustomParameters.end())
            {
                return i->second;
            }
            else
            {
                Ogre::ExceptionFactory::throwException(Exception::ERR_ITEM_NOT_FOUND, Exception::ERR_ITEM_NOT_FOUND, "Parameter at the given index was not found.", "Renderable::getCustomParameter", "./OgreRenderable.h", 287);


            }
        }
        virtual void _updateCustomGpuParameter(
            const GpuProgramParameters::AutoConstantEntry& constantEntry,
            GpuProgramParameters* params) const
        {
            CustomParameterMap::const_iterator i = mCustomParameters.find(constantEntry.data);
            if (i != mCustomParameters.end())
            {
                params->_writeRawConstant(constantEntry.physicalIndex, i->second,
                    constantEntry.elementCount);
            }
        }






        virtual void setPolygonModeOverrideable(bool override)
        {
            mPolygonModeOverrideable = override;
        }




        virtual bool getPolygonModeOverrideable(void) const
        {
            return mPolygonModeOverrideable;
        }
        __attribute__ ((deprecated)) virtual void setUserAny(const Any& anything) { getUserObjectBindings().setUserAny(anything); }




        __attribute__ ((deprecated)) virtual const Any& getUserAny(void) const { return getUserObjectBindings().getUserAny(); }





        UserObjectBindings& getUserObjectBindings() { return mUserObjectBindings; }





        const UserObjectBindings& getUserObjectBindings() const { return mUserObjectBindings; }

        const VertexArrayObjectArray& getVaos( VertexPass vertexPass ) const
                                                { return mVaoPerLod[vertexPass]; }

        uint32 getHlmsHash(void) const { return mHlmsHash; }
        uint32 getHlmsCasterHash(void) const { return mHlmsCasterHash; }
        HlmsDatablock* getDatablock(void) const { return mHlmsDatablock; }




        void setDatablockOrMaterialName( String materialName, String groupName );





        void setDatablock( IdString datablockName );


        virtual void setDatablock( HlmsDatablock *datablock );


        virtual void _setHlmsHashes( uint32 hash, uint32 casterHash );

        uint8 getCurrentMaterialLod(void) const { return mCurrentMaterialLod; }

        friend void LodStrategy::lodSet( ObjectData &t, Real lodValues[4] );
        void setRenderQueueSubGroup( uint8 subGroup ) { mRenderQueueSubGroup = subGroup; }
        uint8 getRenderQueueSubGroup(void) const { return mRenderQueueSubGroup; }

    protected:
        typedef map<size_t, Vector4>::type CustomParameterMap;
        CustomParameterMap mCustomParameters;







        VertexArrayObjectArray mVaoPerLod[NumVertexPass];
        uint32 mHlmsHash;
        uint32 mHlmsCasterHash;
        HlmsDatablock *mHlmsDatablock;
        MaterialPtr mMaterial;
        uint8 mRenderQueueSubGroup;
        bool mHasSkeletonAnimation;
        uint8 mCurrentMaterialLod;
        FastArray<Real> const *mLodMaterial;






        public: uint32 mHlmsGlobalIndex;
    protected:
        bool mPolygonModeOverrideable;
        bool mUseIdentityProjection;
        bool mUseIdentityView;
        UserObjectBindings mUserObjectBindings;
    };

    class RenderableAnimated : public Renderable
    {
    public:
        typedef FastArray<unsigned short> IndexMap;
    protected:
        IndexMap *mBlendIndexToBoneIndexMap;
    public:
        RenderableAnimated();

        const IndexMap* getBlendIndexToBoneIndexMap(void) const { return mBlendIndexToBoneIndexMap; }
    };




}



namespace Ogre
{


    typedef Ogre::uint32 IdType;





    class Id
    {
    public:

        template <typename T> static IdType generateNewId()
        {
            static IdType g_currentId = 0;
            return g_currentId++;
        }
    };

    class IdObject
    {
    private:
        friend struct IdCmp;
        IdType mId;

    protected:



        void _setId( IdType newId ) { mId = newId; }

    public:





        IdObject( IdType id ) : mId( id ) {}


        IdType getId() const { return mId; }

        bool operator()( const IdObject *left, const IdObject *right )
        {
            return left->mId < right->mId;
        }

        bool operator()( const IdObject &left, const IdObject &right )
        {
            return left.mId < right.mId;
        }
    };
}
namespace Ogre
{
    class ArrayRadian
    {
        ArrayReal mRad;

    public:
        explicit ArrayRadian ( ArrayReal r ) : mRad( r ) {}

        ArrayRadian& operator = ( const ArrayReal &f ) { mRad = f; return *this; }
        ArrayRadian& operator = ( const ArrayRadian &r ) { mRad = r.mRad; return *this; }



        ArrayReal valueRadians() const { return mRad; }

        inline const ArrayRadian& operator + () const;
        inline ArrayRadian operator + ( const ArrayRadian& r ) const;

        inline ArrayRadian& operator += ( const ArrayRadian& r );

        inline ArrayRadian operator - () const;
        inline ArrayRadian operator - ( const ArrayRadian& r ) const;

        inline ArrayRadian& operator -= ( const ArrayRadian& r );

        inline ArrayRadian operator * ( ArrayReal f ) const;
        inline ArrayRadian operator * ( const ArrayRadian& f ) const;
        inline ArrayRadian& operator *= ( ArrayReal f );
        inline ArrayRadian operator / ( ArrayReal f ) const;
        inline ArrayRadian& operator /= ( ArrayReal f );

        inline ArrayReal operator < ( const ArrayRadian& r ) const;
        inline ArrayReal operator <= ( const ArrayRadian& r ) const;
        inline ArrayReal operator == ( const ArrayRadian& r ) const;
        inline ArrayReal operator != ( const ArrayRadian& r ) const;
        inline ArrayReal operator >= ( const ArrayRadian& r ) const;
        inline ArrayReal operator > ( const ArrayRadian& r ) const;
    };

    class MathlibSSE2
    {
    public:
        static const ArrayReal HALF;
        static const ArrayReal ONE;
        static const ArrayReal THREE;
        static const ArrayReal NEG_ONE;
        static const ArrayReal PI;
        static const ArrayReal TWO_PI;
        static const ArrayReal ONE_DIV_2PI;
        static const ArrayReal fEpsilon;
        static const ArrayReal fSqEpsilon;
        static const ArrayReal OneMinusEpsilon;
        static const ArrayReal fDeg2Rad;
        static const ArrayReal fRad2Deg;
        static const ArrayReal FLOAT_MIN;
        static const ArrayReal SIGN_MASK;

        static const ArrayReal INFINITEA;
        static const ArrayReal MAX_NEG;
        static const ArrayReal MAX_POS;
        static const ArrayReal LAST_AFFINE_COLUMN;







        static inline ArrayReal Abs4( ArrayReal a )
        {
            return _mm_andnot_ps( _mm_set1_ps( -0.0f ), a );
        }
        static inline ArrayReal Cmov4( ArrayReal arg1, ArrayReal arg2, ArrayMaskR mask )
        {
            assert( _mm_movemask_ps( _mm_cmpeq_ps( arg1, arg1 ) ) == 0x0f &&
                    _mm_movemask_ps( _mm_cmpeq_ps( arg2, arg2 ) ) == 0x0f &&
                    "Passing NaN values to CMov4" );

            ArrayReal newNan1 = _mm_mul_ps( arg1, _mm_setzero_ps() );
            ArrayReal newNan2 = _mm_mul_ps( arg2, _mm_setzero_ps() );
            assert( _mm_movemask_ps( _mm_cmpeq_ps( newNan1, newNan1 ) ) == 0x0f &&
                    _mm_movemask_ps( _mm_cmpeq_ps( newNan2, newNan2 ) ) == 0x0f &&
                    "Passing +/- Infinity values to CMov4" );


            ArrayReal t = _mm_sub_ps( arg1, arg2 );
            return _mm_add_ps( arg2, _mm_and_ps( t, mask ) );
        }
        static inline __m128 CmovRobust( __m128 arg1, __m128 arg2, __m128 mask )
        {
            return _mm_or_ps( _mm_and_ps( arg1, mask ), _mm_andnot_ps( mask, arg2 ) );
        }
        static inline __m128d CmovRobust( __m128d arg1, __m128d arg2, __m128d mask )
        {
            return _mm_or_pd( _mm_and_pd( arg1, mask ), _mm_andnot_pd( mask, arg2 ) );
        }
        static inline ArrayInt CmovRobust( ArrayInt arg1, ArrayInt arg2, ArrayMaskI mask )
        {
            return _mm_or_si128( _mm_and_si128( arg1, mask ), _mm_andnot_si128( mask, arg2 ) );
        }





        static inline ArrayReal And( ArrayReal a, ArrayReal b )
        {
            return _mm_and_ps( a, b );
        }
        static inline ArrayInt And( ArrayInt a, ArrayInt b )
        {
            return _mm_and_si128( a, b );
        }





        static inline __m128i And( __m128i a, uint32 b )
        {
            return _mm_and_si128( a, _mm_set1_epi32( b ) );
        }
        static inline __m128i TestFlags4( __m128i a, __m128i b )
        {

            return _mm_xor_si128( _mm_cmpeq_epi32( _mm_and_si128( a, b ), _mm_setzero_si128() ),
                                    _mm_set1_epi32( -1 ) );
        }





        static inline __m128i AndNot( __m128i a, __m128i b )
        {
            return _mm_andnot_si128( b, a );
        }





        static inline __m128 Or( __m128 a, __m128 b )
        {
            return _mm_or_ps( a, b );
        }
        static inline __m128i Or( __m128i a, __m128i b )
        {
            return _mm_or_si128( a, b );
        }





        static inline __m128 CompareLess( __m128 a, __m128 b )
        {
            return _mm_cmplt_ps( a, b );
        }





        static inline __m128 CompareLessEqual( __m128 a, __m128 b )
        {
            return _mm_cmple_ps( a, b );
        }





        static inline __m128 CompareGreater( __m128 a, __m128 b )
        {
            return _mm_cmpgt_ps( a, b );
        }





        static inline __m128 CompareGreaterEqual( __m128 a, __m128 b )
        {
            return _mm_cmpge_ps( a, b );
        }

        static inline ArrayReal SetAll( Real val )
        {
            return _mm_set_ps1( val );
        }

        static inline ArrayInt SetAll( uint32 val )
        {
            return _mm_set1_epi32( val );
        }





        static inline ArrayReal isInfinity( ArrayReal a )
        {
            return _mm_cmpeq_ps( a, MathlibSSE2::INFINITEA );
        }


        static inline ArrayReal Max( ArrayReal a, ArrayReal b )
        {
            return _mm_max_ps( a, b );
        }


        static inline ArrayReal Min( ArrayReal a, ArrayReal b )
        {
            return _mm_min_ps( a, b );
        }





        static inline Real CollapseMin( ArrayReal a )
        {
            float r;
            ArrayReal t0 = _mm_shuffle_ps( a, a, _MM_SHUFFLE( 2, 3, 2, 3 ) );
            t0 = _mm_min_ps( a, t0 );
            a = _mm_shuffle_ps( t0, t0, _MM_SHUFFLE( 1, 1, 0, 0 ) );
            t0 = _mm_min_ps( a, t0 );
            _mm_store_ss( &r, t0 );
            return r;
        }





        static inline Real CollapseMax( ArrayReal a )
        {
            float r;
            ArrayReal t0 = _mm_shuffle_ps( a, a, _MM_SHUFFLE( 2, 3, 2, 3 ) );
            t0 = _mm_max_ps( a, t0 );
            a = _mm_shuffle_ps( t0, t0, _MM_SHUFFLE( 1, 1, 0, 0 ) );
            t0 = _mm_max_ps( a, t0 );
            _mm_store_ss( &r, t0 );
            return r;
        }
        static inline ArrayReal Inv4( ArrayReal val )
        {
            ArrayReal inv = _mm_rcp_ps( val );
            ArrayReal twoRcp = _mm_add_ps( inv, inv );
            ArrayReal rightSide= _mm_mul_ps( val, _mm_mul_ps( inv, inv ) );
            rightSide = _mm_and_ps( rightSide, _mm_cmpneq_ps( val, _mm_setzero_ps() ) );
            return _mm_sub_ps( twoRcp, rightSide );
        }
        static inline ArrayReal InvNonZero4( ArrayReal val )
        {
            ArrayReal inv = _mm_rcp_ps( val );
            ArrayReal twoRcp = _mm_add_ps( inv, inv );
            ArrayReal rightSide= _mm_mul_ps( val, _mm_mul_ps( inv, inv ) );
            return _mm_sub_ps( twoRcp, rightSide );
        }
        static inline ArrayReal InvSqrt4( ArrayReal f )
        {
            ArrayReal invSqrt = _mm_rsqrt_ps( f );

            ArrayReal halfInvSqrt= _mm_mul_ps( HALF, invSqrt );
            ArrayReal rightSide = _mm_mul_ps( invSqrt, _mm_mul_ps( f, invSqrt ) );
            rightSide = _mm_and_ps( rightSide, _mm_cmpneq_ps( f, _mm_setzero_ps() ) );
            return _mm_mul_ps( halfInvSqrt, _mm_sub_ps( THREE, rightSide ) );
        }
        static inline ArrayReal InvSqrtNonZero4( ArrayReal f )
        {
            ArrayReal invSqrt = _mm_rsqrt_ps( f );

            ArrayReal halfInvSqrt= _mm_mul_ps( HALF, invSqrt );
            ArrayReal rightSide = _mm_mul_ps( invSqrt, _mm_mul_ps( f, invSqrt ) );
            return _mm_mul_ps( halfInvSqrt, _mm_sub_ps( THREE, rightSide ) );
        }
        static inline ArrayReal Modf4( ArrayReal x, ArrayReal &outIntegral );







        static inline ArrayReal ACos4( ArrayReal x );







        static ArrayReal Sin4( ArrayReal x );







        static ArrayReal Cos4( ArrayReal x );
        static void SinCos4( ArrayReal x, ArrayReal &outSin, ArrayReal &outCos );
    };
}


namespace Ogre
{





    inline const ArrayRadian& ArrayRadian::operator + () const
    {
        return *this;
    }

    inline ArrayRadian ArrayRadian::operator + ( const ArrayRadian& r ) const
    {
        return ArrayRadian( _mm_add_ps( mRad, r.mRad ) );
    }






    inline ArrayRadian& ArrayRadian::operator += ( const ArrayRadian& r )
    {
        mRad = _mm_add_ps( mRad, r.mRad );
        return *this;
    }







    inline ArrayRadian ArrayRadian::operator - () const
    {
        return ArrayRadian( _mm_xor_ps( mRad, MathlibSSE2::SIGN_MASK ) );
    }

    inline ArrayRadian ArrayRadian::operator - ( const ArrayRadian& r ) const
    {
        return ArrayRadian( _mm_sub_ps( mRad, r.mRad ) );
    }






    inline ArrayRadian& ArrayRadian::operator -= ( const ArrayRadian& r )
    {
        mRad = _mm_sub_ps( mRad, r.mRad );
        return *this;
    }







    inline ArrayRadian ArrayRadian::operator * ( const ArrayRadian& r ) const
    {
        return ArrayRadian( _mm_mul_ps( mRad, r.mRad ) );
    }

    inline ArrayRadian ArrayRadian::operator / ( ArrayReal r ) const
    {
        return ArrayRadian( _mm_div_ps( mRad, r ) );
    }

    inline ArrayRadian& ArrayRadian::operator /= ( ArrayReal r )
    {
        mRad = _mm_div_ps( mRad, r );
        return *this;
    }

    inline ArrayReal ArrayRadian::operator < ( const ArrayRadian& r ) const { return _mm_cmplt_ps( mRad, r.mRad ); }
    inline ArrayReal ArrayRadian::operator <= ( const ArrayRadian& r ) const { return _mm_cmple_ps( mRad, r.mRad ); }
    inline ArrayReal ArrayRadian::operator == ( const ArrayRadian& r ) const { return _mm_cmpeq_ps( mRad, r.mRad ); }
    inline ArrayReal ArrayRadian::operator != ( const ArrayRadian& r ) const { return _mm_cmpneq_ps( mRad, r.mRad );}
    inline ArrayReal ArrayRadian::operator >= ( const ArrayRadian& r ) const { return _mm_cmpge_ps( mRad, r.mRad ); }
    inline ArrayReal ArrayRadian::operator > ( const ArrayRadian& r ) const { return _mm_cmpgt_ps( mRad, r.mRad ); }


    inline ArrayReal MathlibSSE2::Modf4( ArrayReal x, ArrayReal &outIntegral )
    {
        outIntegral = _mm_cvtepi32_ps( _mm_cvttps_epi32( x ) );
        return _mm_sub_ps( x, outIntegral );
    }

    inline ArrayReal MathlibSSE2::ACos4( ArrayReal x)
    {



        __m128 xabs = Abs4( x );
        __m128 select = _mm_cmplt_ps( x, _mm_setzero_ps() );
        __m128 t1 = _mm_sqrt_ps( _mm_sub_ps( ONE, xabs ) );






        __m128 xabs2 = _mm_mul_ps( xabs, xabs );
        __m128 xabs4 = _mm_mul_ps( xabs2, xabs2 );
        __m128 hi = _mm_add_ps( _mm_set1_ps( 0.0308918810f), _mm_mul_ps( _mm_add_ps( _mm_set1_ps(-0.0170881256f), _mm_mul_ps( _mm_add_ps( _mm_set1_ps(0.0066700901f), _mm_mul_ps( _mm_set1_ps(-0.0012624911f), xabs ) ), xabs ) ), xabs ) );



        __m128 lo = _mm_add_ps( _mm_set1_ps( 1.5707963050f), _mm_mul_ps( _mm_add_ps( _mm_set1_ps(-0.2145988016f), _mm_mul_ps( _mm_add_ps( _mm_set1_ps(0.0889789874f), _mm_mul_ps( _mm_set1_ps(-0.0501743046f), xabs ) ), xabs ) ), xabs ) );




        __m128 result = _mm_add_ps( lo, _mm_mul_ps( hi, xabs4 ) );


        return Cmov4( _mm_sub_ps( PI, _mm_mul_ps( t1, result ) ),
                        _mm_mul_ps( t1, result ),
                        select );
    }

}


namespace Ogre
{
    typedef MathlibSSE2 Mathlib;
}
namespace Ogre
{
    class ArrayVector3
    {
    public:
        ArrayReal mChunkBase[3];

        ArrayVector3() {}
        ArrayVector3( ArrayReal chunkX, ArrayReal chunkY, ArrayReal chunkZ )
        {
            mChunkBase[0] = chunkX;
            mChunkBase[1] = chunkY;
            mChunkBase[2] = chunkZ;
        }

        void getAsVector3( Vector3 &out, size_t index ) const
        {

            const Real *aliasedReal = reinterpret_cast<const Real*>( mChunkBase );
            out.x = aliasedReal[4 * 0 + index];
            out.y = aliasedReal[4 * 1 + index];
            out.z = aliasedReal[4 * 2 + index];
        }



        Vector3 getAsVector3( size_t index ) const
        {

            const Real *aliasedReal = reinterpret_cast<const Real*>( mChunkBase );
            return Vector3( aliasedReal[4 * 0 + index],
                            aliasedReal[4 * 1 + index],
                            aliasedReal[4 * 2 + index] );
        }

        void setFromVector3( const Vector3 &v, size_t index )
        {
            Real *aliasedReal = reinterpret_cast<Real*>( mChunkBase );
            aliasedReal[4 * 0 + index] = v.x;
            aliasedReal[4 * 1 + index] = v.y;
            aliasedReal[4 * 2 + index] = v.z;
        }


        void setAll( const Vector3 &v )
        {
            mChunkBase[0] = _mm_set_ps1( v.x );
            mChunkBase[1] = _mm_set_ps1( v.y );
            mChunkBase[2] = _mm_set_ps1( v.z );
        }
        inline ArrayVector3& operator = ( const Real fScalar )
        {




            ArrayReal tmp = _mm_set1_ps( fScalar );
            mChunkBase[0] = tmp;
            mChunkBase[1] = tmp;
            mChunkBase[2] = tmp;

            return *this;
        }


        inline const ArrayVector3& operator + () const;
        inline ArrayVector3 operator - () const;

        inline friend ArrayVector3 operator + ( const ArrayVector3 &lhs, const ArrayVector3 &rhs );
        inline friend ArrayVector3 operator + ( Real fScalar, const ArrayVector3 &rhs );
        inline friend ArrayVector3 operator + ( const ArrayVector3 &lhs, Real fScalar );

        inline friend ArrayVector3 operator + ( ArrayReal fScalar, const ArrayVector3 &rhs );
        inline friend ArrayVector3 operator + ( const ArrayVector3 &lhs, ArrayReal fScalar );

        inline friend ArrayVector3 operator - ( const ArrayVector3 &lhs, const ArrayVector3 &rhs );
        inline friend ArrayVector3 operator - ( Real fScalar, const ArrayVector3 &rhs );
        inline friend ArrayVector3 operator - ( const ArrayVector3 &lhs, Real fScalar );

        inline friend ArrayVector3 operator - ( ArrayReal fScalar, const ArrayVector3 &rhs );
        inline friend ArrayVector3 operator - ( const ArrayVector3 &lhs, ArrayReal fScalar );

        inline friend ArrayVector3 operator * ( const ArrayVector3 &lhs, const ArrayVector3 &rhs );
        inline friend ArrayVector3 operator * ( Real fScalar, const ArrayVector3 &rhs );
        inline friend ArrayVector3 operator * ( const ArrayVector3 &lhs, Real fScalar );

        inline friend ArrayVector3 operator * ( ArrayReal fScalar, const ArrayVector3 &rhs );
        inline friend ArrayVector3 operator * ( const ArrayVector3 &lhs, ArrayReal fScalar );

        inline friend ArrayVector3 operator / ( const ArrayVector3 &lhs, const ArrayVector3 &rhs );
        inline friend ArrayVector3 operator / ( Real fScalar, const ArrayVector3 &rhs );
        inline friend ArrayVector3 operator / ( const ArrayVector3 &lhs, Real fScalar );

        inline friend ArrayVector3 operator / ( ArrayReal fScalar, const ArrayVector3 &rhs );
        inline friend ArrayVector3 operator / ( const ArrayVector3 &lhs, ArrayReal fScalar );

        inline void operator += ( const ArrayVector3 &a );
        inline void operator += ( const Real fScalar );
        inline void operator += ( const ArrayReal fScalar );

        inline void operator -= ( const ArrayVector3 &a );
        inline void operator -= ( const Real fScalar );
        inline void operator -= ( const ArrayReal fScalar );

        inline void operator *= ( const ArrayVector3 &a );
        inline void operator *= ( const Real fScalar );
        inline void operator *= ( const ArrayReal fScalar );

        inline void operator /= ( const ArrayVector3 &a );
        inline void operator /= ( const Real fScalar );
        inline void operator /= ( const ArrayReal fScalar );


        inline ArrayReal length() const;


        inline ArrayReal squaredLength() const;


        inline ArrayReal distance( const ArrayVector3& rhs ) const;


        inline ArrayReal squaredDistance( const ArrayVector3& rhs ) const;


        inline ArrayReal dotProduct( const ArrayVector3& vec ) const;


        inline ArrayReal absDotProduct( const ArrayVector3& vec ) const;



        inline void normalise( void );


        inline ArrayVector3 crossProduct( const ArrayVector3& rkVector ) const;


        inline ArrayVector3 midPoint( const ArrayVector3& vec ) const;


        inline void makeFloor( const ArrayVector3& cmp );


        inline void makeCeil( const ArrayVector3& cmp );


        inline ArrayReal getMinComponent() const;


        inline ArrayReal getMaxComponent() const;
        inline void setToSign();


        inline ArrayVector3 perpendicular( void ) const;


        inline ArrayVector3 normalisedCopy( void ) const;


        inline ArrayVector3 reflect( const ArrayVector3& normal ) const;
        inline void inverseLeaveZeroes( void );






        inline int isNaN( void ) const;


        inline ArrayVector3 primaryAxis( void ) const;
        inline Vector3 collapseMin( void ) const;
        inline Vector3 collapseMax( void ) const;
        inline void Cmov4( ArrayMaskR mask, const ArrayVector3 &replacement );
        inline void CmovRobust( ArrayMaskR mask, const ArrayVector3 &replacement );
        inline static ArrayVector3 Cmov4( const ArrayVector3 &arg1, const ArrayVector3 &arg2, ArrayMaskR mask );
        inline void loadFromAoS( const Real * __restrict__ src );

        static const ArrayVector3 ZERO;
        static const ArrayVector3 UNIT_X;
        static const ArrayVector3 UNIT_Y;
        static const ArrayVector3 UNIT_Z;
        static const ArrayVector3 NEGATIVE_UNIT_X;
        static const ArrayVector3 NEGATIVE_UNIT_Y;
        static const ArrayVector3 NEGATIVE_UNIT_Z;
        static const ArrayVector3 UNIT_SCALE;
    };




}


namespace Ogre
{
    inline const ArrayVector3& ArrayVector3::operator + () const
    {
        return *this;
    };

    inline ArrayVector3 ArrayVector3::operator - () const
    {
        return ArrayVector3(
            _mm_xor_ps( mChunkBase[0], MathlibSSE2::SIGN_MASK ),
            _mm_xor_ps( mChunkBase[1], MathlibSSE2::SIGN_MASK ),
            _mm_xor_ps( mChunkBase[2], MathlibSSE2::SIGN_MASK ) );
    }



    inline ArrayVector3 operator + ( const ArrayVector3 &lhs, const ArrayVector3 &rhs ) { const ArrayReal * __restrict__ lhsChunkBase = lhs.mChunkBase; const ArrayReal * __restrict__ rhsChunkBase = rhs.mChunkBase; return ArrayVector3( _mm_add_ps( lhsChunkBase[0], rhsChunkBase[0] ), _mm_add_ps( lhsChunkBase[1], rhsChunkBase[1] ), _mm_add_ps( lhsChunkBase[2], rhsChunkBase[2] ) ); };
    inline ArrayVector3 operator + ( const Real fScalar, const ArrayVector3 &rhs ) { ArrayReal lhs = _mm_set1_ps( fScalar ); return ArrayVector3( _mm_add_ps( lhs, rhs.mChunkBase[0] ), _mm_add_ps( lhs, rhs.mChunkBase[1] ), _mm_add_ps( lhs, rhs.mChunkBase[2] ) ); };
    inline ArrayVector3 operator + ( const ArrayVector3 &lhs, const Real fScalar ) { ArrayReal rhs = _mm_set1_ps( fScalar ); return ArrayVector3( _mm_add_ps( lhs.mChunkBase[0], rhs ), _mm_add_ps( lhs.mChunkBase[1], rhs ), _mm_add_ps( lhs.mChunkBase[2], rhs ) ); };

    inline ArrayVector3 operator + ( const ArrayReal lhs, const ArrayVector3 &rhs ) { return ArrayVector3( _mm_add_ps( lhs, rhs.mChunkBase[0] ), _mm_add_ps( lhs, rhs.mChunkBase[1] ), _mm_add_ps( lhs, rhs.mChunkBase[2] ) ); };
    inline ArrayVector3 operator + ( const ArrayVector3 &lhs, const ArrayReal rhs ) { return ArrayVector3( _mm_add_ps( lhs.mChunkBase[0], rhs ), _mm_add_ps( lhs.mChunkBase[1], rhs ), _mm_add_ps( lhs.mChunkBase[2], rhs ) ); };


    inline ArrayVector3 operator - ( const ArrayVector3 &lhs, const ArrayVector3 &rhs ) { const ArrayReal * __restrict__ lhsChunkBase = lhs.mChunkBase; const ArrayReal * __restrict__ rhsChunkBase = rhs.mChunkBase; return ArrayVector3( _mm_sub_ps( lhsChunkBase[0], rhsChunkBase[0] ), _mm_sub_ps( lhsChunkBase[1], rhsChunkBase[1] ), _mm_sub_ps( lhsChunkBase[2], rhsChunkBase[2] ) ); };
    inline ArrayVector3 operator - ( const Real fScalar, const ArrayVector3 &rhs ) { ArrayReal lhs = _mm_set1_ps( fScalar ); return ArrayVector3( _mm_sub_ps( lhs, rhs.mChunkBase[0] ), _mm_sub_ps( lhs, rhs.mChunkBase[1] ), _mm_sub_ps( lhs, rhs.mChunkBase[2] ) ); };
    inline ArrayVector3 operator - ( const ArrayVector3 &lhs, const Real fScalar ) { ArrayReal rhs = _mm_set1_ps( fScalar ); return ArrayVector3( _mm_sub_ps( lhs.mChunkBase[0], rhs ), _mm_sub_ps( lhs.mChunkBase[1], rhs ), _mm_sub_ps( lhs.mChunkBase[2], rhs ) ); };

    inline ArrayVector3 operator - ( const ArrayReal lhs, const ArrayVector3 &rhs ) { return ArrayVector3( _mm_sub_ps( lhs, rhs.mChunkBase[0] ), _mm_sub_ps( lhs, rhs.mChunkBase[1] ), _mm_sub_ps( lhs, rhs.mChunkBase[2] ) ); };
    inline ArrayVector3 operator - ( const ArrayVector3 &lhs, const ArrayReal rhs ) { return ArrayVector3( _mm_sub_ps( lhs.mChunkBase[0], rhs ), _mm_sub_ps( lhs.mChunkBase[1], rhs ), _mm_sub_ps( lhs.mChunkBase[2], rhs ) ); };


    inline ArrayVector3 operator * ( const ArrayVector3 &lhs, const ArrayVector3 &rhs ) { const ArrayReal * __restrict__ lhsChunkBase = lhs.mChunkBase; const ArrayReal * __restrict__ rhsChunkBase = rhs.mChunkBase; return ArrayVector3( _mm_mul_ps( lhsChunkBase[0], rhsChunkBase[0] ), _mm_mul_ps( lhsChunkBase[1], rhsChunkBase[1] ), _mm_mul_ps( lhsChunkBase[2], rhsChunkBase[2] ) ); };
    inline ArrayVector3 operator * ( const Real fScalar, const ArrayVector3 &rhs ) { ArrayReal lhs = _mm_set1_ps( fScalar ); return ArrayVector3( _mm_mul_ps( lhs, rhs.mChunkBase[0] ), _mm_mul_ps( lhs, rhs.mChunkBase[1] ), _mm_mul_ps( lhs, rhs.mChunkBase[2] ) ); };
    inline ArrayVector3 operator * ( const ArrayVector3 &lhs, const Real fScalar ) { ArrayReal rhs = _mm_set1_ps( fScalar ); return ArrayVector3( _mm_mul_ps( lhs.mChunkBase[0], rhs ), _mm_mul_ps( lhs.mChunkBase[1], rhs ), _mm_mul_ps( lhs.mChunkBase[2], rhs ) ); };

    inline ArrayVector3 operator * ( const ArrayReal lhs, const ArrayVector3 &rhs ) { return ArrayVector3( _mm_mul_ps( lhs, rhs.mChunkBase[0] ), _mm_mul_ps( lhs, rhs.mChunkBase[1] ), _mm_mul_ps( lhs, rhs.mChunkBase[2] ) ); };
    inline ArrayVector3 operator * ( const ArrayVector3 &lhs, const ArrayReal rhs ) { return ArrayVector3( _mm_mul_ps( lhs.mChunkBase[0], rhs ), _mm_mul_ps( lhs.mChunkBase[1], rhs ), _mm_mul_ps( lhs.mChunkBase[2], rhs ) ); };


    inline ArrayVector3 operator / ( const ArrayVector3 &lhs, const ArrayVector3 &rhs ) { const ArrayReal * __restrict__ lhsChunkBase = lhs.mChunkBase; const ArrayReal * __restrict__ rhsChunkBase = rhs.mChunkBase; return ArrayVector3( _mm_div_ps( lhsChunkBase[0], rhsChunkBase[0] ), _mm_div_ps( lhsChunkBase[1], rhsChunkBase[1] ), _mm_div_ps( lhsChunkBase[2], rhsChunkBase[2] ) ); };
    inline ArrayVector3 operator / ( const Real fScalar, const ArrayVector3 &rhs ) { ArrayReal lhs = _mm_set1_ps( fScalar ); return ArrayVector3( _mm_div_ps( lhs, rhs.mChunkBase[0] ), _mm_div_ps( lhs, rhs.mChunkBase[1] ), _mm_div_ps( lhs, rhs.mChunkBase[2] ) ); };
    inline ArrayVector3 operator / ( const ArrayVector3 &lhs, const Real fScalar ) { assert( fScalar != 0.0 ); Real fInv = 1.0f / fScalar; ArrayReal rhs = _mm_set1_ps( fInv ); return ArrayVector3( _mm_mul_ps( lhs.mChunkBase[0], rhs ), _mm_mul_ps( lhs.mChunkBase[1], rhs ), _mm_mul_ps( lhs.mChunkBase[2], rhs ) ); };

    inline ArrayVector3 operator / ( const ArrayReal lhs, const ArrayVector3 &rhs ) { return ArrayVector3( _mm_div_ps( lhs, rhs.mChunkBase[0] ), _mm_div_ps( lhs, rhs.mChunkBase[1] ), _mm_div_ps( lhs, rhs.mChunkBase[2] ) ); };
    inline ArrayVector3 operator / ( const ArrayVector3 &lhs, const ArrayReal r ) { { assert( _mm_movemask_ps( _mm_cmpeq_ps( r, _mm_setzero_ps() ) ) == 0 && "One of the 4 floats is a zero. Can't divide by zero" ); }; ArrayReal rhs = MathlibSSE2::Inv4( r ); return ArrayVector3( _mm_mul_ps( lhs.mChunkBase[0], rhs ), _mm_mul_ps( lhs.mChunkBase[1], rhs ), _mm_mul_ps( lhs.mChunkBase[2], rhs ) ); };

    inline ArrayVector3 ArrayVector3::Cmov4( const ArrayVector3 &arg1, const ArrayVector3 &arg2, ArrayReal mask )
    {
        return ArrayVector3(
                MathlibSSE2::Cmov4( arg1.mChunkBase[0], arg2.mChunkBase[0], mask ),
                MathlibSSE2::Cmov4( arg1.mChunkBase[1], arg2.mChunkBase[1], mask ),
                MathlibSSE2::Cmov4( arg1.mChunkBase[2], arg2.mChunkBase[2], mask ) );
    }



    inline void ArrayVector3::operator += ( const ArrayVector3 &a ) { ArrayReal * __restrict__ chunkBase = mChunkBase; const ArrayReal * __restrict__ aChunkBase = a.mChunkBase; chunkBase[0] = _mm_add_ps( chunkBase[0], aChunkBase[0] ); chunkBase[1] = _mm_add_ps( chunkBase[1], aChunkBase[1] ); chunkBase[2] = _mm_add_ps( chunkBase[2], aChunkBase[2] ); };
    inline void ArrayVector3::operator += ( const Real fScalar ) { ArrayReal a = _mm_set1_ps( fScalar ); mChunkBase[0] = _mm_add_ps( mChunkBase[0], a ); mChunkBase[1] = _mm_add_ps( mChunkBase[1], a ); mChunkBase[2] = _mm_add_ps( mChunkBase[2], a ); };
    inline void ArrayVector3::operator += ( const ArrayReal a ) { mChunkBase[0] = _mm_add_ps( mChunkBase[0], a ); mChunkBase[1] = _mm_add_ps( mChunkBase[1], a ); mChunkBase[2] = _mm_add_ps( mChunkBase[2], a ); };


    inline void ArrayVector3::operator -= ( const ArrayVector3 &a ) { ArrayReal * __restrict__ chunkBase = mChunkBase; const ArrayReal * __restrict__ aChunkBase = a.mChunkBase; chunkBase[0] = _mm_sub_ps( chunkBase[0], aChunkBase[0] ); chunkBase[1] = _mm_sub_ps( chunkBase[1], aChunkBase[1] ); chunkBase[2] = _mm_sub_ps( chunkBase[2], aChunkBase[2] ); };
    inline void ArrayVector3::operator -= ( const Real fScalar ) { ArrayReal a = _mm_set1_ps( fScalar ); mChunkBase[0] = _mm_sub_ps( mChunkBase[0], a ); mChunkBase[1] = _mm_sub_ps( mChunkBase[1], a ); mChunkBase[2] = _mm_sub_ps( mChunkBase[2], a ); };
    inline void ArrayVector3::operator -= ( const ArrayReal a ) { mChunkBase[0] = _mm_sub_ps( mChunkBase[0], a ); mChunkBase[1] = _mm_sub_ps( mChunkBase[1], a ); mChunkBase[2] = _mm_sub_ps( mChunkBase[2], a ); };


    inline void ArrayVector3::operator *= ( const ArrayVector3 &a ) { ArrayReal * __restrict__ chunkBase = mChunkBase; const ArrayReal * __restrict__ aChunkBase = a.mChunkBase; chunkBase[0] = _mm_mul_ps( chunkBase[0], aChunkBase[0] ); chunkBase[1] = _mm_mul_ps( chunkBase[1], aChunkBase[1] ); chunkBase[2] = _mm_mul_ps( chunkBase[2], aChunkBase[2] ); };
    inline void ArrayVector3::operator *= ( const Real fScalar ) { ArrayReal a = _mm_set1_ps( fScalar ); mChunkBase[0] = _mm_mul_ps( mChunkBase[0], a ); mChunkBase[1] = _mm_mul_ps( mChunkBase[1], a ); mChunkBase[2] = _mm_mul_ps( mChunkBase[2], a ); };
    inline void ArrayVector3::operator *= ( const ArrayReal a ) { mChunkBase[0] = _mm_mul_ps( mChunkBase[0], a ); mChunkBase[1] = _mm_mul_ps( mChunkBase[1], a ); mChunkBase[2] = _mm_mul_ps( mChunkBase[2], a ); };


    inline void ArrayVector3::operator /= ( const ArrayVector3 &a ) { ArrayReal * __restrict__ chunkBase = mChunkBase; const ArrayReal * __restrict__ aChunkBase = a.mChunkBase; chunkBase[0] = _mm_div_ps( chunkBase[0], aChunkBase[0] ); chunkBase[1] = _mm_div_ps( chunkBase[1], aChunkBase[1] ); chunkBase[2] = _mm_div_ps( chunkBase[2], aChunkBase[2] ); };
    inline void ArrayVector3::operator /= ( const Real fScalar ) { assert( fScalar != 0.0 ); Real fInv = 1.0f / fScalar; ArrayReal a = _mm_set1_ps( fInv ); mChunkBase[0] = _mm_mul_ps( mChunkBase[0], a ); mChunkBase[1] = _mm_mul_ps( mChunkBase[1], a ); mChunkBase[2] = _mm_mul_ps( mChunkBase[2], a ); };
    inline void ArrayVector3::operator /= ( const ArrayReal _a ) { { assert( _mm_movemask_ps( _mm_cmpeq_ps( _a, _mm_setzero_ps() ) ) == 0 && "One of the 4 floats is a zero. Can't divide by zero" ); }; ArrayReal a = MathlibSSE2::Inv4( _a ); mChunkBase[0] = _mm_mul_ps( mChunkBase[0], a ); mChunkBase[1] = _mm_mul_ps( mChunkBase[1], a ); mChunkBase[2] = _mm_mul_ps( mChunkBase[2], a ); };



    inline ArrayReal ArrayVector3::length() const
    {
        return
        _mm_sqrt_ps( _mm_add_ps( _mm_add_ps(
                _mm_mul_ps( mChunkBase[0], mChunkBase[0] ),
                _mm_mul_ps( mChunkBase[1], mChunkBase[1] ) ),
            _mm_mul_ps( mChunkBase[2], mChunkBase[2] ) ) );
    }

    inline ArrayReal ArrayVector3::squaredLength() const
    {
        return
        _mm_add_ps( _mm_add_ps(
            _mm_mul_ps( mChunkBase[0], mChunkBase[0] ),
            _mm_mul_ps( mChunkBase[1], mChunkBase[1] ) ),
        _mm_mul_ps( mChunkBase[2], mChunkBase[2] ) );
    }

    inline ArrayReal ArrayVector3::distance( const ArrayVector3& rhs ) const
    {
        return (*this - rhs).length();
    }

    inline ArrayReal ArrayVector3::squaredDistance( const ArrayVector3& rhs ) const
    {
        return (*this - rhs).squaredLength();
    }

    inline ArrayReal ArrayVector3::dotProduct( const ArrayVector3& vec ) const
    {
        return
        _mm_add_ps( _mm_add_ps(
            _mm_mul_ps( mChunkBase[0], vec.mChunkBase[0] ) ,
            _mm_mul_ps( mChunkBase[1], vec.mChunkBase[1] ) ),
            _mm_mul_ps( mChunkBase[2], vec.mChunkBase[2] ) );
    }

    inline ArrayReal ArrayVector3::absDotProduct( const ArrayVector3& vec ) const
    {
        return
        _mm_add_ps( _mm_add_ps(
            MathlibSSE2::Abs4( _mm_mul_ps( mChunkBase[0], vec.mChunkBase[0] ) ),
            MathlibSSE2::Abs4( _mm_mul_ps( mChunkBase[1], vec.mChunkBase[1] ) ) ),
            MathlibSSE2::Abs4( _mm_mul_ps( mChunkBase[2], vec.mChunkBase[2] ) ) );
    }

    inline void ArrayVector3::normalise( void )
    {
        ArrayReal sqLength = _mm_add_ps( _mm_add_ps(
            _mm_mul_ps( mChunkBase[0], mChunkBase[0] ),
            _mm_mul_ps( mChunkBase[1], mChunkBase[1] ) ),
        _mm_mul_ps( mChunkBase[2], mChunkBase[2] ) );





        sqLength = MathlibSSE2::Cmov4( sqLength, MathlibSSE2::ONE,
                                        _mm_cmpgt_ps( sqLength, MathlibSSE2::FLOAT_MIN ) );
        ArrayReal invLength = MathlibSSE2::InvSqrtNonZero4( sqLength );
        mChunkBase[0] = _mm_mul_ps( mChunkBase[0], invLength );
        mChunkBase[1] = _mm_mul_ps( mChunkBase[1], invLength );
        mChunkBase[2] = _mm_mul_ps( mChunkBase[2], invLength );
    }

    inline ArrayVector3 ArrayVector3::crossProduct( const ArrayVector3& rkVec ) const
    {
        return ArrayVector3(
            _mm_sub_ps(
                _mm_mul_ps( mChunkBase[1], rkVec.mChunkBase[2] ),
                _mm_mul_ps( mChunkBase[2], rkVec.mChunkBase[1] ) ),
            _mm_sub_ps(
                _mm_mul_ps( mChunkBase[2], rkVec.mChunkBase[0] ),
                _mm_mul_ps( mChunkBase[0], rkVec.mChunkBase[2] ) ),
            _mm_sub_ps(
                _mm_mul_ps( mChunkBase[0], rkVec.mChunkBase[1] ),
                _mm_mul_ps( mChunkBase[1], rkVec.mChunkBase[0] ) ) );
    }

    inline ArrayVector3 ArrayVector3::midPoint( const ArrayVector3& rkVec ) const
    {
        return ArrayVector3(
            _mm_mul_ps( _mm_add_ps( mChunkBase[0], rkVec.mChunkBase[0] ), MathlibSSE2::HALF ),
            _mm_mul_ps( _mm_add_ps( mChunkBase[1], rkVec.mChunkBase[1] ), MathlibSSE2::HALF ),
            _mm_mul_ps( _mm_add_ps( mChunkBase[2], rkVec.mChunkBase[2] ), MathlibSSE2::HALF ) );
    }

    inline void ArrayVector3::makeFloor( const ArrayVector3& cmp )
    {
        ArrayReal * __restrict__ aChunkBase = mChunkBase;
        const ArrayReal * __restrict__ bChunkBase = cmp.mChunkBase;
        aChunkBase[0] = _mm_min_ps( aChunkBase[0], bChunkBase[0] );
        aChunkBase[1] = _mm_min_ps( aChunkBase[1], bChunkBase[1] );
        aChunkBase[2] = _mm_min_ps( aChunkBase[2], bChunkBase[2] );
    }

    inline void ArrayVector3::makeCeil( const ArrayVector3& cmp )
    {
        ArrayReal * __restrict__ aChunkBase = mChunkBase;
        const ArrayReal * __restrict__ bChunkBase = cmp.mChunkBase;
        aChunkBase[0] = _mm_max_ps( aChunkBase[0], bChunkBase[0] );
        aChunkBase[1] = _mm_max_ps( aChunkBase[1], bChunkBase[1] );
        aChunkBase[2] = _mm_max_ps( aChunkBase[2], bChunkBase[2] );
    }

    inline ArrayReal ArrayVector3::getMinComponent() const
    {
        return _mm_min_ps( mChunkBase[0], _mm_min_ps( mChunkBase[1], mChunkBase[2] ) );
    }

    inline ArrayReal ArrayVector3::getMaxComponent() const
    {
        return _mm_max_ps( mChunkBase[0], _mm_max_ps( mChunkBase[1], mChunkBase[2] ) );
    }

    inline void ArrayVector3::setToSign()
    {

        ArrayReal signMask = _mm_set1_ps( -0.0f );
        mChunkBase[0] = _mm_or_ps( MathlibSSE2::ONE, _mm_and_ps( signMask, mChunkBase[0] ) );
        mChunkBase[1] = _mm_or_ps( MathlibSSE2::ONE, _mm_and_ps( signMask, mChunkBase[1] ) );
        mChunkBase[2] = _mm_or_ps( MathlibSSE2::ONE, _mm_and_ps( signMask, mChunkBase[2] ) );
    }

    inline ArrayVector3 ArrayVector3::perpendicular( void ) const
    {
        ArrayVector3 perp = this->crossProduct( ArrayVector3::UNIT_X );

        const ArrayReal mask = _mm_cmple_ps( perp.squaredLength(), MathlibSSE2::fSqEpsilon );

        if( _mm_movemask_ps( mask ) )
        {



            ArrayVector3 perp1 = this->crossProduct( ArrayVector3::UNIT_Y );
            perp.mChunkBase[0] = MathlibSSE2::Cmov4( perp1.mChunkBase[0], perp.mChunkBase[0], mask );
            perp.mChunkBase[1] = MathlibSSE2::Cmov4( perp1.mChunkBase[1], perp.mChunkBase[1], mask );
            perp.mChunkBase[2] = MathlibSSE2::Cmov4( perp1.mChunkBase[2], perp.mChunkBase[2], mask );
        }
        perp.normalise();

        return perp;
    }

    inline ArrayVector3 ArrayVector3::normalisedCopy( void ) const
    {
        ArrayReal sqLength = _mm_add_ps( _mm_add_ps(
            _mm_mul_ps( mChunkBase[0], mChunkBase[0] ),
            _mm_mul_ps( mChunkBase[1], mChunkBase[1] ) ),
        _mm_mul_ps( mChunkBase[2], mChunkBase[2] ) );





        sqLength = MathlibSSE2::Cmov4( sqLength, MathlibSSE2::ONE,
                                        _mm_cmpgt_ps( sqLength, MathlibSSE2::FLOAT_MIN ) );
        ArrayReal invLength = MathlibSSE2::InvSqrtNonZero4( sqLength );

        return ArrayVector3(
            _mm_mul_ps( mChunkBase[0], invLength ),
            _mm_mul_ps( mChunkBase[1], invLength ),
            _mm_mul_ps( mChunkBase[2], invLength ) );
    }

    inline ArrayVector3 ArrayVector3::reflect( const ArrayVector3& normal ) const
    {
        const ArrayReal twoPointZero = _mm_set_ps1( 2.0f );
        return ( *this - ( _mm_mul_ps( twoPointZero, this->dotProduct( normal ) ) * normal ) );
    }

    inline void ArrayVector3::inverseLeaveZeroes( void )
    {

        mChunkBase[0] = MathlibSSE2::CmovRobust( mChunkBase[0], MathlibSSE2::InvNonZero4(mChunkBase[0]),
                                                 _mm_cmpeq_ps( mChunkBase[0], _mm_setzero_ps() ) );
        mChunkBase[1] = MathlibSSE2::CmovRobust( mChunkBase[1], MathlibSSE2::InvNonZero4(mChunkBase[1]),
                                                 _mm_cmpeq_ps( mChunkBase[1], _mm_setzero_ps() ) );
        mChunkBase[2] = MathlibSSE2::CmovRobust( mChunkBase[2], MathlibSSE2::InvNonZero4(mChunkBase[2]),
                                                 _mm_cmpeq_ps( mChunkBase[2], _mm_setzero_ps() ) );
    }

    inline int ArrayVector3::isNaN( void ) const
    {
        ArrayReal mask = _mm_and_ps( _mm_and_ps(
            _mm_cmpeq_ps( mChunkBase[0], mChunkBase[0] ),
            _mm_cmpeq_ps( mChunkBase[1], mChunkBase[1] ) ),
            _mm_cmpeq_ps( mChunkBase[2], mChunkBase[2] ) );

        return _mm_movemask_ps( mask ) ^ 0x0000000f;
    }

    inline ArrayVector3 ArrayVector3::primaryAxis( void ) const
    {
        ArrayReal absx = MathlibSSE2::Abs4( mChunkBase[0] );
        ArrayReal absy = MathlibSSE2::Abs4( mChunkBase[1] );
        ArrayReal absz = MathlibSSE2::Abs4( mChunkBase[2] );


        ArrayReal sign = MathlibSSE2::Cmov4( _mm_set1_ps( 1.0f ), _mm_set1_ps( -1.0f ),
                                            _mm_cmpgt_ps( mChunkBase[0], _mm_setzero_ps() ) );
        ArrayVector3 xVec( sign, _mm_setzero_ps(), _mm_setzero_ps() );


        sign = MathlibSSE2::Cmov4( _mm_set1_ps( 1.0f ), _mm_set1_ps( -1.0f ),
                                    _mm_cmpgt_ps( mChunkBase[1], _mm_setzero_ps() ) );
        ArrayVector3 yVec( _mm_setzero_ps(), sign, _mm_setzero_ps() );


        sign = MathlibSSE2::Cmov4( _mm_set1_ps( 1.0f ), _mm_set1_ps( -1.0f ),
                                    _mm_cmpgt_ps( mChunkBase[2], _mm_setzero_ps() ) );
        ArrayVector3 zVec( _mm_setzero_ps(), _mm_setzero_ps(), sign );


        ArrayReal mask = _mm_cmpgt_ps( absx, absz );
        xVec.mChunkBase[0] = MathlibSSE2::Cmov4( xVec.mChunkBase[0], zVec.mChunkBase[0], mask );
        xVec.mChunkBase[2] = MathlibSSE2::Cmov4( xVec.mChunkBase[2], zVec.mChunkBase[2], mask );


        mask = _mm_cmpgt_ps( absy, absz );
        yVec.mChunkBase[1] = MathlibSSE2::Cmov4( yVec.mChunkBase[1], zVec.mChunkBase[1], mask );
        yVec.mChunkBase[2] = MathlibSSE2::Cmov4( yVec.mChunkBase[2], zVec.mChunkBase[2], mask );

        yVec.Cmov4( _mm_cmpgt_ps( absx, absy ), xVec );
        return yVec;
    }

    inline Vector3 ArrayVector3::collapseMin( void ) const
    {
        Real vals[4] __attribute__((__aligned__(16)));
        ArrayReal aosVec0, aosVec1, aosVec2, aosVec3;


        ArrayReal tmp2, tmp0;
        tmp0 = _mm_shuffle_ps( mChunkBase[0], mChunkBase[1], 0x44 );
        tmp2 = _mm_shuffle_ps( mChunkBase[0], mChunkBase[1], 0xEE );

        aosVec0 = _mm_shuffle_ps( tmp0, mChunkBase[2], 0x08 );
        aosVec1 = _mm_shuffle_ps( tmp0, mChunkBase[2], 0x5D );
        aosVec2 = _mm_shuffle_ps( tmp2, mChunkBase[2], 0xA8 );
        aosVec3 = _mm_shuffle_ps( tmp2, mChunkBase[2], 0xFD );


        aosVec0 = _mm_min_ps( aosVec0, aosVec1 );
        aosVec2 = _mm_min_ps( aosVec2, aosVec3 );
        aosVec0 = _mm_min_ps( aosVec0, aosVec2 );

        _mm_store_ps( vals, aosVec0 );

        return Vector3( vals[0], vals[1], vals[2] );
    }

    inline Vector3 ArrayVector3::collapseMax( void ) const
    {
        Real vals[4] __attribute__((__aligned__(16)));
        ArrayReal aosVec0, aosVec1, aosVec2, aosVec3;


        ArrayReal tmp2, tmp0;
        tmp0 = _mm_shuffle_ps( mChunkBase[0], mChunkBase[1], 0x44 );
        tmp2 = _mm_shuffle_ps( mChunkBase[0], mChunkBase[1], 0xEE );

        aosVec0 = _mm_shuffle_ps( tmp0, mChunkBase[2], 0x08 );
        aosVec1 = _mm_shuffle_ps( tmp0, mChunkBase[2], 0x5D );
        aosVec2 = _mm_shuffle_ps( tmp2, mChunkBase[2], 0xA8 );
        aosVec3 = _mm_shuffle_ps( tmp2, mChunkBase[2], 0xFD );


        aosVec0 = _mm_max_ps( aosVec0, aosVec1 );
        aosVec2 = _mm_max_ps( aosVec2, aosVec3 );
        aosVec0 = _mm_max_ps( aosVec0, aosVec2 );

        _mm_store_ps( vals, aosVec0 );

        return Vector3( vals[0], vals[1], vals[2] );
    }

    inline void ArrayVector3::Cmov4( ArrayReal mask, const ArrayVector3 &replacement )
    {
        ArrayReal * __restrict__ aChunkBase = mChunkBase;
        const ArrayReal * __restrict__ bChunkBase = replacement.mChunkBase;
        aChunkBase[0] = MathlibSSE2::Cmov4( aChunkBase[0], bChunkBase[0], mask );
        aChunkBase[1] = MathlibSSE2::Cmov4( aChunkBase[1], bChunkBase[1], mask );
        aChunkBase[2] = MathlibSSE2::Cmov4( aChunkBase[2], bChunkBase[2], mask );
    }

    inline void ArrayVector3::CmovRobust( ArrayReal mask, const ArrayVector3 &replacement )
    {
        ArrayReal * __restrict__ aChunkBase = mChunkBase;
        const ArrayReal * __restrict__ bChunkBase = replacement.mChunkBase;
        aChunkBase[0] = MathlibSSE2::CmovRobust( aChunkBase[0], bChunkBase[0], mask );
        aChunkBase[1] = MathlibSSE2::CmovRobust( aChunkBase[1], bChunkBase[1], mask );
        aChunkBase[2] = MathlibSSE2::CmovRobust( aChunkBase[2], bChunkBase[2], mask );
    }

    inline void ArrayVector3::loadFromAoS( const Real * __restrict__ src )
    {
        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((_mm_load_ps( &src[0] )), (_mm_load_ps( &src[4] )), 0x44); tmp2 = _mm_shuffle_ps((_mm_load_ps( &src[0] )), (_mm_load_ps( &src[4] )), 0xEE); tmp1 = _mm_shuffle_ps((_mm_load_ps( &src[8] )), (_mm_load_ps( &src[12] )), 0x44); tmp3 = _mm_shuffle_ps((_mm_load_ps( &src[8] )), (_mm_load_ps( &src[12] )), 0xEE); (this->mChunkBase[0]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[1]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[2]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); };




    }
}

namespace Ogre
{
    class ArrayQuaternion
    {
    public:
        ArrayReal mChunkBase[4];

        ArrayQuaternion() {}
        ArrayQuaternion( const ArrayReal &chunkW, const ArrayReal &chunkX,
                                const ArrayReal &chunkY, const ArrayReal &chunkZ )
        {
            mChunkBase[0] = chunkW;
            mChunkBase[1] = chunkX;
            mChunkBase[2] = chunkY;
            mChunkBase[3] = chunkZ;
        }

        void getAsQuaternion( Quaternion &out, size_t index ) const
        {

            const Real *aliasedReal = reinterpret_cast<const Real*>( mChunkBase );
            out.w = aliasedReal[4 * 0 + index];
            out.x = aliasedReal[4 * 1 + index];
            out.y = aliasedReal[4 * 2 + index];
            out.z = aliasedReal[4 * 3 + index];
        }



        Quaternion getAsQuaternion( size_t index ) const
        {

            const Real *aliasedReal = reinterpret_cast<const Real*>( mChunkBase );
            return Quaternion( aliasedReal[4 * 0 + index],
                            aliasedReal[4 * 1 + index],
                            aliasedReal[4 * 2 + index],
                            aliasedReal[4 * 3 + index] );
        }

        void setFromQuaternion( const Quaternion &v, size_t index )
        {
            Real *aliasedReal = reinterpret_cast<Real*>( mChunkBase );
            aliasedReal[4 * 0 + index] = v.w;
            aliasedReal[4 * 1 + index] = v.x;
            aliasedReal[4 * 2 + index] = v.y;
            aliasedReal[4 * 3 + index] = v.z;
        }

        void setAll( const Quaternion &v )
        {
            mChunkBase[0] = _mm_set_ps1( v.w );
            mChunkBase[1] = _mm_set_ps1( v.x );
            mChunkBase[2] = _mm_set_ps1( v.y );
            mChunkBase[3] = _mm_set_ps1( v.z );
        }
  inline void FromOrthoDet1RotationMatrix( const ArrayReal * __restrict__ matrix );


        inline void FromAngleAxis( const ArrayRadian& rfAngle, const ArrayVector3& rkAxis );


        inline void ToAngleAxis( ArrayRadian &rfAngle, ArrayVector3 &rkAxis ) const;

        inline friend ArrayQuaternion operator * ( const ArrayQuaternion &lhs, const ArrayQuaternion &rhs );

        inline friend ArrayQuaternion operator + ( const ArrayQuaternion &lhs, const ArrayQuaternion &rhs );
        inline friend ArrayQuaternion operator - ( const ArrayQuaternion &lhs, const ArrayQuaternion &rhs );
        inline friend ArrayQuaternion operator * ( const ArrayQuaternion &lhs, ArrayReal scalar );
        inline friend ArrayQuaternion operator * ( ArrayReal scalar, const ArrayQuaternion &lhs );
        inline void operator += ( const ArrayQuaternion &a );
        inline void operator -= ( const ArrayQuaternion &a );
        inline void operator *= ( const ArrayReal fScalar );


        inline ArrayVector3 xAxis( void ) const;

        inline ArrayVector3 yAxis( void ) const;

        inline ArrayVector3 zAxis( void ) const;


        inline ArrayReal Dot( const ArrayQuaternion& rkQ ) const;


        inline ArrayReal Norm( void ) const;



        inline void normalise( void );

        inline ArrayQuaternion Inverse( void ) const;
        inline ArrayQuaternion UnitInverse( void ) const;
        inline ArrayQuaternion Exp( void ) const;
        inline ArrayQuaternion Log( void ) const;


        inline ArrayVector3 operator * ( const ArrayVector3 &v ) const;
        static inline void mul( const ArrayQuaternion &inQ, ArrayVector3 &inOutVec );




        static inline ArrayQuaternion Slerp( ArrayReal fT, const ArrayQuaternion &rkP,
                                                const ArrayQuaternion &rkQ );




        static inline ArrayQuaternion nlerpShortest( ArrayReal fT, const ArrayQuaternion& rkP,
                                                    const ArrayQuaternion& rkQ );




        static inline ArrayQuaternion nlerp( ArrayReal fT, const ArrayQuaternion& rkP,
                                                const ArrayQuaternion& rkQ );
        inline void Cmov4( ArrayMaskR mask, const ArrayQuaternion &replacement );
        inline static ArrayQuaternion Cmov4( const ArrayQuaternion &arg1, const ArrayQuaternion &arg2, ArrayMaskR mask );

        static const ArrayQuaternion ZERO;
        static const ArrayQuaternion IDENTITY;
    };



}


namespace Ogre
{
    inline ArrayQuaternion operator + ( const ArrayQuaternion &lhs, const ArrayQuaternion &rhs ) { const ArrayReal * __restrict__ lhsChunkBase = lhs.mChunkBase; const ArrayReal * __restrict__ rhsChunkBase = rhs.mChunkBase; return ArrayQuaternion( _mm_add_ps( lhsChunkBase[0], rhsChunkBase[0] ), _mm_add_ps( lhsChunkBase[1], rhsChunkBase[1] ), _mm_add_ps( lhsChunkBase[2], rhsChunkBase[2] ), _mm_add_ps( lhsChunkBase[3], rhsChunkBase[3] ) ); };


    inline ArrayQuaternion operator - ( const ArrayQuaternion &lhs, const ArrayQuaternion &rhs ) { const ArrayReal * __restrict__ lhsChunkBase = lhs.mChunkBase; const ArrayReal * __restrict__ rhsChunkBase = rhs.mChunkBase; return ArrayQuaternion( _mm_sub_ps( lhsChunkBase[0], rhsChunkBase[0] ), _mm_sub_ps( lhsChunkBase[1], rhsChunkBase[1] ), _mm_sub_ps( lhsChunkBase[2], rhsChunkBase[2] ), _mm_sub_ps( lhsChunkBase[3], rhsChunkBase[3] ) ); };


    inline ArrayQuaternion operator * ( const ArrayReal lhs, const ArrayQuaternion &rhs ) { return ArrayQuaternion( _mm_mul_ps( lhs, rhs.mChunkBase[0] ), _mm_mul_ps( lhs, rhs.mChunkBase[1] ), _mm_mul_ps( lhs, rhs.mChunkBase[2] ), _mm_mul_ps( lhs, rhs.mChunkBase[3] ) ); };
    inline ArrayQuaternion operator * ( const ArrayQuaternion &lhs, const ArrayReal rhs ) { return ArrayQuaternion( _mm_mul_ps( lhs.mChunkBase[0], rhs ), _mm_mul_ps( lhs.mChunkBase[1], rhs ), _mm_mul_ps( lhs.mChunkBase[2], rhs ), _mm_mul_ps( lhs.mChunkBase[3], rhs ) ); };



    inline void ArrayQuaternion::operator += ( const ArrayQuaternion &a ) { ArrayReal * __restrict__ chunkBase = mChunkBase; const ArrayReal * __restrict__ aChunkBase = a.mChunkBase; chunkBase[0] = _mm_add_ps( chunkBase[0], aChunkBase[0] ); chunkBase[1] = _mm_add_ps( chunkBase[1], aChunkBase[1] ); chunkBase[2] = _mm_add_ps( chunkBase[2], aChunkBase[2] ); chunkBase[3] = _mm_add_ps( chunkBase[3], aChunkBase[3] ); };


    inline void ArrayQuaternion::operator -= ( const ArrayQuaternion &a ) { ArrayReal * __restrict__ chunkBase = mChunkBase; const ArrayReal * __restrict__ aChunkBase = a.mChunkBase; chunkBase[0] = _mm_sub_ps( chunkBase[0], aChunkBase[0] ); chunkBase[1] = _mm_sub_ps( chunkBase[1], aChunkBase[1] ); chunkBase[2] = _mm_sub_ps( chunkBase[2], aChunkBase[2] ); chunkBase[3] = _mm_sub_ps( chunkBase[3], aChunkBase[3] ); };


    inline void ArrayQuaternion::operator *= ( const ArrayReal a ) { mChunkBase[0] = _mm_mul_ps( mChunkBase[0], a ); mChunkBase[1] = _mm_mul_ps( mChunkBase[1], a ); mChunkBase[2] = _mm_mul_ps( mChunkBase[2], a ); mChunkBase[3] = _mm_mul_ps( mChunkBase[3], a ); };






    inline ArrayQuaternion operator * ( const ArrayQuaternion &lhs, const ArrayQuaternion &rhs )
    {
        return ArrayQuaternion(

            _mm_sub_ps( _mm_sub_ps(
                    _mm_mul_ps( lhs.mChunkBase[0], rhs.mChunkBase[0] ),
                    _mm_mul_ps( lhs.mChunkBase[1], rhs.mChunkBase[1] ) ),
            _mm_add_ps(
                    _mm_mul_ps( lhs.mChunkBase[2], rhs.mChunkBase[2] ),
                    _mm_mul_ps( lhs.mChunkBase[3], rhs.mChunkBase[3] ) ) ),

            _mm_add_ps( _mm_add_ps(
                    _mm_mul_ps( lhs.mChunkBase[0], rhs.mChunkBase[1] ),
                    _mm_mul_ps( lhs.mChunkBase[1], rhs.mChunkBase[0] ) ),
            _mm_sub_ps(
                    _mm_mul_ps( lhs.mChunkBase[2], rhs.mChunkBase[3] ),
                    _mm_mul_ps( lhs.mChunkBase[3], rhs.mChunkBase[2] ) ) ),

            _mm_add_ps( _mm_add_ps(
                    _mm_mul_ps( lhs.mChunkBase[0], rhs.mChunkBase[2] ),
                    _mm_mul_ps( lhs.mChunkBase[2], rhs.mChunkBase[0] ) ),
            _mm_sub_ps(
                    _mm_mul_ps( lhs.mChunkBase[3], rhs.mChunkBase[1] ),
                    _mm_mul_ps( lhs.mChunkBase[1], rhs.mChunkBase[3] ) ) ),

            _mm_add_ps( _mm_add_ps(
                    _mm_mul_ps( lhs.mChunkBase[0], rhs.mChunkBase[3] ),
                    _mm_mul_ps( lhs.mChunkBase[3], rhs.mChunkBase[0] ) ),
            _mm_sub_ps(
                    _mm_mul_ps( lhs.mChunkBase[1], rhs.mChunkBase[2] ),
                    _mm_mul_ps( lhs.mChunkBase[2], rhs.mChunkBase[1] ) ) ) );
    }

    inline ArrayQuaternion ArrayQuaternion::Slerp( ArrayReal fT, const ArrayQuaternion &rkP,
                                                        const ArrayQuaternion &rkQ )
    {
        ArrayReal fCos = rkP.Dot( rkQ );

        fCos = _mm_min_ps( MathlibSSE2::ONE, _mm_max_ps( MathlibSSE2::NEG_ONE, fCos ) );



        ArrayReal m = MathlibSSE2::Cmov4( MathlibSSE2::NEG_ONE, MathlibSSE2::ONE,
                                            _mm_cmplt_ps( fCos, _mm_setzero_ps() ) );
        ArrayQuaternion rkT(
                        _mm_mul_ps( rkQ.mChunkBase[0], m ),
                        _mm_mul_ps( rkQ.mChunkBase[1], m ),
                        _mm_mul_ps( rkQ.mChunkBase[2], m ),
                        _mm_mul_ps( rkQ.mChunkBase[3], m ) );

        ArrayReal fSin = _mm_sqrt_ps( _mm_sub_ps( MathlibSSE2::ONE, _mm_mul_ps( fCos, fCos ) ) );







        ArrayReal fAngle = MathlibSSE2::ACos4( fCos );


        ArrayReal mask = _mm_cmplt_ps( MathlibSSE2::Abs4( fCos ), MathlibSSE2::OneMinusEpsilon );
        ArrayReal fInvSin = MathlibSSE2::InvNonZero4( fSin );
        ArrayReal oneSubT = _mm_sub_ps( MathlibSSE2::ONE, fT );

        ArrayReal fCoeff0 = _mm_mul_ps( MathlibSSE2::Sin4( _mm_mul_ps( oneSubT, fAngle ) ), fInvSin );
        ArrayReal fCoeff1 = _mm_mul_ps( MathlibSSE2::Sin4( _mm_mul_ps( fT, fAngle ) ), fInvSin );

        fCoeff0 = MathlibSSE2::CmovRobust( fCoeff0, oneSubT, mask );
        fCoeff1 = MathlibSSE2::CmovRobust( fCoeff1, fT, mask );


        rkT.mChunkBase[0] = _mm_add_ps( _mm_mul_ps( rkP.mChunkBase[0], fCoeff0 ),
                                         _mm_mul_ps( rkT.mChunkBase[0], fCoeff1 ) ),
        rkT.mChunkBase[1] = _mm_add_ps( _mm_mul_ps( rkP.mChunkBase[1], fCoeff0 ),
                                         _mm_mul_ps( rkT.mChunkBase[1], fCoeff1 ) ),
        rkT.mChunkBase[2] = _mm_add_ps( _mm_mul_ps( rkP.mChunkBase[2], fCoeff0 ),
                                         _mm_mul_ps( rkT.mChunkBase[2], fCoeff1 ) ),
        rkT.mChunkBase[3] = _mm_add_ps( _mm_mul_ps( rkP.mChunkBase[3], fCoeff0 ),
                                         _mm_mul_ps( rkT.mChunkBase[3], fCoeff1 ) );

        rkT.normalise();

        return rkT;
    }

    inline ArrayQuaternion ArrayQuaternion::nlerpShortest( ArrayReal fT, const ArrayQuaternion &rkP,
                                                            const ArrayQuaternion &rkQ )
    {

        ArrayReal signMask = _mm_set1_ps( -0.0f );
        ArrayReal sign = _mm_and_ps( signMask, rkP.Dot( rkQ ) );
        ArrayQuaternion tmpQ = ArrayQuaternion( _mm_xor_ps( rkQ.mChunkBase[0], sign ),
                                                _mm_xor_ps( rkQ.mChunkBase[1], sign ),
                                                _mm_xor_ps( rkQ.mChunkBase[2], sign ),
                                                _mm_xor_ps( rkQ.mChunkBase[3], sign ) );

        ArrayQuaternion retVal(
                _mm_add_ps( rkP.mChunkBase[0], _mm_mul_ps( fT, _mm_sub_ps( tmpQ.mChunkBase[0], rkP.mChunkBase[0] ) ) ),
                _mm_add_ps( rkP.mChunkBase[1], _mm_mul_ps( fT, _mm_sub_ps( tmpQ.mChunkBase[1], rkP.mChunkBase[1] ) ) ),
                _mm_add_ps( rkP.mChunkBase[2], _mm_mul_ps( fT, _mm_sub_ps( tmpQ.mChunkBase[2], rkP.mChunkBase[2] ) ) ),
                _mm_add_ps( rkP.mChunkBase[3], _mm_mul_ps( fT, _mm_sub_ps( tmpQ.mChunkBase[3], rkP.mChunkBase[3] ) ) ) );
        retVal.normalise();

        return retVal;
    }

    inline ArrayQuaternion ArrayQuaternion::nlerp( ArrayReal fT, const ArrayQuaternion &rkP,
                                                        const ArrayQuaternion &rkQ )
    {
        ArrayQuaternion retVal(
                _mm_add_ps( rkP.mChunkBase[0], _mm_mul_ps( fT, _mm_sub_ps( rkQ.mChunkBase[0], rkP.mChunkBase[0] ) ) ),
                _mm_add_ps( rkP.mChunkBase[1], _mm_mul_ps( fT, _mm_sub_ps( rkQ.mChunkBase[1], rkP.mChunkBase[1] ) ) ),
                _mm_add_ps( rkP.mChunkBase[2], _mm_mul_ps( fT, _mm_sub_ps( rkQ.mChunkBase[2], rkP.mChunkBase[2] ) ) ),
                _mm_add_ps( rkP.mChunkBase[3], _mm_mul_ps( fT, _mm_sub_ps( rkQ.mChunkBase[3], rkP.mChunkBase[3] ) ) ) );
        retVal.normalise();

        return retVal;
    }

    inline ArrayQuaternion ArrayQuaternion::Cmov4( const ArrayQuaternion &arg1,
                                                    const ArrayQuaternion &arg2, ArrayMaskR mask )
    {
        return ArrayQuaternion(
                MathlibSSE2::Cmov4( arg1.mChunkBase[0], arg2.mChunkBase[0], mask ),
                MathlibSSE2::Cmov4( arg1.mChunkBase[1], arg2.mChunkBase[1], mask ),
                MathlibSSE2::Cmov4( arg1.mChunkBase[2], arg2.mChunkBase[2], mask ),
                MathlibSSE2::Cmov4( arg1.mChunkBase[3], arg2.mChunkBase[3], mask ) );
    }

    inline void ArrayQuaternion::mul( const ArrayQuaternion &inQ, ArrayVector3 &inOutVec )
    {

        ArrayVector3 qVec( inQ.mChunkBase[1], inQ.mChunkBase[2], inQ.mChunkBase[3] );

        ArrayVector3 uv = qVec.crossProduct( inOutVec );
        ArrayVector3 uuv = qVec.crossProduct( uv );


        ArrayReal w2 = _mm_add_ps( inQ.mChunkBase[0], inQ.mChunkBase[0] );
        uv.mChunkBase[0] = _mm_mul_ps( uv.mChunkBase[0], w2 );
        uv.mChunkBase[1] = _mm_mul_ps( uv.mChunkBase[1], w2 );
        uv.mChunkBase[2] = _mm_mul_ps( uv.mChunkBase[2], w2 );


        uuv.mChunkBase[0] = _mm_add_ps( uuv.mChunkBase[0], uuv.mChunkBase[0] );
        uuv.mChunkBase[1] = _mm_add_ps( uuv.mChunkBase[1], uuv.mChunkBase[1] );
        uuv.mChunkBase[2] = _mm_add_ps( uuv.mChunkBase[2], uuv.mChunkBase[2] );


        inOutVec.mChunkBase[0] = _mm_add_ps( inOutVec.mChunkBase[0],
                                    _mm_add_ps( uv.mChunkBase[0], uuv.mChunkBase[0] ) );
        inOutVec.mChunkBase[1] = _mm_add_ps( inOutVec.mChunkBase[1],
                                    _mm_add_ps( uv.mChunkBase[1], uuv.mChunkBase[1] ) );
        inOutVec.mChunkBase[2] = _mm_add_ps( inOutVec.mChunkBase[2],
                                    _mm_add_ps( uv.mChunkBase[2], uuv.mChunkBase[2] ) );
    }

    inline void ArrayQuaternion::FromOrthoDet1RotationMatrix( const ArrayReal * __restrict__ matrix )
    {
        ArrayReal m00 = matrix[0], m01 = matrix[1], m02 = matrix[2],
                  m10 = matrix[3], m11 = matrix[4], m12 = matrix[5],
                  m20 = matrix[6], m21 = matrix[7], m22 = matrix[8];
        ArrayReal tmp;


        tmp = _mm_max_ps( _mm_setzero_ps(),
                          _mm_add_ps( _mm_add_ps( MathlibSSE2::ONE, m00 ), _mm_add_ps( m11, m22 ) ) );
        mChunkBase[0] = _mm_mul_ps( _mm_sqrt_ps( tmp ), MathlibSSE2::HALF );


        tmp = _mm_max_ps( _mm_setzero_ps(),
                          _mm_sub_ps( _mm_add_ps( MathlibSSE2::ONE, m00 ), _mm_add_ps( m11, m22 ) ) );
        mChunkBase[1] = _mm_mul_ps( _mm_sqrt_ps( tmp ), MathlibSSE2::HALF );


        tmp = _mm_max_ps( _mm_setzero_ps(),
                          _mm_add_ps( _mm_sub_ps( MathlibSSE2::ONE, m00 ), _mm_sub_ps( m11, m22 ) ) );
        mChunkBase[2] = _mm_mul_ps( _mm_sqrt_ps( tmp ), MathlibSSE2::HALF );


        tmp = _mm_max_ps( _mm_setzero_ps(),
                          _mm_sub_ps( _mm_sub_ps( MathlibSSE2::ONE, m00 ), _mm_sub_ps( m11, m22 ) ) );
        mChunkBase[3] = _mm_mul_ps( _mm_sqrt_ps( tmp ), MathlibSSE2::HALF );




        tmp = _mm_and_ps( _mm_sub_ps( m21, m12 ), MathlibSSE2::SIGN_MASK );
        mChunkBase[1] = _mm_or_ps( _mm_andnot_ps( MathlibSSE2::SIGN_MASK, mChunkBase[1] ), tmp );
        tmp = _mm_and_ps( _mm_sub_ps( m02, m20 ), MathlibSSE2::SIGN_MASK );
        mChunkBase[2] = _mm_or_ps( _mm_andnot_ps( MathlibSSE2::SIGN_MASK, mChunkBase[2] ), tmp );
        tmp = _mm_and_ps( _mm_sub_ps( m10, m01 ), MathlibSSE2::SIGN_MASK );
        mChunkBase[3] = _mm_or_ps( _mm_andnot_ps( MathlibSSE2::SIGN_MASK, mChunkBase[3] ), tmp );
    }

    inline void ArrayQuaternion::FromAngleAxis( const ArrayRadian& rfAngle, const ArrayVector3& rkAxis )
    {





        ArrayReal fHalfAngle( _mm_mul_ps( rfAngle.valueRadians(), MathlibSSE2::HALF ) );

        ArrayReal fSin;
        MathlibSSE2::SinCos4( fHalfAngle, fSin, mChunkBase[0] );

        ArrayReal * __restrict__ chunkBase = mChunkBase;
        const ArrayReal * __restrict__ rkAxisChunkBase = rkAxis.mChunkBase;

        chunkBase[1] = _mm_mul_ps( fSin, rkAxisChunkBase[0] );
        chunkBase[2] = _mm_mul_ps( fSin, rkAxisChunkBase[1] );
        chunkBase[3] = _mm_mul_ps( fSin, rkAxisChunkBase[2] );
    }

    inline void ArrayQuaternion::ToAngleAxis( ArrayRadian &rfAngle, ArrayVector3 &rkAxis ) const
    {


        ArrayReal sqLength = _mm_add_ps( _mm_add_ps(
                                _mm_mul_ps( mChunkBase[1], mChunkBase[1] ),
                                _mm_mul_ps( mChunkBase[2], mChunkBase[2] ) ),
                                _mm_mul_ps( mChunkBase[3], mChunkBase[3] ) );

        ArrayReal mask = _mm_cmpgt_ps( sqLength, _mm_setzero_ps() );



        sqLength = MathlibSSE2::Cmov4( sqLength, MathlibSSE2::ONE,
                                        _mm_cmpgt_ps( sqLength, MathlibSSE2::FLOAT_MIN ) );
        ArrayReal fInvLength = MathlibSSE2::InvSqrtNonZero4( sqLength );

        const ArrayReal acosW = MathlibSSE2::ACos4( mChunkBase[0] );
        rfAngle = MathlibSSE2::Cmov4(
                    _mm_add_ps( acosW, acosW ),
                    _mm_setzero_ps(), mask );

        rkAxis.mChunkBase[0] = MathlibSSE2::Cmov4(
                                    _mm_mul_ps( mChunkBase[1], fInvLength ), MathlibSSE2::ONE, mask );
        rkAxis.mChunkBase[1] = MathlibSSE2::Cmov4(
                                    _mm_mul_ps( mChunkBase[2], fInvLength ), _mm_setzero_ps(), mask );
        rkAxis.mChunkBase[2] = MathlibSSE2::Cmov4(
                                    _mm_mul_ps( mChunkBase[3], fInvLength ), _mm_setzero_ps(), mask );
    }

    inline ArrayVector3 ArrayQuaternion::xAxis( void ) const
    {
        ArrayReal fTy = _mm_add_ps( mChunkBase[2], mChunkBase[2] );
        ArrayReal fTz = _mm_add_ps( mChunkBase[3], mChunkBase[3] );
        ArrayReal fTwy = _mm_mul_ps( fTy, mChunkBase[0] );
        ArrayReal fTwz = _mm_mul_ps( fTz, mChunkBase[0] );
        ArrayReal fTxy = _mm_mul_ps( fTy, mChunkBase[1] );
        ArrayReal fTxz = _mm_mul_ps( fTz, mChunkBase[1] );
        ArrayReal fTyy = _mm_mul_ps( fTy, mChunkBase[2] );
        ArrayReal fTzz = _mm_mul_ps( fTz, mChunkBase[3] );

        return ArrayVector3(
                _mm_sub_ps( MathlibSSE2::ONE, _mm_add_ps( fTyy, fTzz ) ),
                _mm_add_ps( fTxy, fTwz ),
                _mm_sub_ps( fTxz, fTwy ) );
    }

    inline ArrayVector3 ArrayQuaternion::yAxis( void ) const
    {
        ArrayReal fTx = _mm_add_ps( mChunkBase[1], mChunkBase[1] );
        ArrayReal fTy = _mm_add_ps( mChunkBase[2], mChunkBase[2] );
        ArrayReal fTz = _mm_add_ps( mChunkBase[3], mChunkBase[3] );
        ArrayReal fTwx = _mm_mul_ps( fTx, mChunkBase[0] );
        ArrayReal fTwz = _mm_mul_ps( fTz, mChunkBase[0] );
        ArrayReal fTxx = _mm_mul_ps( fTx, mChunkBase[1] );
        ArrayReal fTxy = _mm_mul_ps( fTy, mChunkBase[1] );
        ArrayReal fTyz = _mm_mul_ps( fTz, mChunkBase[2] );
        ArrayReal fTzz = _mm_mul_ps( fTz, mChunkBase[3] );

        return ArrayVector3(
                _mm_sub_ps( fTxy, fTwz ),
                _mm_sub_ps( MathlibSSE2::ONE, _mm_add_ps( fTxx, fTzz ) ),
                _mm_add_ps( fTyz, fTwx ) );
    }

    inline ArrayVector3 ArrayQuaternion::zAxis( void ) const
    {
        ArrayReal fTx = _mm_add_ps( mChunkBase[1], mChunkBase[1] );
        ArrayReal fTy = _mm_add_ps( mChunkBase[2], mChunkBase[2] );
        ArrayReal fTz = _mm_add_ps( mChunkBase[3], mChunkBase[3] );
        ArrayReal fTwx = _mm_mul_ps( fTx, mChunkBase[0] );
        ArrayReal fTwy = _mm_mul_ps( fTy, mChunkBase[0] );
        ArrayReal fTxx = _mm_mul_ps( fTx, mChunkBase[1] );
        ArrayReal fTxz = _mm_mul_ps( fTz, mChunkBase[1] );
        ArrayReal fTyy = _mm_mul_ps( fTy, mChunkBase[2] );
        ArrayReal fTyz = _mm_mul_ps( fTz, mChunkBase[2] );

        return ArrayVector3(
                _mm_add_ps( fTxz, fTwy ),
                _mm_sub_ps( fTyz, fTwx ),
                _mm_sub_ps( MathlibSSE2::ONE, _mm_add_ps( fTxx, fTyy ) ) );
    }

    inline ArrayReal ArrayQuaternion::Dot( const ArrayQuaternion& rkQ ) const
    {
        return
        _mm_add_ps( _mm_add_ps( _mm_add_ps(
            _mm_mul_ps( mChunkBase[0], rkQ.mChunkBase[0] ) ,
            _mm_mul_ps( mChunkBase[1], rkQ.mChunkBase[1] ) ),
            _mm_mul_ps( mChunkBase[2], rkQ.mChunkBase[2] ) ),
            _mm_mul_ps( mChunkBase[3], rkQ.mChunkBase[3] ) );
    }

    inline ArrayReal ArrayQuaternion::Norm( void ) const
    {
        return
        _mm_add_ps( _mm_add_ps( _mm_add_ps(
            _mm_mul_ps( mChunkBase[0], mChunkBase[0] ) ,
            _mm_mul_ps( mChunkBase[1], mChunkBase[1] ) ),
            _mm_mul_ps( mChunkBase[2], mChunkBase[2] ) ),
            _mm_mul_ps( mChunkBase[3], mChunkBase[3] ) );
    }

    inline void ArrayQuaternion::normalise( void )
    {
        ArrayReal sqLength = _mm_add_ps( _mm_add_ps( _mm_add_ps(
            _mm_mul_ps( mChunkBase[0], mChunkBase[0] ) ,
            _mm_mul_ps( mChunkBase[1], mChunkBase[1] ) ),
            _mm_mul_ps( mChunkBase[2], mChunkBase[2] ) ),
            _mm_mul_ps( mChunkBase[3], mChunkBase[3] ) );





        sqLength = MathlibSSE2::Cmov4( sqLength, MathlibSSE2::ONE,
                                        _mm_cmpgt_ps( sqLength, MathlibSSE2::FLOAT_MIN ) );
        ArrayReal invLength = MathlibSSE2::InvSqrtNonZero4( sqLength );
        mChunkBase[0] = _mm_mul_ps( mChunkBase[0], invLength );
        mChunkBase[1] = _mm_mul_ps( mChunkBase[1], invLength );
        mChunkBase[2] = _mm_mul_ps( mChunkBase[2], invLength );
        mChunkBase[3] = _mm_mul_ps( mChunkBase[3], invLength );
    }

    inline ArrayQuaternion ArrayQuaternion::Inverse( void ) const
    {
        ArrayReal fNorm = _mm_add_ps( _mm_add_ps( _mm_add_ps(
            _mm_mul_ps( mChunkBase[0], mChunkBase[0] ) ,
            _mm_mul_ps( mChunkBase[1], mChunkBase[1] ) ),
            _mm_mul_ps( mChunkBase[2], mChunkBase[2] ) ),
            _mm_mul_ps( mChunkBase[3], mChunkBase[3] ) );


        fNorm = MathlibSSE2::Cmov4( fNorm, MathlibSSE2::ONE,
                                    _mm_cmpgt_ps( fNorm, MathlibSSE2::fEpsilon ) );
        ArrayReal invNorm = MathlibSSE2::Inv4( fNorm );
        ArrayReal negInvNorm = _mm_mul_ps( invNorm, MathlibSSE2::NEG_ONE );

        return ArrayQuaternion(
            _mm_mul_ps( mChunkBase[0], invNorm ),
            _mm_mul_ps( mChunkBase[1], negInvNorm ),
            _mm_mul_ps( mChunkBase[2], negInvNorm ),
            _mm_mul_ps( mChunkBase[3], negInvNorm ) );
    }

    inline ArrayQuaternion ArrayQuaternion::UnitInverse( void ) const
    {
        return ArrayQuaternion(
            mChunkBase[0],
            _mm_mul_ps( mChunkBase[1], MathlibSSE2::NEG_ONE ),
            _mm_mul_ps( mChunkBase[2], MathlibSSE2::NEG_ONE ),
            _mm_mul_ps( mChunkBase[3], MathlibSSE2::NEG_ONE ) );
    }

    inline ArrayQuaternion ArrayQuaternion::Exp( void ) const
    {




        ArrayReal fAngle = _mm_sqrt_ps( _mm_add_ps( _mm_add_ps(
                                _mm_mul_ps( mChunkBase[1], mChunkBase[1] ),
                                _mm_mul_ps( mChunkBase[2], mChunkBase[2] ) ),
                                _mm_mul_ps( mChunkBase[3], mChunkBase[3] ) ) );

        ArrayReal w, fSin;
        MathlibSSE2::SinCos4( fAngle, fSin, w );


        ArrayReal coeff = MathlibSSE2::CmovRobust( _mm_div_ps( fSin, fAngle ), MathlibSSE2::ONE,
                                _mm_cmpge_ps( MathlibSSE2::Abs4( fSin ), MathlibSSE2::fEpsilon ) );
        return ArrayQuaternion(
            w,
            _mm_mul_ps( mChunkBase[1], coeff ),
            _mm_mul_ps( mChunkBase[2], coeff ),
            _mm_mul_ps( mChunkBase[3], coeff ) );
    }

    inline ArrayQuaternion ArrayQuaternion::Log( void ) const
    {




        ArrayReal fAngle = MathlibSSE2::ACos4( mChunkBase[0] );
        ArrayReal fSin = MathlibSSE2::Sin4( fAngle );


        ArrayReal mask = _mm_and_ps(
                            _mm_cmplt_ps( MathlibSSE2::Abs4( mChunkBase[0] ), MathlibSSE2::ONE ),
                            _mm_cmpge_ps( MathlibSSE2::Abs4( fSin ), MathlibSSE2::fEpsilon ) );





        ArrayReal coeff = MathlibSSE2::CmovRobust( _mm_mul_ps( fAngle, MathlibSSE2::InvNonZero4( fSin ) ),
                                                    MathlibSSE2::ONE, mask );

        return ArrayQuaternion(
            _mm_setzero_ps(),
            _mm_mul_ps( mChunkBase[1], coeff ),
            _mm_mul_ps( mChunkBase[2], coeff ),
            _mm_mul_ps( mChunkBase[3], coeff ) );
    }

    inline ArrayVector3 ArrayQuaternion::operator * ( const ArrayVector3 &v ) const
    {

        ArrayVector3 qVec( mChunkBase[1], mChunkBase[2], mChunkBase[3] );

        ArrayVector3 uv = qVec.crossProduct( v );
        ArrayVector3 uuv = qVec.crossProduct( uv );


        ArrayReal w2 = _mm_add_ps( mChunkBase[0], mChunkBase[0] );
        uv.mChunkBase[0] = _mm_mul_ps( uv.mChunkBase[0], w2 );
        uv.mChunkBase[1] = _mm_mul_ps( uv.mChunkBase[1], w2 );
        uv.mChunkBase[2] = _mm_mul_ps( uv.mChunkBase[2], w2 );


        uuv.mChunkBase[0] = _mm_add_ps( uuv.mChunkBase[0], uuv.mChunkBase[0] );
        uuv.mChunkBase[1] = _mm_add_ps( uuv.mChunkBase[1], uuv.mChunkBase[1] );
        uuv.mChunkBase[2] = _mm_add_ps( uuv.mChunkBase[2], uuv.mChunkBase[2] );


        uv.mChunkBase[0] = _mm_add_ps( v.mChunkBase[0],
                                _mm_add_ps( uv.mChunkBase[0], uuv.mChunkBase[0] ) );
        uv.mChunkBase[1] = _mm_add_ps( v.mChunkBase[1],
                                _mm_add_ps( uv.mChunkBase[1], uuv.mChunkBase[1] ) );
        uv.mChunkBase[2] = _mm_add_ps( v.mChunkBase[2],
                                _mm_add_ps( uv.mChunkBase[2], uuv.mChunkBase[2] ) );

        return uv;
    }

    inline void ArrayQuaternion::Cmov4( ArrayMaskR mask, const ArrayQuaternion &replacement )
    {
        ArrayReal * __restrict__ aChunkBase = mChunkBase;
        const ArrayReal * __restrict__ bChunkBase = replacement.mChunkBase;
        aChunkBase[0] = MathlibSSE2::Cmov4( aChunkBase[0], bChunkBase[0], mask );
        aChunkBase[1] = MathlibSSE2::Cmov4( aChunkBase[1], bChunkBase[1], mask );
        aChunkBase[2] = MathlibSSE2::Cmov4( aChunkBase[2], bChunkBase[2], mask );
        aChunkBase[3] = MathlibSSE2::Cmov4( aChunkBase[3], bChunkBase[3], mask );
    }
}

namespace Ogre
{
    class SimpleMatrix4;
    class ArrayMatrix4
    {
    public:
        ArrayReal mChunkBase[16];

        ArrayMatrix4() {}
        ArrayMatrix4( const ArrayMatrix4 &copy )
        {




            for( size_t i=0; i<16; i+=4 )
            {
                mChunkBase[i ] = copy.mChunkBase[i ];
                mChunkBase[i+1] = copy.mChunkBase[i+1];
                mChunkBase[i+2] = copy.mChunkBase[i+2];
                mChunkBase[i+3] = copy.mChunkBase[i+3];
            }
        }

        void getAsMatrix4( Matrix4 &out, size_t index ) const
        {

            const Real * __restrict__ aliasedReal = reinterpret_cast<const Real*>( mChunkBase );
            Real * __restrict__ matrix = reinterpret_cast<Real*>( out._m );
            for( size_t i=0; i<16; i+=4 )
            {
                matrix[i ] = aliasedReal[4 * (i ) + index];
                matrix[i+1] = aliasedReal[4 * (i+1) + index];
                matrix[i+2] = aliasedReal[4 * (i+2) + index];
                matrix[i+3] = aliasedReal[4 * (i+3) + index];
            }
        }



        Matrix4 getAsMatrix4( size_t index ) const
        {
            Matrix4 retVal;
            getAsMatrix4( retVal, index );

            return retVal;
        }

        void setFromMatrix4( const Matrix4 &m, size_t index )
        {
            Real * __restrict__ aliasedReal = reinterpret_cast<Real*>( mChunkBase );
            const Real * __restrict__ matrix = reinterpret_cast<const Real*>( m._m );
            for( size_t i=0; i<16; i+=4 )
            {
                aliasedReal[4 * (i ) + index] = matrix[i ];
                aliasedReal[4 * (i+1) + index] = matrix[i+1];
                aliasedReal[4 * (i+2) + index] = matrix[i+2];
                aliasedReal[4 * (i+3) + index] = matrix[i+3];
            }
        }


        void setAll( const Matrix4 &m )
        {
            mChunkBase[0] = _mm_set_ps1( m._m[0] );
            mChunkBase[1] = _mm_set_ps1( m._m[1] );
            mChunkBase[2] = _mm_set_ps1( m._m[2] );
            mChunkBase[3] = _mm_set_ps1( m._m[3] );
            mChunkBase[4] = _mm_set_ps1( m._m[4] );
            mChunkBase[5] = _mm_set_ps1( m._m[5] );
            mChunkBase[6] = _mm_set_ps1( m._m[6] );
            mChunkBase[7] = _mm_set_ps1( m._m[7] );
            mChunkBase[8] = _mm_set_ps1( m._m[8] );
            mChunkBase[9] = _mm_set_ps1( m._m[9] );
            mChunkBase[10] = _mm_set_ps1( m._m[10] );
            mChunkBase[11] = _mm_set_ps1( m._m[11] );
            mChunkBase[12] = _mm_set_ps1( m._m[12] );
            mChunkBase[13] = _mm_set_ps1( m._m[13] );
            mChunkBase[14] = _mm_set_ps1( m._m[14] );
            mChunkBase[15] = _mm_set_ps1( m._m[15] );
        }

        static ArrayMatrix4 createAllFromMatrix4( const Matrix4 &m )
        {
            ArrayMatrix4 retVal;
            retVal.setAll( m );
            return retVal;
        }






        inline ArrayMatrix4& operator = ( const ArrayMatrix4& rkMatrix )
        {
            for( size_t i=0; i<16; i+=4 )
            {
                mChunkBase[i ] = rkMatrix.mChunkBase[i ];
                mChunkBase[i+1] = rkMatrix.mChunkBase[i+1];
                mChunkBase[i+2] = rkMatrix.mChunkBase[i+2];
                mChunkBase[i+3] = rkMatrix.mChunkBase[i+3];
            }
            return *this;
        }


        inline friend ArrayMatrix4 operator * ( const ArrayMatrix4 &lhs, const ArrayMatrix4 &rhs );

        inline ArrayVector3 operator * ( const ArrayVector3 &rhs ) const;



        inline void operator *= ( const ArrayMatrix4 &rhs );
        inline void fromQuaternion( const ArrayQuaternion &q );


        inline void makeTransform( const ArrayVector3 &position, const ArrayVector3 &scale,
                                    const ArrayQuaternion &orientation );





        inline void storeToAoS( Matrix4 * __restrict__ dst ) const;





        inline void loadFromAoS( const Matrix4 * __restrict__ src );
        inline void loadFromAoS( const SimpleMatrix4 * __restrict__ src );


        inline bool isAffine() const;

        static const ArrayMatrix4 IDENTITY;
    };





    class SimpleMatrix4
    {
    public:
        ArrayReal mChunkBase[4];


        void load( const Matrix4 &src )
        {
            mChunkBase[0] = _mm_load_ps( src._m );
            mChunkBase[1] = _mm_load_ps( src._m+4 );
            mChunkBase[2] = _mm_load_ps( src._m+8 );
            mChunkBase[3] = _mm_load_ps( src._m+12 );
        }
    };




}


namespace Ogre
{
    inline void concatArrayMat4 ( ArrayReal * __restrict__ outChunkBase,
                                    const ArrayReal * __restrict__ lhsChunkBase,
                                    const ArrayReal * __restrict__ rhsChunkBase )
    {

        assert( outChunkBase != lhsChunkBase && outChunkBase != rhsChunkBase &&
                lhsChunkBase != rhsChunkBase &&
                "Re-strict aliasing rule broken. Compile without OGRE_RESTRICT_ALIASING" );

        outChunkBase[0] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[0], rhsChunkBase[0] ),
                _mm_mul_ps( lhsChunkBase[1], rhsChunkBase[4] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[2], rhsChunkBase[8] ),
                _mm_mul_ps( lhsChunkBase[3], rhsChunkBase[12] ) ) );
        outChunkBase[1] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[0], rhsChunkBase[1] ),
                _mm_mul_ps( lhsChunkBase[1], rhsChunkBase[5] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[2], rhsChunkBase[9] ),
                _mm_mul_ps( lhsChunkBase[3], rhsChunkBase[13] ) ) );
        outChunkBase[2] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[0], rhsChunkBase[2] ),
                _mm_mul_ps( lhsChunkBase[1], rhsChunkBase[6] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[2], rhsChunkBase[10] ),
                _mm_mul_ps( lhsChunkBase[3], rhsChunkBase[14] ) ) );
        outChunkBase[3] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[0], rhsChunkBase[3] ),
                _mm_mul_ps( lhsChunkBase[1], rhsChunkBase[7] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[2], rhsChunkBase[11] ),
                _mm_mul_ps( lhsChunkBase[3], rhsChunkBase[15] ) ) );


        outChunkBase[4] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[4], rhsChunkBase[0] ),
                _mm_mul_ps( lhsChunkBase[5], rhsChunkBase[4] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[6], rhsChunkBase[8] ),
                _mm_mul_ps( lhsChunkBase[7], rhsChunkBase[12] ) ) );
        outChunkBase[5] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[4], rhsChunkBase[1] ),
                _mm_mul_ps( lhsChunkBase[5], rhsChunkBase[5] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[6], rhsChunkBase[9] ),
                _mm_mul_ps( lhsChunkBase[7], rhsChunkBase[13] ) ) );
        outChunkBase[6] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[4], rhsChunkBase[2] ),
                _mm_mul_ps( lhsChunkBase[5], rhsChunkBase[6] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[6], rhsChunkBase[10] ),
                _mm_mul_ps( lhsChunkBase[7], rhsChunkBase[14] ) ) );
        outChunkBase[7] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[4], rhsChunkBase[3] ),
                _mm_mul_ps( lhsChunkBase[5], rhsChunkBase[7] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[6], rhsChunkBase[11] ),
                _mm_mul_ps( lhsChunkBase[7], rhsChunkBase[15] ) ) );


        outChunkBase[8] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[8], rhsChunkBase[0] ),
                _mm_mul_ps( lhsChunkBase[9], rhsChunkBase[4] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[10], rhsChunkBase[8] ),
                _mm_mul_ps( lhsChunkBase[11], rhsChunkBase[12] ) ) );
        outChunkBase[9] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[8], rhsChunkBase[1] ),
                _mm_mul_ps( lhsChunkBase[9], rhsChunkBase[5] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[10], rhsChunkBase[9] ),
                _mm_mul_ps( lhsChunkBase[11], rhsChunkBase[13] ) ) );
        outChunkBase[10] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[8], rhsChunkBase[2] ),
                _mm_mul_ps( lhsChunkBase[9], rhsChunkBase[6] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[10], rhsChunkBase[10] ),
                _mm_mul_ps( lhsChunkBase[11], rhsChunkBase[14] ) ) );
        outChunkBase[11] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[8], rhsChunkBase[3] ),
                _mm_mul_ps( lhsChunkBase[9], rhsChunkBase[7] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[10], rhsChunkBase[11] ),
                _mm_mul_ps( lhsChunkBase[11], rhsChunkBase[15] ) ) );


        outChunkBase[12] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[12], rhsChunkBase[0] ),
                _mm_mul_ps( lhsChunkBase[13], rhsChunkBase[4] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[14], rhsChunkBase[8] ),
                _mm_mul_ps( lhsChunkBase[15], rhsChunkBase[12] ) ) );
        outChunkBase[13] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[12], rhsChunkBase[1] ),
                _mm_mul_ps( lhsChunkBase[13], rhsChunkBase[5] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[14], rhsChunkBase[9] ),
                _mm_mul_ps( lhsChunkBase[15], rhsChunkBase[13] ) ) );
        outChunkBase[14] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[12], rhsChunkBase[2] ),
                _mm_mul_ps( lhsChunkBase[13], rhsChunkBase[6] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[14], rhsChunkBase[10] ),
                _mm_mul_ps( lhsChunkBase[15], rhsChunkBase[14] ) ) );
        outChunkBase[15] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[12], rhsChunkBase[3] ),
                _mm_mul_ps( lhsChunkBase[13], rhsChunkBase[7] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[14], rhsChunkBase[11] ),
                _mm_mul_ps( lhsChunkBase[15], rhsChunkBase[15] ) ) );
    }


    inline void concatArrayMat4 ( ArrayReal * __restrict__ lhsChunkBase,
                                    const ArrayReal * __restrict__ rhsChunkBase )
    {

        assert( lhsChunkBase != rhsChunkBase &&
                "Re-strict aliasing rule broken. Compile without OGRE_RESTRICT_ALIASING" );

        ArrayReal lhs0 = lhsChunkBase[0];
        lhsChunkBase[0] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[0], rhsChunkBase[0] ),
                _mm_mul_ps( lhsChunkBase[1], rhsChunkBase[4] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[2], rhsChunkBase[8] ),
                _mm_mul_ps( lhsChunkBase[3], rhsChunkBase[12] ) ) );
        ArrayReal lhs1 = lhsChunkBase[1];
        lhsChunkBase[1] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhs0, rhsChunkBase[1] ),
                _mm_mul_ps( lhsChunkBase[1], rhsChunkBase[5] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[2], rhsChunkBase[9] ),
                _mm_mul_ps( lhsChunkBase[3], rhsChunkBase[13] ) ) );
        ArrayReal lhs2 = lhsChunkBase[2];
        lhsChunkBase[2] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhs0, rhsChunkBase[2] ),
                _mm_mul_ps( lhs1, rhsChunkBase[6] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[2], rhsChunkBase[10] ),
                _mm_mul_ps( lhsChunkBase[3], rhsChunkBase[14] ) ) );
        lhsChunkBase[3] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhs0, rhsChunkBase[3] ),
                _mm_mul_ps( lhs1, rhsChunkBase[7] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhs2, rhsChunkBase[11] ),
                _mm_mul_ps( lhsChunkBase[3], rhsChunkBase[15] ) ) );


        lhs0 = lhsChunkBase[4];
        lhsChunkBase[4] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[4], rhsChunkBase[0] ),
                _mm_mul_ps( lhsChunkBase[5], rhsChunkBase[4] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[6], rhsChunkBase[8] ),
                _mm_mul_ps( lhsChunkBase[7], rhsChunkBase[12] ) ) );
        lhs1 = lhsChunkBase[5];
        lhsChunkBase[5] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhs0, rhsChunkBase[1] ),
                _mm_mul_ps( lhsChunkBase[5], rhsChunkBase[5] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[6], rhsChunkBase[9] ),
                _mm_mul_ps( lhsChunkBase[7], rhsChunkBase[13] ) ) );
        lhs2 = lhsChunkBase[6];
        lhsChunkBase[6] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhs0, rhsChunkBase[2] ),
                _mm_mul_ps( lhs1, rhsChunkBase[6] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[6], rhsChunkBase[10] ),
                _mm_mul_ps( lhsChunkBase[7], rhsChunkBase[14] ) ) );
        lhsChunkBase[7] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhs0, rhsChunkBase[3] ),
                _mm_mul_ps( lhs1, rhsChunkBase[7] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhs2, rhsChunkBase[11] ),
                _mm_mul_ps( lhsChunkBase[7], rhsChunkBase[15] ) ) );


        lhs0 = lhsChunkBase[8];
        lhsChunkBase[8] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[8], rhsChunkBase[0] ),
                _mm_mul_ps( lhsChunkBase[9], rhsChunkBase[4] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[10], rhsChunkBase[8] ),
                _mm_mul_ps( lhsChunkBase[11], rhsChunkBase[12] ) ) );
        lhs1 = lhsChunkBase[9];
        lhsChunkBase[9] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhs0, rhsChunkBase[1] ),
                _mm_mul_ps( lhsChunkBase[9], rhsChunkBase[5] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[10], rhsChunkBase[9] ),
                _mm_mul_ps( lhsChunkBase[11], rhsChunkBase[13] ) ) );
        lhs2 = lhsChunkBase[10];
        lhsChunkBase[10] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhs0, rhsChunkBase[2] ),
                _mm_mul_ps( lhs1, rhsChunkBase[6] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[10], rhsChunkBase[10] ),
                _mm_mul_ps( lhsChunkBase[11], rhsChunkBase[14] ) ) );
        lhsChunkBase[11] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhs0, rhsChunkBase[3] ),
                _mm_mul_ps( lhs1, rhsChunkBase[7] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhs2, rhsChunkBase[11] ),
                _mm_mul_ps( lhsChunkBase[11], rhsChunkBase[15] ) ) );


        lhs0 = lhsChunkBase[12];
        lhsChunkBase[12] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[12], rhsChunkBase[0] ),
                _mm_mul_ps( lhsChunkBase[13], rhsChunkBase[4] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[14], rhsChunkBase[8] ),
                _mm_mul_ps( lhsChunkBase[15], rhsChunkBase[12] ) ) );
        lhs1 = lhsChunkBase[13];
        lhsChunkBase[13] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhs0, rhsChunkBase[1] ),
                _mm_mul_ps( lhsChunkBase[13], rhsChunkBase[5] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[14], rhsChunkBase[9] ),
                _mm_mul_ps( lhsChunkBase[15], rhsChunkBase[13] ) ) );
        lhs2 = lhsChunkBase[14];
        lhsChunkBase[14] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhs0, rhsChunkBase[2] ),
                _mm_mul_ps( lhs1, rhsChunkBase[6] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhsChunkBase[14], rhsChunkBase[10] ),
                _mm_mul_ps( lhsChunkBase[15], rhsChunkBase[14] ) ) );
        lhsChunkBase[15] =
            _mm_add_ps(
            _mm_add_ps(
                _mm_mul_ps( lhs0, rhsChunkBase[3] ),
                _mm_mul_ps( lhs1, rhsChunkBase[7] ) ),
            _mm_add_ps(
                _mm_mul_ps( lhs2, rhsChunkBase[11] ),
                _mm_mul_ps( lhsChunkBase[15], rhsChunkBase[15] ) ) );
    }

    inline ArrayMatrix4 operator * ( const ArrayMatrix4 &lhs, const ArrayMatrix4 &rhs )
    {
        ArrayMatrix4 retVal;
        concatArrayMat4( retVal.mChunkBase, lhs.mChunkBase, rhs.mChunkBase );
        return retVal;
    }

    inline ArrayVector3 ArrayMatrix4::operator * ( const ArrayVector3 &rhs ) const
    {
        ArrayReal invW = _mm_add_ps( _mm_add_ps(
                                _mm_mul_ps( mChunkBase[12], rhs.mChunkBase[0] ),
                                _mm_mul_ps( mChunkBase[13], rhs.mChunkBase[1] ) ),
                            _mm_add_ps(
                                _mm_mul_ps( mChunkBase[14], rhs.mChunkBase[2] ),
                                mChunkBase[15] ) );
        invW = MathlibSSE2::Inv4( invW );

        return ArrayVector3(

            _mm_mul_ps(
            _mm_add_ps( _mm_add_ps(
                _mm_mul_ps( mChunkBase[0], rhs.mChunkBase[0] ),
                _mm_mul_ps( mChunkBase[1], rhs.mChunkBase[1] ) ),
            _mm_add_ps(
                _mm_mul_ps( mChunkBase[2], rhs.mChunkBase[2] ),
                mChunkBase[3] ) ) , invW ),

            _mm_mul_ps(
            _mm_add_ps( _mm_add_ps(
                _mm_mul_ps( mChunkBase[4], rhs.mChunkBase[0] ),
                _mm_mul_ps( mChunkBase[5], rhs.mChunkBase[1] ) ),
            _mm_add_ps(
                _mm_mul_ps( mChunkBase[6], rhs.mChunkBase[2] ),
                mChunkBase[7] ) ), invW ),

            _mm_mul_ps(
            _mm_add_ps( _mm_add_ps(
                _mm_mul_ps( mChunkBase[8], rhs.mChunkBase[0] ),
                _mm_mul_ps( mChunkBase[9], rhs.mChunkBase[1] ) ),
            _mm_add_ps(
                _mm_mul_ps( mChunkBase[10], rhs.mChunkBase[2] ),
                mChunkBase[11] ) ), invW ) );
    }

    inline void ArrayMatrix4::operator *= ( const ArrayMatrix4 &rhs )
    {
        concatArrayMat4( mChunkBase, rhs.mChunkBase );
    }

    inline void ArrayMatrix4::fromQuaternion( const ArrayQuaternion &q )
    {
        ArrayReal * __restrict__ chunkBase = mChunkBase;
        const ArrayReal * __restrict__ qChunkBase = q.mChunkBase;
        ArrayReal fTx = _mm_add_ps( qChunkBase[1], qChunkBase[1] );
        ArrayReal fTy = _mm_add_ps( qChunkBase[2], qChunkBase[2] );
        ArrayReal fTz = _mm_add_ps( qChunkBase[3], qChunkBase[3] );
        ArrayReal fTwx = _mm_mul_ps( fTx, qChunkBase[0] );
        ArrayReal fTwy = _mm_mul_ps( fTy, qChunkBase[0] );
        ArrayReal fTwz = _mm_mul_ps( fTz, qChunkBase[0] );
        ArrayReal fTxx = _mm_mul_ps( fTx, qChunkBase[1] );
        ArrayReal fTxy = _mm_mul_ps( fTy, qChunkBase[1] );
        ArrayReal fTxz = _mm_mul_ps( fTz, qChunkBase[1] );
        ArrayReal fTyy = _mm_mul_ps( fTy, qChunkBase[2] );
        ArrayReal fTyz = _mm_mul_ps( fTz, qChunkBase[2] );
        ArrayReal fTzz = _mm_mul_ps( fTz, qChunkBase[3] );

        chunkBase[0] = _mm_sub_ps( MathlibSSE2::ONE, _mm_add_ps( fTyy, fTzz ) );
        chunkBase[1] = _mm_sub_ps( fTxy, fTwz );
        chunkBase[2] = _mm_add_ps( fTxz, fTwy );
        chunkBase[4] = _mm_add_ps( fTxy, fTwz );
        chunkBase[5] = _mm_sub_ps( MathlibSSE2::ONE, _mm_add_ps( fTxx, fTzz ) );
        chunkBase[6] = _mm_sub_ps( fTyz, fTwx );
        chunkBase[8] = _mm_sub_ps( fTxz, fTwy );
        chunkBase[9] = _mm_add_ps( fTyz, fTwx );
        chunkBase[10]= _mm_sub_ps( MathlibSSE2::ONE, _mm_add_ps( fTxx, fTyy ) );
    }

    inline void ArrayMatrix4::makeTransform( const ArrayVector3 &position, const ArrayVector3 &scale,
                                             const ArrayQuaternion &orientation )
    {
        ArrayReal * __restrict__ chunkBase = mChunkBase;
        const ArrayReal * __restrict__ posChunkBase = position.mChunkBase;
        const ArrayReal * __restrict__ scaleChunkBase = scale.mChunkBase;
        this->fromQuaternion( orientation );
        chunkBase[0] = _mm_mul_ps( chunkBase[0], scaleChunkBase[0] );
        chunkBase[1] = _mm_mul_ps( chunkBase[1], scaleChunkBase[1] );
        chunkBase[2] = _mm_mul_ps( chunkBase[2], scaleChunkBase[2] );
        chunkBase[3] = posChunkBase[0];

        chunkBase[4] = _mm_mul_ps( chunkBase[4], scaleChunkBase[0] );
        chunkBase[5] = _mm_mul_ps( chunkBase[5], scaleChunkBase[1] );
        chunkBase[6] = _mm_mul_ps( chunkBase[6], scaleChunkBase[2] );
        chunkBase[7] = posChunkBase[1];

        chunkBase[8] = _mm_mul_ps( chunkBase[8], scaleChunkBase[0] );
        chunkBase[9] = _mm_mul_ps( chunkBase[9], scaleChunkBase[1] );
        chunkBase[10]= _mm_mul_ps( chunkBase[10],scaleChunkBase[2] );
        chunkBase[11]= posChunkBase[2];


        chunkBase[12] = mChunkBase[13] = mChunkBase[14] = _mm_setzero_ps();
        chunkBase[15] = MathlibSSE2::ONE;
    }

    inline bool ArrayMatrix4::isAffine() const
    {
        ArrayReal mask =
            _mm_and_ps(
                _mm_and_ps( _mm_cmpeq_ps( mChunkBase[12], _mm_setzero_ps() ),
                    _mm_cmpeq_ps( mChunkBase[13], _mm_setzero_ps() ) ),
                _mm_and_ps( _mm_cmpeq_ps( mChunkBase[14], _mm_setzero_ps() ),
                    _mm_cmpeq_ps( mChunkBase[15], MathlibSSE2::ONE ) ) );

        return _mm_movemask_ps( mask ) == 0x0f;
    }

    inline void ArrayMatrix4::storeToAoS( Matrix4 * __restrict__ dst ) const
    {
                 ArrayReal m0, m1, m2, m3;

        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((this->mChunkBase[0]), (this->mChunkBase[1]), 0x44); tmp2 = _mm_shuffle_ps((this->mChunkBase[0]), (this->mChunkBase[1]), 0xEE); tmp1 = _mm_shuffle_ps((this->mChunkBase[2]), (this->mChunkBase[3]), 0x44); tmp3 = _mm_shuffle_ps((this->mChunkBase[2]), (this->mChunkBase[3]), 0xEE); (m0) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (m1) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (m2) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (m3) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };



        _mm_stream_ps( dst[0]._m, m0 );
        _mm_stream_ps( dst[1]._m, m1 );
        _mm_stream_ps( dst[2]._m, m2 );
        _mm_stream_ps( dst[3]._m, m3 );
        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((this->mChunkBase[4]), (this->mChunkBase[5]), 0x44); tmp2 = _mm_shuffle_ps((this->mChunkBase[4]), (this->mChunkBase[5]), 0xEE); tmp1 = _mm_shuffle_ps((this->mChunkBase[6]), (this->mChunkBase[7]), 0x44); tmp3 = _mm_shuffle_ps((this->mChunkBase[6]), (this->mChunkBase[7]), 0xEE); (m0) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (m1) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (m2) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (m3) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };



        _mm_stream_ps( dst[0]._m+4, m0 );
        _mm_stream_ps( dst[1]._m+4, m1 );
        _mm_stream_ps( dst[2]._m+4, m2 );
        _mm_stream_ps( dst[3]._m+4, m3 );
        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((this->mChunkBase[8]), (this->mChunkBase[9]), 0x44); tmp2 = _mm_shuffle_ps((this->mChunkBase[8]), (this->mChunkBase[9]), 0xEE); tmp1 = _mm_shuffle_ps((this->mChunkBase[10]), (this->mChunkBase[11]), 0x44); tmp3 = _mm_shuffle_ps((this->mChunkBase[10]), (this->mChunkBase[11]), 0xEE); (m0) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (m1) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (m2) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (m3) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };



        _mm_stream_ps( dst[0]._m+8, m0 );
        _mm_stream_ps( dst[1]._m+8, m1 );
        _mm_stream_ps( dst[2]._m+8, m2 );
        _mm_stream_ps( dst[3]._m+8, m3 );
        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((this->mChunkBase[12]), (this->mChunkBase[13]), 0x44); tmp2 = _mm_shuffle_ps((this->mChunkBase[12]), (this->mChunkBase[13]), 0xEE); tmp1 = _mm_shuffle_ps((this->mChunkBase[14]), (this->mChunkBase[15]), 0x44); tmp3 = _mm_shuffle_ps((this->mChunkBase[14]), (this->mChunkBase[15]), 0xEE); (m0) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (m1) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (m2) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (m3) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };



        _mm_stream_ps( dst[0]._m+12, m0 );
        _mm_stream_ps( dst[1]._m+12, m1 );
        _mm_stream_ps( dst[2]._m+12, m2 );
        _mm_stream_ps( dst[3]._m+12, m3 );
    }

    inline void ArrayMatrix4::loadFromAoS( const Matrix4 * __restrict__ src )
    {
        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((_mm_load_ps( src[0]._m )), (_mm_load_ps( src[1]._m )), 0x44); tmp2 = _mm_shuffle_ps((_mm_load_ps( src[0]._m )), (_mm_load_ps( src[1]._m )), 0xEE); tmp1 = _mm_shuffle_ps((_mm_load_ps( src[2]._m )), (_mm_load_ps( src[3]._m )), 0x44); tmp3 = _mm_shuffle_ps((_mm_load_ps( src[2]._m )), (_mm_load_ps( src[3]._m )), 0xEE); (this->mChunkBase[0]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[1]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[2]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[3]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((_mm_load_ps( src[0]._m+4 )), (_mm_load_ps( src[1]._m+4 )), 0x44); tmp2 = _mm_shuffle_ps((_mm_load_ps( src[0]._m+4 )), (_mm_load_ps( src[1]._m+4 )), 0xEE); tmp1 = _mm_shuffle_ps((_mm_load_ps( src[2]._m+4 )), (_mm_load_ps( src[3]._m+4 )), 0x44); tmp3 = _mm_shuffle_ps((_mm_load_ps( src[2]._m+4 )), (_mm_load_ps( src[3]._m+4 )), 0xEE); (this->mChunkBase[4]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[5]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[6]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[7]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((_mm_load_ps( src[0]._m+8 )), (_mm_load_ps( src[1]._m+8 )), 0x44); tmp2 = _mm_shuffle_ps((_mm_load_ps( src[0]._m+8 )), (_mm_load_ps( src[1]._m+8 )), 0xEE); tmp1 = _mm_shuffle_ps((_mm_load_ps( src[2]._m+8 )), (_mm_load_ps( src[3]._m+8 )), 0x44); tmp3 = _mm_shuffle_ps((_mm_load_ps( src[2]._m+8 )), (_mm_load_ps( src[3]._m+8 )), 0xEE); (this->mChunkBase[8]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[9]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[10]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[11]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((_mm_load_ps( src[0]._m+12 )), (_mm_load_ps( src[1]._m+12 )), 0x44); tmp2 = _mm_shuffle_ps((_mm_load_ps( src[0]._m+12 )), (_mm_load_ps( src[1]._m+12 )), 0xEE); tmp1 = _mm_shuffle_ps((_mm_load_ps( src[2]._m+12 )), (_mm_load_ps( src[3]._m+12 )), 0x44); tmp3 = _mm_shuffle_ps((_mm_load_ps( src[2]._m+12 )), (_mm_load_ps( src[3]._m+12 )), 0xEE); (this->mChunkBase[12]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[13]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[14]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[15]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




    }

    inline void ArrayMatrix4::loadFromAoS( const SimpleMatrix4 * __restrict__ src )
    {
        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((src[0].mChunkBase[0]), (src[1].mChunkBase[0]), 0x44); tmp2 = _mm_shuffle_ps((src[0].mChunkBase[0]), (src[1].mChunkBase[0]), 0xEE); tmp1 = _mm_shuffle_ps((src[2].mChunkBase[0]), (src[3].mChunkBase[0]), 0x44); tmp3 = _mm_shuffle_ps((src[2].mChunkBase[0]), (src[3].mChunkBase[0]), 0xEE); (this->mChunkBase[0]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[1]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[2]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[3]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((src[0].mChunkBase[1]), (src[1].mChunkBase[1]), 0x44); tmp2 = _mm_shuffle_ps((src[0].mChunkBase[1]), (src[1].mChunkBase[1]), 0xEE); tmp1 = _mm_shuffle_ps((src[2].mChunkBase[1]), (src[3].mChunkBase[1]), 0x44); tmp3 = _mm_shuffle_ps((src[2].mChunkBase[1]), (src[3].mChunkBase[1]), 0xEE); (this->mChunkBase[4]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[5]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[6]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[7]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((src[0].mChunkBase[2]), (src[1].mChunkBase[2]), 0x44); tmp2 = _mm_shuffle_ps((src[0].mChunkBase[2]), (src[1].mChunkBase[2]), 0xEE); tmp1 = _mm_shuffle_ps((src[2].mChunkBase[2]), (src[3].mChunkBase[2]), 0x44); tmp3 = _mm_shuffle_ps((src[2].mChunkBase[2]), (src[3].mChunkBase[2]), 0xEE); (this->mChunkBase[8]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[9]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[10]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[11]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((src[0].mChunkBase[3]), (src[1].mChunkBase[3]), 0x44); tmp2 = _mm_shuffle_ps((src[0].mChunkBase[3]), (src[1].mChunkBase[3]), 0xEE); tmp1 = _mm_shuffle_ps((src[2].mChunkBase[3]), (src[3].mChunkBase[3]), 0x44); tmp3 = _mm_shuffle_ps((src[2].mChunkBase[3]), (src[3].mChunkBase[3]), 0xEE); (this->mChunkBase[12]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[13]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[14]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[15]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




    }

}
namespace Ogre
{
    typedef vector<char*>::type MemoryPoolVec;
    typedef void (*CleanupRoutines)( char *dstPtr, size_t indexDst, char *srcPtr, size_t indexSrc,
                                     size_t numSlots, size_t numFreeSlots, size_t elementsMemSize );
    class ArrayMemoryManager
    {
    public:
        enum ManagerType
        {
            NodeType,
            ObjectDataType,
            BoneType,



            UserDefinedType0,
            UserDefinedType1,
            UserDefinedType2,
            UserDefinedType3,
            UserDefinedType4,
            UserDefinedType5,
            UserDefinedType6,

            NumStructTypes
        };


        typedef std::vector<ptrdiff_t> PtrdiffVec;
        class RebaseListener
        {
        public:
            virtual void buildDiffList( ManagerType managerType, uint16 level,
                                        const MemoryPoolVec &basePtrs, PtrdiffVec &outDiffsList ) = 0;
            virtual void applyRebase( ManagerType managerType, uint16 level,
                                        const MemoryPoolVec &newBasePtrs,
                                        const PtrdiffVec &diffsList ) = 0;
            virtual void performCleanup( ManagerType managerType, uint16 level,
                                         const MemoryPoolVec &basePtrs,
                                         size_t const *elementsMemSizes, size_t startInstance,
                                         size_t diffInstances ) = 0;
        };

    protected:

        MemoryPoolVec mMemoryPools;
        size_t const *mElementsMemSizes;
        CleanupRoutines const *mCleanupRoutines;
        size_t mTotalMemoryMultiplier;


        size_t mUsedMemory;
        size_t mMaxMemory;
        size_t mMaxHardLimit;
        size_t mCleanupThreshold;
        typedef std::vector<size_t> SlotsVec;
        SlotsVec mAvailableSlots;
        RebaseListener *mRebaseListener;




        uint16 mLevel;

        ManagerType mManagerType;

    public:
        static const size_t MAX_MEMORY_SLOTS;
        ArrayMemoryManager( ManagerType managerType, size_t const *elementsMemSize,
                            CleanupRoutines const *cleanupRoutines, size_t numElementsSize,
                            uint16 depthLevel, size_t hintMaxNodes,
                            size_t cleanupThreshold=100, size_t maxHardLimit=MAX_MEMORY_SLOTS,
                            RebaseListener *rebaseListener=0 );
        void initialize();







        void destroy();


        size_t getFreeMemory() const;

        size_t getUsedMemory() const;

        size_t getWastedMemory() const;

        size_t getAllMemory() const;

    protected:
        size_t createNewSlot();
        void destroySlot( const char *ptrToFirstElement, uint8 index );






        virtual void slotsRecreated( size_t prevNumSlots ) {}
    };
    class NodeArrayMemoryManager : public ArrayMemoryManager
    {

        Node *mDummyNode;

    protected:

        virtual void slotsRecreated( size_t prevNumSlots );

    public:
        enum MemoryTypes
        {
            Parent = 0,
            Owner,
            Position,
            Orientation,
            Scale,
            DerivedPosition,
            DerivedOrientation,
            DerivedScale,
            WorldMat,
            InheritOrientation,
            InheritScale,
            NumMemoryTypes
        };

        static const size_t ElementsMemSize[NumMemoryTypes];
        static const CleanupRoutines NodeCleanupRoutines[NumMemoryTypes];


        NodeArrayMemoryManager( uint16 depthLevel, size_t hintMaxNodes, Node *dummyNode,
                                size_t cleanupThreshold=100, size_t maxHardLimit=MAX_MEMORY_SLOTS,
                                RebaseListener *rebaseListener=0 );
        void createNewNode( Transform &outTransform );







        void destroyNode( Transform &inOutTransform );
        size_t getFirstNode( Transform &outTransform );
    };
    class ObjectDataArrayMemoryManager : public ArrayMemoryManager
    {

        Node *mDummyNode;
        MovableObject *mDummyObject;

    protected:

        virtual void slotsRecreated( size_t prevNumSlots );

    public:
        enum MemoryTypes
        {
            Parent = 0,
            Owner,
            LocalAabb,
            WorldAabb,
            LocalRadius,
            WorldRadius,
            DistanceToCamera,
            UpperDistance,
            VisibilityFlags,
            QueryFlags,
            LightMask,
            NumMemoryTypes
        };

        static const size_t ElementsMemSize[NumMemoryTypes];
        static const CleanupRoutines ObjCleanupRoutines[NumMemoryTypes];


        ObjectDataArrayMemoryManager( uint16 depthLevel, size_t hintMaxNodes, Node *dummyNode,
                                        MovableObject *dummyObject, size_t cleanupThreshold=100,
                                        size_t maxHardLimit=MAX_MEMORY_SLOTS,
                                        RebaseListener *rebaseListener=0 );


        void createNewNode( ObjectData &outData );


        void destroyNode( ObjectData &inOutData );


        size_t getFirstNode( ObjectData &outData );
    };

    extern void cleanerFlat( char *dstPtr, size_t indexDst, char *srcPtr, size_t indexSrc,
                             size_t numSlots, size_t numFreeSlots, size_t elementsMemSize );
    extern void cleanerArrayVector3( char *dstPtr, size_t indexDst, char *srcPtr, size_t indexSrc,
                                     size_t numSlots, size_t numFreeSlots, size_t elementsMemSize );
    extern void cleanerArrayQuaternion( char *dstPtr, size_t indexDst, char *srcPtr, size_t indexSrc,
                                        size_t numSlots, size_t numFreeSlots, size_t elementsMemSize );
    extern void cleanerArrayAabb( char *dstPtr, size_t indexDst, char *srcPtr, size_t indexSrc,
                                    size_t numSlots, size_t numFreeSlots, size_t elementsMemSize );



}

namespace Ogre
{

    struct Transform
    {

        unsigned char mIndex;


        Node **mParents;


        Node **mOwner;


        ArrayVector3 * __restrict__ mPosition;


        ArrayQuaternion * __restrict__ mOrientation;


        ArrayVector3 * __restrict__ mScale;


        ArrayVector3 * __restrict__ mDerivedPosition;


        ArrayQuaternion * __restrict__ mDerivedOrientation;


        ArrayVector3 * __restrict__ mDerivedScale;


        Matrix4 * __restrict__ mDerivedTransform;



        bool * __restrict__ mInheritOrientation;



        bool * __restrict__ mInheritScale;

        Transform() :
            mIndex( 0 ),
            mParents( 0 ),
            mOwner( 0 ),
            mPosition( 0 ),
            mOrientation( 0 ),
            mScale( 0 ),
            mDerivedPosition( 0 ),
            mDerivedOrientation( 0 ),
            mDerivedScale( 0 ),
            mDerivedTransform( 0 ),
            mInheritOrientation( 0 ),
            mInheritScale( 0 )
        {
        }
        void copy( const Transform &inCopy )
        {
            mParents[mIndex] = inCopy.mParents[inCopy.mIndex];
            mOwner[mIndex] = inCopy.mOwner[inCopy.mIndex];

            Vector3 tmp;
            Quaternion qTmp;


            inCopy.mPosition->getAsVector3( tmp, inCopy.mIndex );
            mPosition->setFromVector3( tmp, mIndex );


            inCopy.mOrientation->getAsQuaternion( qTmp, inCopy.mIndex );
            mOrientation->setFromQuaternion( qTmp, mIndex );


            inCopy.mScale->getAsVector3( tmp, inCopy.mIndex );
            mScale->setFromVector3( tmp, mIndex );


            inCopy.mDerivedPosition->getAsVector3( tmp, inCopy.mIndex );
            mDerivedPosition->setFromVector3( tmp, mIndex );


            inCopy.mDerivedOrientation->getAsQuaternion( qTmp, inCopy.mIndex );
            mDerivedOrientation->setFromQuaternion( qTmp, mIndex );


            inCopy.mDerivedScale->getAsVector3( tmp, inCopy.mIndex );
            mDerivedScale->setFromVector3( tmp, mIndex );

            mDerivedTransform[mIndex] = inCopy.mDerivedTransform[mIndex];

            mInheritOrientation[mIndex] = inCopy.mInheritOrientation[inCopy.mIndex];
            mInheritScale[mIndex] = inCopy.mInheritScale[inCopy.mIndex];
        }
        void rebasePtrs( const MemoryPoolVec &newBasePtrs, const ptrdiff_t diff )
        {
            mParents = reinterpret_cast<Node**>( newBasePtrs[NodeArrayMemoryManager::Parent] + diff );
            mOwner = reinterpret_cast<Node**>( newBasePtrs[NodeArrayMemoryManager::Owner] + diff );

            mPosition = reinterpret_cast<ArrayVector3*>(
                                    newBasePtrs[NodeArrayMemoryManager::Position] + diff );
            mOrientation = reinterpret_cast<ArrayQuaternion*>(
                                    newBasePtrs[NodeArrayMemoryManager::Orientation] + diff );
            mScale = reinterpret_cast<ArrayVector3*>(
                                    newBasePtrs[NodeArrayMemoryManager::Scale] + diff );

            mDerivedPosition = reinterpret_cast<ArrayVector3*>(
                                    newBasePtrs[NodeArrayMemoryManager::DerivedPosition] + diff );
            mDerivedOrientation = reinterpret_cast<ArrayQuaternion*>(
                                    newBasePtrs[NodeArrayMemoryManager::DerivedOrientation] + diff );
            mDerivedScale = reinterpret_cast<ArrayVector3*>(
                                    newBasePtrs[NodeArrayMemoryManager::DerivedScale] + diff );

            mDerivedTransform = reinterpret_cast<Matrix4*>(
                                    newBasePtrs[NodeArrayMemoryManager::WorldMat] + diff );

            mInheritOrientation = reinterpret_cast<bool*>(
                                    newBasePtrs[NodeArrayMemoryManager::InheritOrientation] + diff );
            mInheritScale = reinterpret_cast<bool*>(
                                    newBasePtrs[NodeArrayMemoryManager::InheritScale] + diff );
        }




        void advancePack()
        {
            mParents += 4;
            mOwner += 4;
            ++mPosition;
            ++mOrientation;
            ++mScale;
            ++mDerivedPosition;
            ++mDerivedOrientation;
            ++mDerivedScale;
            mDerivedTransform += 4;
            mInheritOrientation += 4;
            mInheritScale += 4;
        }

        void advancePack( size_t numAdvance )
        {
            mParents += 4 * numAdvance;
            mOwner += 4 * numAdvance;
            mPosition += numAdvance;
            mOrientation += numAdvance;
            mScale += numAdvance;
            mDerivedPosition += numAdvance;
            mDerivedOrientation += numAdvance;
            mDerivedScale += numAdvance;
            mDerivedTransform += 4 * numAdvance;
            mInheritOrientation += 4 * numAdvance;
            mInheritScale += 4 * numAdvance;
        }
    };
}

namespace Ogre {
    class Node : public NodeAlloc, public IdObject
    {
        friend class TagPoint;
    public:


        enum TransformSpace
        {

            TS_LOCAL,

            TS_PARENT,

            TS_WORLD
        };
        typedef vector<Node*>::type NodeVec;
        typedef VectorIterator<NodeVec> NodeVecIterator;
        typedef ConstVectorIterator<NodeVec> ConstNodeVecIterator;



        class Listener
        {
        public:
            Listener() {}
            virtual ~Listener() {}







            virtual void nodeUpdated(const Node*) {}

            virtual void nodeDestroyed(const Node*) {}

            virtual void nodeAttached(const Node*) {}

            virtual void nodeDetached(const Node*) {}
        };
    protected:

        uint16 mDepthLevel;

        Node* mParent;

        NodeVec mChildren;

        Transform mTransform;


        String mName;


        void setParent( Node* parent );
        void unsetParent(void);


        void parentDepthLevelChanged(void);







        void _updateFromParent(void);







        virtual void updateFromParentImpl(void);


        virtual Node* createChildImpl( SceneMemoryMgrTypes sceneType ) = 0;


        mutable bool mCachedTransformOutOfDate;



        Listener* mListener;


        NodeMemoryManager *mNodeMemoryManager;


        UserObjectBindings mUserObjectBindings;

    public:






        size_t mGlobalIndex;

        size_t mParentIndex;





        Node( IdType id, NodeMemoryManager *nodeMemoryManager, Node *parent );




        Node( const Transform &transformPtrs );

        virtual ~Node();


        void setName( const String &name ) { mName = name; }


        const String& getName(void) const { return mName; }


        Node* getParent(void) const;






        void migrateTo( NodeMemoryManager *nodeMemoryManager );


        bool isStatic() const;
        virtual bool setStatic( bool bStatic );


        uint16 getDepthLevel() const { return mDepthLevel; }


        Transform& _getTransform() { return mTransform; }



        virtual void _notifyStaticDirty(void) const;





                   Quaternion getOrientation() const;
                   void setOrientation( Quaternion q );
                   void setOrientation( Real w, Real x, Real y, Real z);
                   void resetOrientation(void);





                   void setPosition( const Vector3& pos );





                   void setPosition(Real x, Real y, Real z);





                   Vector3 getPosition(void) const;
                   void setScale(const Vector3& scale);
                   void setScale(Real x, Real y, Real z);





                   Vector3 getScale(void) const;
                   void setInheritOrientation(bool inherit);
                   bool getInheritOrientation(void) const;
                   void setInheritScale(bool inherit);





                   bool getInheritScale(void) const;
                   void scale(const Vector3& scale);
                   void scale(Real x, Real y, Real z);
                   void translate(const Vector3& d, TransformSpace relativeTo = TS_PARENT);
                   void translate(Real x, Real y, Real z, TransformSpace relativeTo = TS_PARENT);
                   void translate(const Matrix3& axes, const Vector3& move, TransformSpace relativeTo = TS_PARENT);
                   void translate(const Matrix3& axes, Real x, Real y, Real z, TransformSpace relativeTo = TS_PARENT);



                   void roll(const Radian& angle, TransformSpace relativeTo = TS_LOCAL);



                   void pitch(const Radian& angle, TransformSpace relativeTo = TS_LOCAL);



                   void yaw(const Radian& angle, TransformSpace relativeTo = TS_LOCAL);



                   void rotate(const Vector3& axis, const Radian& angle, TransformSpace relativeTo = TS_LOCAL);



                   void rotate(const Quaternion& q, TransformSpace relativeTo = TS_LOCAL);



                   Matrix3 getLocalAxes(void) const;







        virtual Node* createChild(
            SceneMemoryMgrTypes sceneType = SCENE_DYNAMIC,
            const Vector3& translate = Vector3::ZERO,
            const Quaternion& rotate = Quaternion::IDENTITY );





        void addChild(Node* child);



        size_t numChildren(void) const { return mChildren.size(); }


        Node* getChild( size_t index ) { return mChildren[index]; }
        const Node* getChild( size_t index ) const { return mChildren[index]; }
        NodeVecIterator getChildIterator(void);
        ConstNodeVecIterator getChildIterator(void) const;
        virtual void removeChild( Node* child );




        virtual void removeAllChildren(void);





                   void _setDerivedPosition(const Vector3& pos);






                   void _setDerivedOrientation(const Quaternion& q);
                   Quaternion _getDerivedOrientation(void) const;
                   Quaternion _getDerivedOrientationUpdated(void);
                   Vector3 _getDerivedPosition(void) const;
                   Vector3 _getDerivedPositionUpdated(void);
                   Vector3 _getDerivedScale(void) const;
                   Vector3 _getDerivedScaleUpdated(void);
                   inline __attribute__((always_inline)) const Matrix4& _getFullTransform(void) const
        {
            assert( !mCachedTransformOutOfDate );
            return mTransform.mDerivedTransform[mTransform.mIndex];
        }


                   const Matrix4& _getFullTransformUpdated(void);






        virtual void setListener(Listener* listener) { mListener = listener; }



        Listener* getListener(void) const { return mListener; }





        static void updateAllTransforms( const size_t numNodes, Transform t );


                   Vector3 convertWorldToLocalPosition( const Vector3 &worldPos );



                   Vector3 convertLocalToWorldPosition( const Vector3 &localPos );


                   Quaternion convertWorldToLocalOrientation( const Quaternion &worldOrientation );



                   Quaternion convertLocalToWorldOrientation( const Quaternion &localOrientation );


        virtual Real getSquaredViewDepth(const Camera* cam) const;
        __attribute__ ((deprecated)) virtual void setUserAny(const Any& anything) { getUserObjectBindings().setUserAny(anything); }




        __attribute__ ((deprecated)) virtual const Any& getUserAny(void) const { return getUserObjectBindings().getUserAny(); }





        UserObjectBindings& getUserObjectBindings() { return mUserObjectBindings; }





        const UserObjectBindings& getUserObjectBindings() const { return mUserObjectBindings; }






        void _setNullNodeMemoryManager(void) { mNodeMemoryManager = 0; }




        virtual void _callMemoryChangeListeners(void) = 0;

        virtual NodeMemoryManager* getDefaultNodeMemoryManager( SceneMemoryMgrTypes sceneType ) = 0;


        virtual void _setCachedTransformOutOfDate(void);
        bool isCachedTransformOutOfDate(void) const { return mCachedTransformOutOfDate; }

    };



}



namespace Ogre {

    typedef vector<Bone*>::type BoneVec;
    typedef map<SkeletonInstance*, BoneVec>::type BonesPerSkeletonInstance;
    class SceneNode : public Node
    {
    public:
        typedef vector<MovableObject*>::type ObjectVec;
        typedef VectorIterator<ObjectVec> ObjectIterator;
        typedef ConstVectorIterator<ObjectVec> ConstObjectIterator;

    protected:
        ObjectVec mAttachments;
        BonesPerSkeletonInstance mBoneChildren;


        SceneManager* mCreator;


        Node* createChildImpl( SceneMemoryMgrTypes sceneType );


        bool mYawFixed;

        Vector3 mYawFixedAxis;





        ObjectVec::iterator getAttachedObjectIt( const String& name );
        ObjectVec::const_iterator getAttachedObjectIt( const String& name ) const;
    public:

        SceneNode( IdType id, SceneManager* creator, NodeMemoryManager *nodeMemoryManager,
                    SceneNode *parent );




        SceneNode( const Transform &transformPtrs );

        virtual ~SceneNode();


        virtual bool setStatic( bool bStatic );


        virtual void _notifyStaticDirty(void) const;






                   void attachObject(MovableObject* obj);



        size_t numAttachedObjects(void) const { return mAttachments.size(); }





        MovableObject* getAttachedObject( size_t index ) { return mAttachments[index]; }





        MovableObject* getAttachedObject( const String& name );





                   void detachObject(MovableObject* obj);



        virtual void detachAllObjects(void);



                   void _attachBone( SkeletonInstance *skeletonInstance, Bone *bone );



                   void _detachBone( SkeletonInstance *skeletonInstance, Bone *bone );



                   void _detachAllBones( SkeletonInstance *skeletonInstance );


        virtual void detachAllBones(void);


        virtual void _callMemoryChangeListeners(void);
        virtual ObjectIterator getAttachedObjectIterator(void);
        virtual ConstObjectIterator getAttachedObjectIterator(void) const;






        SceneManager* getCreator(void) const { return mCreator; }
        virtual void removeAndDestroyChild( SceneNode *sceneNode );







        virtual void removeAndDestroyAllChildren(void);







        virtual SceneNode* createChildSceneNode(
                SceneMemoryMgrTypes sceneType = SCENE_DYNAMIC,
                const Vector3& translate = Vector3::ZERO,
                const Quaternion& rotate = Quaternion::IDENTITY );

        virtual void setListener( Listener* listener );
        void setFixedYawAxis( bool useFixed, const Vector3& fixedAxis = Vector3::UNIT_Y );

        bool isYawFixed(void) const { return mYawFixed; }



        void yaw(const Radian& angle, TransformSpace relativeTo = TS_LOCAL);
        virtual void setDirection(Real x, Real y, Real z,
            TransformSpace relativeTo = TS_LOCAL,
            const Vector3& localDirectionVector = Vector3::NEGATIVE_UNIT_Z);
        virtual void setDirection(const Vector3& vec, TransformSpace relativeTo = TS_LOCAL,
            const Vector3& localDirectionVector = Vector3::NEGATIVE_UNIT_Z);






        virtual void lookAt( const Vector3& targetPoint, TransformSpace relativeTo,
            const Vector3& localDirectionVector = Vector3::NEGATIVE_UNIT_Z);
        virtual void setAutoTracking(bool enabled, SceneNode* const target = 0,
            const Vector3& localDirectionVector = Vector3::NEGATIVE_UNIT_Z,
            const Vector3& offset = Vector3::ZERO);


        SceneNode* getParentSceneNode(void) const;
        virtual void setVisible(bool visible, bool cascade = true);







        virtual void flipVisibility(bool cascade = true);




        virtual NodeMemoryManager* getDefaultNodeMemoryManager( SceneMemoryMgrTypes sceneType );


        virtual void _setCachedTransformOutOfDate(void);

    };




}


namespace Ogre
{
    struct Aabb
    {
        Ogre::Vector3 mCenter;
        Ogre::Vector3 mHalfSize;

        Aabb() :
            mCenter( Vector3::ZERO ),
            mHalfSize( Vector3::ZERO )
        {
        }





        Aabb( const Vector3 &center, const Vector3 &halfSize ) :
                    mCenter( center ),
                    mHalfSize( halfSize )
        {
        }


        inline void setExtents( const Vector3& min, const Vector3& max );


        inline static Aabb newFromExtents( const Vector3& min, const Vector3& max );


        inline Vector3 getMinimum() const;


        inline Vector3 getMaximum() const;


        inline Vector3 getSize(void) const;




        inline void merge( const Aabb& rhs );


        inline void merge( const Vector3& points );
        inline void transformAffine( const Matrix4 &matrix );


        inline bool intersects( const Aabb& b2 ) const;


        inline Aabb intersection( const Aabb& b2 ) const;


        inline Real volume(void) const;


        inline bool contains( const Aabb &other ) const;


        inline bool contains( const Vector3 &v ) const;


        inline Real distance( const Vector3 &v ) const;


        inline Real getRadius() const;


        inline Real getRadiusOrigin() const;

        inline bool operator == ( const Aabb &_r ) const;
        inline bool operator != ( const Aabb &_r ) const;

        static const Aabb BOX_INFINITE;
        static const Aabb BOX_NULL;


        static const Aabb BOX_ZERO;
    };



}


namespace Ogre
{
    inline void Aabb::setExtents( const Vector3& min, const Vector3& max )
    {
        assert( (min.x <= max.x && min.y <= max.y && min.z <= max.z) &&
                "The minimum corner of the box must be less than or equal to maximum corner" );
        mCenter = (max + min) * 0.5f;
        mHalfSize = (max - min) * 0.5f;
    }

    inline Aabb Aabb::newFromExtents( const Vector3& min, const Vector3& max )
    {
        assert( (min.x <= max.x && min.y <= max.y && min.z <= max.z) &&
                "The minimum corner of the box must be less than or equal to maximum corner" );
        Aabb retVal;
        retVal.mCenter = (max + min) * 0.5f;
        retVal.mHalfSize = (max - min) * 0.5f;
        return retVal;
    }

    inline Vector3 Aabb::getMinimum() const
    {
        return mCenter - mHalfSize;
    }

    inline Vector3 Aabb::getMaximum() const
    {
        return mCenter + mHalfSize;
    }

    inline Vector3 Aabb::getSize() const
    {
        return mHalfSize * 2.0f;
    }

    inline void Aabb::merge( const Aabb& rhs )
    {
        Vector3 max( mCenter + mHalfSize );
        max.makeCeil( rhs.mCenter + rhs.mHalfSize );

        Vector3 min( mCenter - mHalfSize );
        min.makeFloor( rhs.mCenter - rhs.mHalfSize );

        if( max.x != std::numeric_limits<float>::infinity() &&
            max.y != std::numeric_limits<float>::infinity() &&
            max.z != std::numeric_limits<float>::infinity() )
        {
            mCenter = ( max + min ) * 0.5f;
        }
        mHalfSize = ( max - min ) * 0.5f;
    }

    inline void Aabb::merge( const Vector3& points )
    {
        Vector3 max( mCenter + mHalfSize );
        max.makeCeil( points );

        Vector3 min( mCenter - mHalfSize );
        min.makeFloor( points );

        if( max.x != std::numeric_limits<float>::infinity() &&
            max.y != std::numeric_limits<float>::infinity() &&
            max.z != std::numeric_limits<float>::infinity() )
        {
            mCenter = ( max + min ) * 0.5f;
        }
        mHalfSize = ( max - min ) * 0.5f;
    }

    inline bool Aabb::intersects( const Aabb& b2 ) const
    {
        Vector3 dist( mCenter - b2.mCenter );
        Vector3 sumHalfSizes( mHalfSize + b2.mHalfSize );





        return ( Math::Abs( dist.x ) <= sumHalfSizes.x ) &
                ( Math::Abs( dist.y ) <= sumHalfSizes.y ) &
                ( Math::Abs( dist.z ) <= sumHalfSizes.z );
    }

    inline Real Aabb::volume(void) const
    {
        const Vector3 size = mHalfSize * 2.0f;
        return size.x * size.y * size.z;
    }

    inline bool Aabb::contains( const Aabb &other ) const
    {
        Vector3 dist( mCenter - other.mCenter );







        return ( Math::Abs( dist.x ) + other.mHalfSize.x <= mHalfSize.x ) &
                ( Math::Abs( dist.y ) + other.mHalfSize.y <= mHalfSize.y ) &
                ( Math::Abs( dist.z ) + other.mHalfSize.z <= mHalfSize.z );
    }

    inline bool Aabb::contains( const Vector3 &v ) const
    {
        Vector3 dist( mCenter - v );




        return ( Math::Abs( dist.x ) <= mHalfSize.x ) &
                ( Math::Abs( dist.y ) <= mHalfSize.y ) &
                ( Math::Abs( dist.z ) <= mHalfSize.z );
    }

    inline Real Aabb::distance( const Vector3 &v ) const
    {
        Vector3 dist( mCenter - v );






        dist.x = Math::Abs( dist.x ) - mHalfSize.x;
        dist.y = Math::Abs( dist.y ) - mHalfSize.y;
        dist.z = Math::Abs( dist.z ) - mHalfSize.z;

        return Ogre::max( Ogre::min( Ogre::min( dist.x, dist.y ), dist.z ), Real(1.0) );
    }

    inline void Aabb::transformAffine( const Matrix4 &m )
    {
        assert( m.isAffine() );

        mCenter = m.transformAffine( mCenter );

        Real x = Math::Abs(m[0][0]) * mHalfSize.x + Math::Abs(m[0][1]) * mHalfSize.y + Math::Abs(m[0][2]) * mHalfSize.z;
        Real y = Math::Abs(m[1][0]) * mHalfSize.x + Math::Abs(m[1][1]) * mHalfSize.y + Math::Abs(m[1][2]) * mHalfSize.z;
        Real z = Math::Abs(m[2][0]) * mHalfSize.x + Math::Abs(m[2][1]) * mHalfSize.y + Math::Abs(m[2][2]) * mHalfSize.z;


        mHalfSize = Vector3(
                Math::Abs(mHalfSize.x) == std::numeric_limits<Real>::infinity() ? mHalfSize.x : x,
                Math::Abs(mHalfSize.y) == std::numeric_limits<Real>::infinity() ? mHalfSize.y : y,
                Math::Abs(mHalfSize.z) == std::numeric_limits<Real>::infinity() ? mHalfSize.z : z );
    }

    inline Real Aabb::getRadius() const
    {
        return sqrtf( mHalfSize.dotProduct( mHalfSize ) );
    }

    inline Real Aabb::getRadiusOrigin() const
    {
        Vector3 v( mCenter );
        v.makeAbs();
        v += mHalfSize;
        return v.length();
    }

    inline bool Aabb::operator == ( const Aabb &_r ) const
    {
        return mCenter == _r.mCenter && mHalfSize == _r.mHalfSize;
    }

    inline bool Aabb::operator != ( const Aabb &_r ) const
    {
        return mCenter != _r.mCenter && mHalfSize != _r.mHalfSize;
    }
}

namespace Ogre
{
    class ArrayAabb
    {
    public:
        ArrayVector3 mCenter;
        ArrayVector3 mHalfSize;

        ArrayAabb( const ArrayVector3 &center, const ArrayVector3 &halfSize ) :
                mCenter( center ), mHalfSize( halfSize )
        {
        }

        void getAsAabb( Aabb &out, size_t index ) const
        {

            const Real *aliasedReal = reinterpret_cast<const Real*>( &mCenter );
            out.mCenter.x = aliasedReal[4 * 0 + index];
            out.mCenter.y = aliasedReal[4 * 1 + index];
            out.mCenter.z = aliasedReal[4 * 2 + index];
            out.mHalfSize.x = aliasedReal[4 * 3 + index];
            out.mHalfSize.y = aliasedReal[4 * 4 + index];
            out.mHalfSize.z = aliasedReal[4 * 5 + index];
        }



        Aabb getAsAabb( size_t index ) const
        {
            Aabb retVal;
            getAsAabb( retVal, index );
            return retVal;
        }

        void setFromAabb( const Aabb &aabb, size_t index )
        {
            Real *aliasedReal = reinterpret_cast<Real*>( &mCenter );
            aliasedReal[4 * 0 + index] = aabb.mCenter.x;
            aliasedReal[4 * 1 + index] = aabb.mCenter.y;
            aliasedReal[4 * 2 + index] = aabb.mCenter.z;
            aliasedReal[4 * 3 + index] = aabb.mHalfSize.x;
            aliasedReal[4 * 4 + index] = aabb.mHalfSize.y;
            aliasedReal[4 * 5 + index] = aabb.mHalfSize.z;
        }

        void setAll( const Aabb &aabb )
        {
            mCenter.setAll( aabb.mCenter );
            mHalfSize.setAll( aabb.mHalfSize );
        }


        inline ArrayVector3 getMinimum() const;


        inline ArrayVector3 getMaximum() const;




        inline void merge( const ArrayAabb& rhs );


        inline void merge( const ArrayVector3& points );
        inline void transformAffine( const ArrayMatrix4 &matrix );


        inline ArrayMaskR intersects( const ArrayAabb& b2 ) const;


        inline ArrayAabb intersection( const ArrayAabb& b2 ) const;


        inline ArrayReal volume(void) const;


        inline ArrayMaskR contains( const ArrayAabb &other ) const;


        inline ArrayMaskR contains( const ArrayVector3 &v ) const;


        inline ArrayReal distance( const ArrayVector3 &v ) const;

        static const ArrayAabb BOX_INFINITE;


        static const ArrayAabb BOX_ZERO;
    };



}


namespace Ogre
{

    inline ArrayVector3 ArrayAabb::getMinimum() const
    {
        return mCenter - mHalfSize;
    }

    inline ArrayVector3 ArrayAabb::getMaximum() const
    {
        return mCenter + mHalfSize;
    }

    inline void ArrayAabb::merge( const ArrayAabb& rhs )
    {
        ArrayVector3 max( mCenter + mHalfSize );
        max.makeCeil( rhs.mCenter + rhs.mHalfSize );

        ArrayVector3 min( mCenter - mHalfSize );
        min.makeFloor( rhs.mCenter - rhs.mHalfSize );

        mCenter = ( max + min ) * Mathlib::HALF;
        mHalfSize = ( max - min ) * Mathlib::HALF;
    }

    inline void ArrayAabb::merge( const ArrayVector3& points )
    {
        ArrayVector3 max( mCenter + mHalfSize );
        max.makeCeil( points );

        ArrayVector3 min( mCenter - mHalfSize );
        min.makeFloor( points );

        mCenter = ( max + min ) * Mathlib::HALF;
        mHalfSize = ( max - min ) * Mathlib::HALF;
    }

    inline ArrayMaskR ArrayAabb::intersects( const ArrayAabb& b2 ) const
    {
        ArrayVector3 dist( mCenter - b2.mCenter );
        ArrayVector3 sumHalfSizes( mHalfSize + b2.mHalfSize );




        ArrayReal maskX = _mm_cmple_ps( MathlibSSE2::Abs4( dist.mChunkBase[0] ),
                                        sumHalfSizes.mChunkBase[0] );
        ArrayReal maskY = _mm_cmple_ps( MathlibSSE2::Abs4( dist.mChunkBase[1] ),
                                        sumHalfSizes.mChunkBase[1] );
        ArrayReal maskZ = _mm_cmple_ps( MathlibSSE2::Abs4( dist.mChunkBase[2] ),
                                        sumHalfSizes.mChunkBase[2] );

        return _mm_and_ps( _mm_and_ps( maskX, maskY ), maskZ );
    }

    inline ArrayReal ArrayAabb::volume(void) const
    {
        ArrayReal w = _mm_add_ps( mHalfSize.mChunkBase[0], mHalfSize.mChunkBase[0] );
        ArrayReal h = _mm_add_ps( mHalfSize.mChunkBase[1], mHalfSize.mChunkBase[1] );
        ArrayReal d = _mm_add_ps( mHalfSize.mChunkBase[2], mHalfSize.mChunkBase[2] );

        return _mm_mul_ps( _mm_mul_ps( w, h ), d );
    }

    inline ArrayReal ArrayAabb::contains( const ArrayAabb &other ) const
    {
        ArrayVector3 dist( mCenter - other.mCenter );
        ArrayReal maskX = _mm_cmple_ps( _mm_add_ps( MathlibSSE2::Abs4( dist.mChunkBase[0] ),
                                        other.mHalfSize.mChunkBase[0] ), mHalfSize.mChunkBase[0] );
        ArrayReal maskY = _mm_cmple_ps( _mm_add_ps( MathlibSSE2::Abs4( dist.mChunkBase[1] ),
                                        other.mHalfSize.mChunkBase[1] ), mHalfSize.mChunkBase[1] );
        ArrayReal maskZ = _mm_cmple_ps( _mm_add_ps( MathlibSSE2::Abs4( dist.mChunkBase[2] ),
                                        other.mHalfSize.mChunkBase[2] ), mHalfSize.mChunkBase[2] );

        return _mm_and_ps( _mm_and_ps( maskX, maskY ), maskZ );
    }

    inline ArrayReal ArrayAabb::contains( const ArrayVector3 &v ) const
    {
        ArrayVector3 dist( mCenter - v );




        ArrayReal maskX = _mm_cmple_ps( MathlibSSE2::Abs4( dist.mChunkBase[0] ),
                                        mHalfSize.mChunkBase[0] );
        ArrayReal maskY = _mm_cmple_ps( MathlibSSE2::Abs4( dist.mChunkBase[1] ),
                                        mHalfSize.mChunkBase[1] );
        ArrayReal maskZ = _mm_cmple_ps( MathlibSSE2::Abs4( dist.mChunkBase[2] ),
                                        mHalfSize.mChunkBase[2] );

        return _mm_and_ps( _mm_and_ps( maskX, maskY ), maskZ );
    }

    inline ArrayReal ArrayAabb::distance( const ArrayVector3 &v ) const
    {
        ArrayVector3 dist( mCenter - v );





        dist.mChunkBase[0] = _mm_sub_ps( MathlibSSE2::Abs4( dist.mChunkBase[0] ),
                                                mHalfSize.mChunkBase[0] );
        dist.mChunkBase[1] = _mm_sub_ps( MathlibSSE2::Abs4( dist.mChunkBase[1] ),
                                                mHalfSize.mChunkBase[1] );
        dist.mChunkBase[2] = _mm_sub_ps( MathlibSSE2::Abs4( dist.mChunkBase[2] ),
                                                mHalfSize.mChunkBase[2] );

        return _mm_max_ps( _mm_min_ps( _mm_min_ps( dist.mChunkBase[0],
                    dist.mChunkBase[1] ), dist.mChunkBase[2] ), _mm_setzero_ps() );
    }

    inline void ArrayAabb::transformAffine( const ArrayMatrix4 &m )
    {
        assert( m.isAffine() );

        mCenter = m * mCenter;

        ArrayReal x = _mm_mul_ps( Mathlib::Abs4( m.mChunkBase[2] ), mHalfSize.mChunkBase[2] );
        x = _mm_add_ps( x, _mm_mul_ps( Mathlib::Abs4( m.mChunkBase[1] ), mHalfSize.mChunkBase[1] ) );
        x = _mm_add_ps( x, _mm_mul_ps( Mathlib::Abs4( m.mChunkBase[0] ), mHalfSize.mChunkBase[0] ) );

        ArrayReal y = _mm_mul_ps( Mathlib::Abs4( m.mChunkBase[6] ), mHalfSize.mChunkBase[2] );
        y = _mm_add_ps( y, _mm_mul_ps( Mathlib::Abs4( m.mChunkBase[5] ), mHalfSize.mChunkBase[1] ) );
        y = _mm_add_ps( y, _mm_mul_ps( Mathlib::Abs4( m.mChunkBase[4] ), mHalfSize.mChunkBase[0] ) );

        ArrayReal z = _mm_mul_ps( Mathlib::Abs4( m.mChunkBase[10] ), mHalfSize.mChunkBase[2] );
        z = _mm_add_ps( z, _mm_mul_ps( Mathlib::Abs4( m.mChunkBase[9] ), mHalfSize.mChunkBase[1] ) );
        z = _mm_add_ps( z, _mm_mul_ps( Mathlib::Abs4( m.mChunkBase[8] ), mHalfSize.mChunkBase[0] ) );


        x = MathlibSSE2::CmovRobust( mHalfSize.mChunkBase[0], x,
                                     _mm_cmpeq_ps( Mathlib::Abs4(mHalfSize.mChunkBase[0]),
                                                   Mathlib::INFINITEA ) );
        y = MathlibSSE2::CmovRobust( mHalfSize.mChunkBase[1], y,
                                     _mm_cmpeq_ps( Mathlib::Abs4(mHalfSize.mChunkBase[1]),
                                                   Mathlib::INFINITEA ) );
        z = MathlibSSE2::CmovRobust( mHalfSize.mChunkBase[2], z,
                                     _mm_cmpeq_ps( Mathlib::Abs4(mHalfSize.mChunkBase[2]),
                                                   Mathlib::INFINITEA ) );

        mHalfSize = ArrayVector3( x, y, z );
    }

}


namespace Ogre
{

    struct ObjectData
    {

        unsigned char mIndex;


        Node **mParents;


        MovableObject **mOwner;






        ArrayAabb * __restrict__ mLocalAabb;


        ArrayAabb * __restrict__ mWorldAabb;







        Real * __restrict__ mLocalRadius;






        Real * __restrict__ mWorldRadius;





        RealAsUint * __restrict__ mDistanceToCamera;


        Real * __restrict__ mUpperDistance;


        uint32 * __restrict__ mVisibilityFlags;


        uint32 * __restrict__ mQueryFlags;
        uint32 * __restrict__ mLightMask;

        ObjectData() :
            mIndex( 0 ),
            mParents( 0 ),
            mLocalAabb( 0 ),
            mWorldAabb( 0 ),
            mWorldRadius( 0 ),
            mDistanceToCamera( 0 ),
            mUpperDistance( 0 ),
            mVisibilityFlags( 0 ),
            mQueryFlags( 0 ),
            mLightMask( 0 )
        {
        }


        void copy( const ObjectData &inCopy )
        {
            mParents[mIndex] = inCopy.mParents[inCopy.mIndex];
            mOwner[mIndex] = inCopy.mOwner[inCopy.mIndex];

            Aabb tmp;
            inCopy.mLocalAabb->getAsAabb( tmp, inCopy.mIndex );
            mLocalAabb->setFromAabb( tmp, mIndex );

            inCopy.mWorldAabb->getAsAabb( tmp, inCopy.mIndex );
            mWorldAabb->setFromAabb( tmp, mIndex );

            mLocalRadius[mIndex] = inCopy.mLocalRadius[inCopy.mIndex];
            mWorldRadius[mIndex] = inCopy.mWorldRadius[inCopy.mIndex];
            mDistanceToCamera[mIndex] = inCopy.mDistanceToCamera[mIndex];
            mUpperDistance[mIndex] = inCopy.mUpperDistance[inCopy.mIndex];
            mVisibilityFlags[mIndex] = inCopy.mVisibilityFlags[inCopy.mIndex];
            mQueryFlags[mIndex] = inCopy.mQueryFlags[inCopy.mIndex];
            mLightMask[mIndex] = inCopy.mLightMask[inCopy.mIndex];
        }




        void advancePack()
        {
            mParents += 4;
            mOwner += 4;
            ++mLocalAabb;
            ++mWorldAabb;
            mLocalRadius += 4;
            mWorldRadius += 4;
            mDistanceToCamera += 4;
            mUpperDistance += 4;
            mVisibilityFlags += 4;
            mQueryFlags += 4;
            mLightMask += 4;
        }

        void advancePack( size_t numAdvance )
        {
            mParents += 4 * numAdvance;
            mOwner += 4 * numAdvance;
            mLocalAabb += numAdvance;
            mWorldAabb += numAdvance;
            mLocalRadius += 4 * numAdvance;
            mWorldRadius += 4 * numAdvance;
            mDistanceToCamera += 4 * numAdvance;
            mUpperDistance += 4 * numAdvance;
            mVisibilityFlags += 4 * numAdvance;
            mQueryFlags += 4 * numAdvance;
            mLightMask += 4 * numAdvance;
        }




        void advanceBoundsPack()
        {

            mOwner += 4;

            mParents += 4;
            ++mLocalAabb;
            ++mWorldAabb;
            mLocalRadius += 4;
            mWorldRadius += 4;
        }




        void advanceFrustumPack()
        {
            mOwner += 4;
            ++mWorldAabb;
            mWorldRadius += 4;
            mDistanceToCamera += 4;
            mUpperDistance += 4;
            mVisibilityFlags += 4;
        }




        void advanceDirtyInstanceMgr()
        {
            ++mWorldAabb;
            mWorldRadius += 4;
            mVisibilityFlags += 4;
        }




        void advanceCullLightPack()
        {
            mOwner += 4;
            ++mWorldAabb;
            mWorldRadius += 4;
            mVisibilityFlags += 4;
            mLightMask += 4;
        }




        void advanceLightPack()
        {
            mOwner += 4;
            ++mWorldAabb;
            mWorldRadius += 4;
            mVisibilityFlags += 4;
            mLightMask += 4;
        }

        void advanceLodPack()
        {
            mOwner += 4;
            ++mWorldAabb;
            mWorldRadius += 4;
        }
    };
}


namespace Ogre {
    namespace VisibilityFlags
    {
        extern const uint32 LAYER_SHADOW_CASTER;
        extern const uint32 LAYER_VISIBILITY;
        extern const uint32 RESERVED_VISIBILITY_FLAGS;
    };



}




namespace Ogre {
    typedef vector<Frustum*>::type FrustumVec;


    class MovableObjectFactory;
    typedef FastArray<Renderable*> RenderableArray;






    class MovableObject : public AnimableObject, public MovableAlloc, public IdObject
    {
    public:
        static const FastArray<Real> c_DefaultLodMesh;



        class Listener
        {
        public:
            Listener(void) {}
            virtual ~Listener() {}

            virtual void objectDestroyed(MovableObject*) {}

            virtual void objectAttached(MovableObject*) {}

            virtual void objectDetached(MovableObject*) {}
        };

        RenderableArray mRenderables;
    protected:

        Node* mParentNode;

        uint8 mRenderQueueID;

        ObjectData mObjectData;

        SceneManager* mManager;


        FastArray<Real> const *mLodMesh;
        unsigned char mCurrentMeshLod;


        Real mMinPixelSize;

        UserObjectBindings mUserObjectBindings;


        Listener* mListener;


        LightList mLightList;





        SkeletonInstance *mSkeletonInstance;


        ObjectMemoryManager *mObjectMemoryManager;


        mutable bool mCachedAabbOutOfDate;



        String mName;



        static uint32 msDefaultQueryFlags;

        static uint32 msDefaultVisibilityFlags;

    protected:
        Aabb updateSingleWorldAabb();
        float updateSingleWorldRadius();

    public:






        size_t mGlobalIndex;

        size_t mParentIndex;





        MovableObject( IdType id, ObjectMemoryManager *objectMemoryManager,
                       SceneManager* manager, uint8 renderQueueId );




        MovableObject( ObjectData *objectDataPtrs );



        virtual ~MovableObject();


        void _notifyManager(SceneManager* man) { mManager = man; }

        SceneManager* _getManager(void) const { return mManager; }


        void setName( const String &name ) { mName = name; }


        const String& getName(void) const { return mName; }


        virtual const String& getMovableType(void) const = 0;


        Node* getParentNode(void) const { return mParentNode; }

        inline SceneNode* getParentSceneNode(void) const;



        virtual void _notifyAttached( Node* parent );


        bool isAttached(void) const { return mParentNode != 0; }


        void detachFromParent(void);


        virtual void _notifyParentNodeMemoryChanged(void) {}

        unsigned char getCurrentMeshLod(void) const { return mCurrentMeshLod; }


        bool isStatic() const;
        bool setStatic( bool bStatic );



        virtual void _notifyStaticDirty(void) const {}






        virtual void _updateRenderQueue(RenderQueue* queue, Camera *camera, const Camera *lodCamera) {}





        static void updateAllBounds( const size_t numNodes, ObjectData t );
        typedef FastArray<MovableObject*> MovableObjectArray;
        static void cullFrustum( const size_t numNodes, ObjectData t, const Camera *frustum,
                                 uint32 sceneVisibilityFlags, MovableObjectArray &outCulledObjects,
                                 const Camera *lodCamera );


        virtual void instanceBatchCullFrustumThreaded( const Frustum *frustum, const Camera *lodCamera,
                                                        uint32 combinedVisibilityFlags ) {}
        static void cullLights( const size_t numNodes, ObjectData t, LightListInfo &outGlobalLightList,
                                const FrustumVec &frustums , const FrustumVec &cubemapFrustums );
        static void buildLightList( const size_t numNodes, ObjectData t,
                                    const LightListInfo &globalLightList );

        static void calculateCastersBox( const size_t numNodes, ObjectData t,
                                         uint32 sceneVisibilityFlags, AxisAlignedBox *outBox );

        friend void LodStrategy::lodUpdateImpl( const size_t numNodes, ObjectData t,
                                                const Camera *camera, Real bias ) const;
        friend void LodStrategy::lodSet( ObjectData &t, Real lodValues[4] );
        inline void setVisible( bool visible );





        inline bool getVisible(void) const;





        bool isVisible(void) const;







        inline void setRenderingDistance(Real dist);


        inline Real getRenderingDistance(void) const;






        void setRenderingMinPixelSize(Real pixelSize) {
            mMinPixelSize = pixelSize;
        }




        Real getRenderingMinPixelSize() const { return mMinPixelSize; }





        UserObjectBindings& getUserObjectBindings() { return mUserObjectBindings; }





        const UserObjectBindings& getUserObjectBindings() const { return mUserObjectBindings; }
        virtual void setRenderQueueGroup(uint8 queueID);


        inline uint8 getRenderQueueGroup(void) const;


        ObjectData& _getObjectData() { return mObjectData; }


        const Matrix4& _getParentNodeFullTransform(void) const;





        Aabb getLocalAabb(void) const;





        void setLocalAabb(const Aabb box);







        Aabb getWorldAabb() const;
        Aabb getWorldAabbUpdated();







        float getWorldRadius() const;
        float getWorldRadiusUpdated();
        inline void setQueryFlags(uint32 flags);



        inline void addQueryFlags(uint32 flags);



        inline void removeQueryFlags(uint32 flags);


        inline uint32 getQueryFlags(void) const;



        static void setDefaultQueryFlags(uint32 flags) { msDefaultQueryFlags = flags; }



        static uint32 getDefaultQueryFlags() { return msDefaultQueryFlags; }


        inline RealAsUint getCachedDistanceToCamera(void) const;


        inline Real getCachedDistanceToCameraAsReal(void) const;
        inline void setVisibilityFlags(uint32 flags);



        inline void addVisibilityFlags(uint32 flags);



        inline void removeVisibilityFlags(uint32 flags);




        inline uint32 getVisibilityFlags(void) const;



        inline static void setDefaultVisibilityFlags(uint32 flags);



        static uint32 getDefaultVisibilityFlags() { return msDefaultVisibilityFlags; }






        void setListener(Listener* listener) { mListener = listener; }



        Listener* getListener(void) const { return mListener; }






        const LightList& queryLights(void) const { return mLightList; }





        inline uint32 getLightMask()const;






        inline void setLightMask(uint32 lightMask);







        LightList* _getLightList() { return &mLightList; }
        inline void setCastShadows( bool enabled );

        inline bool getCastShadows(void) const;

        SkeletonInstance* getSkeletonInstance(void) const { return mSkeletonInstance; }


        void _setCachedAabbOutOfDate(void) { mCachedAabbOutOfDate = true; }
        bool isCachedAabbOutOfDate() const { return mCachedAabbOutOfDate; }


    };






    class MovableObjectFactory : public MovableAlloc
    {
    protected:

        virtual MovableObject* createInstanceImpl( IdType id, ObjectMemoryManager *objectMemoryManager,
                                                   SceneManager* manager,
                                                   const NameValuePairList* params = 0) = 0;
    public:
        MovableObjectFactory() {}
        virtual ~MovableObjectFactory() {}

        virtual const String& getType(void) const = 0;







        virtual MovableObject* createInstance( IdType id, ObjectMemoryManager *objectMemoryManager,
                                        SceneManager* manager, const NameValuePairList* params = 0);

        virtual void destroyInstance(MovableObject* obj) = 0;
    };

    class NullEntity : public MovableObject
    {
        static const String msMovableType;
    public:
        NullEntity() : MovableObject( 0 )
        {
        }

        virtual const String& getMovableType(void) const
        {
            return msMovableType;
        }
        virtual void _updateRenderQueue(RenderQueue* queue, Camera *camera, const Camera *lodCamera,
                                        RealAsUint depth) {}
    };




}



namespace Ogre
{
    inline void MovableObject::setDefaultVisibilityFlags(uint32 flags)
    {
        msDefaultVisibilityFlags = (flags & VisibilityFlags::RESERVED_VISIBILITY_FLAGS) |
                                    ( msDefaultVisibilityFlags &
                                      ~VisibilityFlags::RESERVED_VISIBILITY_FLAGS );
    }

    inline RealAsUint MovableObject::getCachedDistanceToCamera(void) const
    {
        return mObjectData.mDistanceToCamera[mObjectData.mIndex];
    }

    inline Real MovableObject::getCachedDistanceToCameraAsReal(void) const
    {
        return (reinterpret_cast<Real*__restrict__>(mObjectData.mDistanceToCamera))[mObjectData.mIndex];
    }

    inline void MovableObject::setVisibilityFlags( uint32 flags )
    {
        mObjectData.mVisibilityFlags[mObjectData.mIndex] =
                    ( flags & VisibilityFlags::RESERVED_VISIBILITY_FLAGS ) |
                    ( mObjectData.mVisibilityFlags[mObjectData.mIndex] &
                        ~VisibilityFlags::RESERVED_VISIBILITY_FLAGS );
    }

    inline void MovableObject::addVisibilityFlags( uint32 flags )
    {
        mObjectData.mVisibilityFlags[mObjectData.mIndex] |=
                                        flags & VisibilityFlags::RESERVED_VISIBILITY_FLAGS;
    }

    inline void MovableObject::removeVisibilityFlags( uint32 flags )
    {
        mObjectData.mVisibilityFlags[mObjectData.mIndex] &=
                                        ~(flags & VisibilityFlags::RESERVED_VISIBILITY_FLAGS);
    }

    inline uint32 MovableObject::getVisibilityFlags(void) const
    {
        return mObjectData.mVisibilityFlags[mObjectData.mIndex] &
                                                    VisibilityFlags::RESERVED_VISIBILITY_FLAGS;
    }

    inline void MovableObject::setQueryFlags( uint32 flags )
    {
        mObjectData.mQueryFlags[mObjectData.mIndex] = flags;
    }

    inline void MovableObject::addQueryFlags( uint32 flags )
    {
        mObjectData.mQueryFlags[mObjectData.mIndex] |= flags;
    }

    inline void MovableObject::removeQueryFlags( uint32 flags )
    {
        mObjectData.mQueryFlags[mObjectData.mIndex] &= ~flags;
    }

    inline uint32 MovableObject::getQueryFlags(void) const
    {
        return mObjectData.mQueryFlags[mObjectData.mIndex];
    }

    inline uint32 MovableObject::getLightMask() const
    {
        return mObjectData.mLightMask[mObjectData.mIndex];
    }

    inline void MovableObject::setLightMask( uint32 lightMask )
    {
        mObjectData.mLightMask[mObjectData.mIndex] = lightMask;
    }

    inline void MovableObject::setRenderingDistance( Real dist )
    {
        assert( dist > 0.0f );
        if( dist > 0.0f )
            mObjectData.mUpperDistance[mObjectData.mIndex] = dist;
    }

    inline Real MovableObject::getRenderingDistance(void) const
    {
        return mObjectData.mUpperDistance[mObjectData.mIndex];
    }

    inline void MovableObject::setVisible( bool visible )
    {
        assert( (!visible || mParentNode) && "Setting to visible an object without "
                "attachment is not supported!" );

        if( visible )
            mObjectData.mVisibilityFlags[mObjectData.mIndex] |= VisibilityFlags::LAYER_VISIBILITY;
        else
            mObjectData.mVisibilityFlags[mObjectData.mIndex] &= ~VisibilityFlags::LAYER_VISIBILITY;
    }

    inline bool MovableObject::getVisible(void) const
    {
        return (mObjectData.mVisibilityFlags[mObjectData.mIndex] &
                                                    VisibilityFlags::LAYER_VISIBILITY) != 0;
    }

    inline void MovableObject::setCastShadows( bool enabled )
    {
        if( enabled )
            mObjectData.mVisibilityFlags[mObjectData.mIndex] |= VisibilityFlags::LAYER_SHADOW_CASTER;
        else
            mObjectData.mVisibilityFlags[mObjectData.mIndex] &= ~VisibilityFlags::LAYER_SHADOW_CASTER;
    }

    inline bool MovableObject::getCastShadows(void) const
    {
        return (mObjectData.mVisibilityFlags[mObjectData.mIndex] &
                                                    VisibilityFlags::LAYER_SHADOW_CASTER) != 0;
    }

    inline uint8 MovableObject::getRenderQueueGroup(void) const
    {
        return mRenderQueueID;
    }

    inline SceneNode* MovableObject::getParentSceneNode(void) const
    {
        assert( !mParentNode || dynamic_cast<SceneNode*>( mParentNode ) );
        return static_cast<SceneNode*>( mParentNode );
    }
}









namespace Ogre {
    class ResourceGroupListener
    {
    public:
        virtual ~ResourceGroupListener() {}
        virtual void resourceGroupScriptingStarted(const String& groupName, size_t scriptCount) = 0;







        virtual void scriptParseStarted(const String& scriptName, bool& skipThisScript) = 0;



        virtual void scriptParseEnded(const String& scriptName, bool skipped) = 0;

        virtual void resourceGroupScriptingEnded(const String& groupName) = 0;






        virtual void resourceGroupPrepareStarted(const String& groupName, size_t resourceCount)
                { (void)groupName; (void)resourceCount; }




        virtual void resourcePrepareStarted(const ResourcePtr& resource)
                { (void)resource; }



        virtual void resourcePrepareEnded(void) {}





        virtual void worldGeometryPrepareStageStarted(const String& description)
        { (void)description; }





        virtual void worldGeometryPrepareStageEnded(void) {}

        virtual void resourceGroupPrepareEnded(const String& groupName)
        { (void)groupName; }






        virtual void resourceGroupLoadStarted(const String& groupName, size_t resourceCount) = 0;



        virtual void resourceLoadStarted(const ResourcePtr& resource) = 0;


        virtual void resourceLoadEnded(void) = 0;





        virtual void worldGeometryStageStarted(const String& description) = 0;




        virtual void worldGeometryStageEnded(void) = 0;

        virtual void resourceGroupLoadEnded(const String& groupName) = 0;



        virtual void resourceCreated(const ResourcePtr& resource)
        { (void)resource; }



        virtual void resourceRemove(const ResourcePtr& resource)
        { (void)resource; }
    };






    class ResourceLoadingListener
    {
    public:
        virtual ~ResourceLoadingListener() {}


        virtual DataStreamPtr resourceLoading(const String &name, const String &group, Resource *resource) = 0;






        virtual void resourceStreamOpened(const String &name, const String &group, Resource *resource, DataStreamPtr& dataStream) = 0;



        virtual bool resourceCollision(Resource *resource, ResourceManager *resourceManager) = 0;
    };
    class ResourceGroupManager : public Singleton<ResourceGroupManager>, public ResourceAlloc
    {
    public:
                       ;

        static String DEFAULT_RESOURCE_GROUP_NAME;

        static String INTERNAL_RESOURCE_GROUP_NAME;

        static String AUTODETECT_RESOURCE_GROUP_NAME;

        static size_t RESOURCE_SYSTEM_NUM_REFERENCE_COUNTS;

        struct ResourceDeclaration
        {
            String resourceName;
            String resourceType;
            ManualResourceLoader* loader;
            NameValuePairList parameters;
        };

        typedef list<ResourceDeclaration>::type ResourceDeclarationList;
        typedef map<String, ResourceManager*>::type ResourceManagerMap;
        typedef MapIterator<ResourceManagerMap> ResourceManagerIterator;

        struct ResourceLocation
        {

            Archive* archive;

            bool recursive;
        };

        typedef list<ResourceLocation*>::type LocationList;

    protected:

        ResourceManagerMap mResourceManagerMap;


        typedef multimap<Real, ScriptLoader*>::type ScriptLoaderOrderMap;
        ScriptLoaderOrderMap mScriptLoaderOrderMap;

        typedef vector<ResourceGroupListener*>::type ResourceGroupListenerList;
        ResourceGroupListenerList mResourceGroupListenerList;

        ResourceLoadingListener *mLoadingListener;


        typedef map<String, Archive*>::type ResourceLocationIndex;


        typedef unordered_set<ResourcePtr>::type LoadUnloadResourceSet;

        struct ResourceGroup
        {
            enum Status
            {
                UNINITIALSED = 0,
                INITIALISING = 1,
                INITIALISED = 2,
                LOADING = 3,
                LOADED = 4
            };

                                   ;

                                           ;

            String name;

            Status groupStatus;

            LocationList locationList;

            ResourceLocationIndex resourceIndexCaseSensitive;

            ResourceLocationIndex resourceIndexCaseInsensitive;

            ResourceDeclarationList resourceDeclarations;



            typedef map<Real, LoadUnloadResourceSet*>::type LoadResourceOrderMap;
            LoadResourceOrderMap loadResourceOrderMap;

            String worldGeometry;

            SceneManager* worldGeometrySceneManager;

            bool inGlobalPool;

            void addToIndex(const String& filename, Archive* arch);
            void removeFromIndex(const String& filename, Archive* arch);
            void removeFromIndex(Archive* arch);

        };

        typedef map<String, ResourceGroup*>::type ResourceGroupMap;
        ResourceGroupMap mResourceGroupMap;


        String mWorldGroupName;






        void parseResourceGroupScripts(ResourceGroup* grp);




        void createDeclaredResources(ResourceGroup* grp);

        void addCreatedResource(ResourcePtr& res, ResourceGroup& group);

        ResourceGroup* getResourceGroup(const String& name);

        void dropGroupContents(ResourceGroup* grp);

        void deleteGroup(ResourceGroup* grp);

        ResourceGroup* findGroupContainingResourceImpl(const String& filename);

        void fireResourceGroupScriptingStarted(const String& groupName, size_t scriptCount);

        void fireScriptStarted(const String& scriptName, bool &skipScript);

        void fireScriptEnded(const String& scriptName, bool skipped);

        void fireResourceGroupScriptingEnded(const String& groupName);

        void fireResourceGroupLoadStarted(const String& groupName, size_t resourceCount);

        void fireResourceLoadStarted(const ResourcePtr& resource);

        void fireResourceLoadEnded(void);

        void fireResourceGroupLoadEnded(const String& groupName);

        void fireResourceGroupPrepareStarted(const String& groupName, size_t resourceCount);

        void fireResourcePrepareStarted(const ResourcePtr& resource);

        void fireResourcePrepareEnded(void);

        void fireResourceGroupPrepareEnded(const String& groupName);

        void fireResourceCreated(const ResourcePtr& resource);

        void fireResourceRemove(const ResourcePtr& resource);

        time_t resourceModifiedTime(ResourceGroup* group, const String& filename);





        bool resourceExists(ResourceGroup* group, const String& filename);


        ResourceGroup* mCurrentGroup;
    public:
        ResourceGroupManager();
        virtual ~ResourceGroupManager();
        void createResourceGroup(const String& name, const bool inGlobalPool = true);
        void initialiseResourceGroup(const String& name);




        void initialiseAllResourceGroups(void);
        void prepareResourceGroup(const String& name, bool prepareMainResources = true,
            bool prepareWorldGeom = true);
        void loadResourceGroup(const String& name, bool loadMainResources = true,
            bool loadWorldGeom = true);
        void unloadResourceGroup(const String& name, bool reloadableOnly = true);
        void unloadUnreferencedResourcesInGroup(const String& name,
            bool reloadableOnly = true);
        void clearResourceGroup(const String& name);






        void destroyResourceGroup(const String& name);
        bool isResourceGroupInitialised(const String& name);
        bool isResourceGroupLoaded(const String& name);




        bool resourceGroupExists(const String& name);
        void addResourceLocation(const String& name, const String& locType,
            const String& resGroup = DEFAULT_RESOURCE_GROUP_NAME, bool recursive = false, bool readOnly = true);

        void removeResourceLocation(const String& name,
            const String& resGroup = DEFAULT_RESOURCE_GROUP_NAME);

        bool resourceLocationExists(const String& name,
            const String& resGroup = DEFAULT_RESOURCE_GROUP_NAME);
        void declareResource(const String& name, const String& resourceType,
            const String& groupName = DEFAULT_RESOURCE_GROUP_NAME,
            const NameValuePairList& loadParameters = NameValuePairList());
        void declareResource(const String& name, const String& resourceType,
            const String& groupName, ManualResourceLoader* loader,
            const NameValuePairList& loadParameters = NameValuePairList());
        void undeclareResource(const String& name, const String& groupName);
        DataStreamPtr openResource(const String& resourceName,
            const String& groupName = DEFAULT_RESOURCE_GROUP_NAME,
            bool searchGroupsIfNotFound = true, Resource* resourceBeingLoaded = 0);
        DataStreamListPtr openResources(const String& pattern,
            const String& groupName = DEFAULT_RESOURCE_GROUP_NAME);
        StringVectorPtr listResourceNames(const String& groupName, bool dirs = false);







        FileInfoListPtr listResourceFileInfo(const String& groupName, bool dirs = false);
        StringVectorPtr findResourceNames(const String& groupName, const String& pattern,
            bool dirs = false);





        bool resourceExists(const String& group, const String& filename);




        bool resourceExistsInAnyGroup(const String& filename);







        const String& findGroupContainingResource(const String& filename);
        FileInfoListPtr findResourceFileInfo(const String& group, const String& pattern,
            bool dirs = false);


        time_t resourceModifiedTime(const String& group, const String& filename);




        StringVectorPtr listResourceLocations(const String& groupName);







        StringVectorPtr findResourceLocation(const String& groupName, const String& pattern);
        DataStreamPtr createResource(const String& filename, const String& groupName = DEFAULT_RESOURCE_GROUP_NAME,
            bool overwrite = false, const String& locationPattern = BLANKSTRING);
        void deleteResource(const String& filename, const String& groupName = DEFAULT_RESOURCE_GROUP_NAME,
            const String& locationPattern = BLANKSTRING);
        void deleteMatchingResources(const String& filePattern, const String& groupName = DEFAULT_RESOURCE_GROUP_NAME,
            const String& locationPattern = BLANKSTRING);




        void addResourceGroupListener(ResourceGroupListener* l);

        void removeResourceGroupListener(ResourceGroupListener* l);







        void setWorldResourceGroupName(const String& groupName) {mWorldGroupName = groupName;}


        const String& getWorldResourceGroupName(void) const { return mWorldGroupName; }
        void linkWorldGeometryToResourceGroup(const String& group,
            const String& worldGeometry, SceneManager* sceneManager);





        void unlinkWorldGeometryFromResourceGroup(const String& group);
        bool isResourceGroupInGlobalPool(const String& name);


        void shutdownAll(void);
        void _registerResourceManager(const String& resourceType, ResourceManager* rm);







        void _unregisterResourceManager(const String& resourceType);



        ResourceManagerIterator getResourceManagerIterator()
        { return ResourceManagerIterator(
            mResourceManagerMap.begin(), mResourceManagerMap.end()); }





        void _registerScriptLoader(ScriptLoader* su);




        void _unregisterScriptLoader(ScriptLoader* su);




        ScriptLoader *_findScriptLoader(const String &pattern);




        ResourceManager* _getResourceManager(const String& resourceType);




        void _notifyResourceCreated(ResourcePtr& res);




        void _notifyResourceRemoved(ResourcePtr& res);



        void _notifyResourceGroupChanged(const String& oldGroup, Resource* res);





        void _notifyAllResourcesRemoved(ResourceManager* manager);
        void _notifyWorldGeometryStageStarted(const String& description);







        void _notifyWorldGeometryStageEnded(void);






        StringVector getResourceGroups(void);






        ResourceDeclarationList getResourceDeclarationList(const String& groupName);





        const LocationList& getResourceLocationList(const String& groupName);


        void setLoadingListener(ResourceLoadingListener *listener);

        ResourceLoadingListener *getLoadingListener();
        static ResourceGroupManager& getSingleton(void);
        static ResourceGroupManager* getSingletonPtr(void);

    };


}



namespace Ogre {
namespace v1 {
    class BillboardChain : public MovableObject, public Renderable
    {

    public:



        class Element
        {

        public:

            Element();

            Element(const Vector3 &position,
                Real width,
                Real texCoord,
                const ColourValue &colour,
                const Quaternion &orientation);

            Vector3 position;
            Real width;

            Real texCoord;
            ColourValue colour;


            Quaternion orientation;
        };
        typedef vector<Element>::type ElementList;
        BillboardChain( IdType id, ObjectMemoryManager *objectMemoryManager, SceneManager *manager,
                        size_t maxElements = 20, size_t numberOfChains = 1,
                        bool useTextureCoords = true, bool useColours = true,
                        bool dynamic = true );

        virtual ~BillboardChain();



        virtual void setMaxChainElements(size_t maxElements);


        virtual size_t getMaxChainElements(void) const { return mMaxElementsPerChain; }



        virtual void setNumberOfChains(size_t numChains);



        virtual size_t getNumberOfChains(void) const { return mChainCount; }







        virtual void setUseTextureCoords(bool use);



        virtual bool getUseTextureCoords(void) const { return mUseTexCoords; }




        enum TexCoordDirection
        {

            TCD_U,

            TCD_V
        };




        virtual void setTextureCoordDirection(TexCoordDirection dir);



        virtual TexCoordDirection getTextureCoordDirection(void) { return mTexCoordDir; }






        virtual void setOtherTextureCoordRange(Real start, Real end);



        virtual const Real* getOtherTextureCoordRange(void) const { return mOtherTexCoordRange; }







        virtual void setUseVertexColours(bool use);



        virtual bool getUseVertexColours(void) const { return mUseVertexColour; }




        virtual void setDynamic(bool dyn);




        virtual bool getDynamic(void) const { return mDynamic; }
        virtual void addChainElement(size_t chainIndex,
            const Element& billboardChainElement);



        virtual void removeChainElement(size_t chainIndex);






        virtual void updateChainElement(size_t chainIndex, size_t elementIndex,
            const Element& billboardChainElement);





        virtual const Element& getChainElement(size_t chainIndex, size_t elementIndex) const;


        virtual size_t getNumChainElements(size_t chainIndex) const;


        virtual void clearChain(size_t chainIndex);

        virtual void clearAllChains(void);
        void setFaceCamera( bool faceCamera, const Vector3 &normalVector=Vector3::UNIT_X );



        Real getSquaredViewDepth(const Camera* cam) const;
        const AxisAlignedBox& getBoundingBox(void) const;
        const String& getMovableType(void) const;
        void _updateRenderQueue(RenderQueue *, Camera *camera, const Camera *lodCamera);
        void getRenderOperation(RenderOperation &, bool casterPass);
        virtual bool preRender(SceneManager* sm, RenderSystem* rsys);
        void getWorldTransforms(Matrix4 *) const;
        const LightList& getLights(void) const;

    protected:


        size_t mMaxElementsPerChain;

        size_t mChainCount;

        bool mUseTexCoords;

        bool mUseVertexColour;

        bool mDynamic;

        VertexData* mVertexData;

        IndexData* mIndexData;

        bool mVertexDeclDirty;

        bool mBuffersNeedRecreating;

        mutable bool mBoundsDirty;

        bool mIndexContentDirty;

        bool mVertexContentDirty;

        mutable AxisAlignedBox mAABB;

        mutable Real mRadius;

        TexCoordDirection mTexCoordDir;

        Real mOtherTexCoordRange[2];

        Camera *mVertexCameraUsed;

        bool mFaceCamera;



        Vector3 mNormalBase;



        ElementList mChainElementList;
        struct ChainSegment
        {

            size_t start;

            size_t head;

            size_t tail;
        };
        typedef vector<ChainSegment>::type ChainSegmentList;
        ChainSegmentList mChainSegmentList;


        virtual void setupChainContainers(void);

        virtual void setupVertexDeclaration(void);

        virtual void setupBuffers(void);

        virtual void updateVertexBuffer(Camera* cam);

        virtual void updateIndexBuffer(void);
        virtual void updateBoundingBox(void) const;


        static const size_t SEGMENT_EMPTY;
    };



    class BillboardChainFactory : public MovableObjectFactory
    {
    protected:
        virtual MovableObject* createInstanceImpl( IdType id, ObjectMemoryManager *objectMemoryManager,
                                                   SceneManager *manager,
                                                   const NameValuePairList* params = 0 );
    public:
        BillboardChainFactory() {}
        ~BillboardChainFactory() {}

        static String FACTORY_TYPE_NAME;

        const String& getType(void) const;
        void destroyInstance( MovableObject* obj);

    };




}
}


namespace Ogre {
    template <class TContainer, class TContainerValueType, typename TCompValueType>
    class RadixSort
    {
    public:
        typedef typename TContainer::iterator ContainerIter;
    protected:


        int mCounters[4][256];

        int mOffsets[256];

        int mSortSize;

        int mNumPasses;

        struct SortEntry
        {
            TCompValueType key;
            ContainerIter iter;
            SortEntry() {}
            SortEntry(TCompValueType k, ContainerIter it)
                : key(k), iter(it) {}

        };

        typedef std::vector<SortEntry, STLAllocator<SortEntry, GeneralAllocPolicy> > SortVector;
        SortVector mSortArea1;
        SortVector mSortArea2;
        SortVector* mSrc;
        SortVector* mDest;
        TContainer mTmpContainer;


        void sortPass(int byteIndex)
        {


            mOffsets[0] = 0;
            for (int i = 1; i < 256; ++i)
            {
                mOffsets[i] = mOffsets[i-1] + mCounters[byteIndex][i-1];
            }


            for (int i = 0; i < mSortSize; ++i)
            {
                unsigned char byteVal = getByte(byteIndex, (*mSrc)[i].key);
                (*mDest)[mOffsets[byteVal]++] = (*mSrc)[i];
            }

        }
        template <typename T>
        void finalPass(int byteIndex, T val)
        {

            sortPass(byteIndex);
        }


        void finalPass(int byteIndex, int val)
        {
            int numNeg = 0;

            for (int i = 128; i < 256; ++i)
            {
                numNeg += mCounters[byteIndex][i];
            }


            mOffsets[0] = numNeg;
            for (int i = 1; i < 128; ++i)
            {
                mOffsets[i] = mOffsets[i-1] + mCounters[byteIndex][i-1];
            }


            mOffsets[128] = 0;
            for (int i = 129; i < 256; ++i)
            {
                mOffsets[i] = mOffsets[i-1] + mCounters[byteIndex][i-1];
            }


            for (int i = 0; i < mSortSize; ++i)
            {
                unsigned char byteVal = getByte(byteIndex, (*mSrc)[i].key);
                (*mDest)[mOffsets[byteVal]++] = (*mSrc)[i];
            }
        }



        void finalPass(int byteIndex, float val)
        {



            int numNeg = 0;

            for (int i = 128; i < 256; ++i)
            {
                numNeg += mCounters[byteIndex][i];
            }


            mOffsets[0] = numNeg;
            for (int i = 1; i < 128; ++i)
            {
                mOffsets[i] = mOffsets[i-1] + mCounters[byteIndex][i-1];
            }





            mOffsets[255] = mCounters[byteIndex][255];
            for (int i = 254; i > 127; --i)
            {
                mOffsets[i] = mOffsets[i+1] + mCounters[byteIndex][i];
            }


            for (int i = 0; i < mSortSize; ++i)
            {
                unsigned char byteVal = getByte(byteIndex, (*mSrc)[i].key);
                if (byteVal > 127)
                {

                    (*mDest)[--mOffsets[byteVal]] = (*mSrc)[i];
                }
                else
                {

                    (*mDest)[mOffsets[byteVal]++] = (*mSrc)[i];
                }
            }
        }

        inline unsigned char getByte(int byteIndex, TCompValueType val)
        {

            return ((unsigned char*)(&val))[byteIndex];



        }

    public:

        RadixSort() {}
        ~RadixSort() {}






        template <class TFunction>
        void sort(TContainer& container, TFunction func)
        {
            if (container.empty())
                return;


            mSortSize = static_cast<int>(container.size());
            mSortArea1.resize(container.size());
            mSortArea2.resize(container.size());


            mTmpContainer = container;

            mNumPasses = sizeof(TCompValueType);



            int p;
            for (p = 0; p < mNumPasses; ++p)
                memset(mCounters[p], 0, sizeof(int) * 256);


            ContainerIter i = mTmpContainer.begin();
            TCompValueType prevValue = func.operator()(*i);
            bool needsSorting = false;
            for (int u = 0; i != mTmpContainer.end(); ++i, ++u)
            {

                TCompValueType val = func.operator()(*i);

                if (!needsSorting && val < prevValue)
                    needsSorting = true;


                mSortArea1[u].key = val;
                mSortArea1[u].iter = i;


                for (p = 0; p < mNumPasses; ++p)
                {
                    unsigned char byteVal = getByte(p, val);
                    mCounters[p][byteVal]++;
                }

                prevValue = val;

            }


            if (!needsSorting)
                return;



            mSrc = &mSortArea1;
            mDest = &mSortArea2;

            for (p = 0; p < mNumPasses - 1; ++p)
            {
                sortPass(p);

                SortVector* tmp = mSrc;
                mSrc = mDest;
                mDest = tmp;
            }

            finalPass(p, prevValue);


            int c = 0;
            for (i = container.begin();
                i != container.end(); ++i, ++c)
            {
                *i = *((*mDest)[c].iter);
            }
        }

    };




}




namespace Ogre {

    class Camera;
    class MovableObject;
    struct QueuedRenderable
    {
        uint64 hash;
        Renderable *renderable;
        MovableObject const *movableObject;

        QueuedRenderable() : hash( 0 ), renderable( 0 ), movableObject( 0 ) {}
        QueuedRenderable( uint64 _hash, Renderable *_renderable,
                          const MovableObject *_movableObject ) :
            hash( _hash ), renderable( _renderable ), movableObject( _movableObject ) {}

        bool operator < ( const QueuedRenderable &_r ) const
        {
            return this->hash < _r.hash;
        }
    };
    class RenderQueue : public RenderQueueAlloc
    {
    public:
        enum Modes
        {




            V1_LEGACY,
            V1_FAST,






            FAST
        };

    private:
        typedef FastArray<QueuedRenderable> QueuedRenderableArray;

        struct ThreadRenderQueue
        {
            QueuedRenderableArray q;

            uint8 padding[128];
        };

        typedef FastArray<ThreadRenderQueue> QueuedRenderableArrayPerThread;

        struct RenderQueueGroup
        {
            QueuedRenderableArrayPerThread mQueuedRenderablesPerThread;
            QueuedRenderableArray mQueuedRenderables;
            bool mDoSort;
            bool mSorted;
            Modes mMode;

            RenderQueueGroup() : mDoSort( true ), mSorted( false ), mMode( V1_FAST ) {}
        };

        typedef vector<IndirectBufferPacked*>::type IndirectBufferPackedVec;

        RenderQueueGroup mRenderQueues[256];

        HlmsManager *mHlmsManager;
        SceneManager*mSceneManager;
        VaoManager *mVaoManager;

        bool mLastWasCasterPass;
        HlmsMacroblock const *mLastMacroblock;
        HlmsBlendblock const *mLastBlendblock;
        uint32 mLastVaoName;
        v1::VertexData const *mLastVertexData;
        v1::IndexData const *mLastIndexData;
        uint32 mLastTextureHash;

        CommandBuffer *mCommandBuffer;
        IndirectBufferPackedVec mFreeIndirectBuffers;
        IndirectBufferPackedVec mUsedIndirectBuffers;
        IndirectBufferPacked* getIndirectBuffer( size_t numDraws );

        inline __attribute__((always_inline)) void addRenderable( size_t threadIdx, uint8 renderQueueId, bool casterPass,
                                        Renderable* pRend, const MovableObject *pMovableObject,
                                        bool isV1 );

        void renderES2( RenderSystem *rs, bool casterPass, bool dualParaboloid,
                        HlmsCache passCache[], const RenderQueueGroup &renderQueueGroup );



        unsigned char* renderGL3( bool casterPass, bool dualParaboloid,
                        HlmsCache passCache[],
                        const RenderQueueGroup &renderQueueGroup,
                        IndirectBufferPacked *indirectBuffer,
                        unsigned char *indirectDraw, unsigned char *startIndirectDraw );
        void renderGL3V1( bool casterPass, bool dualParaboloid,
                          HlmsCache passCache[],
                          const RenderQueueGroup &renderQueueGroup );

    public:
        RenderQueue( HlmsManager *hlmsManager, SceneManager *sceneManager, VaoManager *vaoManager );
        ~RenderQueue();


        void clear(void);







        void clearState(void);


        void addRenderableV1( uint8 renderQueueId, bool casterPass, Renderable* pRend,
                              const MovableObject *pMovableObject );
        void addRenderableV2( size_t threadIdx, uint8 renderQueueId, bool casterPass,
                              Renderable* pRend, const MovableObject *pMovableObject );

        void render( RenderSystem *rs, uint8 firstRq, uint8 lastRq,
                     bool casterPass, bool dualParaboloid );


        void renderSingleObject( Renderable* pRend, const MovableObject *pMovableObject,
                                 RenderSystem *rs, bool casterPass, bool dualParaboloid );


        void frameEnded(void);







        void setRenderQueueMode( uint8 rqId, RenderQueue::Modes newMode );
        RenderQueue::Modes getRenderQueueMode( uint8 rqId ) const;
        void setSortRenderQueue( uint8 rqId, bool bSort );
        bool getSortRenderQueue( uint8 rqId ) const;
    };



    class RqBits
    {
    public:
        static const int SubRqIdBits;
        static const int TransparencyBits;
        static const int MacroblockBits;
        static const int ShaderBits;
        static const int MeshBits;
        static const int TextureBits;
        static const int DepthBits;

        static const int SubRqIdShift;
        static const int TransparencyShift;
        static const int MacroblockShift;
        static const int ShaderShift;
        static const int MeshShift;
        static const int TextureShift;
        static const int DepthShift;

        static const int DepthShiftTransp;
        static const int MacroblockShiftTransp;
        static const int ShaderShiftTransp;
        static const int MeshShiftTransp;
        static const int TextureShiftTransp;
    };




}



namespace Ogre {
namespace v1 {
    enum BillboardOrigin
    {
        BBO_TOP_LEFT,
        BBO_TOP_CENTER,
        BBO_TOP_RIGHT,
        BBO_CENTER_LEFT,
        BBO_CENTER,
        BBO_CENTER_RIGHT,
        BBO_BOTTOM_LEFT,
        BBO_BOTTOM_CENTER,
        BBO_BOTTOM_RIGHT
    };

    enum BillboardRotationType
    {

        BBR_VERTEX,

        BBR_TEXCOORD
    };

    enum BillboardType
    {

        BBT_POINT,

        BBT_ORIENTED_COMMON,

        BBT_ORIENTED_SELF,

        BBT_PERPENDICULAR_COMMON,

        BBT_PERPENDICULAR_SELF
    };
    class BillboardSet : public MovableObject, public Renderable
    {
    protected:

        BillboardOrigin mOriginType;

        BillboardRotationType mRotationType;

        String mMaterialName;
        String mMaterialGroup;


        Real mDefaultWidth;

        Real mDefaultHeight;


        bool mAllDefaultSize;


        bool mAutoExtendPool;


        bool mSortingEnabled;


        bool mAccurateFacing;

        bool mAllDefaultRotation;
        bool mWorldSpace;

        typedef list<Billboard*>::type ActiveBillboardList;
        typedef list<Billboard*>::type FreeBillboardList;
        typedef vector<Billboard*>::type BillboardPool;
        ActiveBillboardList mActiveBillboards;
        FreeBillboardList mFreeBillboards;





        BillboardPool mBillboardPool;


        VertexData* mVertexData;

        HardwareVertexBufferSharedPtr mMainBuf;
        typedef vector<HardwareVertexBufferSharedPtr>::type HardwareVertexBufferSharedPtrVec;
        typedef vector<HardwareVertexBufferSharedPtrVec>::type HardwareVertexBufferSharedPtrVecVec;
        HardwareVertexBufferSharedPtrVecVec mMainBuffers;
        uint32 mLastLockedBuffer;


        uint32 mLastLockedFrame;

        float* mLockPtr;



        Vector3 mVOffset[4];

        Real mLeftOff, mRightOff, mTopOff, mBottomOff;

        Vector3 mCamX, mCamY;

        Vector3 mCamDir;

        Quaternion mCamQ;

        Vector3 mCamPos;


        IndexData* mIndexData;


        bool mCullIndividual;

        typedef vector< Ogre::FloatRect >::type TextureCoordSets;
        TextureCoordSets mTextureCoords;


        BillboardType mBillboardType;


        Vector3 mCommonDirection;

        Vector3 mCommonUpVector;



        VaoManager *mVaoManager;


        inline bool billboardVisible(const Camera* cam, const Billboard& bill);


        unsigned short mNumVisibleBillboards;


        virtual void increasePool(size_t size);
        void genBillboardAxes(Vector3* pX, Vector3 *pY, const Billboard* pBill = 0);



        void getParametricOffsets(Real& left, Real& right, Real& top, Real& bottom);





        void genVertices(const Vector3* const offsets, const Billboard& pBillboard);
        void genVertOffsets(Real inleft, Real inright, Real intop, Real inbottom,
            Real width, Real height,
            const Vector3& x, const Vector3& y, Vector3* pDestVec);



        struct SortByDirectionFunctor
        {

            Vector3 sortDir;

            SortByDirectionFunctor(const Vector3& dir);
            float operator()(Billboard* bill) const;
        };


        struct SortByDistanceFunctor
        {

            Vector3 sortPos;

            SortByDistanceFunctor(const Vector3& pos);
            float operator()(Billboard* bill) const;
        };

        static RadixSort<ActiveBillboardList, Billboard*, float> mRadixSorter;


        bool mPointRendering;



    private:

        bool mBuffersCreated;

        size_t mPoolSize;

        bool mExternalData;

        bool mAutoUpdate;

        bool mBillboardDataChanged;

        void createExtraVertexBuffer( size_t vertexSize );



        void _createBuffers(void);


        void _destroyBuffers(void);

    public:
        BillboardSet( IdType id, ObjectMemoryManager *objectMemoryManager, SceneManager *manager,
                      unsigned int poolSize = 20, bool externalDataSource = false,
                      uint8 renderQueueId=0 );

        virtual ~BillboardSet();
        Billboard* createBillboard(
            const Vector3& position,
            const ColourValue& colour = ColourValue::White );
        Billboard* createBillboard(
            Real x, Real y, Real z,
            const ColourValue& colour = ColourValue::White );



        virtual int getNumBillboards(void) const;
        virtual void setAutoextend(bool autoextend);





        virtual bool getAutoextend(void) const;




        virtual void setSortingEnabled(bool sortenable);





        virtual bool getSortingEnabled(void) const;
        virtual void setPoolSize(size_t size);







        virtual unsigned int getPoolSize(void) const;




        virtual void clear();
        virtual Billboard* getBillboard(unsigned int index) const;





        virtual void removeBillboard(unsigned int index);





        virtual void removeBillboard(Billboard* pBill);
        virtual void setBillboardOrigin(BillboardOrigin origin);





        virtual BillboardOrigin getBillboardOrigin(void) const;
        virtual void setBillboardRotationType(BillboardRotationType rotationType);





        virtual BillboardRotationType getBillboardRotationType(void) const;
        virtual void setDefaultDimensions(Real width, Real height);


        virtual void setDefaultWidth(Real width);

        virtual Real getDefaultWidth(void) const;

        virtual void setDefaultHeight(Real height);

        virtual Real getDefaultHeight(void) const;


        virtual bool getUseIdentityWorldMatrix(void) const;





        virtual void _notifyCurrentCamera( const Camera* cam );






        void beginBillboards(size_t numBillboards = 0);

        void injectBillboard(const Billboard& bb, const Camera *camera);

        void endBillboards(void);





        void setBounds(const Aabb& aabb, Real radius);





        virtual void _updateRenderQueue(RenderQueue* queue, Camera *camera, const Camera *lodCamera);


        void _updateRenderQueueImpl(RenderQueue* queue, Camera *camera, const Camera *lodCamera);





        virtual void getRenderOperation(RenderOperation& op, bool casterPass);





        virtual void getWorldTransforms(Matrix4* xform) const;



        virtual void _notifyBillboardResized(void);



        virtual void _notifyBillboardRotated(void);


        virtual bool getCullIndividually(void) const;
        virtual void setCullIndividually(bool cullIndividual);
        virtual void setBillboardType(BillboardType bbt);


        virtual BillboardType getBillboardType(void) const;
        virtual void setCommonDirection(const Vector3& vec);


        virtual const Vector3& getCommonDirection(void) const;
        virtual void setCommonUpVector(const Vector3& vec);


        virtual const Vector3& getCommonUpVector(void) const;
        virtual void setUseAccurateFacing(bool acc) { mAccurateFacing = acc; }




        virtual bool getUseAccurateFacing(void) const { return mAccurateFacing; }


        virtual const String& getMovableType(void) const;


        Real getSquaredViewDepth(const Camera* cam) const;


        virtual void _updateBounds(void);

        const LightList& getLights(void) const;


        virtual void _sortBillboards(void);


        virtual SortMode _getSortMode(void) const;






        virtual void setBillboardsInWorldSpace(bool ws) { mWorldSpace = ws; }



        bool getBillboardsInWorldSpace() { return mWorldSpace; }
        virtual void setTextureCoords( Ogre::FloatRect const * coords, uint16 numCoords );
        virtual void setTextureStacksAndSlices( uchar stacks, uchar slices );







        virtual Ogre::FloatRect const * getTextureCoords( uint16 * oNumCoords );
        virtual void setPointRenderingEnabled(bool enabled);


        virtual bool isPointRenderingEnabled(void) const
        { return mPointRendering; }
        void setAutoUpdate(bool autoUpdate);


        bool getAutoUpdate(void) const { return mAutoUpdate; }





        void notifyBillboardDataChanged(void) { mBillboardDataChanged = true; }

        virtual void setMaterial( const MaterialPtr& material );
        virtual void setDatablock( HlmsDatablock *datablock );

    };


    class BillboardSetFactory : public MovableObjectFactory
    {
    protected:
        virtual MovableObject* createInstanceImpl( IdType id, ObjectMemoryManager *objectMemoryManager,
                                                   SceneManager* manager,
                                                   const NameValuePairList* params = 0 );
    public:
        BillboardSetFactory() {}
        ~BillboardSetFactory() {}

        static String FACTORY_TYPE_NAME;

        const String& getType(void) const;
        void destroyInstance( MovableObject* obj);

    };


}
}



namespace Ogre {
namespace v1 {
    class OldNode : public NodeAlloc
    {
    public:


        enum TransformSpace
        {

            TS_LOCAL,

            TS_PARENT,

            TS_WORLD
        };
        typedef unordered_map<String, OldNode*>::type ChildOldNodeMap;
        typedef MapIterator<ChildOldNodeMap> ChildOldNodeIterator;
        typedef ConstMapIterator<ChildOldNodeMap> ConstChildOldNodeIterator;



        class Listener
        {
        public:
            Listener() {}
            virtual ~Listener() {}







            virtual void OldNodeUpdated(const OldNode*) {}

            virtual void OldNodeDestroyed(const OldNode*) {}

            virtual void OldNodeAttached(const OldNode*) {}

            virtual void OldNodeDetached(const OldNode*) {}
        };

    protected:

        OldNode* mParent;

        ChildOldNodeMap mChildren;

        typedef set<OldNode*>::type ChildUpdateSet;

        mutable ChildUpdateSet mChildrenToUpdate;

        mutable bool mNeedParentUpdate;

        mutable bool mNeedChildUpdate;

        mutable bool mParentNotified ;

        mutable bool mQueuedForUpdate;


        String mName;


        Quaternion mOrientation;


        Vector3 mPosition;


        Vector3 mScale;


        bool mInheritOrientation;


        bool mInheritScale;


        virtual void setParent(OldNode* parent);
        mutable Quaternion mDerivedOrientation;
        mutable Vector3 mDerivedPosition;
        mutable Vector3 mDerivedScale;







        virtual void _updateFromParent(void) const;







        virtual void updateFromParentImpl(void) const;



        virtual OldNode* createChildImpl(void) = 0;


        virtual OldNode* createChildImpl(const String& name) = 0;


        Vector3 mInitialPosition;

        Quaternion mInitialOrientation;

        Vector3 mInitialScale;


        mutable Matrix4 mCachedTransform;
        mutable bool mCachedTransformOutOfDate;


        Listener* mListener;

        typedef vector<OldNode*>::type QueuedUpdates;
        static QueuedUpdates msQueuedUpdates;


        UserObjectBindings mUserObjectBindings;

    public:




        OldNode();




        OldNode(const String& name);

        virtual ~OldNode();


        const String& getName(void) const;



        virtual OldNode* getParent(void) const;



        virtual const Quaternion & getOrientation() const;
        virtual void setOrientation( const Quaternion& q );
        virtual void setOrientation( Real w, Real x, Real y, Real z);
        virtual void resetOrientation(void);



        virtual void setPosition(const Vector3& pos);



        virtual void setPosition(Real x, Real y, Real z);



        virtual const Vector3 & getPosition(void) const;
        virtual void setScale(const Vector3& scale);
        virtual void setScale(Real x, Real y, Real z);



        virtual const Vector3 & getScale(void) const;
        virtual void setInheritOrientation(bool inherit);
        virtual bool getInheritOrientation(void) const;
        virtual void setInheritScale(bool inherit);





        virtual bool getInheritScale(void) const;
        virtual void scale(const Vector3& scale);
        virtual void scale(Real x, Real y, Real z);
        virtual void translate(const Vector3& d, TransformSpace relativeTo = TS_PARENT);
        virtual void translate(Real x, Real y, Real z, TransformSpace relativeTo = TS_PARENT);
        virtual void translate(const Matrix3& axes, const Vector3& move, TransformSpace relativeTo = TS_PARENT);
        virtual void translate(const Matrix3& axes, Real x, Real y, Real z, TransformSpace relativeTo = TS_PARENT);



        virtual void roll(const Radian& angle, TransformSpace relativeTo = TS_LOCAL);



        virtual void pitch(const Radian& angle, TransformSpace relativeTo = TS_LOCAL);



        virtual void yaw(const Radian& angle, TransformSpace relativeTo = TS_LOCAL);



        virtual void rotate(const Vector3& axis, const Radian& angle, TransformSpace relativeTo = TS_LOCAL);



        virtual void rotate(const Quaternion& q, TransformSpace relativeTo = TS_LOCAL);



        virtual Matrix3 getLocalAxes(void) const;







        virtual OldNode* createChild(
            const Vector3& translate = Vector3::ZERO,
            const Quaternion& rotate = Quaternion::IDENTITY );
        virtual OldNode* createChild(const String& name, const Vector3& translate = Vector3::ZERO, const Quaternion& rotate = Quaternion::IDENTITY);





        virtual void addChild(OldNode* child);



        virtual unsigned short numChildren(void) const;





        virtual OldNode* getChild(unsigned short index) const;



        virtual OldNode* getChild(const String& name) const;
        virtual ChildOldNodeIterator getChildIterator(void);
        virtual ConstChildOldNodeIterator getChildIterator(void) const;
        virtual OldNode* removeChild(unsigned short index);







        virtual OldNode* removeChild(OldNode* child);






        virtual OldNode* removeChild(const String& name);



        virtual void removeAllChildren(void);





        virtual void _setDerivedPosition(const Vector3& pos);






        virtual void _setDerivedOrientation(const Quaternion& q);



        virtual const Quaternion & _getDerivedOrientation(void) const;



        virtual const Vector3 & _getDerivedPosition(void) const;



        virtual const Vector3 & _getDerivedScale(void) const;
        virtual const Matrix4& _getFullTransform(void) const;
        virtual void _update(bool updateChildren, bool parentHasChanged);






        virtual void setListener(Listener* listener) { mListener = listener; }



        virtual Listener* getListener(void) const { return mListener; }
        virtual void setInitialState(void);


        virtual void resetToInitialState(void);





        virtual const Vector3& getInitialPosition(void) const;


        virtual Vector3 convertWorldToLocalPosition( const Vector3 &worldPos );



        virtual Vector3 convertLocalToWorldPosition( const Vector3 &localPos );


        virtual Quaternion convertWorldToLocalOrientation( const Quaternion &worldOrientation );



        virtual Quaternion convertLocalToWorldOrientation( const Quaternion &localOrientation );


        virtual const Quaternion& getInitialOrientation(void) const;


        virtual const Vector3& getInitialScale(void) const;


        virtual Real getSquaredViewDepth(const Camera* cam) const;
        virtual void needUpdate(bool forceParentUpdate = false);




        virtual void requestUpdate(OldNode* child, bool forceParentUpdate = false);

        virtual void cancelUpdate(OldNode* child);
        static void queueNeedUpdate(OldNode* n);

        static void processQueuedUpdates(void);
        virtual void setUserAny(const Any& anything) { getUserObjectBindings().setUserAny(anything); }




        virtual const Any& getUserAny(void) const { return getUserObjectBindings().getUserAny(); }





        UserObjectBindings& getUserObjectBindings() { return mUserObjectBindings; }





        const UserObjectBindings& getUserObjectBindings() const { return mUserObjectBindings; }

    };



}
}




namespace Ogre
{
namespace v1
{
    class OldBone : public OldNode
    {
    public:

        OldBone(unsigned short handle, Skeleton* creator);

        OldBone(const String& name, unsigned short handle, Skeleton* creator);
        ~OldBone();
        OldBone* createChild(unsigned short handle,
            const Vector3& translate = Vector3::ZERO, const Quaternion& rotate = Quaternion::IDENTITY);



        unsigned short getHandle(void) const;




        void setBindingPose(void);







        void reset(void);
        void setManuallyControlled(bool manuallyControlled);


        bool isManuallyControlled() const;






        void _getOffsetTransform(Matrix4& m) const;


        const Vector3& _getBindingPoseInverseScale(void) const { return mBindDerivedInverseScale; }

        const Vector3& _getBindingPoseInversePosition(void) const { return mBindDerivedInversePosition; }

        const Quaternion& _getBindingPoseInverseOrientation(void) const { return mBindDerivedInverseOrientation; }


        void needUpdate(bool forceParentUpdate = false);


    protected:

        unsigned short mHandle;


        bool mManuallyControlled;


        OldNode* createChildImpl(void);

        OldNode* createChildImpl(const String& name);


        Skeleton* mCreator;


        Vector3 mBindDerivedInverseScale;

        Quaternion mBindDerivedInverseOrientation;

        Vector3 mBindDerivedInversePosition;
    };




}
}
namespace Ogre {
namespace v1 {

    class HardwareBufferManagerBase;
    class HardwareIndexBuffer : public HardwareBuffer
    {
        public:
            enum IndexType {
                IT_16BIT,
                IT_32BIT
            };

        protected:
            HardwareBufferManagerBase* mMgr;
            IndexType mIndexType;
            size_t mNumIndexes;
            size_t mIndexSize;

        public:

            HardwareIndexBuffer(HardwareBufferManagerBase* mgr, IndexType idxType, size_t numIndexes, HardwareBuffer::Usage usage,
                bool useSystemMemory, bool useShadowBuffer);
            ~HardwareIndexBuffer();

            HardwareBufferManagerBase* getManager() const { return mMgr; }

            IndexType getType(void) const { return mIndexType; }

            size_t getNumIndexes(void) const { return mNumIndexes; }

            size_t getIndexSize(void) const { return mIndexSize; }


    };



    class HardwareIndexBufferSharedPtr : public SharedPtr<HardwareIndexBuffer>
    {
    public:
        HardwareIndexBufferSharedPtr() : SharedPtr<HardwareIndexBuffer>() {}
        explicit HardwareIndexBufferSharedPtr(HardwareIndexBuffer* buf);
    };


    typedef HardwareBufferLockGuard<HardwareIndexBufferSharedPtr> HardwareIndexBufferLockGuard;



}
}

namespace Ogre {
namespace v1 {
    typedef vector<HardwareBuffer::Usage>::type BufferUsageList;



    class VertexData : public VertexDataAlloc
    {
    private:

        VertexData(const VertexData& rhs);

        VertexData& operator=(const VertexData& rhs);

        HardwareBufferManagerBase* mMgr;
    public:






        VertexData(HardwareBufferManagerBase* mgr = 0);
        VertexData(VertexDeclaration* dcl, VertexBufferBinding* bind);
        ~VertexData();




        VertexDeclaration* vertexDeclaration;



        VertexBufferBinding* vertexBufferBinding;

        bool mDeleteDclBinding;

        size_t vertexStart;

        size_t vertexCount;



        struct HardwareAnimationData
        {
            unsigned short targetBufferIndex;
            Real parametric;
        };
        typedef vector<HardwareAnimationData>::type HardwareAnimationDataList;

        HardwareAnimationDataList hwAnimationDataList;

        size_t hwAnimDataItemsUsed;






        VertexData* clone(bool copyData = true, HardwareBufferManagerBase* mgr = 0) const;
        void prepareForShadowVolume(void);
        HardwareVertexBufferSharedPtr hardwareShadowVolWBuffer;
        void reorganiseBuffers(VertexDeclaration* newDeclaration, const BufferUsageList& bufferUsage,
            HardwareBufferManagerBase* mgr = 0);
        void reorganiseBuffers(VertexDeclaration* newDeclaration, HardwareBufferManagerBase* mgr = 0);
        void closeGapsInBindings(void);
        void removeUnusedBuffers(void);
        void convertPackedColour(VertexElementType srcType, VertexElementType destType);
        ushort allocateHardwareAnimationElements(ushort count, bool animateNormals);


        HardwareBufferManagerBase* _getHardwareBufferManager(void) const { return mMgr; }

    };


    class IndexData : public IndexDataAlloc
    {
    protected:

        IndexData(const IndexData& rhs);

        IndexData& operator=(const IndexData& rhs);
    public:
        IndexData();
        ~IndexData();

        HardwareIndexBufferSharedPtr indexBuffer;


        size_t indexStart;


        size_t indexCount;






        IndexData* clone(bool copyData = true, HardwareBufferManagerBase* mgr = 0) const;
        void optimiseVertexCacheTriList(void);

    };






    class VertexCacheProfiler : public BufferAlloc
    {
        public:
            VertexCacheProfiler(unsigned int cachesize = 16)
                : size ( cachesize ), tail (0), buffersize (0), hit (0), miss (0)
            {
                cache = static_cast<uint32*>(::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GEOMETRY>::allocateBytes(sizeof(uint32)*(size)));
            }

            ~VertexCacheProfiler()
            {
                ::Ogre::CategorisedAllocPolicy<MEMCATEGORY_GEOMETRY>::deallocateBytes((void*)cache);
            }

            void profile(const HardwareIndexBufferSharedPtr& indexBuffer);
            void reset() { hit = 0; miss = 0; tail = 0; buffersize = 0; }
            void flush() { tail = 0; buffersize = 0; }

            unsigned int getHits() { return hit; }
            unsigned int getMisses() { return miss; }
            unsigned int getSize() { return size; }
        private:
            unsigned int size;
            uint32 *cache;

            unsigned int tail, buffersize;
            unsigned int hit, miss;

            bool inCache(unsigned int index);
    };


}
}



namespace Ogre
{
    enum OrientationMode
    {
        OR_DEGREE_0 = 0,
        OR_DEGREE_90 = 1,
        OR_DEGREE_180 = 2,
        OR_DEGREE_270 = 3,

        OR_PORTRAIT = OR_DEGREE_0,
        OR_LANDSCAPERIGHT = OR_DEGREE_90,
        OR_LANDSCAPELEFT = OR_DEGREE_270
    };



    enum ProjectionType
    {
        PT_ORTHOGRAPHIC,
        PT_PERSPECTIVE
    };



    enum FrustumPlane
    {
        FRUSTUM_PLANE_NEAR = 0,
        FRUSTUM_PLANE_FAR = 1,
        FRUSTUM_PLANE_LEFT = 2,
        FRUSTUM_PLANE_RIGHT = 3,
        FRUSTUM_PLANE_TOP = 4,
        FRUSTUM_PLANE_BOTTOM = 5
    };





    class Frustum : public MovableObject, public Renderable
    {
    protected:

        ProjectionType mProjType;


        Radian mFOVy;

        Real mFarDist;

        Real mNearDist;

        Real mAspect;

        Real mOrthoHeight;

        Vector2 mFrustumOffset;

        Real mFocalLength;


        mutable Plane mFrustumPlanes[6];


        mutable Quaternion mLastParentOrientation;
        mutable Vector3 mLastParentPosition;


        mutable Matrix4 mProjMatrixRS;

        mutable Matrix4 mProjMatrixRSDepth;

        mutable Matrix4 mProjMatrix;

        mutable Matrix4 mViewMatrix;

        mutable bool mRecalcFrustum;

        mutable bool mRecalcView;

        mutable bool mRecalcFrustumPlanes;

        mutable bool mRecalcWorldSpaceCorners;

        mutable bool mRecalcVertexData;

        bool mCustomViewMatrix;

        bool mCustomProjMatrix;

        bool mFrustumExtentsManuallySet;

        mutable Real mLeft, mRight, mTop, mBottom;

        mutable OrientationMode mOrientationMode;


        virtual void calcProjectionParameters(Real& left, Real& right, Real& bottom, Real& top) const;

        virtual void updateFrustum(void) const;

        virtual void updateView(void) const;

        virtual void updateFrustumImpl(void) const;

        virtual void updateViewImpl(void) const;
        virtual void updateFrustumPlanes(void) const;

        virtual void updateFrustumPlanesImpl(void) const;
        virtual void updateWorldSpaceCorners(void) const;

        virtual void updateWorldSpaceCornersImpl(void) const;
        virtual void updateVertexData(void) const;
        virtual bool isViewOutOfDate(void) const;
        virtual bool isFrustumOutOfDate(void) const;

        virtual void invalidateFrustum(void) const;

        virtual void invalidateView(void) const;


        static String msMovableType;

        mutable AxisAlignedBox mBoundingBox;
        mutable v1::VertexData mVertexData;
        mutable Vector3 mWorldSpaceCorners[8];


        bool mReflect;

        mutable Matrix4 mReflectMatrix;

        mutable Plane mReflectPlane;

        const MovablePlane* mLinkedReflectPlane;

        mutable Plane mLastLinkedReflectionPlane;


        bool mObliqueDepthProjection;

        mutable Plane mObliqueProjPlane;

        const MovablePlane* mLinkedObliqueProjPlane;

        mutable Plane mLastLinkedObliqueProjPlane;

    public:


        Frustum( IdType id, ObjectMemoryManager *objectMemoryManager );

        virtual ~Frustum();
        virtual void setFOVy(const Radian& fovy);



        virtual const Radian& getFOVy(void) const;
        virtual void setNearClipDistance(Real nearDist);



        virtual Real getNearClipDistance(void) const;
        virtual void setFarClipDistance(Real farDist);



        virtual Real getFarClipDistance(void) const;
        virtual void setAspectRatio(Real ratio);



        virtual Real getAspectRatio(void) const;
        virtual void setFrustumOffset(const Vector2& offset);
        virtual void setFrustumOffset(Real horizontal = 0.0, Real vertical = 0.0);



        virtual const Vector2& getFrustumOffset() const;





        virtual void setFocalLength(Real focalLength = 1.0);



        virtual Real getFocalLength() const;





        virtual void setFrustumExtents(Real left, Real right, Real top, Real bottom);

        virtual void resetFrustumExtents();

        virtual void getFrustumExtents(Real& outleft, Real& outright, Real& outtop, Real& outbottom) const;
        virtual const Matrix4& getProjectionMatrixRS(void) const;
        virtual const Matrix4& getProjectionMatrixWithRSDepth(void) const;
        virtual const Matrix4& getProjectionMatrix(void) const;



        virtual const Matrix4& getViewMatrix(void) const;





        virtual void calcViewMatrixRelative(const Vector3& relPos, Matrix4& matToUpdate) const;
        virtual void setCustomViewMatrix(bool enable,
            const Matrix4& viewMatrix = Matrix4::IDENTITY);

        virtual bool isCustomViewMatrixEnabled(void) const
        { return mCustomViewMatrix; }
        virtual void setCustomProjectionMatrix(bool enable,
            const Matrix4& projectionMatrix = Matrix4::IDENTITY);

        virtual bool isCustomProjectionMatrixEnabled(void) const
        { return mCustomProjMatrix; }





        const Plane* getFrustumPlanes(void) const;


        const Plane* _getCachedFrustumPlanes(void) const { return mFrustumPlanes; }





        const Plane& getFrustumPlane( unsigned short plane ) const;
        virtual bool isVisible(const AxisAlignedBox& bound, FrustumPlane* culledBy = 0) const;
        virtual bool isVisible(const Sphere& bound, FrustumPlane* culledBy = 0) const;
        virtual bool isVisible(const Vector3& vert, FrustumPlane* culledBy = 0) const;


        const AxisAlignedBox& getBoundingBox(void) const;


        const String& getMovableType(void) const;


        void getRenderOperation(v1::RenderOperation& op, bool casterPass);


        void getWorldTransforms(Matrix4* xform) const;


        Real getSquaredViewDepth(const Camera* cam) const;


        const LightList& getLights(void) const;

        void getCustomWorldSpaceCorners(
                    ArrayVector3 outCorners[(8 + 4 - 1) / 4],
                    Real customFarPlane ) const;







        virtual const Vector3* getWorldSpaceCorners(void) const;



        virtual void setProjectionType(ProjectionType pt);



        virtual ProjectionType getProjectionType(void) const;
        virtual void setOrthoWindow(Real w, Real h);





        virtual void setOrthoWindowHeight(Real h);





        virtual void setOrthoWindowWidth(Real w);


        virtual Real getOrthoWindowHeight() const;



        virtual Real getOrthoWindowWidth() const;






        virtual void enableReflection(const Plane& p);
        virtual void enableReflection(const MovablePlane* p);


        virtual void disableReflection(void);


        virtual bool isReflected(void) const { return mReflect; }

        virtual const Matrix4& getReflectionMatrix(void) const { return mReflectMatrix; }

        virtual const Plane& getReflectionPlane(void) const { return mReflectPlane; }
        virtual bool projectSphere(const Sphere& sphere,
            Real* left, Real* top, Real* right, Real* bottom) const;
        virtual void enableCustomNearClipPlane(const MovablePlane* plane);
        virtual void enableCustomNearClipPlane(const Plane& plane);

        virtual void disableCustomNearClipPlane(void);

        virtual bool isCustomNearClipPlaneEnabled(void) const
        { return mObliqueDepthProjection; }


        static const Real INFINITE_FAR_PLANE_ADJUST;


        virtual const Vector3& getPositionForViewUpdate(void) const;

        virtual const Quaternion& getOrientationForViewUpdate(void) const;



        PlaneBoundedVolume getPlaneBoundedVolume();





        void setOrientationMode(OrientationMode orientationMode);






        OrientationMode getOrientationMode() const;

    };




}




namespace Ogre {

    class Matrix4;
    class Ray;
    class Camera : public Frustum
    {
    public:


        class Listener
        {
        public:
            Listener() {}
            virtual ~Listener() {}


            virtual void cameraPreRenderScene(Camera* cam)
                        { (void)cam; }


            virtual void cameraPostRenderScene(Camera* cam)
                        { (void)cam; }


            virtual void cameraDestroyed(Camera* cam)
                        { (void)cam; }

        };
    protected:

        SceneManager *mSceneMgr;


        Quaternion mOrientation;


        Vector3 mPosition;


        mutable Quaternion mDerivedOrientation;
        mutable Vector3 mDerivedPosition;


        mutable Quaternion mRealOrientation;
        mutable Vector3 mRealPosition;


        bool mYawFixed;

        Vector3 mYawFixedAxis;


        unsigned int mVisFacesLastRender;


        unsigned int mVisBatchesLastRender;


        static String msMovableType;


        SceneNode* mAutoTrackTarget;

        Vector3 mAutoTrackOffset;


        Real mSceneLodFactor;

        Real mSceneLodFactorInv;





        Real mWLeft, mWTop, mWRight, mWBottom;

        bool mWindowSet;

        mutable vector<Plane>::type mWindowClipPlanes;

        mutable bool mRecalcWindow;

        Viewport* mLastViewport;



        bool mAutoAspectRatio;

        Frustum *mCullFrustum;

        bool mUseRenderingDistance;

        const Camera* mLodCamera;


        bool mUseMinPixelSize;

        Real mPixelDisplayRatio;


        vector<bool>::type mRenderedRqs;

        typedef vector<Listener*>::type ListenerList;
        ListenerList mListeners;



        bool isViewOutOfDate(void) const;

        void invalidateFrustum(void) const;

        void invalidateView(void) const;






        virtual void setWindowImpl(void) const;


        virtual vector<Vector4>::type getRayForwardIntersect(const Vector3& anchor, const Vector3 *dir, Real planeOffset) const;

    public:


        Camera( IdType id, ObjectMemoryManager *objectMemoryManager, SceneManager* sm );



        virtual ~Camera();


        virtual void addListener(Listener* l);

        virtual void removeListener(Listener* l);



        SceneManager* getSceneManager(void) const;



        void setPosition(Real x, Real y, Real z);



        void setPosition(const Vector3& vec);



        const Vector3& getPosition(void) const;



        void move(const Vector3& vec);



        void moveRelative(const Vector3& vec);






        void setDirection(Real x, Real y, Real z);



        void setDirection(const Vector3& vec);



        Vector3 getDirection(void) const;



        Vector3 getUp(void) const;



        Vector3 getRight(void) const;
        void lookAt( const Vector3& targetPoint );
        void lookAt(Real x, Real y, Real z);



        void roll(const Radian& angle);



        void yaw(const Radian& angle);



        void pitch(const Radian& angle);



        void rotate(const Vector3& axis, const Radian& angle);



        void rotate(const Quaternion& q);
        void setFixedYawAxis( bool useFixed, const Vector3& fixedAxis = Vector3::UNIT_Y );




        const Quaternion& getOrientation(void) const;



        void setOrientation(const Quaternion& q);
        void _cullScenePhase01(const Camera *lodCamera, Viewport *vp, uint8 firstRq, uint8 lastRq );

        void _renderScenePhase02(const Camera *lodCamera, Viewport *vp, uint8 firstRq, uint8 lastRq,
                                 bool includeOverlays);



                    friend std::ostream& operator<<(std::ostream& o, const Camera& c);



        void _notifyRenderedFaces(unsigned int numfaces);



        void _notifyRenderedBatches(unsigned int numbatches);



        unsigned int _getNumRenderedFaces(void) const;



        unsigned int _getNumRenderedBatches(void) const;



        const Quaternion& getDerivedOrientation(void) const;


        const Vector3& getDerivedPosition(void) const;


        Vector3 getDerivedDirection(void) const;


        Vector3 getDerivedUp(void) const;


        Vector3 getDerivedRight(void) const;


        const Vector3& _getCachedDerivedPosition(void) const { return mDerivedPosition; }



        const Quaternion& getRealOrientation(void) const;


        const Vector3& getRealPosition(void) const;


        Vector3 getRealDirection(void) const;


        Vector3 getRealUp(void) const;


        Vector3 getRealRight(void) const;


        void getWorldTransforms(Matrix4* mat) const;


        const String& getMovableType(void) const;
        void setAutoTracking(bool enabled, SceneNode* const target = 0,
            const Vector3& offset = Vector3::ZERO);
        void setLodBias(Real factor = 1.0);





        Real getLodBias(void) const;
        virtual void setLodCamera(const Camera* lodCam);







        virtual const Camera* getLodCamera() const;






        Ray getCameraToViewportRay(Real screenx, Real screeny) const;





        void getCameraToViewportRay(Real screenx, Real screeny, Ray* outRay) const;
        PlaneBoundedVolume getCameraToViewportBoxVolume(Real screenLeft,
            Real screenTop, Real screenRight, Real screenBottom, bool includeFarPlane = false);
        void getCameraToViewportBoxVolume(Real screenLeft,
            Real screenTop, Real screenRight, Real screenBottom,
            PlaneBoundedVolume* outVolume, bool includeFarPlane = false);


        Real _getLodBiasInverse(void) const;



        void _autoTrack(void);
        virtual void setWindow (Real left, Real top, Real right, Real bottom);

        virtual void resetWindow (void);

        virtual bool isWindowSet(void) const { return mWindowSet; }

        const vector<Plane>::type& getWindowPlanes(void) const;


        SceneNode* getAutoTrackTarget(void) const { return mAutoTrackTarget; }

        const Vector3& getAutoTrackOffset(void) const { return mAutoTrackOffset; }






        Viewport* getLastViewport(void) const {return mLastViewport;}

        void _notifyViewport(Viewport* viewport) {mLastViewport = viewport;}
        void setAutoAspectRatio(bool autoratio);



        bool getAutoAspectRatio(void) const;
        void setCullingFrustum(Frustum* frustum) { mCullFrustum = frustum; }

        Frustum* getCullingFrustum(void) const { return mCullFrustum; }





        virtual void forwardIntersect(const Plane& worldPlane, vector<Vector4>::type* intersect3d) const;


        bool isVisible(const AxisAlignedBox& bound, FrustumPlane* culledBy = 0) const;

        bool isVisible(const Sphere& bound, FrustumPlane* culledBy = 0) const;

        bool isVisible(const Vector3& vert, FrustumPlane* culledBy = 0) const;

        const Vector3* getWorldSpaceCorners(void) const;

        const Plane& getFrustumPlane( unsigned short plane ) const;

        bool projectSphere(const Sphere& sphere,
            Real* left, Real* top, Real* right, Real* bottom) const;

        Real getNearClipDistance(void) const;

        Real getFarClipDistance(void) const;

        const Matrix4& getViewMatrix(void) const;
        const Matrix4& getViewMatrix(bool ownFrustumOnly) const;





        virtual void setUseRenderingDistance(bool use) { mUseRenderingDistance = use; }



        virtual bool getUseRenderingDistance(void) const { return mUseRenderingDistance; }







        virtual void synchroniseBaseSettingsWith(const Camera* cam);


        const Vector3& getPositionForViewUpdate(void) const;

        const Quaternion& getOrientationForViewUpdate(void) const;





        void setUseMinPixelSize(bool enable) { mUseMinPixelSize = enable; }



        bool getUseMinPixelSize() const { return mUseMinPixelSize; }
        Real getPixelDisplayRatio() const { return mPixelDisplayRatio; }





        void _resetRenderedRqs( size_t numRqs );
        void _setRenderedRqs( size_t rqStart, size_t rqEnd );


        bool isRenderedRq( size_t rqId ) const { return mRenderedRqs[rqId]; }

    };



}



namespace Ogre {
    class ConfigFile : public ConfigAlloc
    {
    public:

        ConfigFile();
        virtual ~ConfigFile();

        void load(const String& filename, const String& separators = "\t:=", bool trimWhitespace = true);

        void load(const String& filename, const String& resourceGroup, const String& separators = "\t:=", bool trimWhitespace = true);

        void load(const DataStreamPtr& stream, const String& separators = "\t:=", bool trimWhitespace = true);

        void loadDirect(const String& filename, const String& separators = "\t:=", bool trimWhitespace = true);

        void loadFromResourceSystem(const String& filename, const String& resourceGroup, const String& separators = "\t:=", bool trimWhitespace = true);






        String getSetting(const String& key, const String& section = BLANKSTRING, const String& defaultValue = BLANKSTRING) const;

        StringVector getMultiSetting(const String& key, const String& section = BLANKSTRING) const;

        typedef multimap<String, String>::type SettingsMultiMap;
        typedef MapIterator<SettingsMultiMap> SettingsIterator;

        typedef map<String, SettingsMultiMap*>::type SettingsBySection;
        typedef MapIterator<SettingsBySection> SectionIterator;

        SectionIterator getSectionIterator(void);

        SettingsIterator getSettingsIterator(const String& section = BLANKSTRING);




        void clear(void);
    protected:
        SettingsBySection mSettings;
    };



}



namespace Ogre {







    enum PixelFormat
    {

        PF_UNKNOWN = 0,

        PF_L8 = 1,
        PF_BYTE_L = PF_L8,

        PF_L16 = 2,
        PF_SHORT_L = PF_L16,

        PF_A8 = 3,
        PF_BYTE_A = PF_A8,

        PF_A4L4 = 4,

        PF_BYTE_LA = 5,

        PF_R5G6B5 = 6,

        PF_B5G6R5 = 7,

        PF_R3G3B2 = 31,

        PF_A4R4G4B4 = 8,

        PF_A1R5G5B5 = 9,

        PF_R8G8B8 = 10,

        PF_B8G8R8 = 11,

        PF_A8R8G8B8 = 12,

        PF_A8B8G8R8 = 13,

        PF_B8G8R8A8 = 14,

        PF_R8G8B8A8 = 28,


        PF_X8R8G8B8 = 26,


        PF_X8B8G8R8 = 27,
        PF_BYTE_RGB = PF_B8G8R8,

        PF_BYTE_BGR = PF_R8G8B8,

        PF_BYTE_BGRA = PF_A8R8G8B8,

        PF_BYTE_RGBA = PF_A8B8G8R8,


        PF_A2R10G10B10 = 15,

        PF_A2B10G10R10 = 16,

        PF_DXT1 = 17,

        PF_DXT2 = 18,

        PF_DXT3 = 19,

        PF_DXT4 = 20,

        PF_DXT5 = 21,

        PF_FLOAT16_R = 32,

        PF_FLOAT16_RGB = 22,

        PF_FLOAT16_RGBA = 23,

        PF_FLOAT32_R = 33,

        PF_FLOAT32_RGB = 24,

        PF_FLOAT32_RGBA = 25,

        PF_FLOAT16_GR = 35,

        PF_FLOAT32_GR = 36,

        PF_DEPTH_DEPRECATED = 29,

        PF_SHORT_RGBA = 30,

        PF_SHORT_GR = 34,

        PF_SHORT_RGB = 37,

        PF_PVRTC_RGB2 = 38,

        PF_PVRTC_RGBA2 = 39,

        PF_PVRTC_RGB4 = 40,

        PF_PVRTC_RGBA4 = 41,

        PF_PVRTC2_2BPP = 42,

        PF_PVRTC2_4BPP = 43,

        PF_R11G11B10_FLOAT = 44,

        PF_R8_UINT = 45,

        PF_R8G8_UINT = 46,

        PF_R8G8B8_UINT = 47,

        PF_R8G8B8A8_UINT = 48,

        PF_R16_UINT = 49,

        PF_R16G16_UINT = 50,

        PF_R16G16B16_UINT = 51,

        PF_R16G16B16A16_UINT = 52,

        PF_R32_UINT = 53,

        PF_R32G32_UINT = 54,

        PF_R32G32B32_UINT = 55,

        PF_R32G32B32A32_UINT = 56,

        PF_R8_SINT = 57,

        PF_R8G8_SINT = 58,

        PF_R8G8B8_SINT = 59,

        PF_R8G8B8A8_SINT = 60,

        PF_R16_SINT = 61,

        PF_R16G16_SINT = 62,

        PF_R16G16B16_SINT = 63,

        PF_R16G16B16A16_SINT = 64,

        PF_R32_SINT = 65,

        PF_R32G32_SINT = 66,

        PF_R32G32B32_SINT = 67,

        PF_R32G32B32A32_SINT = 68,

        PF_R9G9B9E5_SHAREDEXP = 69,

        PF_BC4_UNORM = 70,

        PF_BC4_SNORM = 71,

        PF_BC5_UNORM = 72,

        PF_BC5_SNORM = 73,

        PF_BC6H_UF16 = 74,

        PF_BC6H_SF16 = 75,

        PF_BC7_UNORM = 76,

        PF_BC7_UNORM_SRGB = 77,

        PF_R8 = 78,

        PF_RG8 = 79,

        PF_R8_SNORM = 80,

        PF_R8G8_SNORM = 81,

        PF_R8G8B8_SNORM = 82,

        PF_R8G8B8A8_SNORM = 83,

        PF_R16_SNORM = 84,

        PF_R16G16_SNORM = 85,

        PF_R16G16B16_SNORM = 86,

        PF_R16G16B16A16_SNORM = 87,

        PF_ETC1_RGB8 = 88,

        PF_ETC2_RGB8 = 89,

        PF_ETC2_RGBA8 = 90,

        PF_ETC2_RGB8A1 = 91,

        PF_ATC_RGB = 92,

        PF_ATC_RGBA_EXPLICIT_ALPHA = 93,

        PF_ATC_RGBA_INTERPOLATED_ALPHA = 94,
        PF_D24_UNORM_S8_UINT = 95,

        PF_D24_UNORM_X8 = 96,

        PF_X24_S8_UINT = 97,

        PF_D24_UNORM = 98,

        PF_D16_UNORM = 99,

        PF_D32_FLOAT = 100,

        PF_D32_FLOAT_X24_S8_UINT = 101,

        PF_D32_FLOAT_X24_X8 = 102,

        PF_X32_X24_S8_UINT = 103,




        PF_NULL = 104,


        PF_COUNT = 105
    };
    typedef vector<PixelFormat>::type PixelFormatList;




    enum PixelFormatFlags {

        PFF_HASALPHA = 0x00000001,


        PFF_COMPRESSED = 0x00000002,

        PFF_FLOAT = 0x00000004,

        PFF_DEPTH = 0x00000008,


        PFF_NATIVEENDIAN = 0x00000010,


        PFF_LUMINANCE = 0x00000020,

        PFF_INTEGER = 0x00000040,

        PFF_SIGNED = 0x00000080
    };


    enum PixelComponentType
    {
        PCT_BYTE = 0,
        PCT_SHORT = 1,
        PCT_FLOAT16 = 2,
        PCT_FLOAT32 = 3,
        PCT_SINT = 4,
        PCT_UINT = 5,
        PCT_COUNT = 6
    };




    class PixelUtil {
    public:






        static size_t getNumElemBytes( PixelFormat format );







        static size_t getNumElemBits( PixelFormat format );






        static uint8 getMaxMipmapCount( uint32 maxResolution );
        static uint8 getMaxMipmapCount( uint32 width, uint32 height );
        static uint8 getMaxMipmapCount( uint32 width, uint32 height, uint32 depth );
        static size_t getMemorySize(uint32 width, uint32 height, uint32 depth, PixelFormat format);
        static uint32 getCompressedBlockWidth( PixelFormat format, bool apiStrict=true );


        static uint32 getCompressedBlockHeight( PixelFormat format, bool apiStrict=true );
        static unsigned int getFlags( PixelFormat format );


        static bool hasAlpha(PixelFormat format);

        static bool isFloatingPoint(PixelFormat format);

        static bool isInteger(PixelFormat format);

        static bool isSigned(PixelFormat format);

        static bool isCompressed(PixelFormat format);

        static bool isDepth(PixelFormat format);

        static bool isNativeEndian(PixelFormat format);

        static bool isLuminance(PixelFormat format);
        static bool isValidExtent(size_t width, size_t height, size_t depth, PixelFormat format);




        static void getBitDepths(PixelFormat format, int rgba[4]);




        static void getBitMasks(PixelFormat format, uint64 rgba[4]);




        static void getBitShifts(PixelFormat format, unsigned char rgba[4]);



        static String getFormatName(PixelFormat srcformat);
        static bool isAccessible(PixelFormat srcformat);





        static PixelComponentType getComponentType(PixelFormat fmt);




        static size_t getComponentCount(PixelFormat fmt);
        static PixelFormat getFormatFromName(const String& name, bool accessibleOnly = false, bool caseSensitive = false);
        static String getBNFExpressionOfPixelFormats(bool accessibleOnly = false);
        static PixelFormat getFormatForBitDepths(PixelFormat fmt, ushort integerBits, ushort floatBits);






        static void packColour(const ColourValue &colour, const PixelFormat pf, void* dest);







        static void packColour(const uint8 r, const uint8 g, const uint8 b, const uint8 a, const PixelFormat pf, void* dest);







        static void packColour(const float r, const float g, const float b, const float a, const PixelFormat pf, void* dest);






        static void unpackColour(ColourValue *colour, PixelFormat pf, const void* src);
        static void unpackColour(uint8 *r, uint8 *g, uint8 *b, uint8 *a, PixelFormat pf, const void* src);
        static void unpackColour(float *r, float *g, float *b, float *a, PixelFormat pf, const void* src);
        static void bulkPixelConversion(void *src, PixelFormat srcFormat, void *dst, PixelFormat dstFormat, unsigned int count);
        static void bulkPixelConversion(const PixelBox &src, const PixelBox &dst);







        static void convertForNormalMapping(const PixelBox &src, const PixelBox &dst);
        static void bulkCompressedSubregion( const PixelBox &src, const PixelBox &dst,
                                             const Box &dstRegion );





        static void bulkPixelVerticalFlip(const PixelBox &box);
    };



}



namespace Ogre {







    enum ImageFlags
    {
        IF_COMPRESSED = 0x00000001,
        IF_CUBEMAP = 0x00000002,
        IF_3D_TEXTURE = 0x00000004
    };
    class Image : public ImageAlloc
    {
    public:
        typedef Ogre::Box Box;
        typedef Ogre::Rect Rect;
    public:


        Image();


        Image( const Image &img );



        virtual ~Image();



        Image & operator = ( const Image & img );
        Image & flipAroundY();
        Image & flipAroundX();
        Image& loadDynamicImage( uchar* data, uint32 width, uint32 height,
                            uint32 depth,
                             PixelFormat format, bool autoDelete = false,
                             size_t numFaces = 1, uint8 numMipMaps = 0);
        Image& loadDynamicImage( uchar* data, uint32 width,
                                 uint32 height, PixelFormat format)
        {
            return loadDynamicImage(data, width, height, 1, format);
        }
        Image & loadRawData(
            DataStreamPtr& stream,
            uint32 width, uint32 height, uint32 depth,
            PixelFormat format,
            size_t numFaces = 1, size_t numMipMaps = 0);
        Image & loadRawData(
            DataStreamPtr& stream,
            uint32 width, uint32 height,
            PixelFormat format )
        {
            return loadRawData(stream, width, height, 1, format);
        }
        Image & load( const String& filename, const String& groupName );
        Image & load(DataStreamPtr& stream, const String& type = BLANKSTRING );
        Image & loadTwoImagesAsRGBA(const String& rgbFilename, const String& alphaFilename,
            const String& groupName, PixelFormat format = PF_BYTE_RGBA);
        Image & loadTwoImagesAsRGBA(DataStreamPtr& rgbStream, DataStreamPtr& alphaStream, PixelFormat format = PF_BYTE_RGBA,
            const String& rgbType = BLANKSTRING, const String& alphaType = BLANKSTRING);
        Image & combineTwoImagesAsRGBA(const Image& rgb, const Image& alpha, PixelFormat format = PF_BYTE_RGBA);
        void save(const String& filename);





        DataStreamPtr encode(const String& formatextension);







        uchar* getData(void);







        const uchar * getData() const;



        size_t getSize() const;



        uint8 getNumMipmaps() const;



        bool hasFlag(const ImageFlags imgFlag) const;



        uint32 getWidth(void) const;



        uint32 getHeight(void) const;



        uint32 getDepth(void) const;




        size_t getNumFaces(void) const;



        size_t getRowSpan(void) const;



        PixelFormat getFormat() const;



        uchar getBPP() const;



        bool getHasAlpha() const;






        static void applyGamma( uchar *buffer, Real gamma, size_t size, uchar bpp );






        ColourValue getColourAt(size_t x, size_t y, size_t z) const;






        void setColourAt(ColourValue const &cv, size_t x, size_t y, size_t z);




        PixelBox getPixelBox(size_t face = 0, size_t mipmap = 0) const;


        void freeMemory();

        enum Filter
        {
            FILTER_NEAREST,
            FILTER_LINEAR,
            FILTER_BILINEAR,
            FILTER_BOX,
            FILTER_TRIANGLE,
            FILTER_BICUBIC,
            FILTER_GAUSSIAN
        };







        static void scale(const PixelBox &src, const PixelBox &dst, Filter filter = FILTER_BILINEAR);


        void resize(ushort width, ushort height, Filter filter = FILTER_BILINEAR);
        bool generateMipmaps( bool gammaCorrected, Filter filter = FILTER_BILINEAR );


        static size_t calculateSize(size_t mipmaps, size_t faces, uint32 width, uint32 height, uint32 depth, PixelFormat format);


        static String getFileExtFromMagic(DataStreamPtr stream);

    protected:

        uint32 mWidth;

        uint32 mHeight;

        uint32 mDepth;

        size_t mBufSize;

        uint8 mNumMipmaps;

        int mFlags;


        PixelFormat mFormat;


        uchar mPixelSize;
        uchar* mBuffer;


        bool mAutoDelete;
    };

    typedef vector<Image*>::type ImagePtrList;
    typedef vector<const Image*>::type ConstImagePtrList;




}


namespace Ogre {
    enum TextureUsage
    {

        TU_STATIC = v1::HardwareBuffer::HBU_STATIC,
        TU_DYNAMIC = v1::HardwareBuffer::HBU_DYNAMIC,
        TU_WRITE_ONLY = v1::HardwareBuffer::HBU_WRITE_ONLY,
        TU_STATIC_WRITE_ONLY = v1::HardwareBuffer::HBU_STATIC_WRITE_ONLY,
        TU_DYNAMIC_WRITE_ONLY = v1::HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY,
        TU_DYNAMIC_WRITE_ONLY_DISCARDABLE = v1::HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE,

        TU_AUTOMIPMAP = 0x10,


        TU_RENDERTARGET = 0x20,



        TU_UAV = 0x40,


        TU_NOT_TEXTURE = 0x80,


        TU_UAV_NOT_TEXTURE = TU_UAV|TU_NOT_TEXTURE,



        TU_AUTOMIPMAP_AUTO = 0x100,


        TU_DEFAULT = TU_AUTOMIPMAP | TU_STATIC_WRITE_ONLY
    };



    enum TextureType
    {

        TEX_TYPE_1D = 1,

        TEX_TYPE_2D = 2,

        TEX_TYPE_3D = 3,

        TEX_TYPE_CUBE_MAP = 4,

        TEX_TYPE_2D_ARRAY = 5,

        TEX_TYPE_2D_RECT = 6
    };



    enum TextureMipmap
    {

        MIP_UNLIMITED = 0x7FFFFFFF,

        MIP_DEFAULT = -1
    };
    class Texture : public Resource
    {
    public:
        Texture(ResourceManager* creator, const String& name, ResourceHandle handle,
            const String& group, bool isManual = false, ManualResourceLoader* loader = 0);

        virtual ~Texture() {}



        void setTextureType(TextureType ttype ) { mTextureType = ttype; }



        TextureType getTextureType(void) const { return mTextureType; }

        bool isTextureTypeArray(void) const
        {
            return mTextureType == TEX_TYPE_2D_ARRAY;
        }



        uint8 getNumMipmaps(void) const {return mNumMipmaps;}





        void setNumMipmaps(uint8 num) {mNumRequestedMipmaps = mNumMipmaps = num;}





        bool getMipmapsHardwareGenerated(void) const { return mMipmapsHardwareGenerated; }



        float getGamma(void) const { return mGamma; }
        void setGamma(float g) { mGamma = g; }
        void setHardwareGammaEnabled(bool enabled) { mHwGamma = enabled; }




        virtual bool isHardwareGammaEnabled() const { return mHwGamma; }
        virtual void setFSAA(uint fsaa, const String& fsaaHint, bool explicitResolve)
                    { mFSAA = fsaa; mFSAAHint = fsaaHint; mFsaaExplicitResolve = explicitResolve; }




        virtual uint getFSAA() const { return mFSAA; }



        virtual const String& getFSAAHint() const { return mFSAAHint; }



        uint32 getHeight(void) const { return mHeight; }



        uint32 getWidth(void) const { return mWidth; }



        uint32 getDepth(void) const { return mDepth; }



        uint32 getSrcHeight(void) const { return mSrcHeight; }



        uint32 getSrcWidth(void) const { return mSrcWidth; }



        uint32 getSrcDepth(void) const { return mSrcDepth; }



        void setHeight(uint32 h) { mHeight = mSrcHeight = h; }



        void setWidth(uint32 w) { mWidth = mSrcWidth = w; }




        void setDepth(uint32 d) { mDepth = mSrcDepth = d; }



        virtual int getUsage() const
        {
            return mUsage;
        }
        virtual void setUsage(int u) { mUsage = u; }
        virtual void createInternalResources(void);



        virtual void freeInternalResources(void);



        virtual void _autogenerateMipmaps(void) = 0;



        virtual void copyToTexture( TexturePtr& target );







        virtual void loadImage( const Image &img );
        virtual void loadRawData( DataStreamPtr& stream,
            ushort uWidth, ushort uHeight, PixelFormat eFormat);






        virtual void _loadImages( const ConstImagePtrList& images );


        PixelFormat getFormat() const
        {
            return mFormat;
        }


        PixelFormat getDesiredFormat(void) const
        {
            return mDesiredFormat;
        }




        PixelFormat getSrcFormat(void) const
        {
            return mSrcFormat;
        }


        virtual void setFormat(PixelFormat pf);


        virtual bool hasAlpha(void) const;






        virtual void setDesiredIntegerBitDepth(ushort bits);



        virtual ushort getDesiredIntegerBitDepth(void) const;






        virtual void setDesiredFloatBitDepth(ushort bits);



        virtual ushort getDesiredFloatBitDepth(void) const;



        virtual void setDesiredBitDepths(ushort integerBits, ushort floatBits);



        virtual void setTreatLuminanceAsAlpha(bool asAlpha);



        virtual bool getTreatLuminanceAsAlpha(void) const;




        virtual size_t getNumFaces() const;
        virtual v1::HardwarePixelBufferSharedPtr getBuffer(size_t face=0, size_t mipmap=0) = 0;






        virtual void convertToImage(Image& destImage, bool includeMipMaps = false);






        virtual void getCustomAttribute(const String& name, void* pData);

    protected:
        uint32 mHeight;
        uint32 mWidth;
        uint32 mDepth;

        uint8 mNumRequestedMipmaps;
        uint8 mNumMipmaps;
        bool mMipmapsHardwareGenerated;
        float mGamma;
        bool mHwGamma;
        uint mFSAA;
        String mFSAAHint;
        bool mFsaaExplicitResolve;

        TextureType mTextureType;
        PixelFormat mFormat;
        int mUsage;

        PixelFormat mSrcFormat;
        uint32 mSrcWidth, mSrcHeight, mSrcDepth;

        PixelFormat mDesiredFormat;
        unsigned short mDesiredIntegerBitDepth;
        unsigned short mDesiredFloatBitDepth;
        bool mTreatLuminanceAsAlpha;

        bool mInternalResourcesCreated;


        size_t calculateSize(void) const;




        virtual void createInternalResourcesImpl(void) = 0;



        virtual void freeInternalResourcesImpl(void) = 0;


        void unloadImpl(void);




        String getSourceFileType() const;

    };



}




namespace Ogre {
    class TextureUnitState : public TextureUnitStateAlloc
    {
        friend class RenderSystem;
    public:





        enum TextureEffectType
        {

            ET_ENVIRONMENT_MAP,

            ET_PROJECTIVE_TEXTURE,

            ET_UVSCROLL,

            ET_USCROLL,

            ET_VSCROLL,

            ET_ROTATE,

            ET_TRANSFORM

        };






        enum EnvMapType
        {

            ENV_PLANAR,

            ENV_CURVED,

            ENV_REFLECTION,

            ENV_NORMAL
        };






        enum TextureTransformType
        {
            TT_TRANSLATE_U,
            TT_TRANSLATE_V,
            TT_SCALE_U,
            TT_SCALE_V,
            TT_ROTATE
        };



        enum TextureCubeFace
        {
            CUBE_FRONT = 0,
            CUBE_BACK = 1,
            CUBE_LEFT = 2,
            CUBE_RIGHT = 3,
            CUBE_UP = 4,
            CUBE_DOWN = 5
        };



        struct TextureEffect {
            TextureEffectType type;
            int subtype;
            Real arg1, arg2;
            WaveformType waveType;
            Real base;
            Real frequency;
            Real phase;
            Real amplitude;
            Controller<Real>* controller;
            const Frustum* frustum;
        };



        typedef multimap<TextureEffectType, TextureEffect>::type EffectMap;



        TextureUnitState(Pass* parent);

        TextureUnitState(Pass* parent, const TextureUnitState& oth );

        TextureUnitState & operator = ( const TextureUnitState& oth );



        ~TextureUnitState();







        TextureUnitState( Pass* parent, const String& texName, unsigned int texCoordSet = 0);
        const String& getTextureName(void) const;






        void setTextureName( const String& name, TextureType ttype = TEX_TYPE_2D);






        void setTexture( const TexturePtr& texPtr);
        void setCubicTextureName( const String& name, bool forUVW = false );
        void setCubicTextureName( const String* const names, bool forUVW = false );
        void setCubicTexture( const TexturePtr* const texPtrs, bool forUVW = false );
        void setAnimatedTextureName( const String& name, unsigned int numFrames, Real duration = 0 );
        void setAnimatedTextureName( const String* const names, unsigned int numFrames, Real duration = 0 );



        std::pair< size_t, size_t > getTextureDimensions( unsigned int frame = 0 ) const;
        void setCurrentFrame( unsigned int frameNumber );





        unsigned int getCurrentFrame(void) const;






        const String& getFrameTextureName(unsigned int frameNumber) const;
        void setFrameTextureName(const String& name, unsigned int frameNumber);







        void addFrameTextureName(const String& name);
        void deleteFrameTextureName(const size_t frameNumber);




        unsigned int getNumFrames(void) const;



        enum BindingType
        {

            BT_FRAGMENT = 0,



            BT_VERTEX = 1,

            BT_GEOMETRY = 2,

            BT_TESSELLATION_HULL = 3,

            BT_TESSELLATION_DOMAIN = 4,

            BT_COMPUTE = 5
        };


        enum ContentType
        {

            CONTENT_NAMED = 0,

            CONTENT_SHADOW = 1,

            CONTENT_COMPOSITOR = 2
        };
        void setBindingType(BindingType bt);



        BindingType getBindingType(void) const;






        void setContentType(ContentType ct);

        ContentType getContentType(void) const;







        bool isCubic(void) const;





        bool is3D(void) const;





        TextureType getTextureType(void) const;



        void setDesiredFormat(PixelFormat desiredFormat);



        PixelFormat getDesiredFormat(void) const;



        void setNumMipmaps(int numMipmaps);



        int getNumMipmaps(void) const;



        void setIsAlpha(bool isAlpha);



        bool getIsAlpha(void) const;


        Real getGamma() const { return mGamma; }

        void setGamma(Real gamma) { mGamma = gamma; }


        void setHardwareGammaEnabled(bool enabled);

        bool isHardwareGammaEnabled() const;





        unsigned int getTextureCoordSet(void) const;
        void setTextureCoordSet(unsigned int set);
        void setTextureTransform(const Matrix4& xform);
        const Matrix4& getTextureTransform(void) const;
        void setTextureScroll(Real u, Real v);





        void setTextureUScroll(Real value);

        Real getTextureUScroll(void) const;





        void setTextureVScroll(Real value);

        Real getTextureVScroll(void) const;





        void setTextureUScale(Real value);

        Real getTextureUScale(void) const;





        void setTextureVScale(Real value);

        Real getTextureVScale(void) const;
        void setTextureScale(Real uScale, Real vScale);
        void setTextureRotate(const Radian& angle);

        const Radian& getTextureRotate(void) const;
        void setColourOperationEx(
            LayerBlendOperationEx op,
            LayerBlendSource source1 = LBS_TEXTURE,
            LayerBlendSource source2 = LBS_CURRENT,

            const ColourValue& arg1 = ColourValue::White,
            const ColourValue& arg2 = ColourValue::White,

            Real manualBlend = 0.0);
        void setColourOperation( const LayerBlendOperation op);
        void setColourOpMultipassFallback( const SceneBlendFactor sourceFactor, const SceneBlendFactor destFactor);



        const LayerBlendModeEx& getColourBlendMode(void) const;



        const LayerBlendModeEx& getAlphaBlendMode(void) const;



        SceneBlendFactor getColourBlendFallbackSrc(void) const;



        SceneBlendFactor getColourBlendFallbackDest(void) const;
        void setAlphaOperation(LayerBlendOperationEx op,
            LayerBlendSource source1 = LBS_TEXTURE,
            LayerBlendSource source2 = LBS_CURRENT,
            Real arg1 = 1.0,
            Real arg2 = 1.0,
            Real manualBlend = 0.0);
        void addEffect(TextureEffect& effect);
        void setEnvironmentMap(bool enable, EnvMapType envMapType = ENV_CURVED);
        void setScrollAnimation(Real uSpeed, Real vSpeed);
        void setRotateAnimation(Real speed);
        void setTransformAnimation( const TextureTransformType ttype,
            const WaveformType waveType, Real base = 0, Real frequency = 1, Real phase = 0, Real amplitude = 1 );
        void setProjectiveTexturing(bool enabled, const Frustum* projectionSettings = 0);



        void removeAllEffects(void);






        void removeEffect( const TextureEffectType type );






        bool isBlank(void) const;



        void setBlank(void);



        bool isTextureLoadFailing() const { return mTextureLoadFailed; }



        void retryTextureLoad() { mTextureLoadFailed = false; }


        void setSamplerblock( const HlmsSamplerblock &samplerblock );




        const HlmsSamplerblock* getSamplerblock(void) const;


        const EffectMap& getEffects(void) const;

        Real getAnimationDuration(void) const;
        void setCompositorReference(const String& textureName, size_t mrtIndex = 0);


        IdString getReferencedTextureName() const { return mCompositorRefTexName; }

        size_t getReferencedMRTIndex() const { return mCompositorRefMrtIndex; }


        Pass* getParent(void) const { return mParent; }


        void _prepare(void);

        void _unprepare(void);

        void _load(void);

        void _unload(void);

        bool hasViewRelativeTextureCoordinateGeneration(void) const;


        bool isLoaded(void) const;






        void setName(const String& name);

        const String& getName(void) const { return mName; }





        void setTextureNameAlias(const String& name);


        const String& getTextureNameAlias(void) const { return mTextureNameAlias;}
        bool applyTextureAliases(const AliasTextureNamePairList& aliasList, const bool apply = true);


        void _notifyParent(Pass* parent);


        const TexturePtr& _getTexturePtr(void) const;

        const TexturePtr& _getTexturePtr(size_t frame) const;


        void _setTexturePtr(const TexturePtr& texptr);

        void _setTexturePtr(const TexturePtr& texptr, size_t frame);

        size_t calculateSize(void) const;




        Controller<Real>* _getAnimController() const { return mAnimController; }
protected:


        unsigned int mCurrentFrame;


        Real mAnimDuration;
        bool mCubic;

        TextureType mTextureType;
        PixelFormat mDesiredFormat;
        int mTextureSrcMipmaps;

        unsigned int mTextureCoordSetIndex;
        HlmsSamplerblock const *mSamplerblock;

        LayerBlendModeEx mColourBlendMode;
        SceneBlendFactor mColourBlendFallbackSrc;
        SceneBlendFactor mColourBlendFallbackDest;

        LayerBlendModeEx mAlphaBlendMode;
        mutable bool mTextureLoadFailed;
        bool mIsAlpha;
        bool mHwGamma;
        Real mGamma;

        mutable bool mRecalcTexMatrix;
        Real mUMod, mVMod;
        Real mUScale, mVScale;
        Radian mRotate;
        mutable Matrix4 mTexModMatrix;


        BindingType mBindingType;

        ContentType mContentType;

        size_t mCompositorRefMrtIndex;





        vector<String>::type mFrames;
        mutable vector<TexturePtr>::type mFramePtrs;
        String mName;
        String mTextureNameAlias;
        EffectMap mEffects;

        IdString mCompositorRefTexName;






        Pass* mParent;
        Controller<Real>* mAnimController;





        void recalcTextureMatrix(void) const;



        void createAnimController(void);



        void createEffectController(TextureEffect& effect);


        void ensurePrepared(size_t frame) const;

        void ensureLoaded(size_t frame) const;


    };




}




namespace Ogre {







    typedef SharedPtr< ControllerValue<Real> > ControllerValueRealPtr;
    typedef SharedPtr< ControllerFunction<Real> > ControllerFunctionRealPtr;







    class ControllerManager : public Singleton<ControllerManager>, public ControllerAlloc
    {
    protected:
        typedef set<Controller<Real>*>::type ControllerList;
        ControllerList mControllers;


        ControllerValueRealPtr mFrameTimeController;


        ControllerFunctionRealPtr mPassthroughFunction;


        unsigned long mLastFrameNumber;

    public:
        ControllerManager();
        ~ControllerManager();



        Controller<Real>* createController(const ControllerValueRealPtr& src,
            const ControllerValueRealPtr& dest, const ControllerFunctionRealPtr& func);



        Controller<Real>* createFrameTimePassthroughController(
            const ControllerValueRealPtr& dest);



        void clearControllers(void);



        void updateAllControllers(void);
        const ControllerValueRealPtr& getFrameTimeSource(void) const;


        const ControllerFunctionRealPtr& getPassthroughControllerFunction(void) const;
        Controller<Real>* createTextureAnimator(TextureUnitState* layer, Real sequenceTime);
        Controller<Real>* createTextureUVScroller(TextureUnitState* layer, Real speed);
        Controller<Real>* createTextureUScroller(TextureUnitState* layer, Real uSpeed);
        Controller<Real>* createTextureVScroller(TextureUnitState* layer, Real vSpeed);
        Controller<Real>* createTextureRotater(TextureUnitState* layer, Real speed);
        Controller<Real>* createTextureWaveTransformer(TextureUnitState* layer, TextureUnitState::TextureTransformType ttype,
            WaveformType waveType, Real base = 0, Real frequency = 1, Real phase = 0, Real amplitude = 1);
        Controller<Real>* createGpuProgramTimerParam(GpuProgramParametersSharedPtr params, size_t paramIndex,
            Real timeFactor = 1.0f);



        void destroyController(Controller<Real>* controller);





        Real getTimeFactor(void) const;
        void setTimeFactor(Real tf);





        Real getFrameDelay(void) const;
        void setFrameDelay(Real fd);





        Real getElapsedTime(void) const;
        void setElapsedTime(Real elapsedTime);
        static ControllerManager& getSingleton(void);
        static ControllerManager* getSingletonPtr(void);
    };




}




namespace Ogre {
namespace v1 {
    class HardwareBufferManagerBase;
    class HardwareCounterBuffer : public HardwareBuffer
    {
        protected:
            HardwareBufferManagerBase* mMgr;
            String mName;

        public:

            HardwareCounterBuffer(HardwareBufferManagerBase* mgr, size_t sizeBytes,
                            HardwareBuffer::Usage usage, bool useShadowBuffer = false, const String& name = "");
            ~HardwareCounterBuffer();

            HardwareBufferManagerBase* getManager() const { return mMgr; }

            const String& getName() const { return mName; }

    };


    class HardwareCounterBufferSharedPtr : public SharedPtr<HardwareCounterBuffer>
    {
    public:
        HardwareCounterBufferSharedPtr() : SharedPtr<HardwareCounterBuffer>() {}
        explicit HardwareCounterBufferSharedPtr(HardwareCounterBuffer* buf);
    };

}
}




namespace Ogre {
namespace v1 {
    class HardwareBufferManagerBase;
    class HardwareUniformBuffer : public HardwareBuffer
    {
        protected:
            HardwareBufferManagerBase* mMgr;
            String mName;

        public:

            HardwareUniformBuffer(HardwareBufferManagerBase* mgr, size_t sizeBytes,
                            HardwareBuffer::Usage usage, bool useShadowBuffer = false, const String& name = "");
            ~HardwareUniformBuffer();

            HardwareBufferManagerBase* getManager() const { return mMgr; }

            const String& getName() const { return mName; }

    };


    class HardwareUniformBufferSharedPtr : public SharedPtr<HardwareUniformBuffer>
    {
    public:
        HardwareUniformBufferSharedPtr() : SharedPtr<HardwareUniformBuffer>() {}
        explicit HardwareUniformBufferSharedPtr(HardwareUniformBuffer* buf);
    };

}
}





namespace Ogre {
namespace v1 {
    class HardwareBufferLicensee
    {
    public:
        virtual ~HardwareBufferLicensee() { }



        virtual void licenseExpired(HardwareBuffer* buffer) = 0;
    };


    class TempBlendedBufferInfo : public HardwareBufferLicensee, public BufferAlloc
    {
    private:

        HardwareVertexBufferSharedPtr srcPositionBuffer;
        HardwareVertexBufferSharedPtr srcNormalBuffer;

        HardwareVertexBufferSharedPtr destPositionBuffer;
        HardwareVertexBufferSharedPtr destNormalBuffer;

        bool posNormalShareBuffer;
        unsigned short posBindIndex;
        unsigned short normBindIndex;
        bool bindPositions;
        bool bindNormals;

    public:
        ~TempBlendedBufferInfo(void);

        void extractFrom(const VertexData* sourceData);

        void checkoutTempCopies(bool positions = true, bool normals = true);

        void bindTempCopies(VertexData* targetData, bool suppressHardwareUpload);

        void licenseExpired(HardwareBuffer* buffer);

        bool buffersCheckedOut(bool positions = true, bool normals = true) const;
    };
    class HardwareBufferManagerBase : public BufferAlloc
    {
        friend class HardwareVertexBufferSharedPtr;
        friend class HardwareIndexBufferSharedPtr;
    protected:





        typedef set<HardwareVertexBuffer*>::type VertexBufferList;
        typedef set<HardwareIndexBuffer*>::type IndexBufferList;
        typedef set<HardwareUniformBuffer*>::type UniformBufferList;
        typedef set<HardwareCounterBuffer*>::type CounterBufferList;
        VertexBufferList mVertexBuffers;
        IndexBufferList mIndexBuffers;
        UniformBufferList mUniformBuffers;
        CounterBufferList mCounterBuffers;


        typedef set<VertexDeclaration*>::type VertexDeclarationList;
        typedef set<VertexBufferBinding*>::type VertexBufferBindingList;
        VertexDeclarationList mVertexDeclarations;
        VertexBufferBindingList mVertexBufferBindings;


                                       ;
                                      ;
                                        ;
                                        ;
                                            ;
                                              ;


        virtual void destroyAllDeclarations(void);

        virtual void destroyAllBindings(void);


        virtual VertexDeclaration* createVertexDeclarationImpl(void);

        virtual void destroyVertexDeclarationImpl(VertexDeclaration* decl);


        virtual VertexBufferBinding* createVertexBufferBindingImpl(void);

        virtual void destroyVertexBufferBindingImpl(VertexBufferBinding* binding);

    public:

        enum BufferLicenseType
        {

            BLT_MANUAL_RELEASE,

            BLT_AUTOMATIC_RELEASE
        };

    protected:

        class VertexBufferLicense
        {
        public:
            HardwareVertexBuffer* originalBufferPtr;
            BufferLicenseType licenseType;
            size_t expiredDelay;
            HardwareVertexBufferSharedPtr buffer;
            HardwareBufferLicensee* licensee;
            VertexBufferLicense(
                HardwareVertexBuffer* orig,
                BufferLicenseType ltype,
                size_t delay,
                HardwareVertexBufferSharedPtr buf,
                HardwareBufferLicensee* lic)
                : originalBufferPtr(orig)
                , licenseType(ltype)
                , expiredDelay(delay)
                , buffer(buf)
                , licensee(lic)
            {}

        };


        typedef multimap<HardwareVertexBuffer*, HardwareVertexBufferSharedPtr>::type FreeTemporaryVertexBufferMap;

        FreeTemporaryVertexBufferMap mFreeTempVertexBufferMap;

        typedef map<HardwareVertexBuffer*, VertexBufferLicense>::type TemporaryVertexBufferLicenseMap;

        TemporaryVertexBufferLicenseMap mTempVertexBufferLicenses;

        size_t mUnderUsedFrameCount;

        static const size_t UNDER_USED_FRAME_THRESHOLD;

        static const size_t EXPIRED_DELAY_FRAME_THRESHOLD;

                                     ;



        virtual HardwareVertexBufferSharedPtr makeBufferCopy(
            const HardwareVertexBufferSharedPtr& source,
            HardwareBuffer::Usage usage, bool useShadowBuffer);

    public:
        HardwareBufferManagerBase();
        virtual ~HardwareBufferManagerBase();
        virtual HardwareVertexBufferSharedPtr
            createVertexBuffer(size_t vertexSize, size_t numVerts, HardwareBuffer::Usage usage,
            bool useShadowBuffer = false) = 0;
        virtual HardwareIndexBufferSharedPtr
            createIndexBuffer(HardwareIndexBuffer::IndexType itype, size_t numIndexes,
            HardwareBuffer::Usage usage, bool useShadowBuffer = false) = 0;





        virtual RenderToVertexBufferSharedPtr createRenderToVertexBuffer() = 0;






        virtual HardwareUniformBufferSharedPtr createUniformBuffer(size_t sizeBytes,
                                    HardwareBuffer::Usage usage = HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE,
                                    bool useShadowBuffer = false, const String& name = "") = 0;





        virtual HardwareCounterBufferSharedPtr createCounterBuffer(size_t sizeBytes,
                                                                   HardwareBuffer::Usage usage = HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE,
                                                                   bool useShadowBuffer = false, const String& name = "") = 0;


        virtual VertexDeclaration* createVertexDeclaration(void);

        virtual void destroyVertexDeclaration(VertexDeclaration* decl);


        virtual VertexBufferBinding* createVertexBufferBinding(void);

        virtual void destroyVertexBufferBinding(VertexBufferBinding* binding);






        virtual void registerVertexBufferSourceAndCopy(
            const HardwareVertexBufferSharedPtr& sourceBuffer,
            const HardwareVertexBufferSharedPtr& copy);
        virtual HardwareVertexBufferSharedPtr allocateVertexBufferCopy(
            const HardwareVertexBufferSharedPtr& sourceBuffer,
            BufferLicenseType licenseType,
            HardwareBufferLicensee* licensee,
            bool copyData = false);
        virtual void releaseVertexBufferCopy(
            const HardwareVertexBufferSharedPtr& bufferCopy);
        virtual void touchVertexBufferCopy(const HardwareVertexBufferSharedPtr& bufferCopy);
        virtual void _freeUnusedBufferCopies(void);
        virtual void _releaseBufferCopies(bool forceFreeUnused = false);
        virtual void _forceReleaseBufferCopies(const HardwareVertexBufferSharedPtr& sourceBuffer);
        virtual void _forceReleaseBufferCopies(HardwareVertexBuffer* sourceBuffer);


        void _notifyVertexBufferDestroyed(HardwareVertexBuffer* buf);

        void _notifyIndexBufferDestroyed(HardwareIndexBuffer* buf);

        void _notifyUniformBufferDestroyed(HardwareUniformBuffer* buf);

        void _notifyCounterBufferDestroyed(HardwareCounterBuffer* buf);
    };


    class HardwareBufferManager : public HardwareBufferManagerBase, public Singleton<HardwareBufferManager>
    {
        friend class HardwareVertexBufferSharedPtr;
        friend class HardwareIndexBufferSharedPtr;
    protected:
        HardwareBufferManagerBase* mImpl;
    public:
        HardwareBufferManager(HardwareBufferManagerBase* imp);
        ~HardwareBufferManager();


        HardwareVertexBufferSharedPtr
            createVertexBuffer(size_t vertexSize, size_t numVerts, HardwareBuffer::Usage usage,
            bool useShadowBuffer = false)
        {
            return mImpl->createVertexBuffer(vertexSize, numVerts, usage, useShadowBuffer);
        }

        HardwareIndexBufferSharedPtr
            createIndexBuffer(HardwareIndexBuffer::IndexType itype, size_t numIndexes,
            HardwareBuffer::Usage usage, bool useShadowBuffer = false)
        {
            return mImpl->createIndexBuffer(itype, numIndexes, usage, useShadowBuffer);
        }


        RenderToVertexBufferSharedPtr createRenderToVertexBuffer()
        {
            return mImpl->createRenderToVertexBuffer();
        }


        HardwareUniformBufferSharedPtr
                createUniformBuffer(size_t sizeBytes, HardwareBuffer::Usage usage, bool useShadowBuffer, const String& name = "")
        {
            return mImpl->createUniformBuffer(sizeBytes, usage, useShadowBuffer, name);
        }


        HardwareCounterBufferSharedPtr
        createCounterBuffer(size_t sizeBytes, HardwareBuffer::Usage usage, bool useShadowBuffer, const String& name = "")
        {
            return mImpl->createCounterBuffer(sizeBytes, usage, useShadowBuffer, name);
        }


        virtual VertexDeclaration* createVertexDeclaration(void)
        {
            return mImpl->createVertexDeclaration();
        }

        virtual void destroyVertexDeclaration(VertexDeclaration* decl)
        {
            mImpl->destroyVertexDeclaration(decl);
        }


        virtual VertexBufferBinding* createVertexBufferBinding(void)
        {
            return mImpl->createVertexBufferBinding();
        }

        virtual void destroyVertexBufferBinding(VertexBufferBinding* binding)
        {
            mImpl->destroyVertexBufferBinding(binding);
        }

        virtual void registerVertexBufferSourceAndCopy(
            const HardwareVertexBufferSharedPtr& sourceBuffer,
            const HardwareVertexBufferSharedPtr& copy)
        {
            mImpl->registerVertexBufferSourceAndCopy(sourceBuffer, copy);
        }

        virtual HardwareVertexBufferSharedPtr allocateVertexBufferCopy(
            const HardwareVertexBufferSharedPtr& sourceBuffer,
            BufferLicenseType licenseType,
            HardwareBufferLicensee* licensee,
            bool copyData = false)
        {
            return mImpl->allocateVertexBufferCopy(sourceBuffer, licenseType, licensee, copyData);
        }

        virtual void releaseVertexBufferCopy(
            const HardwareVertexBufferSharedPtr& bufferCopy)
        {
            mImpl->releaseVertexBufferCopy(bufferCopy);
        }


        virtual void touchVertexBufferCopy(
            const HardwareVertexBufferSharedPtr& bufferCopy)
        {
            mImpl->touchVertexBufferCopy(bufferCopy);
        }


        virtual void _freeUnusedBufferCopies(void)
        {
            mImpl->_freeUnusedBufferCopies();
        }

        virtual void _releaseBufferCopies(bool forceFreeUnused = false)
        {
            mImpl->_releaseBufferCopies(forceFreeUnused);
        }

        virtual void _forceReleaseBufferCopies(
            const HardwareVertexBufferSharedPtr& sourceBuffer)
        {
            mImpl->_forceReleaseBufferCopies(sourceBuffer);
        }

        virtual void _forceReleaseBufferCopies(HardwareVertexBuffer* sourceBuffer)
        {
            mImpl->_forceReleaseBufferCopies(sourceBuffer);
        }

        void _notifyVertexBufferDestroyed(HardwareVertexBuffer* buf)
        {
            mImpl->_notifyVertexBufferDestroyed(buf);
        }

        void _notifyIndexBufferDestroyed(HardwareIndexBuffer* buf)
        {
            mImpl->_notifyIndexBufferDestroyed(buf);
        }

        void _notifyUniformBufferDestroyed(HardwareUniformBuffer* buf)
        {
            mImpl->_notifyUniformBufferDestroyed(buf);
        }

        void _notifyConterBufferDestroyed(HardwareCounterBuffer* buf)
        {
            mImpl->_notifyCounterBufferDestroyed(buf);
        }
        static HardwareBufferManager& getSingleton(void);
        static HardwareBufferManager* getSingletonPtr(void);

    };



}
}





namespace Ogre {
namespace v1 {
    class SubEntity: public Renderable, public SubEntityAlloc
    {

        friend class Entity;
        friend class SceneManager;
    protected:


        SubEntity(Entity* parent, SubMesh* subMeshBasis);

    public:


        virtual ~SubEntity();

    protected:

        Entity* mParentEntity;


        SubMesh* mSubMesh;

        unsigned char mMaterialLodIndex;


        size_t mIndexStart;


        size_t mIndexEnd;


        VertexData* mSkelAnimVertexData;

        TempBlendedBufferInfo mTempSkelAnimInfo;

        TempBlendedBufferInfo mTempVertexAnimInfo;

        VertexData* mSoftwareVertexAnimVertexData;



        VertexData* mHardwareVertexAnimVertexData;

        bool mVertexAnimationAppliedThisFrame;

        ushort mHardwarePoseCount;


        void prepareTempBlendBuffers(void);

    public:






        virtual void setMaterial( const MaterialPtr& material );




        using Renderable::setDatablock;

        virtual void setDatablock( HlmsDatablock *datablock );



        SubMesh* getSubMesh(void) const;


        Entity* getParent(void) const { return mParentEntity; }



        void getRenderOperation(RenderOperation& op, bool casterPass);





        void setIndexDataStartIndex(size_t start_index);




        size_t getIndexDataStartIndex() const;





        void setIndexDataEndIndex(size_t end_index);



        size_t getIndexDataEndIndex() const;



        void resetIndexDataStartEndIndex();



        void getWorldTransforms(Matrix4* xform) const;


        unsigned short getNumWorldTransforms(void) const;

        Real getSquaredViewDepth(const Camera* cam) const;

        const LightList& getLights(void) const;

        bool getCastsShadows(void) const;
        VertexData* _getSkelAnimVertexData(void);
        VertexData* _getSoftwareVertexAnimVertexData(void);




        VertexData* _getHardwareVertexAnimVertexData(void);



        TempBlendedBufferInfo* _getSkelAnimTempBufferInfo(void);



        TempBlendedBufferInfo* _getVertexAnimTempBufferInfo(void);
        const TempBlendedBufferInfo* _getVertexAnimTempBufferInfo(void) const;

        VertexData* getVertexDataForBinding( bool casterPass );



        void _markBuffersUnusedForAnimation(void);


        void _markBuffersUsedForAnimation(void);

        bool _getBuffersMarkedForAnimation(void) const { return mVertexAnimationAppliedThisFrame; }



        void _restoreBuffersForUnusedAnimation(bool hardwareAnimation);


        void _updateCustomGpuParameter(
            const GpuProgramParameters::AutoConstantEntry& constantEntry,
            GpuProgramParameters* params) const;
    };



}
}



namespace Ogre {
namespace v1 {
    class Entity : public MovableObject, public Resource::Listener
    {

        friend class EntityFactory;
        friend class SubEntity;
    public:

        typedef set<Entity*>::type EntitySet;
        typedef map<unsigned short, bool>::type SchemeHardwareAnimMap;

    protected:



        Entity( IdType id, ObjectMemoryManager *objectMemoryManager, SceneManager *manager );


        Entity( IdType id, ObjectMemoryManager *objectMemoryManager, SceneManager *manager,
                const MeshPtr& mesh );



        MeshPtr mMesh;



        typedef vector<SubEntity>::type SubEntityList;
        SubEntityList mSubEntityList;



        AnimationStateSet* mAnimationState;



        TempBlendedBufferInfo mTempSkelAnimInfo;

        VertexData* mSkelAnimVertexData;

        TempBlendedBufferInfo mTempVertexAnimInfo;

        VertexData* mSoftwareVertexAnimVertexData;



        VertexData* mHardwareVertexAnimVertexData;

        bool mVertexAnimationAppliedThisFrame;

        bool mPreparedForShadowVolumes;




        const VertexData* findBlendedVertexData(const VertexData* orig);



        SubEntity* findSubEntityForVertexData(const VertexData* orig);




        void extractTempBufferInfo(VertexData* sourceData, TempBlendedBufferInfo* info);

        VertexData* cloneVertexDataRemoveBlendInfo(const VertexData* source);

        void prepareTempBlendBuffers(void);


        void markBuffersUnusedForAnimation(void);



        void restoreBuffersForUnusedAnimation(bool hardwareAnimation);
        void bindMissingHardwarePoseBuffers(const VertexData* srcData,
            VertexData* destData);




        void initialisePoseVertexData(const VertexData* srcData, VertexData* destData,
            bool animateNormals);




        void finalisePoseNormals(const VertexData* srcData, VertexData* destData);


        Matrix4 *mBoneWorldMatrices;

        Matrix4 *mBoneMatrices;
        unsigned short mNumBoneMatrices;

        unsigned long mFrameAnimationLastUpdated;


        void updateAnimation(void);




        unsigned long *mFrameBonesLastUpdated;





        EntitySet* mSharedSkeletonEntities;





        bool cacheBoneMatrices(void);


        bool mDisplaySkeleton;



        SchemeHardwareAnimMap mSchemeHardwareAnim;


        bool mCurrentHWAnimationState;


        ushort mHardwarePoseCount;

        bool mVertexProgramInUse;

        int mSoftwareAnimationRequests;

        int mSoftwareAnimationNormalsRequests;

        bool mSkipAnimStateUpdates;

        bool mAlwaysUpdateMainSkeleton;

        bool mUpdateBoundingBoxFromSkeleton;






        typedef vector<Entity*>::type LODEntityList;
        LODEntityList mLodEntityList;



        OldSkeletonInstance* mSkeletonInstance;


        bool mInitialised;


        Matrix4 mLastParentXform;


        size_t mMeshStateCount;


        void buildSubEntityList(MeshPtr& mesh, SubEntityList* sublist);


        void attachObjectImpl(MovableObject *pMovable, TagPoint *pAttachingPoint);


        void detachObjectImpl(MovableObject* pObject);


        void reevaluateVertexProcessing(void);







        bool calcVertexProcessing(void);


        void applyVertexAnimation(bool hardwareAnimation);

        ushort initHardwareAnimationElements(VertexData* vdata, ushort numberOfElements, bool animateNormals);

        bool tempVertexAnimBuffersBound(void) const;

        bool tempSkelAnimBuffersBound(bool requestNormals) const;

    public:


        ~Entity();



        const MeshPtr& getMesh(void) const;



        SubEntity* getSubEntity(size_t index);
        const SubEntity* getSubEntity(size_t index) const;





        SubEntity* getSubEntity( const String& name );
        const SubEntity* getSubEntity( const String& name ) const;



        size_t getNumSubEntities(void) const;


        void setDatablock( HlmsDatablock *datablock );


        void setDatablock( IdString datablockName );
        Entity* clone(void) const;
        void setDatablockOrMaterialName( const String& name,
                                         const String& groupName = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME );
        void setMaterialName( const String& name, const String& groupName = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME );
        void setMaterial(const MaterialPtr& material);
        void setRenderQueueSubGroup( uint8 subGroup );


        void setRenderQueueGroup(uint8 queueID);



        void _updateRenderQueue(RenderQueue* queue, Camera *camera, const Camera *lodCamera);


        const String& getMovableType(void) const;







        AnimationState* getAnimationState(const String& name) const;

        bool hasAnimationState(const String& name) const;
        AnimationStateSet* getAllAnimationStates(void) const;



        void setDisplaySkeleton(bool display);



        bool getDisplaySkeleton(void) const;






        Entity* getManualLodLevel(size_t index) const;






        size_t getNumManualLodLevels(void) const;




        void setPolygonModeOverrideable(bool PolygonModeOverrideable);
        TagPoint* attachObjectToBone(const String &boneName,
            MovableObject *pMovable,
            const Quaternion &offsetOrientation = Quaternion::IDENTITY,
            const Vector3 &offsetPosition = Vector3::ZERO);






        MovableObject* detachObjectFromBone(const String &movableName);







        void detachObjectFromBone(MovableObject* obj);


        void detachAllObjectsFromBone(void);
        EdgeData* getEdgeList(void);

        bool hasEdgeList(void);


        const Matrix4* _getBoneMatrices(void) const { return mBoneMatrices;}

        unsigned short _getNumBoneMatrices(void) const { return mNumBoneMatrices; }

        bool hasSkeleton(void) const { return mSkeletonInstance != 0; }

        OldSkeletonInstance* getSkeleton(void) const { return mSkeletonInstance; }
        bool isHardwareAnimationEnabled(void);


        void _notifyAttached( Node* parent );







        int getSoftwareAnimationRequests(void) const { return mSoftwareAnimationRequests; }
        int getSoftwareAnimationNormalsRequests(void) const { return mSoftwareAnimationNormalsRequests; }
        void addSoftwareAnimationRequest(bool normalsAlso);
        void removeSoftwareAnimationRequest(bool normalsAlso);





        void shareSkeletonInstanceWith(Entity* entity);



        bool hasVertexAnimation(void) const;




        void stopSharingSkeletonInstance();




        inline bool sharesSkeletonInstance() const { return mSharedSkeletonEntities != NULL; }




        inline const EntitySet* getSkeletonInstanceSharingSet() const { return mSharedSkeletonEntities; }
        void refreshAvailableAnimationState(void);
        void _updateAnimation(void);






        bool _isAnimated(void) const;



        bool _isSkeletonAnimated(void) const;
        VertexData* _getSkelAnimVertexData(void) const;
        VertexData* _getSoftwareVertexAnimVertexData(void) const;




        VertexData* _getHardwareVertexAnimVertexData(void) const;



        TempBlendedBufferInfo* _getSkelAnimTempBufferInfo(void);



        TempBlendedBufferInfo* _getVertexAnimTempBufferInfo(void);

        uint32 getTypeFlags(void) const;

        VertexData* getVertexDataForBinding( bool casterPass );


        enum VertexDataBindChoice
        {
            BIND_ORIGINAL,
            BIND_SOFTWARE_SKELETAL,
            BIND_SOFTWARE_MORPH,
            BIND_HARDWARE_MORPH
        };

        VertexDataBindChoice chooseVertexDataForBinding(bool hasVertexAnim);


        bool _getBuffersMarkedForAnimation(void) const { return mVertexAnimationAppliedThisFrame; }


        void _markBuffersUsedForAnimation(void);
        bool isInitialised(void) const { return mInitialised; }
        void _initialise(bool forceReinitialise = false);

        void _deinitialise(void);




        void setSkipAnimationStateUpdate(bool skip) {
            mSkipAnimStateUpdates = skip;
        }




        bool getSkipAnimationStateUpdate() const {
            return mSkipAnimStateUpdates;
        }





        void setAlwaysUpdateMainSkeleton(bool update) {
            mAlwaysUpdateMainSkeleton = update;
        }





        bool getAlwaysUpdateMainSkeleton() const {
            return mAlwaysUpdateMainSkeleton;
        }
        void setUpdateBoundingBoxFromSkeleton(bool update);





        bool getUpdateBoundingBoxFromSkeleton() const {
            return mUpdateBoundingBoxFromSkeleton;
        }


    };


    class EntityFactory : public MovableObjectFactory
    {
    protected:
        virtual MovableObject* createInstanceImpl( IdType id, ObjectMemoryManager *objectMemoryManager,
                                                   SceneManager *manager,
                                                   const NameValuePairList* params = 0 );
    public:
        EntityFactory() {}
        ~EntityFactory() {}

        static String FACTORY_TYPE_NAME;

        const String& getType(void) const;
        void destroyInstance( MovableObject* obj);

    };



}
}



namespace Ogre {
    struct FrameEvent
    {







        Real timeSinceLastEvent;






        Real timeSinceLastFrame;
    };
    class FrameListener
    {
    public:







        virtual bool frameStarted(const FrameEvent& evt)
        { (void)evt; return true; }
        virtual bool frameRenderingQueued(const FrameEvent& evt)
                { (void)evt; return true; }
        virtual bool frameEnded(const FrameEvent& evt)
        { (void)evt; return true; }

        virtual ~FrameListener() {}

    };


}



namespace Ogre {
    class ScriptLoader
    {
    public:
        virtual ~ScriptLoader();
        virtual const StringVector& getScriptPatterns(void) const = 0;






        virtual void parseScript(DataStreamPtr& stream, const String& groupName) = 0;
        virtual Real getLoadingOrder(void) const = 0;

    };




}



namespace Ogre {



    template <typename T>
    class Pool
    {
    protected:
        typedef typename list<T>::type ItemList;
        ItemList mItems;
                       ;
    public:
        Pool() {}
        virtual ~Pool() {}




        virtual std::pair<bool, T> removeItem()
        {
                                ;
            std::pair<bool, T> ret;
            if (mItems.empty())
            {
                ret.first = false;
            }
            else
            {
                ret.first = true;
                ret.second = mItems.front();
                mItems.pop_front();
            }
            return ret;
        }



        virtual void addItem(const T& i)
        {
                                ;
            mItems.push_front(i);
        }

        virtual void clear()
        {
                                ;
            mItems.clear();
        }
    };
    class ResourceManager : public ScriptLoader, public ResourceAlloc
    {
    public:
                       ;
        ResourceManager();
        virtual ~ResourceManager();
        virtual ResourcePtr createResource(const String& name, const String& group,
            bool isManual = false, ManualResourceLoader* loader = 0,
            const NameValuePairList* createParams = 0);

        typedef std::pair<ResourcePtr, bool> ResourceCreateOrRetrieveResult;
        virtual ResourceCreateOrRetrieveResult createOrRetrieve(const String& name,
            const String& group, bool isManual = false,
            ManualResourceLoader* loader = 0,
            const NameValuePairList* createParams = 0);
        virtual void setMemoryBudget(size_t bytes);



        virtual size_t getMemoryBudget(void) const;


        virtual size_t getMemoryUsage(void) const { return mMemoryUsage.get(); }







        virtual void unload(const String& name);







        virtual void unload(ResourceHandle handle);
        virtual void unloadAll(bool reloadableOnly = true);
        virtual void reloadAll(bool reloadableOnly = true);
        virtual void unloadUnreferencedResources(bool reloadableOnly = true);
        virtual void reloadUnreferencedResources(bool reloadableOnly = true);
        virtual void remove(ResourcePtr& r);
        virtual void remove(const String& name);
        virtual void remove(ResourceHandle handle);
        virtual void removeAll(void);
        virtual void removeUnreferencedResources(bool reloadableOnly = true);



        virtual ResourcePtr getResourceByName(const String& name, const String& groupName = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME);


        virtual ResourcePtr getByHandle(ResourceHandle handle);


        virtual bool resourceExists(const String& name)
        {
            return !getResourceByName(name).isNull();
        }

        virtual bool resourceExists(ResourceHandle handle)
        {
            return !getByHandle(handle).isNull();
        }




        virtual void _notifyResourceTouched(Resource* res);




        virtual void _notifyResourceLoaded(Resource* res);




        virtual void _notifyResourceUnloaded(Resource* res);
        virtual ResourcePtr prepare(const String& name,
            const String& group, bool isManual = false,
            ManualResourceLoader* loader = 0, const NameValuePairList* loadParams = 0,
            bool backgroundThread = false);
        virtual ResourcePtr load(const String& name,
            const String& group, bool isManual = false,
            ManualResourceLoader* loader = 0, const NameValuePairList* loadParams = 0,
            bool backgroundThread = false);
        virtual const StringVector& getScriptPatterns(void) const { return mScriptPatterns; }
        virtual void parseScript(DataStreamPtr& stream, const String& groupName)
                { (void)stream; (void)groupName; }







        virtual Real getLoadingOrder(void) const { return mLoadOrder; }


        const String& getResourceType(void) const { return mResourceType; }


        virtual void setVerbose(bool v) { mVerbose = v; }


        virtual bool getVerbose(void) { return mVerbose; }







        class ResourcePool : public Pool<ResourcePtr>, public ResourceAlloc
        {
        protected:
            String mName;
        public:
            ResourcePool(const String& name);
            ~ResourcePool();

            const String& getName() const;
            void clear();
        };


        ResourcePool* getResourcePool(const String& name);

        void destroyResourcePool(ResourcePool* pool);

        void destroyResourcePool(const String& name);

        void destroyAllResourcePools();




    protected:


        ResourceHandle getNextHandle(void);
        virtual Resource* createImpl(const String& name, ResourceHandle handle,
            const String& group, bool isManual, ManualResourceLoader* loader,
            const NameValuePairList* createParams) = 0;

        virtual void addImpl( ResourcePtr& res );

        virtual void removeImpl( ResourcePtr& res );


        virtual void checkUsage(void);


    public:
        typedef unordered_map< String, ResourcePtr >::type ResourceMap;
        typedef unordered_map< String, ResourceMap >::type ResourceWithGroupMap;
        typedef map<ResourceHandle, ResourcePtr>::type ResourceHandleMap;
    protected:
        ResourceHandleMap mResourcesByHandle;
        ResourceMap mResources;
        ResourceWithGroupMap mResourcesWithGroup;
        size_t mMemoryBudget;
        AtomicScalar<ResourceHandle> mNextHandle;
        AtomicScalar<size_t> mMemoryUsage;

        bool mVerbose;




        StringVector mScriptPatterns;

        Real mLoadOrder;

        String mResourceType;

    public:
        typedef MapIterator<ResourceHandleMap> ResourceMapIterator;




        ResourceMapIterator getResourceIterator(void)
        {
            return ResourceMapIterator(mResourcesByHandle.begin(), mResourcesByHandle.end());
        }

    protected:
        typedef map<String, ResourcePool*>::type ResourcePoolMap;
        ResourcePoolMap mResourcePoolMap;
    };




}





namespace Ogre {
    class GpuProgramManager : public ResourceManager, public Singleton<GpuProgramManager>
    {
    public:

        typedef set<String>::type SyntaxCodes;
        typedef map<String, GpuSharedParametersPtr>::type SharedParametersMap;

        struct Hash
        {
            uint64 hashVal[2];

            bool operator < ( const Hash &_r ) const
            {
                if( hashVal[0] < _r.hashVal[0] ) return true;
                if( hashVal[0] > _r.hashVal[0] ) return false;

                if( hashVal[1] < _r.hashVal[1] ) return true;


                return false;
            }
        };

        typedef MemoryDataStreamPtr Microcode;
        typedef map<Hash, Microcode>::type MicrocodeMap;

    protected:
        SharedParametersMap mSharedParametersMap;
        MicrocodeMap mMicrocodeCache;
        bool mSaveMicrocodesToCache;
        bool mCacheDirty;

        static Hash computeHashWithRenderSystemName( const String &source );


        virtual Resource* createImpl(const String& name, ResourceHandle handle,
            const String& group, bool isManual, ManualResourceLoader* loader,
            GpuProgramType gptype, const String& syntaxCode) = 0;
    public:
        GpuProgramManager();
        virtual ~GpuProgramManager();



        GpuProgramPtr getByName(const String& name, bool preferHighLevelPrograms = true);
        virtual GpuProgramPtr load(const String& name, const String& groupName,
            const String& filename, GpuProgramType gptype,
            const String& syntaxCode);
        virtual GpuProgramPtr loadFromString(const String& name, const String& groupName,
            const String& code, GpuProgramType gptype,
            const String& syntaxCode);


        virtual const SyntaxCodes& getSupportedSyntax(void) const;



        virtual bool isSyntaxSupported(const String& syntaxCode) const;






        virtual GpuProgramParametersSharedPtr createParameters(void);
        virtual GpuProgramPtr createProgram(const String& name,
            const String& groupName, const String& filename,
            GpuProgramType gptype, const String& syntaxCode);
        virtual GpuProgramPtr createProgramFromString(const String& name,
            const String& groupName, const String& code,
            GpuProgramType gptype, const String& syntaxCode);




        virtual ResourcePtr create(const String& name, const String& group,
            GpuProgramType gptype, const String& syntaxCode, bool isManual = false,
            ManualResourceLoader* loader = 0);






        ResourcePtr getResourceByName(const String& name, bool preferHighLevelPrograms = true);







        virtual GpuSharedParametersPtr createSharedParameters(const String& name);




        virtual GpuSharedParametersPtr getSharedParameters(const String& name) const;



        virtual const SharedParametersMap& getAvailableSharedParameters() const;



        bool getSaveMicrocodesToCache();


        void setSaveMicrocodesToCache( const bool val );



        bool isCacheDirty(void) const;

        bool canGetCompiledShaderBuffer();



        virtual bool isMicrocodeAvailableInCache( const String &source ) const;



        virtual const Microcode & getMicrocodeFromCache( const String &source ) const;




        virtual Microcode createMicrocode( const uint32 size ) const;




        virtual void addMicrocodeToCache( const String & source, const Microcode & microcode );




        virtual void removeMicrocodeFromCache( const String & source );




        virtual void saveMicrocodeCache( DataStreamPtr stream ) const;



        virtual void loadMicrocodeCache( DataStreamPtr stream );


        virtual void clearMicrocodeCache(void);
        static GpuProgramManager& getSingleton(void);
        static GpuProgramManager* getSingletonPtr(void);



    };



}





namespace Ogre {







    class PixelBox: public Box, public ImageAlloc {
    public:

        PixelBox() {}
        ~PixelBox() {}







        PixelBox(const Box &extents, PixelFormat pixelFormat, void *pixelData=0):
            Box(extents), data(pixelData), format(pixelFormat)
        {
            setConsecutive();
        }
        PixelBox(uint32 width, uint32 height, uint32 depth, PixelFormat pixelFormat, void *pixelData=0):
            Box(0, 0, 0, width, height, depth),
            data(pixelData), format(pixelFormat)
        {
            setConsecutive();
        }


        void *data;

        PixelFormat format;






        size_t rowPitch;







        size_t slicePitch;


        size_t rowPitchAlwaysBytes(void) const;

        size_t slicePitchAlwaysBytes(void) const;




        void setConsecutive();







        size_t getRowSkip() const;







        size_t getSliceSkip() const { return slicePitch - (getHeight() * rowPitch); }


        size_t getSliceSkipAlwaysBytes() const;




        bool isConsecutive() const;




        size_t getConsecutiveSize() const;
        PixelBox getSubVolume(const Box &def) const;




        void* getTopLeftFrontPixelPtr() const;






        ColourValue getColourAt(size_t x, size_t y, size_t z);






        void setColourAt(ColourValue const &cv, size_t x, size_t y, size_t z);
    };




}






namespace Ogre {
namespace v1 {
    class HardwarePixelBuffer : public HardwareBuffer
    {
    protected:

        uint32 mWidth, mHeight, mDepth;

        size_t mRowPitch, mSlicePitch;

        PixelFormat mFormat;

        bool mHwGamma;

        PixelBox mCurrentLock;

        Image::Box mLockedBox;



        virtual PixelBox lockImpl(const Image::Box &lockBox, LockOptions options) = 0;



        virtual void* lockImpl(size_t offset, size_t length, LockOptions options);




        virtual void _clearSliceRTT(size_t zoffset);
        friend class Ogre::RenderTexture;
    public:

        HardwarePixelBuffer(uint32 mWidth, uint32 mHeight, uint32 mDepth,
                PixelFormat mFormat, bool hwGamma,
                HardwareBuffer::Usage usage, bool useSystemMemory, bool useShadowBuffer);
        ~HardwarePixelBuffer();




        using HardwareBuffer::lock;







        virtual const PixelBox& lock(const Image::Box& lockBox, LockOptions options);

        virtual void* lock(size_t offset, size_t length, LockOptions options, UploadOptions uploadOpt = HBU_DEFAULT);





        const PixelBox& getCurrentLock();


        virtual void readData(size_t offset, size_t length, void* pDest);

        virtual void writeData(size_t offset, size_t length, const void* pSource,
                bool discardWholeBuffer = false);
        virtual void blit(const HardwarePixelBufferSharedPtr &src, const Image::Box &srcBox, const Image::Box &dstBox);






        void blit(const HardwarePixelBufferSharedPtr &src);
        virtual void blitFromMemory(const PixelBox &src, const Image::Box &dstBox) = 0;






        void blitFromMemory(const PixelBox &src)
        {
            blitFromMemory(src, Box(0,0,0,mWidth,mHeight,mDepth));
        }
        virtual void blitToMemory(const Image::Box &srcBox, const PixelBox &dst) = 0;






        void blitToMemory(const PixelBox &dst)
        {
            blitToMemory(Box(0,0,0,mWidth,mHeight,mDepth), dst);
        }
        virtual RenderTexture *getRenderTarget(size_t slice=0);


        uint32 getWidth() const { return mWidth; }

        uint32 getHeight() const { return mHeight; }

        uint32 getDepth() const { return mDepth; }

        PixelFormat getFormat() const { return mFormat; }
    };


    class HardwarePixelBufferSharedPtr : public SharedPtr<HardwarePixelBuffer>
    {
    public:
        HardwarePixelBufferSharedPtr() : SharedPtr<HardwarePixelBuffer>() {}
        explicit HardwarePixelBufferSharedPtr(HardwarePixelBuffer* buf);


    };



}
}


namespace Ogre {
    class HardwareOcclusionQuery : public RenderSysAlloc
{



public:
    HardwareOcclusionQuery();




    virtual ~HardwareOcclusionQuery();
    virtual void beginOcclusionQuery() = 0;




    virtual void endOcclusionQuery() = 0;
    virtual bool pullOcclusionQuery(unsigned int* NumOfFragments) = 0;






    unsigned int getLastQuerysPixelcount() const { return mPixelCount; }





     virtual bool isStillOutstanding(void) = 0;





    protected :

        unsigned int mPixelCount;

        bool mIsQueryResultStillOutstanding;
};



}


namespace Ogre {
    class HighLevelGpuProgram : public GpuProgram
    {
    protected:

        bool mHighLevelLoaded;

        GpuProgramPtr mAssemblerProgram;

        mutable bool mConstantDefsBuilt;


        virtual void loadHighLevel(void);

        virtual void unloadHighLevel(void);



        virtual void loadHighLevelImpl(void);


        virtual void createLowLevelImpl(void) = 0;

        virtual void unloadHighLevelImpl(void) = 0;

        virtual void populateParameterNames(GpuProgramParametersSharedPtr params);






        virtual void buildConstantDefinitions() const = 0;


        void loadImpl();

        void unloadImpl();
    public:

        HighLevelGpuProgram(ResourceManager* creator, const String& name, ResourceHandle handle,
            const String& group, bool isManual = false, ManualResourceLoader* loader = 0);
        ~HighLevelGpuProgram();
        GpuProgramParametersSharedPtr createParameters(void);

        GpuProgram* _getBindingDelegate(void) { return mAssemblerProgram.getPointer(); }





        const GpuNamedConstants& getConstantDefinitions() const;

        virtual size_t calculateSize(void) const;




    };



}

namespace Ogre {
    class HighLevelGpuProgramFactory : public FactoryAlloc
    {
    public:
        HighLevelGpuProgramFactory() {}
        virtual ~HighLevelGpuProgramFactory();

        virtual const String& getLanguage(void) const = 0;
        virtual HighLevelGpuProgram* create(ResourceManager* creator,
            const String& name, ResourceHandle handle,
            const String& group, bool isManual, ManualResourceLoader* loader) = 0;
        virtual void destroy(HighLevelGpuProgram* prog) = 0;
    };
    class HighLevelGpuProgramManager
        : public ResourceManager, public Singleton<HighLevelGpuProgramManager>
    {
    public:
        typedef map<String, HighLevelGpuProgramFactory*>::type FactoryMap;
    protected:

        FactoryMap mFactories;


        HighLevelGpuProgramFactory* mNullFactory;

        HighLevelGpuProgramFactory* mUnifiedFactory;

        HighLevelGpuProgramFactory* getFactory(const String& language);


        Resource* createImpl(const String& name, ResourceHandle handle,
            const String& group, bool isManual, ManualResourceLoader* loader,
            const NameValuePairList* createParams);
    public:
        HighLevelGpuProgramManager();
        ~HighLevelGpuProgramManager();

        void addFactory(HighLevelGpuProgramFactory* factory);

        void removeFactory(HighLevelGpuProgramFactory* factory);


        bool isLanguageSupported(const String& lang);



        HighLevelGpuProgramPtr getByName(const String& name, const String& groupName = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME);
        HighLevelGpuProgramPtr createProgram(
            const String& name, const String& groupName,
            const String& language, GpuProgramType gptype);
        static HighLevelGpuProgramManager& getSingleton(void);
        static HighLevelGpuProgramManager* getSingletonPtr(void);


    };



}



namespace Ogre {
namespace v1 {







    class RenderOperation {
    public:

        enum OperationType {

            OT_POINT_LIST = 1,

            OT_LINE_LIST = 2,

            OT_LINE_STRIP = 3,

            OT_TRIANGLE_LIST = 4,

            OT_TRIANGLE_STRIP = 5,

            OT_TRIANGLE_FAN = 6,

            OT_PATCH_1_CONTROL_POINT = 7,
            OT_PATCH_2_CONTROL_POINT = 8,
            OT_PATCH_3_CONTROL_POINT = 9,
            OT_PATCH_4_CONTROL_POINT = 10,
            OT_PATCH_5_CONTROL_POINT = 11,
            OT_PATCH_6_CONTROL_POINT = 12,
            OT_PATCH_7_CONTROL_POINT = 13,
            OT_PATCH_8_CONTROL_POINT = 14,
            OT_PATCH_9_CONTROL_POINT = 15,
            OT_PATCH_10_CONTROL_POINT = 16,
            OT_PATCH_11_CONTROL_POINT = 17,
            OT_PATCH_12_CONTROL_POINT = 18,
            OT_PATCH_13_CONTROL_POINT = 19,
            OT_PATCH_14_CONTROL_POINT = 20,
            OT_PATCH_15_CONTROL_POINT = 21,
            OT_PATCH_16_CONTROL_POINT = 22,
            OT_PATCH_17_CONTROL_POINT = 23,
            OT_PATCH_18_CONTROL_POINT = 24,
            OT_PATCH_19_CONTROL_POINT = 25,
            OT_PATCH_20_CONTROL_POINT = 26,
            OT_PATCH_21_CONTROL_POINT = 27,
            OT_PATCH_22_CONTROL_POINT = 28,
            OT_PATCH_23_CONTROL_POINT = 29,
            OT_PATCH_24_CONTROL_POINT = 30,
            OT_PATCH_25_CONTROL_POINT = 31,
            OT_PATCH_26_CONTROL_POINT = 32,
            OT_PATCH_27_CONTROL_POINT = 33,
            OT_PATCH_28_CONTROL_POINT = 34,
            OT_PATCH_29_CONTROL_POINT = 35,
            OT_PATCH_30_CONTROL_POINT = 36,
            OT_PATCH_31_CONTROL_POINT = 37,
            OT_PATCH_32_CONTROL_POINT = 38
        };

        static AtomicScalar<uint32> MeshIndexId;
        uint32 meshIndex;


        VertexData *vertexData;


        OperationType operationType;





        bool useIndexes;


        IndexData *indexData;
        size_t numberOfInstances;


        bool renderToVertexBuffer;



        bool useGlobalInstancingVertexBufferIsAvailable;

    RenderOperation() :
            meshIndex(0),
            vertexData(0),
            operationType(OT_TRIANGLE_LIST),
            useIndexes(true),
            indexData(0),



            numberOfInstances(1),
            renderToVertexBuffer(false),
            useGlobalInstancingVertexBufferIsAvailable(true)
            {}


    };


}
}





namespace Ogre
{
    enum SceneMemoryMgrTypes;
    class NullEntity;
    class ObjectMemoryManager : ArrayMemoryManager::RebaseListener
    {
        typedef vector<ObjectDataArrayMemoryManager>::type ArrayMemoryManagerVec;

        ArrayMemoryManagerVec mMemoryManagers;


        size_t mTotalObjects;


        SceneNode *mDummyNode;
        Transform mDummyTransformPtrs;
        NullEntity *mDummyObject;





        SceneMemoryMgrTypes mMemoryManagerType;
        ObjectMemoryManager *mTwinMemoryManager;





        void growToDepth( size_t newDepth );

    public:
        ObjectMemoryManager();
        virtual ~ObjectMemoryManager();


        void _setTwin( SceneMemoryMgrTypes memoryManagerType, ObjectMemoryManager *twinMemoryManager );


        ObjectMemoryManager* getTwin() const { return mTwinMemoryManager; }
        SceneMemoryMgrTypes getMemoryManagerType() const { return mMemoryManagerType; }







        void objectCreated( ObjectData &outObjectData, size_t renderQueue );
        void objectMoved( ObjectData &inOutObjectData, size_t oldRenderQueue, size_t newRenderQueue );







        void objectDestroyed( ObjectData &outObjectData, size_t renderQueue );
        void migrateTo( ObjectData &inOutTransform, size_t renderQueue,
                        ObjectMemoryManager *dstObjectMemoryManager );






        size_t getNumRenderQueues() const;

        size_t _getTotalRenderQueues() const { return mMemoryManagers.size(); }
        size_t getTotalNumObjects() const { return mTotalObjects; }


        SceneNode* _getDummyNode() const { return mDummyNode; }
        size_t getFirstObjectData( ObjectData &outObjectData, size_t renderQueue );


        virtual void buildDiffList( ArrayMemoryManager::ManagerType managerType, uint16 level,
                                    const MemoryPoolVec &basePtrs,
                                    ArrayMemoryManager::PtrdiffVec &outDiffsList );
        virtual void applyRebase( ArrayMemoryManager::ManagerType managerType, uint16 level,
                                    const MemoryPoolVec &newBasePtrs,
                                    const ArrayMemoryManager::PtrdiffVec &diffsList );
        virtual void performCleanup( ArrayMemoryManager::ManagerType managerType, uint16 level,
                                     const MemoryPoolVec &basePtrs, size_t const *elementsMemSizes,
                                     size_t startInstance, size_t diffInstances );
    };



}

namespace Ogre
{
namespace v1
{
    class InstanceBatch : public Renderable, public MovableObject
    {
    public:
        typedef vector<InstancedEntity*>::type InstancedEntityVec;
        typedef vector<Vector4>::type CustomParamsVec;
        typedef FastArray<InstancedEntity*> InstancedEntityArray;

        enum SkeletalAnimationMode
        {
            SKELETONS_NOT_SUPPORTED,
            SKELETONS_SUPPORTED,
            SKELETONS_LUT
        };

    protected:
        RenderOperation mRenderOperation;
        size_t mInstancesPerBatch;

        InstanceManager *mCreator;
        ObjectMemoryManager mLocalObjectMemoryManager;

        MeshPtr mMeshReference;
        Mesh::IndexMap const *mIndexToBoneMap;





        InstancedEntityVec mInstancedEntities;
        InstancedEntityVec mUnusedEntities;






        InstancedEntityArray mAnimatedEntities;





        CustomParamsVec mCustomParams;

        SkeletalAnimationMode mTechnSupportsSkeletal;


        mutable Real mCachedCameraDist;

        mutable const Camera *mCachedCamera;


        bool mTransformSharingDirty;

        bool mStaticDirty;

        vector<Aabb>::type mThreadAabbs;
        MovableObjectArray mCulledInstances;


        bool mRemoveOwnVertexData;

        bool mRemoveOwnIndexData;

        virtual void setupVertices( const SubMesh* baseSubMesh ) = 0;
        virtual void setupIndices( const SubMesh* baseSubMesh ) = 0;
        virtual void createAllInstancedEntities(void);
        virtual void deleteAllInstancedEntities(void);
        virtual void deleteUnusedInstancedEntities(void);

        virtual InstancedEntity* generateInstancedEntity(size_t num);


        virtual bool checkSubMeshCompatibility( const SubMesh* baseSubMesh );


        void defragmentBatchNoCull( InstancedEntityVec &usedEntities, CustomParamsVec &usedParams );






        void defragmentBatchDoCull( InstancedEntityVec &usedEntities, CustomParamsVec &usedParams );




        void instanceBatchCullFrustumThreadedImpl( const Camera *frustum, const Camera *lodCamera,
                                                   uint32 combinedVisibilityFlags );

    public:
        InstanceBatch( IdType id, ObjectMemoryManager *objectMemoryManager,
                       InstanceManager *creator, MeshPtr &meshReference, const MaterialPtr &material,
                       size_t instancesPerBatch, const Mesh::IndexMap *indexToBoneMap );
        virtual ~InstanceBatch();

        MeshPtr& _getMeshRef() { return mMeshReference; }



        void _setInstancesPerBatch( size_t instancesPerBatch );

        const Mesh::IndexMap* _getIndexToBoneMap() const { return mIndexToBoneMap; }







        SkeletalAnimationMode _supportsSkeletalAnimation() const { return mTechnSupportsSkeletal; }



        void _updateAnimations(void);







        void _updateEntitiesBoundsThread( size_t threadIdx );


        void _updateBounds(void);
        virtual size_t calculateMaxNumInstances( const SubMesh *baseSubMesh, uint16 flags ) const = 0;
        virtual RenderOperation build( const SubMesh* baseSubMesh );
        virtual void buildFrom( const SubMesh *baseSubMesh, const RenderOperation &renderOperation );

        const Ogre::v1::MeshPtr& _getMeshReference(void) const { return mMeshReference; }




        bool isBatchFull(void) const { return mUnusedEntities.empty(); }



        bool isBatchUnused(void) const { return mUnusedEntities.size() == mInstancedEntities.size(); }




        void getInstancedEntitiesInUse( InstancedEntityVec &outEntities, CustomParamsVec &outParams );



        void _addAnimatedInstance( InstancedEntity *instancedEntity );





        void _removeAnimatedInstance( const InstancedEntity *instancedEntity );
        void _defragmentBatch( bool optimizeCulling, InstancedEntityVec &usedEntities,
                                CustomParamsVec &usedParams );






        void _defragmentBatchDiscard(void);
        bool setStatic( bool bStatic );




        virtual void _notifyStaticDirty(void);







        InstancedEntity* createInstancedEntity();







        void removeInstancedEntity( InstancedEntity *instancedEntity );





        bool useBoneWorldMatrices() const { return mTechnSupportsSkeletal != SKELETONS_LUT; }



        void _markTransformSharingDirty() { mTransformSharingDirty = true; }


        void _setCustomParam( InstancedEntity *instancedEntity, unsigned char idx, const Vector4 &newParam );


        const Vector4& _getCustomParam( InstancedEntity *instancedEntity, unsigned char idx );



        void getRenderOperation( RenderOperation& op, bool casterPass ) { op = mRenderOperation; }


        Real getSquaredViewDepth( const Camera* cam ) const;

        const LightList& getLights( void ) const;


        const String& getMovableType(void) const;


        using Renderable::getUserAny;
        using Renderable::setUserAny;
    };
}
}


namespace Ogre {
    class DualQuaternion
    {
    public:

        inline DualQuaternion ()
            : w(1), x(0), y(0), z(0), dw(1), dx(0), dy(0), dz(0)
        {
        }


        inline DualQuaternion (Real fW, Real fX, Real fY, Real fZ,
                Real fdW, Real fdX, Real fdY, Real fdZ)
            : w(fW), x(fX), y(fY), z(fZ), dw(fdW), dx(fdX), dy(fdY), dz(fdZ)
        {
        }


        inline DualQuaternion(const Matrix4& rot)
        {
            this->fromTransformationMatrix(rot);
        }


        inline DualQuaternion(const Quaternion& q, const Vector3& trans)
        {
            this->fromRotationTranslation(q, trans);
        }


        inline DualQuaternion(Real* valptr)
        {
            memcpy(&w, valptr, sizeof(Real)*8);
        }


        inline Real operator [] ( const size_t i ) const
        {
            assert( i < 8 );

            return *(&w+i);
        }


        inline Real& operator [] ( const size_t i )
        {
            assert( i < 8 );

            return *(&w+i);
        }

        inline DualQuaternion& operator= (const DualQuaternion& rkQ)
        {
            w = rkQ.w;
            x = rkQ.x;
            y = rkQ.y;
            z = rkQ.z;
            dw = rkQ.dw;
            dx = rkQ.dx;
            dy = rkQ.dy;
            dz = rkQ.dz;

            return *this;
        }

        inline bool operator== (const DualQuaternion& rhs) const
        {
            return (rhs.w == w) && (rhs.x == x) && (rhs.y == y) && (rhs.z == z) &&
                (rhs.dw == dw) && (rhs.dx == dx) && (rhs.dy == dy) && (rhs.dz == dz);
        }

        inline bool operator!= (const DualQuaternion& rhs) const
        {
            return !operator==(rhs);
        }


        inline Real* ptr()
        {
            return &w;
        }


        inline const Real* ptr() const
        {
            return &w;
        }


        inline void swap(DualQuaternion& other)
        {
            std::swap(w, other.w);
            std::swap(x, other.x);
            std::swap(y, other.y);
            std::swap(z, other.z);
            std::swap(dw, other.dw);
            std::swap(dx, other.dx);
            std::swap(dy, other.dy);
            std::swap(dz, other.dz);
        }


        inline bool isNaN() const
        {
            return Math::isNaN(w) || Math::isNaN(x) || Math::isNaN(y) || Math::isNaN(z) ||
                Math::isNaN(dw) || Math::isNaN(dx) || Math::isNaN(dy) || Math::isNaN(dz);
        }


        void fromRotationTranslation (const Quaternion& q, const Vector3& trans);


        void toRotationTranslation (Quaternion& q, Vector3& translation) const;


        void fromTransformationMatrix (const Matrix4& kTrans);


        void toTransformationMatrix (Matrix4& kTrans) const;

        Real w, x, y, z, dw, dx, dy, dz;





        inline friend std::ostream& operator <<
        ( std::ostream& o, const DualQuaternion& q )
        {
            o << "DualQuaternion(" << q.w << ", " << q.x << ", " << q.y << ", " << q.z << ", " << q.dw << ", " << q.dx << ", " << q.dy << ", " << q.dz << ")";
            return o;
        }
    };



}
namespace Ogre
{

    struct KfTransform
    {
        ArrayVector3 mPosition;
        ArrayQuaternion mOrientation;
        ArrayVector3 mScale;
    };
}

namespace Ogre
{
    class KfTransformArrayMemoryManager;

    struct KeyFrameRig
    {
        Real mFrame;
        Real mInvNextFrameDistance;


        KfTransform * __restrict__ mBoneTransform;
    };

    typedef vector<KeyFrameRig>::type KeyFrameRigVec;

    typedef FastArray<BoneTransform> TransformArray;

    class SkeletonTrack : public AnimationAlloc
    {
    protected:

        KeyFrameRigVec mKeyFrameRigs;
        Real mNumFrames;

        uint32 mBoneBlockIdx;
        uint32 mUsedSlots;

        KfTransformArrayMemoryManager *mLocalMemoryManager;

    public:
        SkeletonTrack( uint32 boneBlockIdx, KfTransformArrayMemoryManager *kfTransformMemoryManager );
        ~SkeletonTrack();

        void setNumKeyFrame( size_t numKeyFrames );

        void addKeyFrame( Real timestamp, Real frameRate );
        void setKeyFrameTransform( Real frame, uint32 slot, const Vector3 &vPos,
                                    const Quaternion &qRot, const Vector3 vScale );

        uint32 getBoneBlockIdx(void) const { return mBoneBlockIdx; }
        size_t getUsedSlots(void) const { return mUsedSlots; }
        void _setMaxUsedSlot( uint32 slot )
                                        { mUsedSlots = std::max( slot+1, mUsedSlots ); }

        const KeyFrameRigVec& getKeyFrames(void) const { return mKeyFrameRigs; }
        KeyFrameRigVec& _getKeyFrames(void) { return mKeyFrameRigs; }

        inline void getKeyFrameRigAt( KeyFrameRigVec::const_iterator &inOutPrevFrame,
                                        KeyFrameRigVec::const_iterator &outNextFrame,
                                        Real frame ) const;
        void applyKeyFrameRigAt( KeyFrameRigVec::const_iterator &inOutLastKnownKeyFrame, float frame,
                                 ArrayReal animWeight, const ArrayReal * __restrict__ perBoneWeights,
                                 const TransformArray &KfTransforms ) const;





        void _bakeUnusedSlots(void);
    };

    typedef vector<SkeletonTrack>::type SkeletonTrackVec;
}


namespace Ogre
{
    template <typename T, MemoryCategory M_CATEGORY> class RawSimdUniquePtr
    {
        T * __restrict__ mPtr;
        size_t mNumElements;

    public:
        RawSimdUniquePtr() : mPtr( 0 ), mNumElements( 0 ) {}

        RawSimdUniquePtr( size_t numElements ) :
            mPtr( static_cast<T * __restrict__>(
                    ::Ogre::CategorisedAlignAllocPolicy<M_CATEGORY>::allocateBytes(numElements * sizeof( T )) ) ),
            mNumElements( numElements )
        {
        }

        RawSimdUniquePtr( const RawSimdUniquePtr &copy ) :
            mPtr( 0 ),
            mNumElements( copy.mNumElements )
        {
            if( copy.mPtr )
            {





                mPtr = static_cast<T * __restrict__>(
                            ::Ogre::CategorisedAlignAllocPolicy<M_CATEGORY>::allocateBytes(copy.mNumElements * sizeof( T )) );
                memcpy( mPtr, copy.mPtr, copy.mNumElements * sizeof( T ) );
            }
        }

        ~RawSimdUniquePtr()
        {
            ::Ogre::CategorisedAlignAllocPolicy<M_CATEGORY>::deallocateBytes((void*)mPtr);
            mPtr = 0;
        }

        void swap( RawSimdUniquePtr &copy )
        {
            std::swap( mPtr, copy.mPtr );
            std::swap( mNumElements, copy.mNumElements );
        }

        void operator = ( const RawSimdUniquePtr &copy )
        {
            if( this != &copy )
            {
                ::Ogre::CategorisedAlignAllocPolicy<M_CATEGORY>::deallocateBytes((void*)mPtr);
                mPtr = 0;
                mNumElements = copy.mNumElements;

                if( copy.mPtr )
                {





                    mPtr = static_cast<T * __restrict__>(
                                    ::Ogre::CategorisedAlignAllocPolicy<M_CATEGORY>::allocateBytes(copy.mNumElements * sizeof( T )) );
                    memcpy( mPtr, copy.mPtr, copy.mNumElements * sizeof( T ) );
                }
            }
        }

        T * get() { return mPtr; }
        const T * get() const { return mPtr; }
        size_t size() const { return mNumElements; }
    };
}


namespace Ogre
{
    class SkeletonAnimationDef;
    class SkeletonInstance;

    typedef vector<KeyFrameRigVec::const_iterator>::type KnownKeyFramesVec;
    class SkeletonAnimation : public MovableAlloc
    {
        SkeletonAnimationDef const *mDefinition;
    protected:
        RawSimdUniquePtr<ArrayReal, MEMCATEGORY_ANIMATION> mBoneWeights;
        Real mCurrentFrame;
    public:
        Real mFrameRate;
        Real mWeight;
        FastArray<size_t> const *mSlotStarts;
        bool mLoop;
        bool mEnabled;
        SkeletonInstance *mOwner;
    protected:
        IdString mName;


        KnownKeyFramesVec mLastKnownKeyFrames;

    public:
        SkeletonAnimation( const SkeletonAnimationDef *definition, const FastArray<size_t> *slotStarts,
                            SkeletonInstance *owner );




        void _initialize(void);





        void addTime( Real time ) { addFrame( time * mFrameRate ); }





        void addFrame( Real frames );





        void setTime( Real time ) { setFrame( time * mFrameRate ); }





        void setFrame( Real frame );


        Real getCurrentTime(void) const { return mCurrentFrame / mFrameRate; }


        Real getCurrentFrame(void) const { return mCurrentFrame; }


        Real getNumFrames(void) const;


        Real getDuration(void) const;

        IdString getName(void) const { return mName; }






        void setLoop( bool bLoop ) { mLoop = bLoop; }



        bool getLoop(void) const { return mLoop; }
        void setBoneWeight( IdString boneName, Real weight );
        Real getBoneWeight( IdString boneName ) const;
        Real* getBoneWeightPtr( IdString boneName );


        void setEnabled( bool bEnable );
        bool getEnabled(void) const { return mEnabled; }

        void _applyAnimation( const TransformArray &boneTransforms );

        void _swapBoneWeightsUniquePtr( RawSimdUniquePtr<ArrayReal, MEMCATEGORY_ANIMATION>
                                        &inOutBoneWeights );

        const SkeletonAnimationDef* getDefinition(void) const { return mDefinition; }
    };



}


namespace Ogre
{
    class SimpleMatrixAf4x3;
    class ArrayMatrixAf4x3
    {
    public:
        ArrayReal mChunkBase[12];

        ArrayMatrixAf4x3() {}
        ArrayMatrixAf4x3( const ArrayMatrixAf4x3 &copy )
        {




            for( size_t i=0; i<12; i+=4 )
            {
                mChunkBase[i ] = copy.mChunkBase[i ];
                mChunkBase[i+1] = copy.mChunkBase[i+1];
                mChunkBase[i+2] = copy.mChunkBase[i+2];
                mChunkBase[i+3] = copy.mChunkBase[i+3];
            }
        }


        void setAll( const Matrix4 &m )
        {
            mChunkBase[0] = _mm_set_ps1( m._m[0] );
            mChunkBase[1] = _mm_set_ps1( m._m[1] );
            mChunkBase[2] = _mm_set_ps1( m._m[2] );
            mChunkBase[3] = _mm_set_ps1( m._m[3] );
            mChunkBase[4] = _mm_set_ps1( m._m[4] );
            mChunkBase[5] = _mm_set_ps1( m._m[5] );
            mChunkBase[6] = _mm_set_ps1( m._m[6] );
            mChunkBase[7] = _mm_set_ps1( m._m[7] );
            mChunkBase[8] = _mm_set_ps1( m._m[8] );
            mChunkBase[9] = _mm_set_ps1( m._m[9] );
            mChunkBase[10] = _mm_set_ps1( m._m[10] );
            mChunkBase[11] = _mm_set_ps1( m._m[11] );
        }

        static ArrayMatrixAf4x3 createAllFromMatrix4( const Matrix4 &m )
        {
            ArrayMatrixAf4x3 retVal;
            retVal.setAll( m );
            return retVal;
        }


        inline __attribute__((always_inline)) friend ArrayMatrixAf4x3 operator * ( const ArrayMatrixAf4x3 &lhs, const ArrayMatrixAf4x3 &rhs );

        inline ArrayVector3 operator * ( const ArrayVector3 &rhs ) const;



        inline __attribute__((always_inline)) void operator *= ( const ArrayMatrixAf4x3 &rhs );
        inline void fromQuaternion( const ArrayQuaternion &q );


        inline void makeTransform( const ArrayVector3 &position, const ArrayVector3 &scale,
                                    const ArrayQuaternion &orientation );


        inline void decomposition( ArrayVector3 &position, ArrayVector3 &scale,
                                   ArrayQuaternion &orientation ) const;





        inline void setToInverse(void);




        inline void setToInverseDegeneratesAsIdentity(void);
        inline void retain( ArrayMaskR orientation, ArrayMaskR scale );





        inline void streamToAoS( Matrix4 * __restrict__ dst ) const;
        inline void storeToAoS( SimpleMatrixAf4x3 * __restrict__ src ) const;
        inline void streamToAoS( SimpleMatrixAf4x3 * __restrict__ src ) const;





        inline void loadFromAoS( const Matrix4 * __restrict__ src );
        inline void loadFromAoS( const Matrix4 * __restrict__ * src );
        inline void loadFromAoS( const SimpleMatrixAf4x3 * __restrict__ src );
        inline void loadFromAoS( const SimpleMatrixAf4x3 * __restrict__ * src );

        static const ArrayMatrixAf4x3 IDENTITY;
    };





    class SimpleMatrixAf4x3
    {
    public:
        ArrayReal mChunkBase[3];

        SimpleMatrixAf4x3() {}
        SimpleMatrixAf4x3( ArrayReal row0, ArrayReal row1, ArrayReal row2 )
        {
            mChunkBase[0] = row0;
            mChunkBase[1] = row1;
            mChunkBase[2] = row2;
        }


        void load( const Matrix4 &src )
        {
            mChunkBase[0] = _mm_load_ps( src._m );
            mChunkBase[1] = _mm_load_ps( src._m+4 );
            mChunkBase[2] = _mm_load_ps( src._m+8 );
        }


        void store( Matrix4 *dst ) const
        {
            float * __restrict__ dstPtr = reinterpret_cast<float*>( dst );

            _mm_store_ps( dstPtr, mChunkBase[0] );
            _mm_store_ps( dstPtr + 4, mChunkBase[1] );
            _mm_store_ps( dstPtr + 8, mChunkBase[2] );
            dstPtr += 12;
            *dstPtr++ = 0;
            *dstPtr++ = 0;
            *dstPtr++ = 0;
            *dstPtr++ = 1;
        }


        void store4x3( Matrix4 *dst ) const
        {
            float * __restrict__ dstPtr = reinterpret_cast<float*>( dst );

            _mm_store_ps( dstPtr, mChunkBase[0] );
            _mm_store_ps( dstPtr + 4, mChunkBase[1] );
            _mm_store_ps( dstPtr + 8, mChunkBase[2] );
        }


        void store4x3( float * __restrict__ dst ) const
        {
            _mm_store_ps( dst, mChunkBase[0] );
            _mm_store_ps( dst + 4, mChunkBase[1] );
            _mm_store_ps( dst + 8, mChunkBase[2] );
        }


        void streamTo4x3( float * __restrict__ dst ) const
        {

            _mm_stream_ps( dst, mChunkBase[0] );
            _mm_stream_ps( dst+4, mChunkBase[1] );
            _mm_stream_ps( dst+8, mChunkBase[2] );





        }

        static const SimpleMatrixAf4x3 IDENTITY;
    };




}


namespace Ogre
{
    inline __attribute__((always_inline)) void concatArrayMatAf4x3( ArrayReal * __restrict__ outChunkBase,
                                        const ArrayReal * __restrict__ lhsChunkBase,
                                        const ArrayReal * __restrict__ rhsChunkBase )
    {

        assert( outChunkBase != lhsChunkBase && outChunkBase != rhsChunkBase &&
                lhsChunkBase != rhsChunkBase &&
                "Re-strict aliasing rule broken. Compile without OGRE_RESTRICT_ALIASING" );

        outChunkBase[0] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[2], rhsChunkBase[8] ), _mm_mul_ps( lhsChunkBase[1], rhsChunkBase[4] ) ), _mm_mul_ps( lhsChunkBase[0], rhsChunkBase[0] ) );


        outChunkBase[1] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[2], rhsChunkBase[9] ), _mm_mul_ps( lhsChunkBase[1], rhsChunkBase[5] ) ), _mm_mul_ps( lhsChunkBase[0], rhsChunkBase[1] ) );


        outChunkBase[2] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[2], rhsChunkBase[10] ), _mm_mul_ps( lhsChunkBase[1], rhsChunkBase[6] ) ), _mm_mul_ps( lhsChunkBase[0], rhsChunkBase[2] ) );


        outChunkBase[3] = _mm_add_ps( _mm_add_ps( _mm_add_ps( lhsChunkBase[3], _mm_mul_ps( lhsChunkBase[2], rhsChunkBase[11] ) ), _mm_mul_ps( lhsChunkBase[1], rhsChunkBase[7] ) ), _mm_mul_ps( lhsChunkBase[0], rhsChunkBase[3] ) );





        outChunkBase[4] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[6], rhsChunkBase[8] ), _mm_mul_ps( lhsChunkBase[5], rhsChunkBase[4] ) ), _mm_mul_ps( lhsChunkBase[4], rhsChunkBase[0] ) );


        outChunkBase[5] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[6], rhsChunkBase[9] ), _mm_mul_ps( lhsChunkBase[5], rhsChunkBase[5] ) ), _mm_mul_ps( lhsChunkBase[4], rhsChunkBase[1] ) );


        outChunkBase[6] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[6], rhsChunkBase[10] ), _mm_mul_ps( lhsChunkBase[5], rhsChunkBase[6] ) ), _mm_mul_ps( lhsChunkBase[4], rhsChunkBase[2] ) );


        outChunkBase[7] = _mm_add_ps( _mm_add_ps( _mm_add_ps( lhsChunkBase[7], _mm_mul_ps( lhsChunkBase[6], rhsChunkBase[11] ) ), _mm_mul_ps( lhsChunkBase[5], rhsChunkBase[7] ) ), _mm_mul_ps( lhsChunkBase[4], rhsChunkBase[3] ) );





        outChunkBase[8] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[10],rhsChunkBase[8] ), _mm_mul_ps( lhsChunkBase[9], rhsChunkBase[4] ) ), _mm_mul_ps( lhsChunkBase[8], rhsChunkBase[0] ) );


        outChunkBase[9] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[10],rhsChunkBase[9] ), _mm_mul_ps( lhsChunkBase[9], rhsChunkBase[5] ) ), _mm_mul_ps( lhsChunkBase[8], rhsChunkBase[1] ) );


        outChunkBase[10] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[10],rhsChunkBase[10] ), _mm_mul_ps( lhsChunkBase[9], rhsChunkBase[6] ) ), _mm_mul_ps( lhsChunkBase[8], rhsChunkBase[2] ) );


        outChunkBase[11] = _mm_add_ps( _mm_add_ps( _mm_add_ps( lhsChunkBase[11], _mm_mul_ps( lhsChunkBase[10], rhsChunkBase[11] ) ), _mm_mul_ps( lhsChunkBase[9], rhsChunkBase[7] ) ), _mm_mul_ps( lhsChunkBase[8], rhsChunkBase[3] ) );



    }


    inline __attribute__((always_inline)) void concatArrayMatAf4x3( ArrayReal * __restrict__ lhsChunkBase,
                                        const ArrayReal * __restrict__ rhsChunkBase )
    {

        assert( lhsChunkBase != rhsChunkBase &&
                "Re-strict aliasing rule broken. Compile without OGRE_RESTRICT_ALIASING" );

        ArrayReal lhs0 = lhsChunkBase[0];
        lhsChunkBase[0] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[2], rhsChunkBase[8] ), _mm_mul_ps( lhsChunkBase[1], rhsChunkBase[4] ) ), _mm_mul_ps( lhsChunkBase[0], rhsChunkBase[0] ) );


        ArrayReal lhs1 = lhsChunkBase[1];
        lhsChunkBase[1] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[2], rhsChunkBase[9] ), _mm_mul_ps( lhsChunkBase[1], rhsChunkBase[5] ) ), _mm_mul_ps( lhs0, rhsChunkBase[1] ) );


        ArrayReal lhs2 = lhsChunkBase[2];
        lhsChunkBase[2] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[2], rhsChunkBase[10] ), _mm_mul_ps( lhs1, rhsChunkBase[6] ) ), _mm_mul_ps( lhs0, rhsChunkBase[2] ) );



        lhsChunkBase[3] = _mm_add_ps( _mm_add_ps( _mm_add_ps( lhsChunkBase[3], _mm_mul_ps( lhs2, rhsChunkBase[11] ) ), _mm_mul_ps( lhs1, rhsChunkBase[7] ) ), _mm_mul_ps( lhs0, rhsChunkBase[3] ) );





        lhs0 = lhsChunkBase[4];
        lhsChunkBase[4] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[6], rhsChunkBase[8] ), _mm_mul_ps( lhsChunkBase[5], rhsChunkBase[4] ) ), _mm_mul_ps( lhsChunkBase[4], rhsChunkBase[0] ) );


        lhs1 = lhsChunkBase[5];
        lhsChunkBase[5] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[6], rhsChunkBase[9] ), _mm_mul_ps( lhsChunkBase[5], rhsChunkBase[5] ) ), _mm_mul_ps( lhs0, rhsChunkBase[1] ) );


        lhs2 = lhsChunkBase[6];
        lhsChunkBase[6] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[6], rhsChunkBase[10] ), _mm_mul_ps( lhs1, rhsChunkBase[6] ) ), _mm_mul_ps( lhs0, rhsChunkBase[2] ) );



        lhsChunkBase[7] = _mm_add_ps( _mm_add_ps( _mm_add_ps( lhsChunkBase[7], _mm_mul_ps( lhs2, rhsChunkBase[11] ) ), _mm_mul_ps( lhs1, rhsChunkBase[7] ) ), _mm_mul_ps( lhs0, rhsChunkBase[3] ) );





        lhs0 = lhsChunkBase[8];
        lhsChunkBase[8] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[10],rhsChunkBase[8] ), _mm_mul_ps( lhsChunkBase[9], rhsChunkBase[4] ) ), _mm_mul_ps( lhsChunkBase[8], rhsChunkBase[0] ) );


        lhs1 = lhsChunkBase[9];
        lhsChunkBase[9] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[10],rhsChunkBase[9] ), _mm_mul_ps( lhsChunkBase[9], rhsChunkBase[5] ) ), _mm_mul_ps( lhs0, rhsChunkBase[1] ) );


        lhs2 = lhsChunkBase[10];
        lhsChunkBase[10] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( lhsChunkBase[10],rhsChunkBase[10] ), _mm_mul_ps( lhs1, rhsChunkBase[6] ) ), _mm_mul_ps( lhs0, rhsChunkBase[2] ) );



        lhsChunkBase[11] = _mm_add_ps( _mm_add_ps( _mm_add_ps( lhsChunkBase[11], _mm_mul_ps( lhs2, rhsChunkBase[11] ) ), _mm_mul_ps( lhs1, rhsChunkBase[7] ) ), _mm_mul_ps( lhs0, rhsChunkBase[3] ) );



    }

    inline __attribute__((always_inline)) ArrayMatrixAf4x3 operator * ( const ArrayMatrixAf4x3 &lhs, const ArrayMatrixAf4x3 &rhs )
    {
        ArrayMatrixAf4x3 retVal;
        concatArrayMatAf4x3( retVal.mChunkBase, lhs.mChunkBase, rhs.mChunkBase );
        return retVal;
    }

    inline ArrayVector3 ArrayMatrixAf4x3::operator * ( const ArrayVector3 &rhs ) const
    {
        return ArrayVector3(


            _mm_add_ps(
                _mm_add_ps( _mm_mul_ps( mChunkBase[1], rhs.mChunkBase[1] ), _mm_mul_ps( mChunkBase[0], rhs.mChunkBase[0] ) ),


                _mm_add_ps( mChunkBase[3], _mm_mul_ps( mChunkBase[2], rhs.mChunkBase[2] ) ) ),




            _mm_add_ps(
                _mm_add_ps( _mm_mul_ps( mChunkBase[5], rhs.mChunkBase[1] ), _mm_mul_ps( mChunkBase[4], rhs.mChunkBase[0] ) ),


                _mm_add_ps( mChunkBase[7], _mm_mul_ps( mChunkBase[6], rhs.mChunkBase[2] ) ) ),




            _mm_add_ps(
                _mm_add_ps( _mm_mul_ps( mChunkBase[9], rhs.mChunkBase[1] ), _mm_mul_ps( mChunkBase[8], rhs.mChunkBase[0] ) ),


                _mm_add_ps( mChunkBase[11], _mm_mul_ps( mChunkBase[10], rhs.mChunkBase[2] ) ) ) );


    }

    inline __attribute__((always_inline)) void ArrayMatrixAf4x3::operator *= ( const ArrayMatrixAf4x3 &rhs )
    {
        concatArrayMatAf4x3( mChunkBase, rhs.mChunkBase );
    }

    inline void ArrayMatrixAf4x3::fromQuaternion( const ArrayQuaternion &q )
    {
        ArrayReal * __restrict__ chunkBase = mChunkBase;
        const ArrayReal * __restrict__ qChunkBase = q.mChunkBase;
        ArrayReal fTx = _mm_add_ps( qChunkBase[1], qChunkBase[1] );
        ArrayReal fTy = _mm_add_ps( qChunkBase[2], qChunkBase[2] );
        ArrayReal fTz = _mm_add_ps( qChunkBase[3], qChunkBase[3] );
        ArrayReal fTwx = _mm_mul_ps( fTx, qChunkBase[0] );
        ArrayReal fTwy = _mm_mul_ps( fTy, qChunkBase[0] );
        ArrayReal fTwz = _mm_mul_ps( fTz, qChunkBase[0] );
        ArrayReal fTxx = _mm_mul_ps( fTx, qChunkBase[1] );
        ArrayReal fTxy = _mm_mul_ps( fTy, qChunkBase[1] );
        ArrayReal fTxz = _mm_mul_ps( fTz, qChunkBase[1] );
        ArrayReal fTyy = _mm_mul_ps( fTy, qChunkBase[2] );
        ArrayReal fTyz = _mm_mul_ps( fTz, qChunkBase[2] );
        ArrayReal fTzz = _mm_mul_ps( fTz, qChunkBase[3] );

        chunkBase[0] = _mm_sub_ps( MathlibSSE2::ONE, _mm_add_ps( fTyy, fTzz ) );
        chunkBase[1] = _mm_sub_ps( fTxy, fTwz );
        chunkBase[2] = _mm_add_ps( fTxz, fTwy );
        chunkBase[4] = _mm_add_ps( fTxy, fTwz );
        chunkBase[5] = _mm_sub_ps( MathlibSSE2::ONE, _mm_add_ps( fTxx, fTzz ) );
        chunkBase[6] = _mm_sub_ps( fTyz, fTwx );
        chunkBase[8] = _mm_sub_ps( fTxz, fTwy );
        chunkBase[9] = _mm_add_ps( fTyz, fTwx );
        chunkBase[10]= _mm_sub_ps( MathlibSSE2::ONE, _mm_add_ps( fTxx, fTyy ) );
    }

    inline void ArrayMatrixAf4x3::makeTransform( const ArrayVector3 &position, const ArrayVector3 &scale,
                                             const ArrayQuaternion &orientation )
    {
        ArrayReal * __restrict__ chunkBase = mChunkBase;
        const ArrayReal * __restrict__ posChunkBase = position.mChunkBase;
        const ArrayReal * __restrict__ scaleChunkBase = scale.mChunkBase;
        this->fromQuaternion( orientation );
        chunkBase[0] = _mm_mul_ps( chunkBase[0], scaleChunkBase[0] );
        chunkBase[1] = _mm_mul_ps( chunkBase[1], scaleChunkBase[1] );
        chunkBase[2] = _mm_mul_ps( chunkBase[2], scaleChunkBase[2] );
        chunkBase[3] = posChunkBase[0];

        chunkBase[4] = _mm_mul_ps( chunkBase[4], scaleChunkBase[0] );
        chunkBase[5] = _mm_mul_ps( chunkBase[5], scaleChunkBase[1] );
        chunkBase[6] = _mm_mul_ps( chunkBase[6], scaleChunkBase[2] );
        chunkBase[7] = posChunkBase[1];

        chunkBase[8] = _mm_mul_ps( chunkBase[8], scaleChunkBase[0] );
        chunkBase[9] = _mm_mul_ps( chunkBase[9], scaleChunkBase[1] );
        chunkBase[10]= _mm_mul_ps( chunkBase[10],scaleChunkBase[2] );
        chunkBase[11]= posChunkBase[2];
    }

    inline void ArrayMatrixAf4x3::decomposition( ArrayVector3 &position, ArrayVector3 &scale,
                                                 ArrayQuaternion &orientation ) const
    {
        const ArrayReal * __restrict__ chunkBase = mChunkBase;


        ArrayReal m00 = mChunkBase[0], m01 = mChunkBase[1], m02 = mChunkBase[2];
        ArrayReal m10 = mChunkBase[4], m11 = mChunkBase[5], m12 = mChunkBase[6];
        ArrayReal m20 = mChunkBase[8], m21 = mChunkBase[9], m22 = mChunkBase[10];


        ArrayReal fInvLength = MathlibSSE2::InvSqrt4(
                        _mm_add_ps( _mm_add_ps( _mm_mul_ps( m20, m20 ), _mm_mul_ps( m10, m10 ) ), _mm_mul_ps( m00, m00 ) ) );



        ArrayReal q00, q01, q02,
                  q10, q11, q12,
                  q20, q21, q22;
        q00 = _mm_mul_ps( m00, fInvLength );
        q10 = _mm_mul_ps( m10, fInvLength );
        q20 = _mm_mul_ps( m20, fInvLength );


        ArrayReal fDot = _mm_add_ps( _mm_add_ps( _mm_mul_ps( q20, m21 ), _mm_mul_ps( q10, m11 ) ), _mm_mul_ps( q00, m01 ) );
        q01 = _mm_sub_ps( m01, _mm_mul_ps( fDot, q00 ) );
        q11 = _mm_sub_ps( m11, _mm_mul_ps( fDot, q10 ) );
        q21 = _mm_sub_ps( m21, _mm_mul_ps( fDot, q20 ) );


        fInvLength = MathlibSSE2::InvSqrt4(
                        _mm_add_ps( _mm_add_ps( _mm_mul_ps( q21, q21 ), _mm_mul_ps( q11, q11 ) ), _mm_mul_ps( q01, q01 ) ) );



        q01 = _mm_mul_ps( q01, fInvLength );
        q11 = _mm_mul_ps( q11, fInvLength );
        q21 = _mm_mul_ps( q21, fInvLength );


        fDot = _mm_add_ps( _mm_add_ps( _mm_mul_ps( q20, m22 ), _mm_mul_ps( q10, m12 ) ), _mm_mul_ps( q00, m02 ) );
        q02 = _mm_sub_ps( m02, _mm_mul_ps( fDot, q00 ) );
        q12 = _mm_sub_ps( m12, _mm_mul_ps( fDot, q10 ) );
        q22 = _mm_sub_ps( m22, _mm_mul_ps( fDot, q20 ) );


        fDot = _mm_add_ps( _mm_add_ps( _mm_mul_ps( q21, m22 ), _mm_mul_ps( q11, m12 ) ), _mm_mul_ps( q01, m02 ) );
        q02 = _mm_sub_ps( q02, _mm_mul_ps( fDot, q01 ) );
        q12 = _mm_sub_ps( q12, _mm_mul_ps( fDot, q11 ) );
        q22 = _mm_sub_ps( q22, _mm_mul_ps( fDot, q21 ) );


        fInvLength = MathlibSSE2::InvSqrt4(
                        _mm_add_ps( _mm_add_ps( _mm_mul_ps( q22, q22 ), _mm_mul_ps( q12, q12 ) ), _mm_mul_ps( q02, q02 ) ) );



        q02 = _mm_mul_ps( q02, fInvLength );
        q12 = _mm_mul_ps( q12, fInvLength );
        q22 = _mm_mul_ps( q22, fInvLength );







        ArrayReal fDet = _mm_add_ps(
                    _mm_add_ps( _mm_mul_ps( _mm_mul_ps( q00, q11 ), q22 ),
                                _mm_mul_ps( _mm_mul_ps( q01, q12 ), q20 ) ),
                    _mm_mul_ps( _mm_mul_ps( q02, q10 ), q21 ) );
        ArrayReal fTmp = _mm_add_ps(
                    _mm_add_ps( _mm_mul_ps( _mm_mul_ps( q02, q11 ), q20 ),
                                _mm_mul_ps( _mm_mul_ps( q01, q10 ), q22 ) ),
                    _mm_mul_ps( _mm_mul_ps( q00, q12 ), q21 ) );
        fDet = _mm_sub_ps( fDet, fTmp );







        fDet = _mm_and_ps( fDet, MathlibSSE2::SIGN_MASK );
        q00 = _mm_xor_ps( q00, fDet );
        q01 = _mm_xor_ps( q01, fDet );
        q02 = _mm_xor_ps( q02, fDet );
        q10 = _mm_xor_ps( q10, fDet );
        q11 = _mm_xor_ps( q11, fDet );
        q12 = _mm_xor_ps( q12, fDet );
        q20 = _mm_xor_ps( q20, fDet );
        q21 = _mm_xor_ps( q21, fDet );
        q22 = _mm_xor_ps( q22, fDet );

        const ArrayReal matrix[9] = { q00, q01, q02,
                                      q10, q11, q12,
                                      q20, q21, q22 };
        orientation.FromOrthoDet1RotationMatrix( matrix );




        ArrayReal * __restrict__ scaleChunkBase = scale.mChunkBase;
        scaleChunkBase[0] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( q20, m20 ), _mm_mul_ps( q10, m10 ) ), _mm_mul_ps( q00, m00 ) );
        scaleChunkBase[1] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( q21, m21 ), _mm_mul_ps( q11, m11 ) ), _mm_mul_ps( q01, m01 ) );
        scaleChunkBase[2] = _mm_add_ps( _mm_add_ps( _mm_mul_ps( q22, m22 ), _mm_mul_ps( q12, m12 ) ), _mm_mul_ps( q02, m02 ) );

        ArrayReal * __restrict__ posChunkBase = position.mChunkBase;
        posChunkBase[0] = chunkBase[3];
        posChunkBase[1] = chunkBase[7];
        posChunkBase[2] = chunkBase[11];
    }

    inline void ArrayMatrixAf4x3::setToInverse(void)
    {
        ArrayReal m10 = mChunkBase[4], m11 = mChunkBase[5], m12 = mChunkBase[6];
        ArrayReal m20 = mChunkBase[8], m21 = mChunkBase[9], m22 = mChunkBase[10];

        ArrayReal t00 = _mm_sub_ps( _mm_mul_ps( m22, m11 ), _mm_mul_ps( m21, m12 ) );
        ArrayReal t10 = _mm_sub_ps( _mm_mul_ps( m20, m12 ), _mm_mul_ps( m22, m10 ) );
        ArrayReal t20 = _mm_sub_ps( _mm_mul_ps( m21, m10 ), _mm_mul_ps( m20, m11 ) );

        ArrayReal m00 = mChunkBase[0], m01 = mChunkBase[1], m02 = mChunkBase[2];


        ArrayReal det = _mm_add_ps( _mm_add_ps( _mm_mul_ps( m02, t20 ), _mm_mul_ps( m01, t10 ) ), _mm_mul_ps( m00, t00 ) );
        ArrayReal invDet= _mm_div_ps( MathlibSSE2::ONE, det );

        t00 = _mm_mul_ps( t00, invDet );
        t10 = _mm_mul_ps( t10, invDet );
        t20 = _mm_mul_ps( t20, invDet );

        m00 = _mm_mul_ps( m00, invDet );
        m01 = _mm_mul_ps( m01, invDet );
        m02 = _mm_mul_ps( m02, invDet );

        ArrayReal r00 = t00;
        ArrayReal r01 = _mm_sub_ps( _mm_mul_ps( m02, m21 ), _mm_mul_ps( m01, m22 ) );
        ArrayReal r02 = _mm_sub_ps( _mm_mul_ps( m01, m12 ), _mm_mul_ps( m02, m11 ) );

        ArrayReal r10 = t10;
        ArrayReal r11 = _mm_sub_ps( _mm_mul_ps( m00, m22 ), _mm_mul_ps( m02, m20 ) );
        ArrayReal r12 = _mm_sub_ps( _mm_mul_ps( m02, m10 ), _mm_mul_ps( m00, m12 ) );

        ArrayReal r20 = t20;
        ArrayReal r21 = _mm_sub_ps( _mm_mul_ps( m01, m20 ), _mm_mul_ps( m00, m21 ) );
        ArrayReal r22 = _mm_sub_ps( _mm_mul_ps( m00, m11 ), _mm_mul_ps( m01, m10 ) );

        ArrayReal m03 = mChunkBase[3], m13 = mChunkBase[7], m23 = mChunkBase[11];




        ArrayReal r03 = _mm_add_ps( _mm_add_ps( _mm_mul_ps( r02, m23 ), _mm_mul_ps( r01, m13 ) ), _mm_mul_ps( r00, m03 ) );
        ArrayReal r13 = _mm_add_ps( _mm_add_ps( _mm_mul_ps( r12, m23 ), _mm_mul_ps( r11, m13 ) ), _mm_mul_ps( r10, m03 ) );
        ArrayReal r23 = _mm_add_ps( _mm_add_ps( _mm_mul_ps( r22, m23 ), _mm_mul_ps( r21, m13 ) ), _mm_mul_ps( r20, m03 ) );

        r03 = _mm_mul_ps( r03, MathlibSSE2::NEG_ONE );
        r13 = _mm_mul_ps( r13, MathlibSSE2::NEG_ONE );
        r23 = _mm_mul_ps( r23, MathlibSSE2::NEG_ONE );

        mChunkBase[0] = r00;
        mChunkBase[1] = r01;
        mChunkBase[2] = r02;
        mChunkBase[3] = r03;

        mChunkBase[4] = r10;
        mChunkBase[5] = r11;
        mChunkBase[6] = r12;
        mChunkBase[7] = r13;

        mChunkBase[8] = r20;
        mChunkBase[9] = r21;
        mChunkBase[10]= r22;
        mChunkBase[11]= r23;
    }

    inline void ArrayMatrixAf4x3::setToInverseDegeneratesAsIdentity(void)
    {
        ArrayReal m10 = mChunkBase[4], m11 = mChunkBase[5], m12 = mChunkBase[6];
        ArrayReal m20 = mChunkBase[8], m21 = mChunkBase[9], m22 = mChunkBase[10];

        ArrayReal t00 = _mm_sub_ps( _mm_mul_ps( m22, m11 ), _mm_mul_ps( m21, m12 ) );
        ArrayReal t10 = _mm_sub_ps( _mm_mul_ps( m20, m12 ), _mm_mul_ps( m22, m10 ) );
        ArrayReal t20 = _mm_sub_ps( _mm_mul_ps( m21, m10 ), _mm_mul_ps( m20, m11 ) );

        ArrayReal m00 = mChunkBase[0], m01 = mChunkBase[1], m02 = mChunkBase[2];


        ArrayReal det = _mm_add_ps( _mm_add_ps( _mm_mul_ps( m02, t20 ), _mm_mul_ps( m01, t10 ) ), _mm_mul_ps( m00, t00 ) );
        ArrayReal invDet= _mm_div_ps( MathlibSSE2::ONE, det );


        ArrayMaskR degenerateMask = _mm_cmplt_ps( MathlibSSE2::Abs4( det ), MathlibSSE2::fEpsilon );

        t00 = _mm_mul_ps( t00, invDet );
        t10 = _mm_mul_ps( t10, invDet );
        t20 = _mm_mul_ps( t20, invDet );

        m00 = _mm_mul_ps( m00, invDet );
        m01 = _mm_mul_ps( m01, invDet );
        m02 = _mm_mul_ps( m02, invDet );

        ArrayReal r00 = t00;
        ArrayReal r01 = _mm_sub_ps( _mm_mul_ps( m02, m21 ), _mm_mul_ps( m01, m22 ) );
        ArrayReal r02 = _mm_sub_ps( _mm_mul_ps( m01, m12 ), _mm_mul_ps( m02, m11 ) );

        ArrayReal r10 = t10;
        ArrayReal r11 = _mm_sub_ps( _mm_mul_ps( m00, m22 ), _mm_mul_ps( m02, m20 ) );
        ArrayReal r12 = _mm_sub_ps( _mm_mul_ps( m02, m10 ), _mm_mul_ps( m00, m12 ) );

        ArrayReal r20 = t20;
        ArrayReal r21 = _mm_sub_ps( _mm_mul_ps( m01, m20 ), _mm_mul_ps( m00, m21 ) );
        ArrayReal r22 = _mm_sub_ps( _mm_mul_ps( m00, m11 ), _mm_mul_ps( m01, m10 ) );

        ArrayReal m03 = mChunkBase[3], m13 = mChunkBase[7], m23 = mChunkBase[11];




        ArrayReal r03 = _mm_add_ps( _mm_add_ps( _mm_mul_ps( r02, m23 ), _mm_mul_ps( r01, m13 ) ), _mm_mul_ps( r00, m03 ) );
        ArrayReal r13 = _mm_add_ps( _mm_add_ps( _mm_mul_ps( r12, m23 ), _mm_mul_ps( r11, m13 ) ), _mm_mul_ps( r10, m03 ) );
        ArrayReal r23 = _mm_add_ps( _mm_add_ps( _mm_mul_ps( r22, m23 ), _mm_mul_ps( r21, m13 ) ), _mm_mul_ps( r20, m03 ) );

        r03 = _mm_mul_ps( r03, MathlibSSE2::NEG_ONE );
        r13 = _mm_mul_ps( r13, MathlibSSE2::NEG_ONE );
        r23 = _mm_mul_ps( r23, MathlibSSE2::NEG_ONE );

        mChunkBase[0] = MathlibSSE2::CmovRobust( MathlibSSE2::ONE, r00, degenerateMask );
        mChunkBase[1] = MathlibSSE2::CmovRobust( _mm_setzero_ps(), r01, degenerateMask );
        mChunkBase[2] = MathlibSSE2::CmovRobust( _mm_setzero_ps(), r02, degenerateMask );
        mChunkBase[3] = MathlibSSE2::CmovRobust( _mm_setzero_ps(), r03, degenerateMask );

        mChunkBase[4] = MathlibSSE2::CmovRobust( _mm_setzero_ps(), r10, degenerateMask );
        mChunkBase[5] = MathlibSSE2::CmovRobust( MathlibSSE2::ONE, r11, degenerateMask );
        mChunkBase[6] = MathlibSSE2::CmovRobust( _mm_setzero_ps(), r12, degenerateMask );
        mChunkBase[7] = MathlibSSE2::CmovRobust( _mm_setzero_ps(), r13, degenerateMask );

        mChunkBase[8] = MathlibSSE2::CmovRobust( _mm_setzero_ps(), r20, degenerateMask );
        mChunkBase[9] = MathlibSSE2::CmovRobust( _mm_setzero_ps(), r21, degenerateMask );
        mChunkBase[10]= MathlibSSE2::CmovRobust( MathlibSSE2::ONE, r22, degenerateMask );
        mChunkBase[11]= MathlibSSE2::CmovRobust( _mm_setzero_ps(), r23, degenerateMask );
    }

    inline void ArrayMatrixAf4x3::retain( ArrayMaskR orientation, ArrayMaskR scale )
    {
        ArrayVector3 row0( mChunkBase[0], mChunkBase[1], mChunkBase[2] );
        ArrayVector3 row1( mChunkBase[4], mChunkBase[5], mChunkBase[6] );
        ArrayVector3 row2( mChunkBase[8], mChunkBase[9], mChunkBase[10] );

        ArrayVector3 vScale( row0.length(), row1.length(), row2.length() );
        ArrayVector3 vInvScale( vScale );
        vInvScale.inverseLeaveZeroes();

        row0 *= vInvScale.mChunkBase[0];
        row1 *= vInvScale.mChunkBase[1];
        row2 *= vInvScale.mChunkBase[2];

        vScale.Cmov4( scale, ArrayVector3::UNIT_SCALE );

        row0.Cmov4( orientation, ArrayVector3::UNIT_X );
        row1.Cmov4( orientation, ArrayVector3::UNIT_Y );
        row2.Cmov4( orientation, ArrayVector3::UNIT_Z );

        row0 *= vScale.mChunkBase[0];
        row1 *= vScale.mChunkBase[1];
        row2 *= vScale.mChunkBase[2];

        mChunkBase[0] = row0.mChunkBase[0];
        mChunkBase[1] = row0.mChunkBase[1];
        mChunkBase[2] = row0.mChunkBase[2];

        mChunkBase[4] = row1.mChunkBase[0];
        mChunkBase[5] = row1.mChunkBase[1];
        mChunkBase[6] = row1.mChunkBase[2];

        mChunkBase[8] = row2.mChunkBase[0];
        mChunkBase[9] = row2.mChunkBase[1];
        mChunkBase[10]= row2.mChunkBase[2];
    }

    inline void ArrayMatrixAf4x3::streamToAoS( Matrix4 * __restrict__ dst ) const
    {
                 ArrayReal m0, m1, m2, m3;

        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((this->mChunkBase[0]), (this->mChunkBase[1]), 0x44); tmp2 = _mm_shuffle_ps((this->mChunkBase[0]), (this->mChunkBase[1]), 0xEE); tmp1 = _mm_shuffle_ps((this->mChunkBase[2]), (this->mChunkBase[3]), 0x44); tmp3 = _mm_shuffle_ps((this->mChunkBase[2]), (this->mChunkBase[3]), 0xEE); (m0) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (m1) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (m2) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (m3) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };



        _mm_stream_ps( dst[0]._m, m0 );
        _mm_stream_ps( dst[1]._m, m1 );
        _mm_stream_ps( dst[2]._m, m2 );
        _mm_stream_ps( dst[3]._m, m3 );
        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((this->mChunkBase[4]), (this->mChunkBase[5]), 0x44); tmp2 = _mm_shuffle_ps((this->mChunkBase[4]), (this->mChunkBase[5]), 0xEE); tmp1 = _mm_shuffle_ps((this->mChunkBase[6]), (this->mChunkBase[7]), 0x44); tmp3 = _mm_shuffle_ps((this->mChunkBase[6]), (this->mChunkBase[7]), 0xEE); (m0) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (m1) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (m2) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (m3) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };



        _mm_stream_ps( dst[0]._m+4, m0 );
        _mm_stream_ps( dst[1]._m+4, m1 );
        _mm_stream_ps( dst[2]._m+4, m2 );
        _mm_stream_ps( dst[3]._m+4, m3 );
        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((this->mChunkBase[8]), (this->mChunkBase[9]), 0x44); tmp2 = _mm_shuffle_ps((this->mChunkBase[8]), (this->mChunkBase[9]), 0xEE); tmp1 = _mm_shuffle_ps((this->mChunkBase[10]), (this->mChunkBase[11]), 0x44); tmp3 = _mm_shuffle_ps((this->mChunkBase[10]), (this->mChunkBase[11]), 0xEE); (m0) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (m1) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (m2) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (m3) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };



        _mm_stream_ps( dst[0]._m+8, m0 );
        _mm_stream_ps( dst[1]._m+8, m1 );
        _mm_stream_ps( dst[2]._m+8, m2 );
        _mm_stream_ps( dst[3]._m+8, m3 );

        _mm_stream_ps( dst[0]._m+12, MathlibSSE2::LAST_AFFINE_COLUMN );
        _mm_stream_ps( dst[1]._m+12, MathlibSSE2::LAST_AFFINE_COLUMN );
        _mm_stream_ps( dst[2]._m+12, MathlibSSE2::LAST_AFFINE_COLUMN );
        _mm_stream_ps( dst[3]._m+12, MathlibSSE2::LAST_AFFINE_COLUMN );
    }

    inline void ArrayMatrixAf4x3::storeToAoS( SimpleMatrixAf4x3 * __restrict__ dst ) const
    {
        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((this->mChunkBase[0]), (this->mChunkBase[1]), 0x44); tmp2 = _mm_shuffle_ps((this->mChunkBase[0]), (this->mChunkBase[1]), 0xEE); tmp1 = _mm_shuffle_ps((this->mChunkBase[2]), (this->mChunkBase[3]), 0x44); tmp3 = _mm_shuffle_ps((this->mChunkBase[2]), (this->mChunkBase[3]), 0xEE); (dst[0].mChunkBase[0]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (dst[1].mChunkBase[0]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (dst[2].mChunkBase[0]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (dst[3].mChunkBase[0]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((this->mChunkBase[4]), (this->mChunkBase[5]), 0x44); tmp2 = _mm_shuffle_ps((this->mChunkBase[4]), (this->mChunkBase[5]), 0xEE); tmp1 = _mm_shuffle_ps((this->mChunkBase[6]), (this->mChunkBase[7]), 0x44); tmp3 = _mm_shuffle_ps((this->mChunkBase[6]), (this->mChunkBase[7]), 0xEE); (dst[0].mChunkBase[1]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (dst[1].mChunkBase[1]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (dst[2].mChunkBase[1]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (dst[3].mChunkBase[1]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((this->mChunkBase[8]), (this->mChunkBase[9]), 0x44); tmp2 = _mm_shuffle_ps((this->mChunkBase[8]), (this->mChunkBase[9]), 0xEE); tmp1 = _mm_shuffle_ps((this->mChunkBase[10]), (this->mChunkBase[11]), 0x44); tmp3 = _mm_shuffle_ps((this->mChunkBase[10]), (this->mChunkBase[11]), 0xEE); (dst[0].mChunkBase[2]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (dst[1].mChunkBase[2]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (dst[2].mChunkBase[2]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (dst[3].mChunkBase[2]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




    }

    inline void ArrayMatrixAf4x3::streamToAoS( SimpleMatrixAf4x3 * __restrict__ _dst ) const
    {
                 __m128 dst0, dst1, dst2, dst3;
        Real *dst = reinterpret_cast<Real*>( _dst );

        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((this->mChunkBase[0]), (this->mChunkBase[1]), 0x44); tmp2 = _mm_shuffle_ps((this->mChunkBase[0]), (this->mChunkBase[1]), 0xEE); tmp1 = _mm_shuffle_ps((this->mChunkBase[2]), (this->mChunkBase[3]), 0x44); tmp3 = _mm_shuffle_ps((this->mChunkBase[2]), (this->mChunkBase[3]), 0xEE); (dst0) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (dst1) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (dst2) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (dst3) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        _mm_stream_ps( &dst[0], dst0 );
        _mm_stream_ps( &dst[12], dst1 );
        _mm_stream_ps( &dst[24], dst2 );
        _mm_stream_ps( &dst[36], dst3 );

        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((this->mChunkBase[4]), (this->mChunkBase[5]), 0x44); tmp2 = _mm_shuffle_ps((this->mChunkBase[4]), (this->mChunkBase[5]), 0xEE); tmp1 = _mm_shuffle_ps((this->mChunkBase[6]), (this->mChunkBase[7]), 0x44); tmp3 = _mm_shuffle_ps((this->mChunkBase[6]), (this->mChunkBase[7]), 0xEE); (dst0) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (dst1) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (dst2) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (dst3) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        _mm_stream_ps( &dst[4], dst0 );
        _mm_stream_ps( &dst[16], dst1 );
        _mm_stream_ps( &dst[28], dst2 );
        _mm_stream_ps( &dst[40], dst3 );

        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((this->mChunkBase[8]), (this->mChunkBase[9]), 0x44); tmp2 = _mm_shuffle_ps((this->mChunkBase[8]), (this->mChunkBase[9]), 0xEE); tmp1 = _mm_shuffle_ps((this->mChunkBase[10]), (this->mChunkBase[11]), 0x44); tmp3 = _mm_shuffle_ps((this->mChunkBase[10]), (this->mChunkBase[11]), 0xEE); (dst0) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (dst1) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (dst2) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (dst3) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        _mm_stream_ps( &dst[8], dst0 );
        _mm_stream_ps( &dst[20], dst1 );
        _mm_stream_ps( &dst[32], dst2 );
        _mm_stream_ps( &dst[44], dst3 );
    }

    inline void ArrayMatrixAf4x3::loadFromAoS( const Matrix4 * __restrict__ src )
    {
        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((_mm_load_ps( src[0]._m )), (_mm_load_ps( src[1]._m )), 0x44); tmp2 = _mm_shuffle_ps((_mm_load_ps( src[0]._m )), (_mm_load_ps( src[1]._m )), 0xEE); tmp1 = _mm_shuffle_ps((_mm_load_ps( src[2]._m )), (_mm_load_ps( src[3]._m )), 0x44); tmp3 = _mm_shuffle_ps((_mm_load_ps( src[2]._m )), (_mm_load_ps( src[3]._m )), 0xEE); (this->mChunkBase[0]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[1]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[2]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[3]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((_mm_load_ps( src[0]._m+4 )), (_mm_load_ps( src[1]._m+4 )), 0x44); tmp2 = _mm_shuffle_ps((_mm_load_ps( src[0]._m+4 )), (_mm_load_ps( src[1]._m+4 )), 0xEE); tmp1 = _mm_shuffle_ps((_mm_load_ps( src[2]._m+4 )), (_mm_load_ps( src[3]._m+4 )), 0x44); tmp3 = _mm_shuffle_ps((_mm_load_ps( src[2]._m+4 )), (_mm_load_ps( src[3]._m+4 )), 0xEE); (this->mChunkBase[4]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[5]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[6]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[7]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((_mm_load_ps( src[0]._m+8 )), (_mm_load_ps( src[1]._m+8 )), 0x44); tmp2 = _mm_shuffle_ps((_mm_load_ps( src[0]._m+8 )), (_mm_load_ps( src[1]._m+8 )), 0xEE); tmp1 = _mm_shuffle_ps((_mm_load_ps( src[2]._m+8 )), (_mm_load_ps( src[3]._m+8 )), 0x44); tmp3 = _mm_shuffle_ps((_mm_load_ps( src[2]._m+8 )), (_mm_load_ps( src[3]._m+8 )), 0xEE); (this->mChunkBase[8]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[9]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[10]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[11]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




    }

    inline void ArrayMatrixAf4x3::loadFromAoS( const Matrix4 * __restrict__ * src )
    {
        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((_mm_load_ps( src[0]->_m )), (_mm_load_ps( src[1]->_m )), 0x44); tmp2 = _mm_shuffle_ps((_mm_load_ps( src[0]->_m )), (_mm_load_ps( src[1]->_m )), 0xEE); tmp1 = _mm_shuffle_ps((_mm_load_ps( src[2]->_m )), (_mm_load_ps( src[3]->_m )), 0x44); tmp3 = _mm_shuffle_ps((_mm_load_ps( src[2]->_m )), (_mm_load_ps( src[3]->_m )), 0xEE); (this->mChunkBase[0]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[1]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[2]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[3]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((_mm_load_ps( src[0]->_m+4 )), (_mm_load_ps( src[1]->_m+4 )), 0x44); tmp2 = _mm_shuffle_ps((_mm_load_ps( src[0]->_m+4 )), (_mm_load_ps( src[1]->_m+4 )), 0xEE); tmp1 = _mm_shuffle_ps((_mm_load_ps( src[2]->_m+4 )), (_mm_load_ps( src[3]->_m+4 )), 0x44); tmp3 = _mm_shuffle_ps((_mm_load_ps( src[2]->_m+4 )), (_mm_load_ps( src[3]->_m+4 )), 0xEE); (this->mChunkBase[4]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[5]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[6]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[7]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((_mm_load_ps( src[0]->_m+8 )), (_mm_load_ps( src[1]->_m+8 )), 0x44); tmp2 = _mm_shuffle_ps((_mm_load_ps( src[0]->_m+8 )), (_mm_load_ps( src[1]->_m+8 )), 0xEE); tmp1 = _mm_shuffle_ps((_mm_load_ps( src[2]->_m+8 )), (_mm_load_ps( src[3]->_m+8 )), 0x44); tmp3 = _mm_shuffle_ps((_mm_load_ps( src[2]->_m+8 )), (_mm_load_ps( src[3]->_m+8 )), 0xEE); (this->mChunkBase[8]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[9]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[10]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[11]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




    }

    inline void ArrayMatrixAf4x3::loadFromAoS( const SimpleMatrixAf4x3 * __restrict__ src )
    {
        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((src[0].mChunkBase[0]), (src[1].mChunkBase[0]), 0x44); tmp2 = _mm_shuffle_ps((src[0].mChunkBase[0]), (src[1].mChunkBase[0]), 0xEE); tmp1 = _mm_shuffle_ps((src[2].mChunkBase[0]), (src[3].mChunkBase[0]), 0x44); tmp3 = _mm_shuffle_ps((src[2].mChunkBase[0]), (src[3].mChunkBase[0]), 0xEE); (this->mChunkBase[0]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[1]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[2]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[3]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((src[0].mChunkBase[1]), (src[1].mChunkBase[1]), 0x44); tmp2 = _mm_shuffle_ps((src[0].mChunkBase[1]), (src[1].mChunkBase[1]), 0xEE); tmp1 = _mm_shuffle_ps((src[2].mChunkBase[1]), (src[3].mChunkBase[1]), 0x44); tmp3 = _mm_shuffle_ps((src[2].mChunkBase[1]), (src[3].mChunkBase[1]), 0xEE); (this->mChunkBase[4]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[5]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[6]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[7]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((src[0].mChunkBase[2]), (src[1].mChunkBase[2]), 0x44); tmp2 = _mm_shuffle_ps((src[0].mChunkBase[2]), (src[1].mChunkBase[2]), 0xEE); tmp1 = _mm_shuffle_ps((src[2].mChunkBase[2]), (src[3].mChunkBase[2]), 0x44); tmp3 = _mm_shuffle_ps((src[2].mChunkBase[2]), (src[3].mChunkBase[2]), 0xEE); (this->mChunkBase[8]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[9]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[10]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[11]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




    }

    inline void ArrayMatrixAf4x3::loadFromAoS( const SimpleMatrixAf4x3 * __restrict__ * src )
    {
        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((src[0]->mChunkBase[0]), (src[1]->mChunkBase[0]), 0x44); tmp2 = _mm_shuffle_ps((src[0]->mChunkBase[0]), (src[1]->mChunkBase[0]), 0xEE); tmp1 = _mm_shuffle_ps((src[2]->mChunkBase[0]), (src[3]->mChunkBase[0]), 0x44); tmp3 = _mm_shuffle_ps((src[2]->mChunkBase[0]), (src[3]->mChunkBase[0]), 0xEE); (this->mChunkBase[0]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[1]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[2]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[3]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((src[0]->mChunkBase[1]), (src[1]->mChunkBase[1]), 0x44); tmp2 = _mm_shuffle_ps((src[0]->mChunkBase[1]), (src[1]->mChunkBase[1]), 0xEE); tmp1 = _mm_shuffle_ps((src[2]->mChunkBase[1]), (src[3]->mChunkBase[1]), 0x44); tmp3 = _mm_shuffle_ps((src[2]->mChunkBase[1]), (src[3]->mChunkBase[1]), 0xEE); (this->mChunkBase[4]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[5]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[6]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[7]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




        { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_shuffle_ps((src[0]->mChunkBase[2]), (src[1]->mChunkBase[2]), 0x44); tmp2 = _mm_shuffle_ps((src[0]->mChunkBase[2]), (src[1]->mChunkBase[2]), 0xEE); tmp1 = _mm_shuffle_ps((src[2]->mChunkBase[2]), (src[3]->mChunkBase[2]), 0x44); tmp3 = _mm_shuffle_ps((src[2]->mChunkBase[2]), (src[3]->mChunkBase[2]), 0xEE); (this->mChunkBase[8]) = _mm_shuffle_ps(tmp0, tmp1, 0x88); (this->mChunkBase[9]) = _mm_shuffle_ps(tmp0, tmp1, 0xDD); (this->mChunkBase[10]) = _mm_shuffle_ps(tmp2, tmp3, 0x88); (this->mChunkBase[11]) = _mm_shuffle_ps(tmp2, tmp3, 0xDD); };




    }

}


namespace Ogre
{

    struct BoneTransform
    {

        unsigned char mIndex;


        Bone **mOwner;


        ArrayVector3 * __restrict__ mPosition;


        ArrayQuaternion * __restrict__ mOrientation;


        ArrayVector3 * __restrict__ mScale;


        SimpleMatrixAf4x3 const * * __restrict__ mParentNodeTransform;


        SimpleMatrixAf4x3 const * * __restrict__ mParentTransform;



        SimpleMatrixAf4x3 * __restrict__ mDerivedTransform;



        SimpleMatrixAf4x3 * __restrict__ mFinalTransform;



        bool * __restrict__ mInheritOrientation;



        bool * __restrict__ mInheritScale;

        BoneTransform() :
            mIndex( 0 ),
            mOwner( 0 ),
            mPosition( 0 ),
            mOrientation( 0 ),
            mScale( 0 ),
            mParentNodeTransform( 0 ),
            mParentTransform( 0 ),
            mDerivedTransform( 0 ),
            mFinalTransform( 0 ),
            mInheritOrientation( 0 ),
            mInheritScale( 0 )
        {
        }
        void copy( const BoneTransform &inCopy )
        {
            mOwner[mIndex] = inCopy.mOwner[inCopy.mIndex];

            Vector3 tmp;
            Quaternion qTmp;


            inCopy.mPosition->getAsVector3( tmp, inCopy.mIndex );
            mPosition->setFromVector3( tmp, mIndex );


            inCopy.mOrientation->getAsQuaternion( qTmp, inCopy.mIndex );
            mOrientation->setFromQuaternion( qTmp, mIndex );


            inCopy.mScale->getAsVector3( tmp, inCopy.mIndex );
            mScale->setFromVector3( tmp, mIndex );

            mParentNodeTransform[mIndex]= inCopy.mParentNodeTransform[inCopy.mIndex];
            mParentTransform[mIndex] = inCopy.mParentTransform[inCopy.mIndex];
            mDerivedTransform[mIndex] = inCopy.mDerivedTransform[inCopy.mIndex];
            mFinalTransform[mIndex] = inCopy.mFinalTransform[inCopy.mIndex];

            mInheritOrientation[mIndex] = inCopy.mInheritOrientation[inCopy.mIndex];
            mInheritScale[mIndex] = inCopy.mInheritScale[inCopy.mIndex];
        }




        void advancePack()
        {
            mOwner += 4;
            ++mPosition;
            ++mOrientation;
            ++mScale;
            mParentNodeTransform+= 4;
            mParentTransform += 4;
            mDerivedTransform += 4;
            mFinalTransform += 4;
            mInheritOrientation += 4;
            mInheritScale += 4;
        }

        void advancePack( size_t numAdvance )
        {
            mOwner += 4 * numAdvance;
            mPosition += numAdvance;
            mOrientation += numAdvance;
            mScale += numAdvance;
            mParentNodeTransform+= 4 * numAdvance;
            mParentTransform += 4 * numAdvance;
            mDerivedTransform += 4 * numAdvance;
            mFinalTransform += 4 * numAdvance;
            mInheritOrientation += 4 * numAdvance;
            mInheritScale += 4 * numAdvance;
        }
    };
}






namespace Ogre {
    class Bone : public NodeAlloc, public IdObject
    {
    public:
        typedef vector<Bone*>::type BoneVec;
        typedef vector<TagPoint*>::type TagPointVec;

    protected:
        ArrayMatrixAf4x3 const * __restrict__ mReverseBind;
        BoneTransform mTransform;


        mutable bool mCachedTransformOutOfDate;
        Node *mDebugParentNode;
        bool mInitialized;



        uint16 mDepthLevel;

        Bone *mParent;

        BoneVec mChildren;

        TagPointVec mTagPointChildren;

        String mName;


        BoneMemoryManager *mBoneMemoryManager;


        void _updateFromParent(void);


        void updateFromParentImpl(void);

        void setCachedTransformOutOfDate(void) const;

        void resetParentTransformPtr(void);




        void removeChild( Bone* child );

    public:






        size_t mGlobalIndex;

        size_t mParentIndex;

        Bone();
        virtual ~Bone();

        void _initialize( IdType id, BoneMemoryManager *boneMemoryManager,
                            Bone *parent, ArrayMatrixAf4x3 const * __restrict__ reverseBind );
        void _deinitialize( bool debugCheckLifoOrder=true );


        uint16 getDepthLevel() const { return mDepthLevel; }


        BoneTransform& _getTransform() { return mTransform; }


        void _memoryRebased(void);

        void _setReverseBindPtr( const ArrayMatrixAf4x3 *ptr ) { mReverseBind = ptr; }


        void setName( const String &name ) { mName = name; }


        const String& getName(void) const { return mName; }


        Bone* getParent(void) const { return mParent; }


        size_t getNumChildren(void) const { return mChildren.size(); }


        Bone* getChild(size_t index) { return mChildren[index]; }
        const Bone* getChild(size_t index) const { return mChildren[index]; }






        const BoneVec& getChildren(void) { return mChildren; }


        void addTagPoint( TagPoint *tagPoint );

        void removeTagPoint( TagPoint *tagPoint );
        void _setNodeParent( Node *nodeParent );





        inline void setOrientation( Quaternion q );





        inline Quaternion getOrientation() const;





        inline void setPosition( const Vector3& pos );





        inline Vector3 getPosition(void) const;





        inline void setScale( const Vector3& pos );





        inline Vector3 getScale(void) const;
        void setInheritOrientation(bool inherit);





        bool getInheritOrientation(void) const;







        void setInheritScale(bool inherit);





        bool getInheritScale(void) const;
        Matrix4 _getDerivedTransform(void) const;
        inline __attribute__((always_inline)) const SimpleMatrixAf4x3& _getLocalSpaceTransform(void) const
        {
            assert( !mCachedTransformOutOfDate );
            return mTransform.mDerivedTransform[mTransform.mIndex];
        }
        inline __attribute__((always_inline)) const SimpleMatrixAf4x3& _getFullTransform(void) const
        {
            assert( !mCachedTransformOutOfDate &&
                    (!mDebugParentNode || !mDebugParentNode->isCachedTransformOutOfDate()) );
            return mTransform.mFinalTransform[mTransform.mIndex];
        }


        const SimpleMatrixAf4x3& _getFullTransformUpdated(void);
        static void updateAllTransforms( const size_t numNodes, BoneTransform t,
                                         ArrayMatrixAf4x3 const * __restrict__ reverseBind,
                                         size_t numBinds );


        virtual void _setCachedTransformOutOfDate(void);
        bool isCachedTransformOutOfDate(void) const { return mCachedTransformOutOfDate; }

    };




}


namespace Ogre
{

    inline Quaternion Bone::getOrientation() const
    {
        return mTransform.mOrientation->getAsQuaternion( mTransform.mIndex );
    }

    inline void Bone::setOrientation( Quaternion q )
    {
        assert(!q.isNaN() && "Invalid orientation supplied as parameter");
        q.normalise();
        mTransform.mOrientation->setFromQuaternion( q, mTransform.mIndex );
        this->setCachedTransformOutOfDate();
    }

    inline void Bone::setPosition(const Vector3& pos)
    {
        assert(!pos.isNaN() && "Invalid vector supplied as parameter");
        mTransform.mPosition->setFromVector3( pos, mTransform.mIndex );
        this->setCachedTransformOutOfDate();
    }

    inline Vector3 Bone::getPosition(void) const
    {
        return mTransform.mPosition->getAsVector3( mTransform.mIndex );
    }

    inline void Bone::setScale(const Vector3& scale)
    {
        assert(!scale.isNaN() && "Invalid vector supplied as parameter");
        mTransform.mScale->setFromVector3( scale, mTransform.mIndex );
        this->setCachedTransformOutOfDate();
    }

    inline Vector3 Bone::getScale(void) const
    {
        return mTransform.mScale->getAsVector3( mTransform.mIndex );
    }
}


namespace Ogre
{
    class SkeletonDef;
    typedef vector<SkeletonAnimation>::type SkeletonAnimationVec;
    typedef vector<SkeletonAnimation*>::type ActiveAnimationsVec;
    class SkeletonInstance : public MovableAlloc
    {
    public:
        typedef vector<Bone>::type BoneVec;

    protected:
        BoneVec mBones;
        TransformArray mBoneStartTransforms;

        RawSimdUniquePtr<ArrayReal, MEMCATEGORY_ANIMATION> mManualBones;

        FastArray<size_t> mSlotStarts;

        SkeletonAnimationVec mAnimations;
        ActiveAnimationsVec mActiveAnimations;

        SkeletonDef const *mDefinition;




        BoneVec mUnusedNodes;


        Node *mParentNode;

        struct SceneNodeBonePair
        {
            Bone *boneChild;
            SceneNode *sceneNodeParent;
            SceneNodeBonePair( Bone *_boneChild, SceneNode *_sceneNodeParent ) :
                boneChild( _boneChild ), sceneNodeParent( _sceneNodeParent ) {}
        };
        typedef vector<SceneNodeBonePair>::type SceneNodeBonePairVec;

        SceneNodeBonePairVec mCustomParentSceneNodes;

        uint16 mRefCount;

    public:
        SkeletonInstance( const SkeletonDef *skeletonDef, BoneMemoryManager *boneMemoryManager );
        ~SkeletonInstance();

        const SkeletonDef* getDefinition(void) const { return mDefinition; }

        void update(void);


        void resetToPose(void);
        void setManualBone( Bone *bone, bool isManual );





        bool isManualBone( Bone *bone );







        void setSceneNodeAsParentOfBone( Bone *bone, SceneNode *nodeParent );


        inline __attribute__((always_inline)) const SimpleMatrixAf4x3& _getBoneFullTransform( size_t index ) const
        {
            return mBones[index]._getFullTransform();
        }


        Bone* getBone( IdString boneName );


        Bone* getBone( size_t index );


        size_t getNumBones(void) const;

        bool hasAnimation( IdString name ) const;

        SkeletonAnimation* getAnimation( IdString name );


        const SkeletonAnimationVec& getAnimations() const { return mAnimations; }





        void addAnimationsFromSkeleton( const String &skelName, const String &groupName );


        void _enableAnimation( SkeletonAnimation *animation );


        void _disableAnimation( SkeletonAnimation *animation );







        void setParentNode( Node *parentNode );


        Node* getParentNode(void) const { return mParentNode; }

        void getTransforms( SimpleMatrixAf4x3 * __restrict__ outTransform,
                            const FastArray<unsigned short> &usedBones ) const;




        void _updateBoneStartTransforms(void);

        const TransformArray& _getTransformArray() const { return mBoneStartTransforms; }

        const void* _getMemoryBlock(void) const;
        const void* _getMemoryUniqueOffset(void) const;

        void _incrementRefCount(void);
        void _decrementRefCount(void);
        uint16 _getRefCount(void) const;
    };

    inline bool OrderSkeletonInstanceByMemory( const SkeletonInstance *_left,
                                                const SkeletonInstance *_right )
    {
        return _left->_getMemoryUniqueOffset() < _right->_getMemoryUniqueOffset();
    }



}

namespace Ogre
{
namespace v1
{
    class InstancedEntity : public Ogre::MovableObject
    {
        friend class InstanceBatch;
        friend class InstanceBatchShader;
        friend class InstanceBatchHW;
        friend class InstanceBatchHW_VTF;
        friend class BaseInstanceBatchVTF;
    protected:
        uint16 mInstanceId;
        bool mInUse;
        InstanceBatch *mBatchOwner;


        AnimationStateSet *mAnimationState;
        OldSkeletonInstance *mSkeletonInstance;
        Matrix4 *mBoneMatrices;
        Matrix4 *mBoneWorldMatrices;
        unsigned long mFrameAnimationLastUpdated;





        InstancedEntity* mSharedTransformEntity;



        uint16 mTransformLookupNumber;


        typedef vector<InstancedEntity*>::type InstancedEntityVec;
        InstancedEntityVec mSharingPartners;


        size_t getTransforms( Matrix4 *xform ) const;

        size_t getTransforms3x4( float *xform ) const;





        inline __attribute__((always_inline)) void writeSingleTransform3x4( float * __restrict__ xform ) const;
        inline __attribute__((always_inline)) void writeAnimatedTransform3x4( float * __restrict__ xform,
                                                    Mesh::IndexMap::const_iterator boneIdxStart,
                                                    Mesh::IndexMap::const_iterator boneIdxEnd ) const;
        inline __attribute__((always_inline)) void writeLutTransform3x4( float * __restrict__ xform,
                                                    Mesh::IndexMap::const_iterator boneIdxStart,
                                                    Mesh::IndexMap::const_iterator boneIdxEnd ) const;
        inline __attribute__((always_inline)) void writeDualQuatTransform( float * __restrict__ xform,
                                                    Mesh::IndexMap::const_iterator boneIdxStart,
                                                    Mesh::IndexMap::const_iterator boneIdxEnd ) const;


        bool findVisible( Camera *camera ) const;


        void createSkeletonInstance();
        void destroySkeletonInstance();



        void stopSharingTransformAsSlave( bool notifyMaster );


        void unlinkTransform( bool notifyMaster=true );


        void notifyUnlink( const InstancedEntity *slave );


        void setInUse(bool used);

    public:
        InstancedEntity( IdType id, ObjectMemoryManager *objectMemoryManager, InstanceBatch *batchOwner,
                         uint32 instanceID,



                         InstancedEntity* sharedTransformEntity = NULL );
        virtual ~InstancedEntity();
        bool shareTransformWith( InstancedEntity *slave );
        void stopSharingTransform();

        InstanceBatch* _getOwner() const { return mBatchOwner; }

        const String& getMovableType(void) const;

        const AxisAlignedBox& getBoundingBox(void) const;



        Real getSquaredViewDepth( const Camera* cam ) const;


        virtual void _notifyStaticDirty(void) const;


        virtual void _notifyAttached( Node* parent );






        void _updateRenderQueue( RenderQueue* queue, Camera *camera, const Camera *lodCamera ) {}


        bool hasSkeleton(void) const { return mSkeletonInstance != 0; }



        OldSkeletonInstance* getSkeleton(void) const { return mSkeletonInstance; }






        AnimationState* getAnimationState(const String& name) const;

        AnimationStateSet* getAllAnimationStates(void) const;






        bool _updateAnimation(void);



        void setTransformLookupNumber(uint16 num) { mTransformLookupNumber = num;}


        bool isInUse() const { return mInUse; }


        virtual bool isInScene(void) const
        {


            return mInUse;
        }
        void setCustomParam( unsigned char idx, const Vector4 &newParam );
        const Vector4& getCustomParam( unsigned char idx );
    };
}
}


namespace Ogre
{
namespace v1
{

    inline __attribute__((always_inline)) void InstancedEntity::writeSingleTransform3x4( float * __restrict__ xform ) const
    {

        const Matrix4& mat = mParentNode->_getFullTransform();
        _mm_stream_ps( xform, _mm_load_ps( mat[0] ) );
        _mm_stream_ps( xform+4, _mm_load_ps( mat[1] ) );
        _mm_stream_ps( xform+8, _mm_load_ps( mat[2] ) );
    }


    inline __attribute__((always_inline)) void InstancedEntity::writeAnimatedTransform3x4( float * __restrict__ xform,
                                                            Mesh::IndexMap::const_iterator itor,
                                                            Mesh::IndexMap::const_iterator end ) const
    {




        while( itor != end )
        {

            Matrix4 const * __restrict__ mat = reinterpret_cast<Matrix4 const * __restrict__>
                                                    (mBoneWorldMatrices[*itor++][0]);
            _mm_stream_ps( xform, _mm_load_ps( (*mat)[0] ) );
            _mm_stream_ps( xform+4, _mm_load_ps( (*mat)[1] ) );
            _mm_stream_ps( xform+8, _mm_load_ps( (*mat)[2] ) );
            xform += 12;
        }
    }

    inline __attribute__((always_inline)) void InstancedEntity::writeLutTransform3x4( float * __restrict__ xform,
                                                            Mesh::IndexMap::const_iterator itor,
                                                            Mesh::IndexMap::const_iterator end ) const
    {
        while( itor != end )
        {

            Matrix4 const * __restrict__ mat = reinterpret_cast<Matrix4 const * __restrict__>
                                                    (mBoneMatrices[*itor++][0]);
            _mm_stream_ps( xform, _mm_load_ps( (*mat)[0] ) );
            _mm_stream_ps( xform+4, _mm_load_ps( (*mat)[1] ) );
            _mm_stream_ps( xform+8, _mm_load_ps( (*mat)[2] ) );
            xform += 12;
        }
    }

    inline __attribute__((always_inline)) void InstancedEntity::writeDualQuatTransform( float * __restrict__ xform,
                                                            Mesh::IndexMap::const_iterator itor,
                                                            Mesh::IndexMap::const_iterator end ) const
    {
        DualQuaternion dQuat;
        Matrix4 matrix;

        matrix[3][0] = 0;
        matrix[3][1] = 0;
        matrix[3][2] = 0;
        matrix[3][3] = 1;

        while( itor != end )
        {
            const Matrix4 &boneWorldMat = mBoneWorldMatrices[*itor++];

            for(int i = 0; i < 3; ++i)
            {
                matrix[i][0] = boneWorldMat[i][0];
                matrix[i][1] = boneWorldMat[i][1];
                matrix[i][2] = boneWorldMat[i][2];
                matrix[i][3] = boneWorldMat[i][3];
            }


            dQuat.fromTransformationMatrix( matrix );


            for(int i = 0; i < 8; ++i)
                *xform++ = static_cast<float>( dQuat[i] );
        }
    }
}
}



namespace Ogre
{
namespace v1
{
    class InstanceManager : public FactoryAlloc
    {
    public:
        enum InstancingTechnique
        {
            ShaderBased,
            TextureVTF,
            HWInstancingBasic,
            HWInstancingVTF,
            InstancingTechniquesCount
        };


        enum BatchSettingId
        {

            CAST_SHADOWS = 0,

            SHOW_BOUNDINGBOX,

            NUM_SETTINGS
        };

    private:
        struct BatchSettings
        {

            bool setting[NUM_SETTINGS];

            BatchSettings()
            {
                setting[CAST_SHADOWS] = true;
                setting[SHOW_BOUNDINGBOX] = false;
            }
        };

        typedef vector<InstanceBatch*>::type InstanceBatchVec;
        typedef map<IdString, InstanceBatchVec>::type InstanceBatchMap;

        typedef map<IdString, BatchSettings>::type BatchSettingsMap;

        const IdString mName;
        MeshPtr mMeshReference;
        InstanceBatchMap mInstanceBatches;

        size_t mIdCount;

        InstanceBatchVec mDynamicBatches;
        InstanceBatchVec mDirtyStaticBatches;

        RenderOperation mSharedRenderOperation;

        size_t mInstancesPerBatch;
        InstancingTechnique mInstancingTechnique;
        uint16 mInstancingFlags;
        unsigned short mSubMeshIdx;

        BatchSettingsMap mBatchSettings;
        SceneManager* mSceneManager;

        size_t mMaxLookupTableInstances;
        unsigned char mNumCustomParams;




        inline InstanceBatch* getFreeBatch( const String &materialName, SceneMemoryMgrTypes sceneType );
        InstanceBatch* buildNewBatch( const String &materialName, SceneMemoryMgrTypes sceneType,
                                        bool firstTime );



        void defragmentBatches( bool optimizeCull, vector<InstancedEntity*>::type &entities,
                                vector<Ogre::Vector4>::type &usedParams,
                                InstanceBatchVec &fragmentedBatches );




        void applySettingToBatches( BatchSettingId id, bool value, const InstanceBatchVec &container );

    public:
        InstanceManager( IdString customName, SceneManager *sceneManager,
                         const String &meshName, const String &groupName,
                         InstancingTechnique instancingTechnique, uint16 instancingFlags,
                         size_t instancesPerBatch, unsigned short subMeshIdx, bool useBoneMatrixLookup = false);
        virtual ~InstanceManager();

        const IdString getName() const { return mName; }

        SceneManager* getSceneManager() const { return mSceneManager; }






        void setInstancesPerBatch( size_t instancesPerBatch );
        void setMaxLookupTableInstances( size_t maxLookupTableInstances );
        void setNumCustomParams( unsigned char numCustomParams );

        unsigned char getNumCustomParams() const
        { return mNumCustomParams; }


        InstancingTechnique getInstancingTechnique() const
        { return mInstancingTechnique; }
        size_t getMaxOrBestNumInstancesPerBatch( const String &materialName, size_t suggestedSize,
                                                 uint16 flags );


        InstancedEntity* createInstancedEntity( const String &materialName,
                                                SceneMemoryMgrTypes sceneType=SCENE_DYNAMIC );







        void cleanupEmptyBatches(void);
        void defragmentBatches( bool optimizeCulling );
        void setSetting( BatchSettingId id, bool enabled, IdString materialName=IdString() );


        bool getSetting( BatchSettingId id, IdString materialName ) const;




        bool hasSettings( IdString materialName ) const
        { return mBatchSettings.find( materialName ) != mBatchSettings.end(); }


        void setBatchesAsStatic( bool bStatic );






        void _addToDynamicBatchList( InstanceBatch *dynamicBatch );






        void _removeFromDynamicBatchList( InstanceBatch *batch );




        void _addDirtyStaticBatch( InstanceBatch *dirtyBatch );



        void _updateAnimations(void);



        void _updateDirtyBatchesThread( size_t threadIdx );


        void _updateDirtyBatches(void);

        typedef ConstMapIterator<InstanceBatchMap> InstanceBatchMapIterator;
        typedef ConstVectorIterator<InstanceBatchVec> InstanceBatchIterator;


        InstanceBatchMapIterator getInstanceBatchMapIterator(void) const
        { return InstanceBatchMapIterator( mInstanceBatches.begin(), mInstanceBatches.end() ); }







        InstanceBatchIterator getInstanceBatchIterator( const String &materialName,
                                                        SceneMemoryMgrTypes sceneType ) const;
    };

    struct InstanceManagerCmp
    {
        bool operator () ( const InstanceManager *a, const InstanceManager *b ) const
        {
            return a->getName() < b->getName();
        }
        bool operator () ( const InstanceManager *a, IdString name ) const
        {
            return a->getName() < name;
        }
        bool operator () ( IdString name, const InstanceManager *a ) const
        {
            return name < a->getName();
        }
    };

}
}



namespace Ogre
{
namespace v1
{
    class KeyFrame : public AnimationAlloc
    {
    public:


        KeyFrame(const AnimationTrack* parent, Real time);

        virtual ~KeyFrame() {}


        Real getTime(void) const { return mTime; }


        virtual KeyFrame* _clone(AnimationTrack* newParent) const;


    protected:
        Real mTime;
        const AnimationTrack* mParentTrack;
    };




    class NumericKeyFrame : public KeyFrame
    {
    public:

        NumericKeyFrame(const AnimationTrack* parent, Real time);
        ~NumericKeyFrame() {}


        virtual const AnyNumeric& getValue(void) const;




        virtual void setValue(const AnyNumeric& val);


        KeyFrame* _clone(AnimationTrack* newParent) const;
    protected:
        AnyNumeric mValue;
    };



    class TransformKeyFrame : public KeyFrame
    {
    public:

        TransformKeyFrame(const AnimationTrack* parent, Real time);
        ~TransformKeyFrame() {}






        virtual void setTranslate(const Vector3& trans);


        const Vector3& getTranslate(void) const;






        virtual void setScale(const Vector3& scale);


        virtual const Vector3& getScale(void) const;





        virtual void setRotation(const Quaternion& rot);


        virtual const Quaternion& getRotation(void) const;


        KeyFrame* _clone(AnimationTrack* newParent) const;
    protected:
        Vector3 mTranslate;
        Vector3 mScale;
        Quaternion mRotate;


    };






    class VertexMorphKeyFrame : public KeyFrame
    {
    public:

        VertexMorphKeyFrame(const AnimationTrack* parent, Real time);
        ~VertexMorphKeyFrame() {}







        void setVertexBuffer(const HardwareVertexBufferSharedPtr& buf);


        const HardwareVertexBufferSharedPtr& getVertexBuffer(void) const;


        KeyFrame* _clone(AnimationTrack* newParent) const;

    protected:
        HardwareVertexBufferSharedPtr mBuffer;

    };





    class VertexPoseKeyFrame : public KeyFrame
    {
    public:

        VertexPoseKeyFrame(const AnimationTrack* parent, Real time);
        ~VertexPoseKeyFrame() {}





        struct PoseRef
        {







            ushort poseIndex;



            Real influence;

            PoseRef(ushort p, Real i) : poseIndex(p), influence(i) {}
        };
        typedef vector<PoseRef>::type PoseRefList;




        void addPoseReference(ushort poseIndex, Real influence);



        void updatePoseReference(ushort poseIndex, Real influence);



        void removePoseReference(ushort poseIndex);

        void removeAllPoseReferences(void);



        const PoseRefList& getPoseReferences(void) const;

        typedef VectorIterator<PoseRefList> PoseRefIterator;
        typedef ConstVectorIterator<PoseRefList> ConstPoseRefIterator;


        PoseRefIterator getPoseReferenceIterator(void);


        ConstPoseRefIterator getPoseReferenceIterator(void) const;


        KeyFrame* _clone(AnimationTrack* newParent) const;

        void _applyBaseKeyFrame(const VertexPoseKeyFrame* base);

    protected:
        PoseRefList mPoseRefs;

    };



}
}



namespace Ogre {
    class PlaneBoundedVolume
    {
    public:
        typedef vector<Plane>::type PlaneList;

        PlaneList planes;
        Plane::Side outside;

        PlaneBoundedVolume() :outside(Plane::NEGATIVE_SIDE) {}

        PlaneBoundedVolume(Plane::Side theOutside)
            : outside(theOutside) {}




        inline bool intersects(const AxisAlignedBox& box) const
        {
            if (box.isNull()) return false;
            if (box.isInfinite()) return true;


            Vector3 centre = box.getCenter();

            Vector3 halfSize = box.getHalfSize();

            PlaneList::const_iterator i, iend;
            iend = planes.end();
            for (i = planes.begin(); i != iend; ++i)
            {
                const Plane& plane = *i;

                Plane::Side side = plane.getSide(centre, halfSize);
                if (side == outside)
                {

                    return false;
                }
            }


            return true;

        }



        inline bool intersects(const Sphere& sphere) const
        {
            PlaneList::const_iterator i, iend;
            iend = planes.end();
            for (i = planes.begin(); i != iend; ++i)
            {
                const Plane& plane = *i;


                Real d = plane.getDistance(sphere.getCenter());

                if (outside == Plane::NEGATIVE_SIDE) d = -d;

                if ( (d - sphere.getRadius()) > 0)
                    return false;
            }

            return true;

        }





        inline std::pair<bool, Real> intersects(const Ray& ray)
        {
            return Math::intersects(ray, planes, outside == Plane::POSITIVE_SIDE);
        }

    };

    typedef vector<PlaneBoundedVolume>::type PlaneBoundedVolumeList;




}



namespace Ogre {
    class Light : public MovableObject
    {
  void resetAabb(void);
  void updateLightBounds(void);
    public:

        Real tempSquareDist;

        void _calcTempSquareDist(const Vector3& worldPos);


        enum LightTypes
        {

            LT_DIRECTIONAL = 0,

            LT_POINT = 1,

            LT_SPOTLIGHT = 2,

            NUM_LIGHT_TYPES
        };



        Light( IdType id, ObjectMemoryManager *objectMemoryManager, SceneManager *manager );



        ~Light();



        void setType(LightTypes type);


        virtual void setRenderQueueGroup(uint8 queueID);



        LightTypes getType(void) const { return mLightType; }
        inline void setDiffuseColour(Real red, Real green, Real blue);
        inline void setDiffuseColour(const ColourValue& colour);



        const ColourValue& getDiffuseColour(void) const { return mDiffuse; }
        inline void setSpecularColour(Real red, Real green, Real blue);
        inline void setSpecularColour(const ColourValue& colour);



        const ColourValue& getSpecularColour(void) const { return mSpecular; }
        void setAttenuationBasedOnRadius( Real radius, Real lumThreshold);
        void setAttenuation(Real range, Real constant, Real linear, Real quadratic);



        Real getAttenuationRange(void) const { return mRange; }



        Real getAttenuationConstant(void) const { return mAttenuationConst; }



        Real getAttenuationLinear(void) const { return mAttenuationLinear; }



        Real getAttenuationQuadric(void) const { return mAttenuationQuad; }







        void setDirection(const Vector3& vec);






        Vector3 getDirection(void) const;
  void setAffectParentNode( bool bAffect );

  bool getAffectParentNode(void) const { return mAffectParentNode; }
        void setSpotlightRange(const Radian& innerAngle, const Radian& outerAngle, Real falloff = 1.0);



        const Radian& getSpotlightInnerAngle(void) const { return mSpotInner; }



        const Radian& getSpotlightOuterAngle(void) const { return mSpotOuter; }



        Real getSpotlightFalloff(void) const { return mSpotFalloff; }



        void setSpotlightInnerAngle(const Radian& val);



        void setSpotlightOuterAngle(const Radian& val);



        inline void setSpotlightFalloff(Real val);







        void setSpotlightNearClipDistance(Real nearClip) { mSpotNearClip = nearClip; }




        Real getSpotlightNearClipDistance() const { return mSpotNearClip; }
        void setPowerScale(Real power);




        Real getPowerScale(void) const { return mPowerScale; }


        virtual void _updateRenderQueue(RenderQueue* queue, Camera *camera, const Camera *lodCamera) {}


        const String& getMovableType(void) const;


        Vector3 getDerivedDirection(void) const;
        Vector3 getDerivedDirectionUpdated(void) const;
        Vector4 getAs4DVector(void) const;


        uint32 getTypeFlags(void) const;


        AnimableValuePtr createAnimableValue(const String& valueName);
        void setShadowFarDistance(Real distance);


        void resetShadowFarDistance(void);



        Real getShadowFarDistance(void) const;
        Real getShadowFarDistanceSquared(void) const;






        void setShadowNearClipDistance(Real nearClip) { mShadowNearClipDist = nearClip; }







        Real getShadowNearClipDistance() const { return mShadowNearClipDist; }




        Real _deriveShadowNearClipDistance(const Camera* maincam) const;
        void setShadowFarClipDistance(Real farClip) { mShadowFarClipDist = farClip; }







        Real getShadowFarClipDistance() const { return mShadowFarClipDist; }




        Real _deriveShadowFarClipDistance(const Camera* maincam) const;
        void setCustomParameter(uint16 index, const Vector4& value);





        const Vector4& getCustomParameter(uint16 index) const;
        virtual void _updateCustomGpuParameter(uint16 paramIndex,
            const GpuProgramParameters::AutoConstantEntry& constantEntry,
            GpuProgramParameters* params) const;






        bool isInLightRange(const Ogre::Sphere& sphere) const;






        bool isInLightRange(const Ogre::AxisAlignedBox& container) const;

    protected:

        LightTypes mLightType;
        ColourValue mDiffuse;
        ColourValue mSpecular;

        Radian mSpotOuter;
        Radian mSpotInner;
        Real mSpotFalloff;
        Real mSpotNearClip;
        Real mRange;
        Real mAttenuationConst;
        Real mAttenuationLinear;
        Real mAttenuationQuad;
        Real mPowerScale;
        bool mOwnShadowFarDist;
  bool mAffectParentNode;
        Real mShadowFarDist;
        Real mShadowFarDistSquared;

        Real mShadowNearClipDist;
        Real mShadowFarClipDist;


        static String msMovableType;

        typedef map<uint16, Vector4>::type CustomParameterMap;

        CustomParameterMap mCustomParameters;
    };


    class LightFactory : public MovableObjectFactory
    {
    protected:
        virtual MovableObject* createInstanceImpl( IdType id, ObjectMemoryManager *objectMemoryManager,
                                                   SceneManager *manager,
                                                   const NameValuePairList* params = 0 );
    public:
        LightFactory() {}
        ~LightFactory() {}

        static String FACTORY_TYPE_NAME;

        const String& getType(void) const;
        void destroyInstance(MovableObject* obj);

    };



}


namespace Ogre
{
    inline void Light::setSpotlightFalloff( Real val )
    {
        mSpotFalloff = val;
    }

    inline void Light::setDiffuseColour( Real red, Real green, Real blue )
    {
        mDiffuse.r = red;
        mDiffuse.b = blue;
        mDiffuse.g = green;
    }

    inline void Light::setDiffuseColour( const ColourValue& colour )
    {
        mDiffuse = colour;
    }

    inline void Light::setSpecularColour( Real red, Real green, Real blue )
    {
        mSpecular.r = red;
        mSpecular.b = blue;
        mSpecular.g = green;
    }

    inline void Light::setSpecularColour( const ColourValue& colour )
    {
        mSpecular = colour;
    }
}









namespace Ogre {
    enum LoggingLevel
    {
        LL_LOW = 1,
        LL_NORMAL = 2,
        LL_BOREME = 3
    };



    enum LogMessageLevel
    {
        LML_TRIVIAL = 1,
        LML_NORMAL = 2,
        LML_CRITICAL = 3
    };


    class LogListener
    {
    public:
        virtual ~LogListener() {}
        virtual void messageLogged( const String& message, LogMessageLevel lml, bool maskDebug, const String &logName, bool& skipThisMessage ) = 0;
    };
    class Log : public LogAlloc
    {
    protected:
        std::ofstream mLog;
        LoggingLevel mLogLevel;
        bool mDebugOut;
        bool mSuppressFile;
        bool mTimeStamp;
        String mLogName;

        typedef vector<LogListener*>::type mtLogListener;
        mtLogListener mListeners;
    public:

        class Stream;

                       ;




        Log( const String& name, bool debugOutput = true, bool suppressFileOutput = false);





        ~Log();


        const String& getName() const { return mLogName; }

        bool isDebugOutputEnabled() const { return mDebugOut; }

        bool isFileOutputSuppressed() const { return mSuppressFile; }

        bool isTimeStampEnabled() const { return mTimeStamp; }




        void logMessage( const String& message, LogMessageLevel lml = LML_NORMAL, bool maskDebug = false );


        Stream stream(LogMessageLevel lml = LML_NORMAL, bool maskDebug = false);





        void setDebugOutputEnabled(bool debugOutput);




        void setLogDetail(LoggingLevel ll);




        void setTimeStampEnabled(bool timeStamp);


        LoggingLevel getLogDetail() const { return mLogLevel; }






        void addListener(LogListener* listener);







        void removeListener(LogListener* listener);
        class Stream
        {
        protected:
            Log* mTarget;
            LogMessageLevel mLevel;
            bool mMaskDebug;
            typedef StringStream BaseStream;
            BaseStream mCache;

        public:


            struct Flush {};

            Stream(Log* target, LogMessageLevel lml, bool maskDebug)
                :mTarget(target), mLevel(lml), mMaskDebug(maskDebug)
            {

            }

            Stream(const Stream& rhs)
                : mTarget(rhs.mTarget), mLevel(rhs.mLevel), mMaskDebug(rhs.mMaskDebug)
            {

                mCache.str(rhs.mCache.str());
            }
            ~Stream()
            {

                if (mCache.tellp() > 0)
                {
                    mTarget->logMessage(mCache.str(), mLevel, mMaskDebug);
                }
            }

            template <typename T>
            Stream& operator<< (const T& v)
            {
                mCache << v;
                return *this;
            }

            Stream& operator<< (const Flush& v)
            {
                                (void)v;
                mTarget->logMessage(mCache.str(), mLevel, mMaskDebug);
                mCache.str(BLANKSTRING);
                return *this;
            }


        };







    };


}




namespace Ogre
{
    class LogManager : public Singleton<LogManager>, public LogAlloc
    {
    protected:
        typedef map<String, Log*>::type LogList;


        LogList mLogs;


        Log* mDefaultLog;

    public:
                       ;

        LogManager();
        ~LogManager();
        Log* createLog( const String& name, bool defaultLog = false, bool debuggerOutput = true,
            bool suppressFileOutput = false);



        Log* getLog( const String& name);



        Log* getDefaultLog();


        void destroyLog(const String& name);

        void destroyLog(Log* log);




        Log* setDefaultLog(Log* newLog);



        void logMessage( const String& message, LogMessageLevel lml = LML_NORMAL,
            bool maskDebug = false);



        void logMessage( LogMessageLevel lml, const String& message,
            bool maskDebug = false) { logMessage(message, lml, maskDebug); }


        Log::Stream stream(LogMessageLevel lml = LML_NORMAL,
            bool maskDebug = false);



        void setLogDetail(LoggingLevel ll);
        static LogManager& getSingleton(void);
        static LogManager* getSingletonPtr(void);

    };




}



namespace Ogre
{
namespace v1
{
    class ManualObject : public MovableObject
    {
    public:
        ManualObject( IdType id, ObjectMemoryManager *objectMemoryManager, SceneManager *manager );
        virtual ~ManualObject();


        class ManualObjectSection;
        virtual void clear(void);
        virtual void estimateVertexCount(size_t vcount);
        virtual void estimateIndexCount(size_t icount);
        virtual void begin(const String& materialName,
            RenderOperation::OperationType opType = RenderOperation::OT_TRIANGLE_LIST, const String & groupName = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);




        virtual void setDynamic(bool dyn) { mDynamic = dyn; }

        virtual bool getDynamic() const { return mDynamic; }
        virtual void beginUpdate(size_t sectionIndex);







        virtual void position(const Vector3& pos);

        virtual void position(Real x, Real y, Real z);






        virtual void normal(const Vector3& norm);

        virtual void normal(Real x, Real y, Real z);
        virtual void tangent(const Vector3& tan);

        virtual void tangent(Real x, Real y, Real z);
        virtual void textureCoord(Real u);

        virtual void textureCoord(Real u, Real v);

        virtual void textureCoord(Real u, Real v, Real w);

        virtual void textureCoord(Real x, Real y, Real z, Real w);

        virtual void textureCoord(const Vector2& uv);

        virtual void textureCoord(const Vector3& uvw);

        virtual void textureCoord(const Vector4& xyzw);



        virtual void colour(const ColourValue& col);



        virtual void colour(Real r, Real g, Real b, Real a = 1.0f);
        virtual void index(uint32 idx);
        virtual void triangle(uint32 i1, uint32 i2, uint32 i3);
        virtual void quad(uint32 i1, uint32 i2, uint32 i3, uint32 i4);


        virtual size_t getCurrentVertexCount() const;


        virtual size_t getCurrentIndexCount() const;





        virtual ManualObjectSection* end(void);
        virtual void setMaterialName(size_t subIndex, const String& name, const String & group = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
        virtual MeshPtr convertToMesh(const String& meshName,
            const String& groupName = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
            bool buildShadowMapBuffers = true );
        void setUseIdentityProjection(bool useIdentityProjection);
        bool getUseIdentityProjection(void) const { return mUseIdentityProjection; }
        void setUseIdentityView(bool useIdentityView);
        bool getUseIdentityView(void) const { return mUseIdentityView; }



        ManualObjectSection* getSection(unsigned int index) const;



        unsigned int getNumSections(void) const;
        void setKeepDeclarationOrder(bool keepOrder) { mKeepDeclarationOrder = keepOrder; }





        bool getKeepDeclarationOrder() const { return mKeepDeclarationOrder; }



        const String& getMovableType(void) const;

        void _updateRenderQueue(RenderQueue* queue, Camera *camera, const Camera *lodCamera);

        EdgeData* getEdgeList(void);

        bool hasEdgeList(void);


        class ManualObjectSection : public Renderable, public MovableAlloc
        {
        protected:
            ManualObject* mParent;
            String mMaterialName;
            String mGroupName;
            mutable MaterialPtr mMaterial;
            RenderOperation mRenderOperation;
            bool m32BitIndices;


        public:
            ManualObjectSection(ManualObject* parent, const String& materialName,
                RenderOperation::OperationType opType, const String & groupName = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
            virtual ~ManualObjectSection();


            RenderOperation* getRenderOperation(void);

            const String& getMaterialName(void) const { return mMaterialName; }

            const String& getMaterialGroup(void) const { return mGroupName; }

            void setMaterialName(const String& name, const String& groupName = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME );

            void set32BitIndices(bool n32) { m32BitIndices = n32; }

            bool get32BitIndices() const { return m32BitIndices; }



            const MaterialPtr& getMaterial(void) const;

            void getRenderOperation(RenderOperation& op, bool casterPass);

            void getWorldTransforms(Matrix4* xform) const;

            Real getSquaredViewDepth(const Ogre::Camera *) const;

            const LightList &getLights(void) const;



        };

        typedef vector<ManualObjectSection*>::type SectionList;

    protected:

        bool mDynamic;

        SectionList mSectionList;

        ManualObjectSection* mCurrentSection;

        bool mCurrentUpdating;

        struct TempVertex
        {
            Vector3 position;
            Vector3 normal;
            Vector3 tangent;
            Vector4 texCoord[8];
            ushort texCoordDims[8];
            ColourValue colour;
        };

        TempVertex mTempVertex;

        bool mFirstVertex;

        bool mTempVertexPending;

        char* mTempVertexBuffer;

        size_t mTempVertexSize;

        uint32* mTempIndexBuffer;

        size_t mTempIndexSize;

        size_t mDeclSize;

        size_t mEstVertexCount;

        size_t mEstIndexCount;

        ushort mTexCoordIndex;

        bool mAnyIndexed;

        EdgeData* mEdgeList;

        bool mUseIdentityProjection;

        bool mUseIdentityView;

        bool mKeepDeclarationOrder;



        virtual void resetTempAreas(void);

        virtual void resizeTempVertexBufferIfNeeded(size_t numVerts);

        virtual void resizeTempIndexBufferIfNeeded(size_t numInds);


        virtual void copyTempVertexToBuffer(void);

    };



    class ManualObjectFactory : public MovableObjectFactory
    {
    protected:
        virtual MovableObject* createInstanceImpl( IdType id, ObjectMemoryManager *objectMemoryManager,
                                                   SceneManager *manager,
                                                   const NameValuePairList* params = 0 );
    public:
        ManualObjectFactory() {}
        ~ManualObjectFactory() {}

        static String FACTORY_TYPE_NAME;

        const String& getType(void) const;
        void destroyInstance( MovableObject* obj);

    };


}
}




namespace Ogre {

    class MaterialSerializer;
    class MaterialManager : public ResourceManager, public Singleton<MaterialManager>
    {
    public:



        class Listener
        {
        public:

            virtual ~Listener() { }
            virtual Technique* handleSchemeNotFound(unsigned short schemeIndex,
                const String& schemeName, Material* originalMaterial, unsigned short lodIndex,
                const Renderable* rend) = 0;





   virtual bool afterIlluminationPassesCreated(Technique* technique) { return false; }





   virtual bool beforeIlluminationPassesCleared(Technique* technique) { return false; }
        };

    protected:

        MaterialSerializer* mSerializer;

        MaterialPtr mDefaultSettings;


        Resource* createImpl(const String& name, ResourceHandle handle,
            const String& group, bool isManual, ManualResourceLoader* loader,
            const NameValuePairList* params);


        typedef map<String, unsigned short>::type SchemeMap;

        SchemeMap mSchemes;

        String mActiveSchemeName;

        unsigned short mActiveSchemeIndex;


        typedef list<Listener*>::type ListenerList;
        typedef map<String, ListenerList>::type ListenerMap;
        ListenerMap mListenerMap;

    public:

        static String DEFAULT_SCHEME_NAME;



        MaterialPtr create (const String& name, const String& group,
                            bool isManual = false, ManualResourceLoader* loader = 0,
                            const NameValuePairList* createParams = 0);



        MaterialPtr getByName(const String& name, const String& groupName = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME);



        MaterialManager();



        virtual ~MaterialManager();



        void initialise(void);



        void parseScript(DataStreamPtr& stream, const String& groupName);
        virtual MaterialPtr getDefaultSettings(void) const { return mDefaultSettings; }




        virtual unsigned short _getSchemeIndex(const String& name);



        virtual const String& _getSchemeName(unsigned short index);



        virtual unsigned short _getActiveSchemeIndex(void) const;




        virtual const String& getActiveScheme(void) const;




        virtual void setActiveScheme(const String& schemeName);





        virtual void addListener(Listener* l, const Ogre::String& schemeName = BLANKSTRING);





        virtual void removeListener(Listener* l, const Ogre::String& schemeName = BLANKSTRING);


        virtual Technique* _arbitrateMissingTechniqueForActiveScheme(
            Material* mat, unsigned short lodIndex, const Renderable* rend);


  virtual void _notifyAfterIlluminationPassesCreated(Technique* mat);


  virtual void _notifyBeforeIlluminationPassesCleared(Technique* mat);
        static MaterialManager& getSingleton(void);
        static MaterialManager* getSingletonPtr(void);

    };



}



namespace Ogre {
    struct MaterialScriptProgramDefinition
    {
        String name;
        GpuProgramType progType;
        String language;
        String source;
        String syntax;
        bool supportsSkeletalAnimation;
        bool supportsMorphAnimation;
        ushort supportsPoseAnimation;
        bool usesVertexTextureFetch;
        vector<std::pair<String, String> >::type customParameters;
    };


    class MaterialSerializer : public SerializerAlloc
    {
    public:


        enum SerializeEvent
        {
            MSE_PRE_WRITE,
            MSE_WRITE_BEGIN,
            MSE_WRITE_END,
            MSE_POST_WRITE
        };




        class Listener
        {
        public:
            virtual ~Listener() {}
            virtual void materialEventRaised(MaterialSerializer* ser,
                SerializeEvent event, bool& skip, const Material* mat)
                        { (void)ser; (void)event; (void)skip; (void)mat; }
            virtual void techniqueEventRaised(MaterialSerializer* ser,
                SerializeEvent event, bool& skip, const Technique* tech)
                        { (void)ser; (void)event; (void)skip; (void)tech; }
            virtual void passEventRaised(MaterialSerializer* ser,
                SerializeEvent event, bool& skip, const Pass* pass)
                        { (void)ser; (void)event; (void)skip; (void)pass; }
            void gpuProgramRefEventRaised(MaterialSerializer* ser,
                SerializeEvent event, bool& skip,
                const String& attrib,
                const GpuProgramPtr& program,
                const GpuProgramParametersSharedPtr& params,
                GpuProgramParameters* defaultParams)
                        {
                            (void)ser;
                            (void)event;
                            (void)skip;
                            (void)attrib;
                            (void)program;
                            (void)params;
                            (void)defaultParams;
                        }
            virtual void textureUnitStateEventRaised(MaterialSerializer* ser,
                SerializeEvent event, bool& skip, const TextureUnitState* textureUnit)
                        {
                            (void)ser;
                            (void)event;
                            (void)skip;
                            (void)textureUnit;
                        }
        };

    protected:

        typedef vector<Listener*>::type ListenerList;
        typedef ListenerList::iterator ListenerListIterator;
        typedef ListenerList::const_iterator ListenerListConstIterator;
        ListenerList mListeners;

        void writeMaterial(const MaterialPtr& pMat, const String& materialName = "");
        void writeTechnique(const Technique* pTech);
        void writePass(const Pass* pPass);
        void writeVertexProgramRef(const Pass* pPass);
        void writeTessellationHullProgramRef(const Pass* pPass);
        void writeTessellationDomainProgramRef(const Pass* pPass);
        void writeShadowCasterVertexProgramRef(const Pass* pPass);
        void writeShadowCasterFragmentProgramRef(const Pass* pPass);
        void writeGeometryProgramRef(const Pass* pPass);
        void writeFragmentProgramRef(const Pass* pPass);
        void writeGpuProgramRef(const String& attrib, const GpuProgramPtr& program, const GpuProgramParametersSharedPtr& params);
        void writeGpuPrograms(void);
        void writeGPUProgramParameters(const GpuProgramParametersSharedPtr& params, GpuProgramParameters* defaultParams,
                                       const unsigned short level = 4, const bool useMainBuffer = true);
        void writeNamedGpuProgramParameters(const GpuProgramParametersSharedPtr& params, GpuProgramParameters* defaultParams,
                                            const unsigned short level = 4, const bool useMainBuffer = true);
        void writeLowLevelGpuProgramParameters(const GpuProgramParametersSharedPtr& params, GpuProgramParameters* defaultParams,
                                               const unsigned short level = 4, const bool useMainBuffer = true);
        void writeGpuProgramParameter(
            const String& commandName, const String& identifier,
            const GpuProgramParameters::AutoConstantEntry* autoEntry,
            const GpuProgramParameters::AutoConstantEntry* defaultAutoEntry,
            bool isFloat, bool isDouble, bool isInt, bool isUnsignedInt,
            size_t physicalIndex, size_t physicalSize,
            const GpuProgramParametersSharedPtr& params, GpuProgramParameters* defaultParams,
            const unsigned short level, const bool useMainBuffer);
        void writeTextureUnit(const TextureUnitState *pTex);
        void writeSceneBlendFactor(const SceneBlendFactor c_src, const SceneBlendFactor c_dest,
                                   const SceneBlendFactor a_src, const SceneBlendFactor a_dest);
        void writeSceneBlendFactor(const SceneBlendFactor sbf_src, const SceneBlendFactor sbf_dest);
        void writeSceneBlendFactor(const SceneBlendFactor sbf);
        void writeCompareFunction(const CompareFunction cf);
        void writeColourValue(const ColourValue &colour, bool writeAlpha = false);
        void writeLayerBlendOperationEx(const LayerBlendOperationEx op);
        void writeLayerBlendSource(const LayerBlendSource lbs);

        typedef multimap<TextureUnitState::TextureEffectType, TextureUnitState::TextureEffect>::type EffectMap;

        void writeRotationEffect(const TextureUnitState::TextureEffect& effect, const TextureUnitState *pTex);
        void writeTransformEffect(const TextureUnitState::TextureEffect& effect, const TextureUnitState *pTex);
        void writeScrollEffect(const TextureUnitState::TextureEffect& effect, const TextureUnitState *pTex);
        void writeEnvironmentMapEffect(const TextureUnitState::TextureEffect& effect, const TextureUnitState *pTex);

        String convertFiltering(FilterOptions fo);





        void fireMaterialEvent(SerializeEvent event, bool& skip, const Material* mat);




        void fireTechniqueEvent(SerializeEvent event, bool& skip, const Technique* tech);




        void firePassEvent(SerializeEvent event, bool& skip, const Pass* pass);




        void fireGpuProgramRefEvent(SerializeEvent event, bool& skip,
            const String& attrib,
            const GpuProgramPtr& program,
            const GpuProgramParametersSharedPtr& params,
            GpuProgramParameters* defaultParams);





        void fireTextureUnitStateEvent(SerializeEvent event, bool& skip, const TextureUnitState* textureUnit);

   public:

        MaterialSerializer();

        virtual ~MaterialSerializer() {}
        void queueForExport(const MaterialPtr& pMat, bool clearQueued = false,
            bool exportDefaults = false, const String& materialName = "");
        void exportQueued(const String& filename, const bool includeProgDef = false, const String& programFilename = "");
        void exportMaterial(const MaterialPtr& pMat, const String& filename, bool exportDefaults = false,
            const bool includeProgDef = false, const String& programFilename = "",
            const String& materialName = "");

        const String &getQueuedAsString() const;

        void clearQueue();




        void addListener(Listener* listener);




        void removeListener(Listener* listener);

    private:
        String mBuffer;
        String mGpuProgramBuffer;
        typedef set<String>::type GpuProgramDefinitionContainer;
        typedef GpuProgramDefinitionContainer::iterator GpuProgramDefIterator;
        GpuProgramDefinitionContainer mGpuProgramDefinitionContainer;
        bool mDefaults;

    public:
        void beginSection(unsigned short level, const bool useMainBuffer = true)
        {
            String& buffer = (useMainBuffer ? mBuffer : mGpuProgramBuffer);
            buffer += "\n";
            for (unsigned short i = 0; i < level; ++i)
            {
                buffer += "\t";
            }
            buffer += "{";
        }
        void endSection(unsigned short level, const bool useMainBuffer = true)
        {
            String& buffer = (useMainBuffer ? mBuffer : mGpuProgramBuffer);
            buffer += "\n";
            for (unsigned short i = 0; i < level; ++i)
            {
                buffer += "\t";
            }
            buffer += "}";
        }

        void writeAttribute(unsigned short level, const String& att, const bool useMainBuffer = true)
        {
            String& buffer = (useMainBuffer ? mBuffer : mGpuProgramBuffer);
            buffer += "\n";
            for (unsigned short i = 0; i < level; ++i)
            {
                buffer += "\t";
            }
            buffer += att;
        }

        void writeValue(const String& val, const bool useMainBuffer = true)
        {
            String& buffer = (useMainBuffer ? mBuffer : mGpuProgramBuffer);
            buffer += (" " + val);
        }

        String quoteWord(const String& val)
        {
            if (val.find_first_of(" \t") != String::npos)
                return ("\"" + val + "\"");
            else return val;
        }


        void writeComment(unsigned short level, const String& comment, const bool useMainBuffer = true)
        {
            String& buffer = (useMainBuffer ? mBuffer : mGpuProgramBuffer);
            buffer += "\n";
            for (unsigned short i = 0; i < level; ++i)
            {
                buffer += "\t";
            }
            buffer += "// " + comment;
        }



    };


}







namespace Ogre {
namespace v1 {
    class PatchSurface : public PatchAlloc
    {
    public:
        PatchSurface();
        ~PatchSurface();

        enum PatchSurfaceType
        {

            PST_BEZIER
        };


        enum
        {
            AUTO_LEVEL = -1
        };

        enum VisibleSide {

            VS_FRONT,

            VS_BACK,

            VS_BOTH
        };
        void defineSurface(void* controlPointBuffer,
            v1::VertexDeclaration *declaration, size_t width, size_t height,
            PatchSurfaceType pType = PST_BEZIER,
            size_t uMaxSubdivisionLevel = AUTO_LEVEL, size_t vMaxSubdivisionLevel = AUTO_LEVEL,
            VisibleSide visibleSide = VS_FRONT);






        size_t getRequiredVertexCount(void) const;





        size_t getRequiredIndexCount(void) const;


        size_t getCurrentIndexCount(void) const;

        size_t getIndexOffset(void) const { return mIndexOffset; }

        size_t getVertexOffset(void) const { return mVertexOffset; }



        const AxisAlignedBox& getBounds(void) const;


        Real getBoundingSphereRadius(void) const;
        void build(v1::HardwareVertexBufferSharedPtr destVertexBuffer, size_t vertexStart,
            v1::HardwareIndexBufferSharedPtr destIndexBuffer, size_t indexStart);
        void setSubdivisionFactor(Real factor);


        Real getSubdivisionFactor(void) const;

        void* getControlPointBuffer(void) const
        {
            return mControlPointBuffer;
        }


        void notifyControlPointBufferDeallocated(void) {
            mControlPointBuffer = 0;
        }
    protected:

        v1::VertexDeclaration* mDeclaration;

        void* mControlPointBuffer;

        PatchSurfaceType mType;

        size_t mCtlWidth;

        size_t mCtlHeight;

        size_t mCtlCount;

        size_t mULevel;

        size_t mVLevel;

        size_t mMaxULevel;
        size_t mMaxVLevel;

        size_t mMeshWidth;

        size_t mMeshHeight;

        VisibleSide mVSide;

        Real mSubdivisionFactor;

        vector<Vector3>::type mVecCtlPoints;



        size_t findLevel( Vector3& a, Vector3& b, Vector3& c);

        void distributeControlPoints(void* lockedBuffer);
        void subdivideCurve(void* lockedBuffer, size_t startIdx, size_t stepSize, size_t numSteps, size_t iterations);
        void interpolateVertexData(void* lockedBuffer, size_t leftIndex, size_t rightIndex, size_t destIndex);
        void makeTriangles(void);

        size_t getAutoULevel(bool forMax = false);
        size_t getAutoVLevel(bool forMax = false);

        v1::HardwareVertexBufferSharedPtr mVertexBuffer;
        v1::HardwareIndexBufferSharedPtr mIndexBuffer;
        size_t mVertexOffset;
        size_t mIndexOffset;
        size_t mRequiredVertexCount;
        size_t mRequiredIndexCount;
        size_t mCurrIndexCount;

        AxisAlignedBox mAABB;
        Real mBoundingSphere;



    };



}
}



namespace Ogre {
namespace v1 {

    class MeshSerializerListener;
    class MeshManager: public ResourceManager, public Singleton<MeshManager>,
        public ManualResourceLoader
    {
    public:
        MeshManager();
        ~MeshManager();


        void _initialise(void);



        MeshPtr getByName(const String& name, const String& groupName = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME);




        MeshPtr create (const String& name, const String& group,
                            bool isManual = false, ManualResourceLoader* loader = 0,
                            const NameValuePairList* createParams = 0);
        ResourceCreateOrRetrieveResult createOrRetrieve(
            const String& name,
            const String& group,
            bool isManual=false, ManualResourceLoader* loader=0,
            const NameValuePairList* params=0,
            HardwareBuffer::Usage vertexBufferUsage = HardwareBuffer::HBU_STATIC_WRITE_ONLY,
            HardwareBuffer::Usage indexBufferUsage = HardwareBuffer::HBU_STATIC_WRITE_ONLY,
            bool vertexBufferShadowed = true, bool indexBufferShadowed = true);
        MeshPtr prepare( const String& filename, const String& groupName,
            HardwareBuffer::Usage vertexBufferUsage = HardwareBuffer::HBU_STATIC_WRITE_ONLY,
            HardwareBuffer::Usage indexBufferUsage = HardwareBuffer::HBU_STATIC_WRITE_ONLY,
            bool vertexBufferShadowed = true, bool indexBufferShadowed = true);
        MeshPtr load( const String& filename, const String& groupName,
            HardwareBuffer::Usage vertexBufferUsage = HardwareBuffer::HBU_STATIC_WRITE_ONLY,
            HardwareBuffer::Usage indexBufferUsage = HardwareBuffer::HBU_STATIC_WRITE_ONLY,
            bool vertexBufferShadowed = true, bool indexBufferShadowed = true);
        MeshPtr createManual( const String& name, const String& groupName,
            ManualResourceLoader* loader = 0);
        MeshPtr createPlane(
            const String& name, const String& groupName, const Plane& plane,
            Real width, Real height,
            int xsegments = 1, int ysegments = 1,
            bool normals = true, unsigned short numTexCoordSets = 1,
            Real uTile = 1.0f, Real vTile = 1.0f, const Vector3& upVector = Vector3::UNIT_Y,
            HardwareBuffer::Usage vertexBufferUsage = HardwareBuffer::HBU_STATIC_WRITE_ONLY,
            HardwareBuffer::Usage indexBufferUsage = HardwareBuffer::HBU_STATIC_WRITE_ONLY,
            bool vertexShadowBuffer = true, bool indexShadowBuffer = true);
        MeshPtr createCurvedIllusionPlane(
            const String& name, const String& groupName, const Plane& plane,
            Real width, Real height, Real curvature,
            int xsegments = 1, int ysegments = 1,
            bool normals = true, unsigned short numTexCoordSets = 1,
            Real uTile = 1.0f, Real vTile = 1.0f, const Vector3& upVector = Vector3::UNIT_Y,
            const Quaternion& orientation = Quaternion::IDENTITY,
            HardwareBuffer::Usage vertexBufferUsage = HardwareBuffer::HBU_STATIC_WRITE_ONLY,
            HardwareBuffer::Usage indexBufferUsage = HardwareBuffer::HBU_STATIC_WRITE_ONLY,
            bool vertexShadowBuffer = true, bool indexShadowBuffer = true,
            int ySegmentsToKeep = -1);
        MeshPtr createCurvedPlane(
            const String& name, const String& groupName, const Plane& plane,
            Real width, Real height, Real bow = 0.5f,
            int xsegments = 1, int ysegments = 1,
            bool normals = false, unsigned short numTexCoordSets = 1,
            Real uTile = 1.0f, Real vTile = 1.0f, const Vector3& upVector = Vector3::UNIT_Y,
            HardwareBuffer::Usage vertexBufferUsage = HardwareBuffer::HBU_STATIC_WRITE_ONLY,
            HardwareBuffer::Usage indexBufferUsage = HardwareBuffer::HBU_STATIC_WRITE_ONLY,
            bool vertexShadowBuffer = true, bool indexShadowBuffer = true);
        PatchMeshPtr createBezierPatch(
            const String& name, const String& groupName, void* controlPointBuffer,
            VertexDeclaration *declaration, size_t width, size_t height,
            size_t uMaxSubdivisionLevel = PatchSurface::AUTO_LEVEL,
            size_t vMaxSubdivisionLevel = PatchSurface::AUTO_LEVEL,
            PatchSurface::VisibleSide visibleSide = PatchSurface::VS_FRONT,
            HardwareBuffer::Usage vbUsage = HardwareBuffer::HBU_STATIC_WRITE_ONLY,
            HardwareBuffer::Usage ibUsage = HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY,
            bool vbUseShadow = true, bool ibUseShadow = true);




        void setPrepareAllMeshesForShadowVolumes(bool enable);

        bool getPrepareAllMeshesForShadowVolumes(void);
        static MeshManager& getSingleton(void);
        static MeshManager* getSingletonPtr(void);




        Real getBoundsPaddingFactor(void);



        void setBoundsPaddingFactor(Real paddingFactor);




        static void unshareVertices( Mesh *mesh );



        void setListener(MeshSerializerListener *listener);



        MeshSerializerListener *getListener();


        void loadResource(Resource* res);

    protected:

        Resource* createImpl(const String& name, ResourceHandle handle,
            const String& group, bool isManual, ManualResourceLoader* loader,
            const NameValuePairList* createParams);



        void tesselate2DMesh(SubMesh* pSub, unsigned short meshWidth, unsigned short meshHeight,
            bool doubleSided = false,
            HardwareBuffer::Usage indexBufferUsage = HardwareBuffer::HBU_STATIC_WRITE_ONLY,
            bool indexSysMem = false);

        void createPrefabPlane(void);
        void createPrefabCube(void);
        void createPrefabSphere(void);


        enum MeshBuildType
        {
            MBT_PLANE,
            MBT_CURVED_ILLUSION_PLANE,
            MBT_CURVED_PLANE
        };

        struct MeshBuildParams
        {
            MeshBuildType type;
            Plane plane;
            Real width;
            Real height;
            Real curvature;
            int xsegments;
            int ysegments;
            bool normals;
            unsigned short numTexCoordSets;
            Real xTile;
            Real yTile;
            Vector3 upVector;
            Quaternion orientation;
            HardwareBuffer::Usage vertexBufferUsage;
            HardwareBuffer::Usage indexBufferUsage;
            bool vertexShadowBuffer;
            bool indexShadowBuffer;
            int ySegmentsToKeep;
        };

        typedef map<Resource*, MeshBuildParams>::type MeshBuildParamsMap;
        MeshBuildParamsMap mMeshBuildParams;


        void loadManualPlane(Mesh* pMesh, MeshBuildParams& params);

        void loadManualCurvedPlane(Mesh* pMesh, MeshBuildParams& params);

        void loadManualCurvedIllusionPlane(Mesh* pMesh, MeshBuildParams& params);

        bool mPrepAllMeshesForShadowVolumes;


        Real mBoundsPaddingFactor;


        MeshSerializerListener *mListener;
    };




}
}



namespace Ogre {
    class MovablePlane : public Plane, public MovableObject
    {
    protected:
        mutable Plane mDerivedPlane;
        mutable Vector3 mLastTranslate;
        mutable Quaternion mLastRotate;
        AxisAlignedBox mNullBB;
        mutable bool mDirty;
        static String msMovableType;
    public:

        MovablePlane( IdType id, ObjectMemoryManager *objectMemoryManager, SceneManager *manager );
        MovablePlane( IdType id, ObjectMemoryManager *objectMemoryManager, SceneManager *manager,
                      const Plane& rhs );

        MovablePlane( IdType id, ObjectMemoryManager *objectMemoryManager, SceneManager *manager,
                      const Vector3& rkNormal, Real fConstant );
        MovablePlane( IdType id, ObjectMemoryManager *objectMemoryManager, SceneManager *manager,
                      const Vector3& rkNormal, const Vector3& rkPoint );
        MovablePlane( IdType id, ObjectMemoryManager *objectMemoryManager, SceneManager *manager,
                      const Vector3& rkPoint0, const Vector3& rkPoint1, const Vector3& rkPoint2 );
        ~MovablePlane() {}

        const AxisAlignedBox& getBoundingBox(void) const { return mNullBB; }

        void _updateRenderQueue(RenderQueue*, Camera *camera, const Camera *lodCamera) { }

        const String& getMovableType(void) const;

        const Plane& _getDerivedPlane(void) const;
    };


}



namespace Ogre {
namespace v1 {
    class EdgeData : public EdgeDataAlloc
    {
    public:

        EdgeData();


        struct Triangle {


            size_t indexSet;

            size_t vertexSet;

            size_t vertIndex[3];


            size_t sharedVertIndex[3];

            Triangle() :indexSet(0), vertexSet(0) {}
        };

        struct Edge {



            size_t triIndex[2];


            size_t vertIndex[2];

            size_t sharedVertIndex[2];

            bool degenerate;
        };




        typedef std::vector<Vector4, STLAllocator<Vector4, CategorisedAlignAllocPolicy<MEMCATEGORY_GEOMETRY> > > TriangleFaceNormalList;




        typedef vector<char>::type TriangleLightFacingList;

        typedef vector<Triangle>::type TriangleList;
        typedef vector<Edge>::type EdgeList;


        struct EdgeGroup
        {

            size_t vertexSet;

            const VertexData* vertexData;




            size_t triStart;

            size_t triCount;

            EdgeList edges;

        };

        typedef vector<EdgeGroup>::type EdgeGroupList;




        TriangleList triangles;

        TriangleFaceNormalList triangleFaceNormals;

        TriangleLightFacingList triangleLightFacings;

        EdgeGroupList edgeGroups;

        bool isClosed;
        void updateTriangleLightFacing(const Vector4& lightPos);





        void updateFaceNormals(size_t vertexSet, const HardwareVertexBufferSharedPtr& positionBuffer);

        EdgeData* clone();



        void log(Log* log);

    };
    class EdgeListBuilder
    {
    public:

        EdgeListBuilder();
        virtual ~EdgeListBuilder();





        void addVertexData(const VertexData* vertexData);
        void addIndexData(const IndexData* indexData, size_t vertexSet = 0,
            RenderOperation::OperationType opType = RenderOperation::OT_TRIANGLE_LIST);





        EdgeData* build(void);


        void log(Log* l);
    protected:






        struct CommonVertex {
            Vector3 position;
            size_t index;
            size_t vertexSet;
            size_t indexSet;
            size_t originalIndex;
        };

        struct Geometry {
            size_t vertexSet;
            size_t indexSet;
            const IndexData* indexData;
            RenderOperation::OperationType opType;
        };

        struct geometryLess {
            bool operator()(const Geometry& a, const Geometry& b) const
            {
                if (a.vertexSet < b.vertexSet) return true;
                if (a.vertexSet > b.vertexSet) return false;
                return a.indexSet < b.indexSet;
            }
        };

        struct vectorLess {
            bool operator()(const Vector3& a, const Vector3& b) const
            {
                if (a.x < b.x) return true;
                if (a.x > b.x) return false;
                if (a.y < b.y) return true;
                if (a.y > b.y) return false;
                return a.z < b.z;
            }
        };

        typedef vector<const VertexData*>::type VertexDataList;
        typedef vector<Geometry>::type GeometryList;
        typedef vector<CommonVertex>::type CommonVertexList;

        GeometryList mGeometryList;
        VertexDataList mVertexDataList;
        CommonVertexList mVertices;
        EdgeData* mEdgeData;

        typedef map<Vector3, size_t, vectorLess>::type CommonVertexMap;
        CommonVertexMap mCommonVertexMap;



        typedef multimap< std::pair<size_t, size_t>, std::pair<size_t, size_t> >::type EdgeMap;
        EdgeMap mEdgeMap;

        void buildTrianglesEdges(const Geometry &geometry);


        size_t findOrCreateCommonVertex(const Vector3& vec, size_t vertexSet,
            size_t indexSet, size_t originalIndex);

        void connectOrCreateEdge(size_t vertexSet, size_t triangleIndex, size_t vertIndex0, size_t vertIndex1,
            size_t sharedVertIndex0, size_t sharedVertIndex1);
    };



}
}





namespace Ogre {
namespace v1 {

    class MeshSerializerListener;
    struct MeshLodUsage;
    class MeshSerializerImpl : public Serializer
    {
    public:
        MeshSerializerImpl();
        virtual ~MeshSerializerImpl();
        void exportMesh(const Mesh* pMesh, DataStreamPtr stream,
            Endian endianMode = ENDIAN_NATIVE);
        void importMesh(DataStreamPtr& stream, Mesh* pDest, MeshSerializerListener *listener);

    protected:


        virtual void writeSubMeshNameTable(const Mesh* pMesh);
        virtual void writeMesh(const Mesh* pMesh);
        virtual void writeSubMesh(const SubMesh* s);
        virtual void writeSubMeshOperation(const SubMesh* s);
        virtual void writeSubMeshTextureAliases(const SubMesh* s);
        virtual void writeGeometry(const VertexData* pGeom);
        virtual void writeSkeletonLink(const String& skelName);
        virtual void writeMeshBoneAssignment(const VertexBoneAssignment& assign);
        virtual void writeSubMeshBoneAssignment(const VertexBoneAssignment& assign);

        virtual void writeLodLevel(const Mesh* pMesh);
        virtual void writeLodUsageManual(const MeshLodUsage& usage);
        virtual void writeLodUsageGenerated(const Mesh* pMesh, const MeshLodUsage& usage, unsigned short lodNum, uint8 casterPass);
        virtual void writeLodUsageGeneratedSubmesh(const SubMesh* submesh, unsigned short lodNum, uint8 casterPass);

        virtual void writeBoundsInfo(const Mesh* pMesh);
        virtual void writeEdgeList(const Mesh* pMesh);
        virtual void writeAnimations(const Mesh* pMesh);
        virtual void writeAnimation(const Animation* anim);
        virtual void writePoses(const Mesh* pMesh);
        virtual void writePose(const Pose* pose);
        virtual void writeAnimationTrack(const VertexAnimationTrack* track);
        virtual void writeMorphKeyframe(const VertexMorphKeyFrame* kf, size_t vertexCount);
        virtual void writePoseKeyframe(const VertexPoseKeyFrame* kf);
        virtual void writePoseKeyframePoseRef(const VertexPoseKeyFrame::PoseRef& poseRef);
        virtual void writeExtremes(const Mesh *pMesh);
        virtual void writeSubMeshExtremes(unsigned short idx, const SubMesh* s);

        virtual size_t calcMeshSize(const Mesh* pMesh);
        virtual size_t calcSubMeshSize(const SubMesh* pSub);
        virtual size_t calcGeometrySize(const VertexData* pGeom);
        virtual size_t calcSkeletonLinkSize(const String& skelName);
        virtual size_t calcBoneAssignmentSize(void);
        virtual size_t calcSubMeshOperationSize(const SubMesh* pSub);
        virtual size_t calcSubMeshNameTableSize(const Mesh* pMesh);
        virtual size_t calcLodLevelSize(const Mesh* pMesh);
        virtual size_t calcLodUsageManualSize(const MeshLodUsage& usage);
        virtual size_t calcLodUsageGeneratedSize(const Mesh* pMesh, const MeshLodUsage& usage, unsigned short lodNum, uint8 casterPass);
        virtual size_t calcLodUsageGeneratedSubmeshSize(const SubMesh* submesh, unsigned short lodNum, uint8 casterPass);
        virtual size_t calcEdgeListSize(const Mesh* pMesh);
        virtual size_t calcEdgeListLodSize(const EdgeData* data, bool isManual);
        virtual size_t calcEdgeGroupSize(const EdgeData::EdgeGroup& group);
        virtual size_t calcPosesSize(const Mesh* pMesh);
        virtual size_t calcPoseSize(const Pose* pose);
        virtual size_t calcAnimationsSize(const Mesh* pMesh);
        virtual size_t calcAnimationSize(const Animation* anim);
        virtual size_t calcAnimationTrackSize(const VertexAnimationTrack* track);
        virtual size_t calcMorphKeyframeSize(const VertexMorphKeyFrame* kf, size_t vertexCount);
        virtual size_t calcPoseKeyframeSize(const VertexPoseKeyFrame* kf);
        virtual size_t calcPoseKeyframePoseRefSize(void);
        virtual size_t calcPoseVertexSize(const Pose* pose);
        virtual size_t calcSubMeshTextureAliasesSize(const SubMesh* pSub);
        virtual size_t calcBoundsInfoSize(const Mesh* pMesh);
        virtual size_t calcExtremesSize(const Mesh* pMesh);
        virtual size_t calcSubMeshExtremesSize(unsigned short idx, const SubMesh* s);

        virtual void readTextureLayer(DataStreamPtr& stream, Mesh* pMesh, MaterialPtr& pMat);
        virtual void readSubMeshNameTable(DataStreamPtr& stream, Mesh* pMesh);
        virtual void readMesh(DataStreamPtr& stream, Mesh* pMesh, MeshSerializerListener *listener);
        virtual void readSubMesh(DataStreamPtr& stream, Mesh* pMesh, MeshSerializerListener *listener);
        virtual void readSubMeshOperation(DataStreamPtr& stream, Mesh* pMesh, SubMesh* sub);
        virtual void readSubMeshTextureAlias(DataStreamPtr& stream, Mesh* pMesh, SubMesh* sub);
        virtual void readGeometry(DataStreamPtr& stream, Mesh* pMesh, VertexData* dest);
        virtual void readGeometryVertexDeclaration(DataStreamPtr& stream, Mesh* pMesh, VertexData* dest);
        virtual void readGeometryVertexElement(DataStreamPtr& stream, Mesh* pMesh, VertexData* dest);
        virtual void readGeometryVertexBuffer(DataStreamPtr& stream, Mesh* pMesh, VertexData* dest);

        virtual void readSkeletonLink(DataStreamPtr& stream, Mesh* pMesh, MeshSerializerListener *listener);
        virtual void readMeshBoneAssignment(DataStreamPtr& stream, Mesh* pMesh);
        virtual void readSubMeshBoneAssignment(DataStreamPtr& stream, Mesh* pMesh,
            SubMesh* sub);
        virtual void readMeshLodLevel(DataStreamPtr& stream, Mesh* pMesh);

        virtual void readMeshLodUsageManual(DataStreamPtr& stream, Mesh* pMesh, unsigned short lodNum, MeshLodUsage& usage);
        virtual void readMeshLodUsageGenerated(DataStreamPtr& stream, Mesh* pMesh, unsigned short lodNum, MeshLodUsage& usage, uint8 casterPass);

        virtual void readBoundsInfo(DataStreamPtr& stream, Mesh* pMesh);
        virtual void readEdgeList(DataStreamPtr& stream, Mesh* pMesh);
        virtual void readEdgeListLodInfo(DataStreamPtr& stream, EdgeData* edgeData);
        virtual void readPoses(DataStreamPtr& stream, Mesh* pMesh);
        virtual void readPose(DataStreamPtr& stream, Mesh* pMesh);
        virtual void readAnimations(DataStreamPtr& stream, Mesh* pMesh);
        virtual void readAnimation(DataStreamPtr& stream, Mesh* pMesh);
        virtual void readAnimationTrack(DataStreamPtr& stream, Animation* anim,
            Mesh* pMesh);
        virtual void readMorphKeyFrame(DataStreamPtr& stream, VertexAnimationTrack* track);
        virtual void readPoseKeyFrame(DataStreamPtr& stream, VertexAnimationTrack* track);
        virtual void readExtremes(DataStreamPtr& stream, Mesh *pMesh);



        virtual void flipFromLittleEndian(void* pData, size_t vertexCount, size_t vertexSize, const VertexDeclaration::VertexElementList& elems);

        virtual void flipToLittleEndian(void* pData, size_t vertexCount, size_t vertexSize, const VertexDeclaration::VertexElementList& elems);


        virtual void flipEndian(void* pData, size_t vertexCount, size_t vertexSize, const VertexDeclaration::VertexElementList& elems);


        virtual void enableValidation();

        uint8 mNumBufferPasses;
        ushort exportedLodCount;
    };




    class MeshSerializerImpl_v1_10 : public MeshSerializerImpl
    {
    public:
        MeshSerializerImpl_v1_10();
        virtual ~MeshSerializerImpl_v1_10();

    protected:
        virtual void readMesh(DataStreamPtr& stream, Mesh* pMesh, MeshSerializerListener *listener);
        virtual void writeMesh(const Mesh* pMesh);
        virtual size_t calcLodLevelSize(const Mesh* pMesh);
    };





    class MeshSerializerImpl_v1_8 : public MeshSerializerImpl_v1_10
    {
    public:
        MeshSerializerImpl_v1_8();
        ~MeshSerializerImpl_v1_8();
    protected:


        virtual bool isLodMixed(const Mesh* pMesh);
        virtual size_t calcLodLevelSize(const Mesh* pMesh);
        virtual size_t calcLodUsageManualSize(const MeshLodUsage& usage);
        virtual size_t calcLodUsageGeneratedSize(const Mesh* pMesh, const MeshLodUsage& usage, unsigned short lodNum, uint8 casterPass);
        virtual size_t calcLodUsageGeneratedSubmeshSize(const SubMesh* submesh, unsigned short lodNum, uint8 casterPass);

        virtual void writeLodLevel(const Mesh* pMesh);
        virtual void writeLodUsageGenerated(const Mesh* pMesh, const MeshLodUsage& usage, unsigned short lodNum, uint8 casterPass);
        virtual void writeLodUsageGeneratedSubmesh(const SubMesh* submesh, unsigned short lodNum, uint8 casterPass);
        virtual void writeLodUsageManual(const MeshLodUsage& usage);

        virtual void readMeshLodUsageGenerated( DataStreamPtr& stream, Mesh* pMesh,
                                                unsigned short lodNum, MeshLodUsage& usage,
                                                uint8 casterPass );
        virtual void readMeshLodUsageManual(DataStreamPtr& stream, Mesh* pMesh, unsigned short lodNum, MeshLodUsage& usage);

        virtual void readMeshLodLevel(DataStreamPtr& stream, Mesh* pMesh);
        virtual void enableValidation();
    };




    class MeshSerializerImpl_v1_41 : public MeshSerializerImpl_v1_8
    {
    public:
        MeshSerializerImpl_v1_41();
        ~MeshSerializerImpl_v1_41();
    protected:
        void writeMorphKeyframe(const VertexMorphKeyFrame* kf, size_t vertexCount);
        void readMorphKeyFrame(DataStreamPtr& stream, VertexAnimationTrack* track);
        void writePose(const Pose* pose);
        void readPose(DataStreamPtr& stream, Mesh* pMesh);
        size_t calcMorphKeyframeSize(const VertexMorphKeyFrame* kf, size_t vertexCount);
        size_t calcPoseSize(const Pose* pose);
        size_t calcPoseVertexSize(void);
    };




    class MeshSerializerImpl_v1_4 : public MeshSerializerImpl_v1_41
    {
    public:
        MeshSerializerImpl_v1_4();
        ~MeshSerializerImpl_v1_4();
    protected:
        virtual size_t calcLodLevelSize(const Mesh* pMesh);
        virtual void readMeshLodLevel(DataStreamPtr& stream, Mesh* pMesh);

        virtual void writeLodLevel(const Mesh* pMesh);
        virtual void writeLodUsageGenerated(const Mesh* pMesh, const MeshLodUsage& usage, unsigned short lodNum, uint8 casterPass);

    };




    class MeshSerializerImpl_v1_3 : public MeshSerializerImpl_v1_4
    {
    public:
        MeshSerializerImpl_v1_3();
        ~MeshSerializerImpl_v1_3();
    protected:
        virtual void readEdgeListLodInfo(DataStreamPtr& stream, EdgeData* edgeData);


        virtual void reorganiseTriangles(EdgeData* edgeData);

        virtual void writeEdgeList(const Mesh* pMesh);
        virtual size_t calcEdgeListLodSize(const EdgeData* edgeData, bool isManual);
        virtual size_t calcEdgeGroupSize(const EdgeData::EdgeGroup& group);
    };




    class MeshSerializerImpl_v1_2 : public MeshSerializerImpl_v1_3
    {
    public:
        MeshSerializerImpl_v1_2();
        ~MeshSerializerImpl_v1_2();
    protected:
        virtual void readMesh(DataStreamPtr& stream, Mesh* pMesh, MeshSerializerListener *listener);
        virtual void readGeometry(DataStreamPtr& stream, Mesh* pMesh, VertexData* dest);
        virtual void readGeometryPositions(unsigned short bindIdx, DataStreamPtr& stream,
            Mesh* pMesh, VertexData* dest);
        virtual void readGeometryNormals(unsigned short bindIdx, DataStreamPtr& stream,
            Mesh* pMesh, VertexData* dest);
        virtual void readGeometryColours(unsigned short bindIdx, DataStreamPtr& stream,
            Mesh* pMesh, VertexData* dest);
        virtual void readGeometryTexCoords(unsigned short bindIdx, DataStreamPtr& stream,
            Mesh* pMesh, VertexData* dest, unsigned short set);
    };




    class MeshSerializerImpl_v1_1 : public MeshSerializerImpl_v1_2
    {
    public:
        MeshSerializerImpl_v1_1();
        ~MeshSerializerImpl_v1_1();
    protected:
        void readGeometryTexCoords(unsigned short bindIdx, DataStreamPtr& stream,
            Mesh* pMesh, VertexData* dest, unsigned short set);
    };



}
}

namespace Ogre {
namespace v1 {
    class MeshSerializerListener;


    enum MeshVersion
    {

        MESH_VERSION_LATEST,


        MESH_VERSION_2_1,


        MESH_VERSION_1_10,

        MESH_VERSION_1_8,

        MESH_VERSION_1_7,

        MESH_VERSION_1_4,

        MESH_VERSION_1_0,


        MESH_VERSION_LEGACY
    };
    class MeshSerializer : public Serializer
    {
    public:
        MeshSerializer();
        virtual ~MeshSerializer();
        void exportMesh(const Mesh* pMesh, const String& filename,
            Endian endianMode = ENDIAN_NATIVE);
        void exportMesh(const Mesh* pMesh, const String& filename,
                        MeshVersion version,
                        Endian endianMode = ENDIAN_NATIVE);
        void exportMesh(const Mesh* pMesh, DataStreamPtr stream,
            Endian endianMode = ENDIAN_NATIVE);
        void exportMesh(const Mesh* pMesh, DataStreamPtr stream,
                        MeshVersion version,
                        Endian endianMode = ENDIAN_NATIVE);
        void importMesh(DataStreamPtr& stream, Mesh* pDest);


        void setListener(MeshSerializerListener *listener);

        MeshSerializerListener *getListener();

    protected:

        class MeshVersionData : public SerializerAlloc
        {
        public:
            MeshVersion version;
            String versionString;
            MeshSerializerImpl* impl;

            MeshVersionData(MeshVersion _ver, const String& _string, MeshSerializerImpl* _impl)
            : version(_ver), versionString(_string), impl(_impl) {}

            ~MeshVersionData() { delete impl; }

        };

        typedef vector<MeshVersionData*>::type MeshVersionDataList;
        MeshVersionDataList mVersionData;

        MeshSerializerListener *mListener;

    };
    class MeshSerializerListener
    {
    public:
        virtual ~MeshSerializerListener() {}

        virtual void processMaterialName(Mesh *mesh, String *name) = 0;

        virtual void processSkeletonName(Mesh *mesh, String *name) = 0;

        virtual void processMeshCompleted(Mesh *mesh) = 0;
    };


}
}




namespace Ogre {
    class ParticleAffector : public StringInterface, public FXAlloc
    {
    protected:

        String mType;
        void addBaseParameters(void) { }

        ParticleSystem* mParent;
    public:
        ParticleAffector(ParticleSystem* parent): mParent(parent) {}


        virtual ~ParticleAffector();
        virtual void _initParticle(Particle* pParticle)
                {

                    (void)pParticle;
                }
        virtual void _affectParticles(ParticleSystem* pSystem, Real timeElapsed) = 0;






        const String &getType(void) const { return mType; }

    };



}


namespace Ogre {
    namespace EmitterCommands {

        class CmdAngle : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdColour : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };


        class CmdColourRangeStart : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdColourRangeEnd : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };


        class CmdDirection : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };


        class CmdUp : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };


        class CmdDirPositionRef : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };


        class CmdEmissionRate : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdVelocity : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdMinVelocity : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdMaxVelocity : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdTTL : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdMinTTL : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdMaxTTL : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdPosition : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdDuration : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdMinDuration : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdMaxDuration : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdRepeatDelay : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdMinRepeatDelay : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdMaxRepeatDelay : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdName : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };


        class CmdEmittedEmitter : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

    }



}

namespace Ogre {
    class ParticleVisualData : public FXAlloc
    {
    public:
        ParticleVisualData() {}
        virtual ~ParticleVisualData() {}

    };


    class Particle : public FXAlloc
    {
    protected:

        ParticleSystem* mParentSystem;

        ParticleVisualData* mVisual;
    public:

        enum ParticleType
        {
            Visual,
            Emitter
        };


        bool mOwnDimensions;

        Real mWidth;

        Real mHeight;

        Radian mRotation;



        Vector3 mPosition;

        Vector3 mDirection;

        ColourValue mColour;

        Real mTimeToLive;

        Real mTotalTimeToLive;

        Radian mRotationSpeed;

        ParticleType mParticleType;

        Particle()
            : mParentSystem(0), mVisual(0), mOwnDimensions(false), mWidth(0), mHeight(0),
            mRotation(0), mPosition(Vector3::ZERO), mDirection(Vector3::ZERO),
            mColour(ColourValue::White), mTimeToLive(10), mTotalTimeToLive(10),
            mRotationSpeed(0), mParticleType(Visual)
        {
        }
        void setDimensions(Real width, Real height);






        bool hasOwnDimensions(void) const { return mOwnDimensions; }


        Real getOwnWidth(void) const { return mWidth; }


        Real getOwnHeight(void) const { return mHeight; }


        void setRotation(const Radian& rad);

        const Radian& getRotation(void) const { return mRotation; }



        void _notifyOwner(ParticleSystem* owner);



        void _notifyVisualData(ParticleVisualData* vis) { mVisual = vis; }


        ParticleVisualData* getVisualData(void) const { return mVisual; }


        void resetDimensions(void);
    };


}




namespace Ogre {
    class ParticleEmitter : public StringInterface, public Particle
    {
    protected:


        static EmitterCommands::CmdAngle msAngleCmd;
        static EmitterCommands::CmdColour msColourCmd;
        static EmitterCommands::CmdColourRangeStart msColourRangeStartCmd;
        static EmitterCommands::CmdColourRangeEnd msColourRangeEndCmd;
        static EmitterCommands::CmdDirection msDirectionCmd;
        static EmitterCommands::CmdUp msUpCmd;
        static EmitterCommands::CmdDirPositionRef msDirPositionRefCmd;
        static EmitterCommands::CmdEmissionRate msEmissionRateCmd;
        static EmitterCommands::CmdMaxTTL msMaxTTLCmd;
        static EmitterCommands::CmdMaxVelocity msMaxVelocityCmd;
        static EmitterCommands::CmdMinTTL msMinTTLCmd;
        static EmitterCommands::CmdMinVelocity msMinVelocityCmd;
        static EmitterCommands::CmdPosition msPositionCmd;
        static EmitterCommands::CmdTTL msTTLCmd;
        static EmitterCommands::CmdVelocity msVelocityCmd;
        static EmitterCommands::CmdDuration msDurationCmd;
        static EmitterCommands::CmdMinDuration msMinDurationCmd;
        static EmitterCommands::CmdMaxDuration msMaxDurationCmd;
        static EmitterCommands::CmdRepeatDelay msRepeatDelayCmd;
        static EmitterCommands::CmdMinRepeatDelay msMinRepeatDelayCmd;
        static EmitterCommands::CmdMaxRepeatDelay msMaxRepeatDelayCmd;
        static EmitterCommands::CmdName msNameCmd;
        static EmitterCommands::CmdEmittedEmitter msEmittedEmitterCmd;



        ParticleSystem* mParent;

        Vector3 mPosition;

        Real mEmissionRate;

        String mType;

        Vector3 mDirection;

        Vector3 mUp;

        bool mUseDirPositionRef;


        Vector3 mDirPositionRef;

        Radian mAngle;

        Real mMinSpeed;

        Real mMaxSpeed;

        Real mMinTTL;

        Real mMaxTTL;

        ColourValue mColourRangeStart;

        ColourValue mColourRangeEnd;


        bool mEnabled;


        Real mStartTime;

        Real mDurationMin;

        Real mDurationMax;

        Real mDurationRemain;


        Real mRepeatDelayMin;
        Real mRepeatDelayMax;

        Real mRepeatDelayRemain;


        Real mRemainder;


        String mName;


        String mEmittedEmitter;



        bool mEmitted;







        virtual void genEmissionDirection( const Vector3 &particlePos, Vector3& destVector );





        virtual void genEmissionVelocity(Vector3& destVector);


        virtual Real genEmissionTTL(void);


        virtual void genEmissionColour(ColourValue& destColour);


        virtual unsigned short genConstantEmissionCount(Real timeElapsed);
        void addBaseParameters(void);


        void initDurationRepeat(void);


    public:
        ParticleEmitter(ParticleSystem* psys);

        virtual ~ParticleEmitter();


        virtual void setPosition(const Vector3& pos);


        virtual const Vector3& getPosition(void) const;
        virtual void setDirection(const Vector3& direction);


        virtual const Vector3& getDirection(void) const;
        virtual void setUp(const Vector3& up);


        virtual const Vector3& getUp(void) const;
        virtual void setDirPositionReference( const Vector3& position, bool enable );


        virtual const Vector3& getDirPositionReference() const;


        virtual bool getDirPositionReferenceEnabled() const;
        virtual void setAngle(const Radian& angle);


        virtual const Radian& getAngle(void) const;
        virtual void setParticleVelocity(Real speed);
        virtual void setParticleVelocity(Real min, Real max);

        virtual void setMinParticleVelocity(Real min);

        virtual void setMaxParticleVelocity(Real max);


        virtual Real getParticleVelocity(void) const;


        virtual Real getMinParticleVelocity(void) const;


        virtual Real getMaxParticleVelocity(void) const;
        virtual void setEmissionRate(Real particlesPerSecond);


        virtual Real getEmissionRate(void) const;
        virtual void setTimeToLive(Real ttl);
        virtual void setTimeToLive(Real minTtl, Real maxTtl);


        virtual void setMinTimeToLive(Real min);

        virtual void setMaxTimeToLive(Real max);


        virtual Real getTimeToLive(void) const;


        virtual Real getMinTimeToLive(void) const;

        virtual Real getMaxTimeToLive(void) const;
        virtual void setColour(const ColourValue& colour);
        virtual void setColour(const ColourValue& colourStart, const ColourValue& colourEnd);

        virtual void setColourRangeStart(const ColourValue& colour);

        virtual void setColourRangeEnd(const ColourValue& colour);

        virtual const ColourValue& getColour(void) const;

        virtual const ColourValue& getColourRangeStart(void) const;

        virtual const ColourValue& getColourRangeEnd(void) const;
        virtual unsigned short _getEmissionCount(Real timeElapsed) = 0;
        virtual void _initParticle(Particle* pParticle) {

            pParticle->resetDimensions();
        }







        const String &getType(void) const { return mType; }





        virtual void setEnabled(bool enabled);


        virtual bool getEnabled(void) const;
        virtual void setStartTime(Real startTime);

        virtual Real getStartTime(void) const;
        virtual void setDuration(Real duration);


        virtual Real getDuration(void) const;
        virtual void setDuration(Real min, Real max);

        virtual void setMinDuration(Real min);

        virtual void setMaxDuration(Real max);

        virtual Real getMinDuration(void) const;

        virtual Real getMaxDuration(void) const;
        virtual void setRepeatDelay(Real duration);


        virtual Real getRepeatDelay(void) const;
        virtual void setRepeatDelay(Real min, Real max);

        virtual void setMinRepeatDelay(Real min);

        virtual void setMaxRepeatDelay(Real max);

        virtual Real getMinRepeatDelay(void) const;

        virtual Real getMaxRepeatDelay(void) const;


        const String &getName(void) const;


        virtual void setName(const String& newName);


        const String &getEmittedEmitter(void) const;


        virtual void setEmittedEmitter(const String& emittedEmitter);


        virtual bool isEmitted(void) const;


        virtual void setEmitted(bool emitted);


    };



}



namespace Ogre {
    class ParticleIterator
    {
        friend class ParticleSystem;
    protected:
        list<Particle*>::type::iterator mPos;
        list<Particle*>::type::iterator mStart;
        list<Particle*>::type::iterator mEnd;


        ParticleIterator(list<Particle*>::type::iterator start, list<Particle*>::type::iterator end);

    public:

        bool end(void);


        Particle* getNext(void);
    };


}








namespace Ogre {
    class ParticleSystem : public StringInterface, public MovableObject
    {
    public:


        class CmdQuota : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdEmittedEmitterQuota : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdMaterial : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdCull : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdWidth : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdHeight : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdRenderer : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdSorted : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdLocalSpace : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdIterationInterval : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };

        class CmdNonvisibleTimeout : public ParamCommand
        {
        public:
            String doGet(const void* target) const;
            void doSet(void* target, const String& val);
        };






        ParticleSystem( IdType id, ObjectMemoryManager *objectMemoryManager, SceneManager *manager,
                        const String& resourceGroupName );

        virtual ~ParticleSystem();
        void setRenderer(const String& typeName);


        ParticleSystemRenderer* getRenderer(void) const;

        const String& getRendererName(void) const;
        ParticleEmitter* addEmitter(const String& emitterType);
        ParticleEmitter* getEmitter(unsigned short index) const;


        unsigned short getNumEmitters(void) const;
        void removeEmitter(unsigned short index);


        void removeAllEmitters(void);







        void removeEmitter(ParticleEmitter *emitter);
        ParticleAffector* addAffector(const String& affectorType);
        ParticleAffector* getAffector(unsigned short index) const;


        unsigned short getNumAffectors(void) const;
        void removeAffector(unsigned short index);


        void removeAllAffectors(void);



        void clear();
        size_t getNumParticles(void) const;
        Particle* createParticle(void);
        Particle* createEmitterParticle(const String& emitterName);







        Particle* getParticle(size_t index);





        size_t getParticleQuota(void) const;
        void setParticleQuota(size_t quota);





        size_t getEmittedEmitterQuota(void) const;






        void setEmittedEmitterQuota(size_t quota);






        ParticleSystem& operator=(const ParticleSystem& rhs);







        void _update(Real timeElapsed);







        ParticleIterator _getIterator(void);





        virtual void setMaterialName( const String& name, const String& groupName = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME );




        virtual const String& getMaterialName(void) const;





        void _notifyAttached(Node* parent);





        virtual void _updateRenderQueue(RenderQueue* queue, Camera *camera, const Camera *lodCamera);
        void fastForward(Real time, Real interval = 0.1);
        void setSpeedFactor(Real speedFactor) { mSpeedFactor = speedFactor; }



        Real getSpeedFactor(void) const { return mSpeedFactor; }
        void setIterationInterval(Real iterationInterval);



        Real getIterationInterval(void) const { return mIterationInterval; }



        static void setDefaultIterationInterval(Real iterationInterval) { msDefaultIterationInterval = iterationInterval; }



        static Real getDefaultIterationInterval(void) { return msDefaultIterationInterval; }
        void setNonVisibleUpdateTimeout(Real timeout);



        Real getNonVisibleUpdateTimeout(void) const { return mNonvisibleTimeout; }



        static void setDefaultNonVisibleUpdateTimeout(Real timeout)
        { msDefaultNonvisibleTimeout = timeout; }



        static Real getDefaultNonVisibleUpdateTimeout(void) { return msDefaultNonvisibleTimeout; }


        const String& getMovableType(void) const;



        virtual void _notifyParticleResized(void);



        virtual void _notifyParticleRotated(void);
        virtual void setDefaultDimensions(Real width, Real height);


        virtual void setDefaultWidth(Real width);

        virtual Real getDefaultWidth(void) const;

        virtual void setDefaultHeight(Real height);

        virtual Real getDefaultHeight(void) const;

        virtual bool getCullIndividually(void) const;
        virtual void setCullIndividually(bool cullIndividual);

        virtual const String& getResourceGroupName(void) const { return mResourceGroupName; }






        const String& getOrigin(void) const { return mOrigin; }

        void _notifyOrigin(const String& origin) { mOrigin = origin; }


        void setRenderQueueGroup(uint8 queueID);

        void setRenderQueueSubGroup( uint8 subGroup );







        void setSortingEnabled(bool enabled) { mSorted = enabled; }

        bool getSortingEnabled(void) const { return mSorted; }
        void setBoundsAutoUpdated(bool autoUpdate, Real stopIn = 0.0f);
        void setKeepParticlesInLocalSpace(bool keepLocal);




        bool getKeepParticlesInLocalSpace(void) const { return mLocalSpace; }
        void _updateBounds(void);
        void setEmitting(bool v);






        bool getEmitting() const;
    protected:


        static CmdCull msCullCmd;
        static CmdHeight msHeightCmd;
        static CmdMaterial msMaterialCmd;
        static CmdQuota msQuotaCmd;
        static CmdEmittedEmitterQuota msEmittedEmitterQuotaCmd;
        static CmdWidth msWidthCmd;
        static CmdRenderer msRendererCmd;
        static CmdSorted msSortedCmd;
        static CmdLocalSpace msLocalSpaceCmd;
        static CmdIterationInterval msIterationIntervalCmd;
        static CmdNonvisibleTimeout msNonvisibleTimeoutCmd;

        bool mBoundsAutoUpdate;
        Real mBoundsUpdateTime;
        Real mUpdateRemainTime;


        String mResourceGroupName;

        String mMaterialName;

        bool mIsRendererConfigured;

        MaterialPtr mMaterial;

        Real mDefaultWidth;

        Real mDefaultHeight;

        Real mSpeedFactor;

        Real mIterationInterval;

        bool mIterationIntervalSet;

        bool mSorted;

        bool mLocalSpace;

        Real mNonvisibleTimeout;

        bool mNonvisibleTimeoutSet;

        Real mTimeSinceLastVisible;

        unsigned long mLastVisibleFrame;

        Controller<Real>* mTimeController;

        bool mEmittedEmitterPoolInitialised;

        bool mIsEmitting;

        typedef list<Particle*>::type ActiveParticleList;
        typedef list<Particle*>::type FreeParticleList;
        typedef vector<Particle*>::type ParticlePool;


        struct SortByDirectionFunctor
        {

            Vector3 sortDir;

            SortByDirectionFunctor(const Vector3& dir);
            float operator()(Particle* p) const;
        };


        struct SortByDistanceFunctor
        {

            Vector3 sortPos;

            SortByDistanceFunctor(const Vector3& pos);
            float operator()(Particle* p) const;
        };

        static RadixSort<ActiveParticleList, Particle*, float> mRadixSorter;
        ActiveParticleList mActiveParticles;
        FreeParticleList mFreeParticles;





        ParticlePool mParticlePool;

        typedef list<ParticleEmitter*>::type FreeEmittedEmitterList;
        typedef list<ParticleEmitter*>::type ActiveEmittedEmitterList;
        typedef vector<ParticleEmitter*>::type EmittedEmitterList;
        typedef map<String, FreeEmittedEmitterList>::type FreeEmittedEmitterMap;
        typedef map<String, EmittedEmitterList>::type EmittedEmitterPool;
        EmittedEmitterPool mEmittedEmitterPool;





        FreeEmittedEmitterMap mFreeEmittedEmitters;






        ActiveEmittedEmitterList mActiveEmittedEmitters;

        typedef vector<ParticleEmitter*>::type ParticleEmitterList;
        typedef vector<ParticleAffector*>::type ParticleAffectorList;


        ParticleEmitterList mEmitters;

        ParticleAffectorList mAffectors;


        ParticleSystemRenderer* mRenderer;


        bool mCullIndividual;


        String mRendererType;


        size_t mPoolSize;


        size_t mEmittedEmitterPoolSize;


        String mOrigin;


        static Real msDefaultIterationInterval;

        static Real msDefaultNonvisibleTimeout;


        void _expire(Real timeElapsed);


        void _triggerEmitters(Real timeElapsed);



        void _executeTriggerEmitters(ParticleEmitter* emitter, unsigned requested, Real timeElapsed);


        void _applyMotion(Real timeElapsed);


        void _triggerAffectors(Real timeElapsed);


        void _sortParticles(Camera* cam);


        void increasePool(size_t size);
        void increaseEmittedEmitterPool(size_t size);


        void initParameters(void);


        void configureRenderer(void);


        void createVisualParticles(size_t poolstart, size_t poolend);

        void destroyVisualParticles(size_t poolstart, size_t poolend);






        void initialiseEmittedEmitters(void);




        void initialiseEmittedEmitterPool(void);


        void addFreeEmittedEmitters(void);


        void removeAllEmittedEmitters(void);




        FreeEmittedEmitterList* findFreeEmittedEmitter (const String& name);






        void removeFromActiveEmittedEmitters (ParticleEmitter* emitter);





        void addActiveEmittedEmittersToFreeList (void);
        void _notifyReorganiseEmittedEmitterData (void);
    };



}



namespace Ogre {


    class ParticleSystemFactory;
    class ParticleSystemManager:
        public Singleton<ParticleSystemManager>, public ScriptLoader, public FXAlloc
    {
        friend class ParticleSystemFactory;
    public:
        typedef map<String, ParticleSystem*>::type ParticleTemplateMap;
        typedef map<String, ParticleAffectorFactory*>::type ParticleAffectorFactoryMap;
        typedef map<String, ParticleEmitterFactory*>::type ParticleEmitterFactoryMap;
        typedef map<String, ParticleSystemRendererFactory*>::type ParticleSystemRendererFactoryMap;
    protected:
                       ;


        ParticleTemplateMap mSystemTemplates;


        ParticleEmitterFactoryMap mEmitterFactories;


        ParticleAffectorFactoryMap mAffectorFactories;


        ParticleSystemRendererFactoryMap mRendererFactories;

        StringVector mScriptPatterns;


        ParticleSystemFactory* mFactory;

        ObjectMemoryManager mTemplatesObjectMemMgr;


        void parseNewEmitter(const String& type, DataStreamPtr& chunk, ParticleSystem* sys);

        void parseNewAffector(const String& type, DataStreamPtr& chunk, ParticleSystem* sys);

        void parseAttrib(const String& line, ParticleSystem* sys);

        void parseEmitterAttrib(const String& line, ParticleEmitter* sys);

        void parseAffectorAttrib(const String& line, ParticleAffector* sys);

        void skipToNextCloseBrace(DataStreamPtr& chunk);

        void skipToNextOpenBrace(DataStreamPtr& chunk);


        ParticleSystem* createSystemImpl( IdType id, ObjectMemoryManager *objectMemoryManager,
                                          SceneManager *manager, size_t quota,
                                          const String& resourceGroup );

        ParticleSystem* createSystemImpl( IdType id, ObjectMemoryManager *objectMemoryManager,
                                          SceneManager *manager, const String& templateName );

        void destroySystemImpl(ParticleSystem* sys);


    public:

        ParticleSystemManager();
        virtual ~ParticleSystemManager();
        void addEmitterFactory(ParticleEmitterFactory* factory);
        void addAffectorFactory(ParticleAffectorFactory* factory);
        void addRendererFactory(ParticleSystemRendererFactory* factory);
        void addTemplate(const String& name, ParticleSystem* sysTemplate);
        void removeTemplate(const String& name, bool deleteTemplate = true);







        void removeAllTemplates(bool deleteTemplate = true);
        void removeTemplatesByResourceGroup(const String& resourceGroup);
        ParticleSystem* createTemplate(const String& name, const String& resourceGroup);






        ParticleSystem* getTemplate(const String& name);
        ParticleEmitter* _createEmitter(const String& emitterType, ParticleSystem* psys);
        void _destroyEmitter(ParticleEmitter* emitter);
        ParticleAffector* _createAffector(const String& affectorType, ParticleSystem* psys);
        void _destroyAffector(ParticleAffector* affector);
        ParticleSystemRenderer* _createRenderer(const String& rendererType, SceneManager *sceneManager);
        void _destroyRenderer(ParticleSystemRenderer* renderer);






        void _initialise(void);


        const StringVector& getScriptPatterns(void) const;

        void parseScript(DataStreamPtr& stream, const String& groupName);

        Real getLoadingOrder(void) const;

        typedef MapIterator<ParticleAffectorFactoryMap> ParticleAffectorFactoryIterator;
        typedef MapIterator<ParticleEmitterFactoryMap> ParticleEmitterFactoryIterator;
        typedef MapIterator<ParticleSystemRendererFactoryMap> ParticleRendererFactoryIterator;

        ParticleAffectorFactoryIterator getAffectorFactoryIterator(void);

        ParticleEmitterFactoryIterator getEmitterFactoryIterator(void);

        ParticleRendererFactoryIterator getRendererFactoryIterator(void);


        typedef MapIterator<ParticleTemplateMap> ParticleSystemTemplateIterator;

        ParticleSystemTemplateIterator getTemplateIterator(void)
        {
            return ParticleSystemTemplateIterator(
                mSystemTemplates.begin(), mSystemTemplates.end());
        }


        ParticleSystemFactory* _getFactory(void) { return mFactory; }
        static ParticleSystemManager& getSingleton(void);
        static ParticleSystemManager* getSingletonPtr(void);

    };


    class ParticleSystemFactory : public MovableObjectFactory
    {
    protected:
        virtual MovableObject* createInstanceImpl( IdType id, ObjectMemoryManager *objectMemoryManager,
                                                   SceneManager *manager,
                                                   const NameValuePairList* params = 0 );
    public:
        ParticleSystemFactory() {}
        ~ParticleSystemFactory() {}

        static String FACTORY_TYPE_NAME;

        const String& getType(void) const;
        void destroyInstance( MovableObject* obj);

    };



}


namespace Ogre {
    class Pass : public PassAlloc
    {
    protected:

        static AtomicScalar<uint32> gId;

        uint32 mId;
        Technique* mParent;
        unsigned short mIndex;
        String mName;


        ColourValue mAmbient;
        ColourValue mDiffuse;
        ColourValue mSpecular;
        ColourValue mEmissive;
        Real mShininess;
        TrackVertexColourType mTracking;

        HlmsLowLevelDatablock *mDatablock;


        CompareFunction mAlphaRejectFunc;
        unsigned char mAlphaRejectVal;




        unsigned short mMaxSimultaneousLights;

        unsigned short mStartLight;

        bool mIteratePerLight;

        unsigned short mLightsPerIteration;

        bool mRunOnlyForOneLightType;
        Light::LightTypes mOnlyLightType;

        uint32 mLightMask;


        ShadeOptions mShadeOptions;

        bool mPolygonModeOverrideable;


        bool mFogOverride;
        FogMode mFogMode;
        ColourValue mFogColour;
        Real mFogStart;
        Real mFogEnd;
        Real mFogDensity;



        typedef vector<TextureUnitState*>::type TextureUnitStates;
        TextureUnitStates mTextureUnitStates;


        GpuProgramUsage *mVertexProgramUsage;

        GpuProgramUsage *mShadowCasterVertexProgramUsage;

        GpuProgramUsage *mShadowCasterFragmentProgramUsage;

        GpuProgramUsage *mFragmentProgramUsage;

        GpuProgramUsage *mGeometryProgramUsage;

        GpuProgramUsage *mTessellationHullProgramUsage;

        GpuProgramUsage *mTessellationDomainProgramUsage;

        GpuProgramUsage *mComputeProgramUsage;

        size_t mPassIterationCount;

        Real mPointSize;
        Real mPointMinSize;
        Real mPointMaxSize;
        bool mPointSpritesEnabled;
        bool mPointAttenuationEnabled;

        Real mPointAttenuationCoeffs[3];

        typedef vector<size_t>::type ContentTypeLookup;
        ContentTypeLookup mShadowContentTypeLookup;

        bool mLightScissoring;

        bool mLightClipPlanes;

        UserObjectBindings mUserObjectBindings;


    public:

        static void _getBlendFlags(SceneBlendType type, SceneBlendFactor& source, SceneBlendFactor& dest);

    public:
                                               ;
                                               ;
                                       ;
                                          ;

        Pass(Technique* parent, unsigned short index);

        Pass(Technique* parent, unsigned short index, const Pass& oth );

        Pass& operator=(const Pass& oth);
        virtual ~Pass();

        uint32 getId(void) const { return mId; }


        bool isProgrammable(void) const { return mVertexProgramUsage || mFragmentProgramUsage || mGeometryProgramUsage ||
                                                 mTessellationHullProgramUsage || mTessellationDomainProgramUsage || mComputeProgramUsage; }


        bool hasVertexProgram(void) const { return mVertexProgramUsage != NULL; }

        bool hasFragmentProgram(void) const { return mFragmentProgramUsage != NULL; }

        bool hasGeometryProgram(void) const { return mGeometryProgramUsage != NULL; }

        bool hasTessellationHullProgram(void) const { return mTessellationHullProgramUsage != NULL; }

        bool hasTessellationDomainProgram(void) const { return mTessellationDomainProgramUsage != NULL; }

        bool hasComputeProgram(void) const { return mComputeProgramUsage != NULL; }

        bool hasShadowCasterVertexProgram(void) const { return mShadowCasterVertexProgramUsage != NULL; }

        bool hasShadowCasterFragmentProgram(void) const { return mShadowCasterFragmentProgramUsage != NULL; }

        size_t calculateSize(void) const;


        unsigned short getIndex(void) const { return mIndex; }





        void setName(const String& name);

        const String& getName(void) const { return mName; }
        void setAmbient(Real red, Real green, Real blue);
        void setAmbient(const ColourValue& ambient);
        void setDiffuse(Real red, Real green, Real blue, Real alpha);
        void setDiffuse(const ColourValue& diffuse);
        void setSpecular(Real red, Real green, Real blue, Real alpha);
        void setSpecular(const ColourValue& specular);






        void setShininess(Real val);
        void setSelfIllumination(Real red, Real green, Real blue);





        void setEmissive(Real red, Real green, Real blue)
        {
            setSelfIllumination(red, green, blue);
        }
        void setSelfIllumination(const ColourValue& selfIllum);





        void setEmissive(const ColourValue& emissive)
        {
            setSelfIllumination(emissive);
        }



        void setVertexColourTracking(TrackVertexColourType tracking);






        Real getPointSize(void) const;
        void setPointSize(Real ps);






        void setPointSpritesEnabled(bool enabled);




        bool getPointSpritesEnabled(void) const;
        void setPointAttenuation(bool enabled,
            Real constant = 0.0f, Real linear = 1.0f, Real quadratic = 0.0f);


        bool isPointAttenuationEnabled(void) const;


        Real getPointAttenuationConstant(void) const;

        Real getPointAttenuationLinear(void) const;

        Real getPointAttenuationQuadratic(void) const;


        void setPointMinSize(Real min);

        Real getPointMinSize(void) const;



        void setPointMaxSize(Real max);



        Real getPointMaxSize(void) const;



        const ColourValue& getAmbient(void) const;



        const ColourValue& getDiffuse(void) const;



        const ColourValue& getSpecular(void) const;



        const ColourValue& getSelfIllumination(void) const;





        const ColourValue& getEmissive(void) const
        {
            return getSelfIllumination();
        }



        Real getShininess(void) const;



        TrackVertexColourType getVertexColourTracking(void) const;





        TextureUnitState* createTextureUnitState(void);
        TextureUnitState* createTextureUnitState( const String& textureName, unsigned short texCoordSet = 0);





        void addTextureUnitState(TextureUnitState* state);


        TextureUnitState* getTextureUnitState( size_t index );



        TextureUnitState* getTextureUnitState(const String& name);


        const TextureUnitState* getTextureUnitState( size_t index ) const;



        const TextureUnitState* getTextureUnitState(const String& name) const;







        unsigned short getTextureUnitStateIndex(const TextureUnitState* state) const;

        typedef VectorIterator<TextureUnitStates> TextureUnitStateIterator;

        TextureUnitStateIterator getTextureUnitStateIterator(void);

        typedef ConstVectorIterator<TextureUnitStates> ConstTextureUnitStateIterator;

        ConstTextureUnitStateIterator getTextureUnitStateIterator(void) const;





        void removeTextureUnitState(unsigned short index);



        void removeAllTextureUnitStates(void);



        unsigned short getNumTextureUnitStates(void) const
        {
            return static_cast<unsigned short>(mTextureUnitStates.size());
        }

        size_t getNumShadowContentTextures(void) const { return mShadowContentTypeLookup.size(); }


        void recreateShadowContentTypeLookup(void);





        void insertShadowContentTypeLookup( size_t textureUnitIndex );




        void removeShadowContentTypeLookup( size_t textureUnitIndex );


        bool isTransparent(void) const;


        bool getColourWriteEnabled(void) const;
        void setMaxSimultaneousLights(unsigned short maxLights);

        unsigned short getMaxSimultaneousLights(void) const;
        void setStartLight(unsigned short startLight);

        unsigned short getStartLight(void) const;


        void setLightMask(uint32 mask);

        uint32 getLightMask() const;





        void setShadingMode( ShadeOptions mode );



        ShadeOptions getShadingMode(void) const;






        virtual void setPolygonModeOverrideable(bool override)
        {
            mPolygonModeOverrideable = override;
        }




        virtual bool getPolygonModeOverrideable(void) const
        {
            return mPolygonModeOverrideable;
        }
        void setFog(
            bool overrideScene,
            FogMode mode = FOG_NONE,
            const ColourValue& colour = ColourValue::White,
            Real expDensity = 0.001, Real linearStart = 0.0, Real linearEnd = 1.0 );



        bool getFogOverride(void) const;





        FogMode getFogMode(void) const;



        const ColourValue& getFogColour(void) const;





        Real getFogStart(void) const;





        Real getFogEnd(void) const;





        Real getFogDensity(void) const;


        HlmsDatablock* _getDatablock(void) const;


        void setMacroblock( const HlmsMacroblock &macroblock );




        const HlmsMacroblock* getMacroblock(void) const;


        void setBlendblock( const HlmsBlendblock &blendblock );




        const HlmsBlendblock* getBlendblock(void) const;



        void setAlphaRejectFunction(CompareFunction func);



        void setAlphaRejectValue(unsigned char val);



        CompareFunction getAlphaRejectFunction(void) const { return mAlphaRejectFunc; }



        unsigned char getAlphaRejectValue(void) const { return mAlphaRejectVal; }
        void setIteratePerLight(bool enabled,
                                bool onlyForOneLightType = true, Light::LightTypes lightType = Light::LT_POINT);


        bool getIteratePerLight(void) const { return mIteratePerLight; }

        bool getRunOnlyForOneLightType(void) const { return mRunOnlyForOneLightType; }


        Light::LightTypes getOnlyLightType() const { return mOnlyLightType; }
        void setLightCountPerIteration(unsigned short c);



        unsigned short getLightCountPerIteration(void) const;


        Technique* getParent(void) const { return mParent; }


        const String& getResourceGroup(void) const;
        void setVertexProgram(const String& name, bool resetParams = true);






        void setVertexProgramParameters(GpuProgramParametersSharedPtr params);

        const String& getVertexProgramName(void) const;

        GpuProgramParametersSharedPtr getVertexProgramParameters(void) const;

        const GpuProgramPtr& getVertexProgram(void) const;
        void setShadowCasterVertexProgram(const String& name);






        void setShadowCasterVertexProgramParameters(GpuProgramParametersSharedPtr params);

        const String& getShadowCasterVertexProgramName(void) const;

        GpuProgramParametersSharedPtr getShadowCasterVertexProgramParameters(void) const;


        const GpuProgramPtr& getShadowCasterVertexProgram(void) const;
        void setShadowCasterFragmentProgram(const String& name);






        void setShadowCasterFragmentProgramParameters(GpuProgramParametersSharedPtr params);

        const String& getShadowCasterFragmentProgramName(void) const;

        GpuProgramParametersSharedPtr getShadowCasterFragmentProgramParameters(void) const;


        const GpuProgramPtr& getShadowCasterFragmentProgram(void) const;
        void setFragmentProgram(const String& name, bool resetParams = true);




        void setFragmentProgramParameters(GpuProgramParametersSharedPtr params);

        const String& getFragmentProgramName(void) const;

        GpuProgramParametersSharedPtr getFragmentProgramParameters(void) const;

        const GpuProgramPtr& getFragmentProgram(void) const;
        void setGeometryProgram(const String& name, bool resetParams = true);




        void setGeometryProgramParameters(GpuProgramParametersSharedPtr params);

        const String& getGeometryProgramName(void) const;

        GpuProgramParametersSharedPtr getGeometryProgramParameters(void) const;

        const GpuProgramPtr& getGeometryProgram(void) const;


        void _notifyIndex(unsigned short index);


        void _prepare(void);

        void _unprepare(void);

        void _load(void);

        void _unload(void);

        bool isLoaded(void) const;





        void _updateAutoParams(const AutoParamDataSource* source, uint16 variabilityMask) const;







        size_t _getTextureUnitWithContentTypeIndex( TextureUnitState::ContentType contentType,
                                                    size_t index) const;
        void setSamplerblock( const HlmsSamplerblock &samplerblock );



        bool isAmbientOnly(void) const;
        void setPassIterationCount(const size_t count) { mPassIterationCount = count; }



        size_t getPassIterationCount(void) const { return mPassIterationCount; }
        bool applyTextureAliases(const AliasTextureNamePairList& aliasList, const bool apply = true) const;
        void setLightScissoringEnabled(bool enabled) { mLightScissoring = enabled; }



        bool getLightScissoringEnabled() const { return mLightScissoring; }
        void setLightClipPlanesEnabled(bool enabled) { mLightClipPlanes = enabled; }



        bool getLightClipPlanesEnabled() const { return mLightClipPlanes; }





        UserObjectBindings& getUserObjectBindings() { return mUserObjectBindings; }





        const UserObjectBindings& getUserObjectBindings() const { return mUserObjectBindings; }
        void setTessellationHullProgram(const String& name, bool resetParams = true);




        void setTessellationHullProgramParameters(GpuProgramParametersSharedPtr params);

        const String& getTessellationHullProgramName(void) const;

        GpuProgramParametersSharedPtr getTessellationHullProgramParameters(void) const;

        const GpuProgramPtr& getTessellationHullProgram(void) const;
        void setTessellationDomainProgram(const String& name, bool resetParams = true);




        void setTessellationDomainProgramParameters(GpuProgramParametersSharedPtr params);

        const String& getTessellationDomainProgramName(void) const;

        GpuProgramParametersSharedPtr getTessellationDomainProgramParameters(void) const;

        const GpuProgramPtr& getTessellationDomainProgram(void) const;
        void setComputeProgram(const String& name, bool resetParams = true);




        void setComputeProgramParameters(GpuProgramParametersSharedPtr params);

        const String& getComputeProgramName(void) const;

        GpuProgramParametersSharedPtr getComputeProgramParameters(void) const;

        const GpuProgramPtr& getComputeProgram(void) const;
    };




}
namespace Ogre {
namespace v1 {
    class PatchMesh : public Mesh
    {
    protected:

        PatchSurface mSurface;

        VertexDeclaration* mDeclaration;
    public:

        PatchMesh(ResourceManager* creator, const String& name, ResourceHandle handle,
            const String& group);

        void update(void* controlPointBuffer, size_t width, size_t height,
                    size_t uMaxSubdivisionLevel, size_t vMaxSubdivisionLevel,
                    PatchSurface::VisibleSide visibleSide);

        void define(void* controlPointBuffer,
            VertexDeclaration *declaration, size_t width, size_t height,
            size_t uMaxSubdivisionLevel = PatchSurface::AUTO_LEVEL,
            size_t vMaxSubdivisionLevel = PatchSurface::AUTO_LEVEL,
            PatchSurface::VisibleSide visibleSide = PatchSurface::VS_FRONT,
            HardwareBuffer::Usage vbUsage = HardwareBuffer::HBU_STATIC_WRITE_ONLY,
            HardwareBuffer::Usage ibUsage = HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY,
            bool vbUseShadow = false, bool ibUseShadow = false);




        void setSubdivision(Real factor);
    protected:

        void loadImpl(void);

        void prepareImpl(void) {}

    };


}
}

namespace Ogre {
    enum ProfileGroupMask
    {

        OGREPROF_USER_DEFAULT = 0x00000001,

        OGREPROF_ALL = 0xFF000000,

        OGREPROF_GENERAL = 0x80000000,

        OGREPROF_CULLING = 0x40000000,

        OGREPROF_RENDERING = 0x20000000
    };
    class Profile :
        public ProfilerAlloc
    {

        public:
            Profile(const String& profileName, uint32 groupID = (uint32)OGREPROF_USER_DEFAULT);
            ~Profile();

        protected:


            String mName;

            uint32 mGroupID;

    };




    struct ProfileFrame
    {


        ulong frameTime;


        uint calls;


        uint hierarchicalLvl;

    };


    struct ProfileHistory
    {

        Real currentTimePercent;

        Real currentTimeMillisecs;


        Real maxTimePercent;

        Real maxTimeMillisecs;


        Real minTimePercent;

        Real minTimeMillisecs;


        uint numCallsThisFrame;


        Real totalTimePercent;

        Real totalTimeMillisecs;



        ulong totalCalls;


        uint hierarchicalLvl;

    };


    class ProfileInstance : public ProfilerAlloc
    {
        friend class Profiler;
    public:
        ProfileInstance(void);
        virtual ~ProfileInstance(void);

        typedef Ogre::map<String,ProfileInstance*>::type ProfileChildren;

        void logResults();
        void reset();

        inline bool watchForMax(void) { return history.currentTimePercent == history.maxTimePercent; }
        inline bool watchForMin(void) { return history.currentTimePercent == history.minTimePercent; }
        inline bool watchForLimit(Real limit, bool greaterThan = true)
        {
            if (greaterThan)
                return history.currentTimePercent > limit;
            else
                return history.currentTimePercent < limit;
        }

        bool watchForMax(const String& profileName);
        bool watchForMin(const String& profileName);
        bool watchForLimit(const String& profileName, Real limit, bool greaterThan = true);


        String name;


        ProfileInstance* parent;

        ProfileChildren children;

        ProfileFrame frame;
        ulong frameNumber;

        ProfileHistory history;


        ulong currTime;



        ulong accum;


        uint hierarchicalLvl;
    };






    class ProfileSessionListener
    {
    public:
        enum DisplayMode
        {

            DISPLAY_PERCENTAGE,

            DISPLAY_MILLISECONDS
        };

        ProfileSessionListener() : mDisplayMode(DISPLAY_MILLISECONDS) {}
        virtual ~ProfileSessionListener() {}


        virtual void initializeSession() = 0;


        virtual void finializeSession() = 0;





        virtual void changeEnableState(bool enabled) {};


        virtual void displayResults(const ProfileInstance& instance, ulong maxTotalFrameTime) {};


        void setDisplayMode(DisplayMode d) { mDisplayMode = d; }


        DisplayMode getDisplayMode() const { return mDisplayMode; }

    protected:

        DisplayMode mDisplayMode;
    };
    class Profiler :
        public Singleton<Profiler>,
        public ProfilerAlloc
    {
        public:
            Profiler();
            ~Profiler();


            void setTimer(Timer* t);


            Timer* getTimer();
            void beginProfile(const String& profileName, uint32 groupID = (uint32)OGREPROF_USER_DEFAULT);
            void endProfile(const String& profileName, uint32 groupID = (uint32)OGREPROF_USER_DEFAULT);




            void beginGPUEvent(const String& event);




            void endGPUEvent(const String& event);




            void markGPUEvent(const String& event);






            void setEnabled(bool enabled);


            bool getEnabled() const;




            void enableProfile(const String& profileName);




            void disableProfile(const String& profileName);



            void setProfileGroupMask(uint32 mask) { mProfileMask = mask; }


            uint32 getProfileGroupMask() const { return mProfileMask; }






            bool watchForMax(const String& profileName);






            bool watchForMin(const String& profileName);
            bool watchForLimit(const String& profileName, Real limit, bool greaterThan = true);


            void logResults();


            void reset();


            void setUpdateDisplayFrequency(uint freq);


            uint getUpdateDisplayFrequency() const;







            void addListener(ProfileSessionListener* listener);







            void removeListener(ProfileSessionListener* listener);
            static Profiler& getSingleton(void);
            static Profiler* getSingletonPtr(void);

        protected:
            friend class ProfileInstance;

            typedef vector<ProfileSessionListener*>::type TProfileSessionListener;
            TProfileSessionListener mListeners;


            void initialize();

            void displayResults();


            void processFrameStats(void);

            void processFrameStats(ProfileInstance* instance, Real& maxFrameTime);


            void changeEnableState();


            typedef set<String>::type DisabledProfileMap;
            typedef ProfileInstance::ProfileChildren ProfileChildren;

            ProfileInstance* mCurrent;
            ProfileInstance* mLast;
            ProfileInstance mRoot;


            DisabledProfileMap mDisabledProfiles;


            bool mInitialized;



            uint mUpdateDisplayFrequency;


            uint mCurrentFrame;


            Timer* mTimer;


            ulong mTotalFrameTime;


            bool mEnabled;



            bool mNewEnableState;


            uint32 mProfileMask;


            ulong mMaxTotalFrameTime;


            Real mAverageFrameTime;
            bool mResetExtents;


    };



}



namespace Ogre {
    class RenderQueueListener
    {
    public:
        virtual ~RenderQueueListener() {}



        virtual void preRenderQueues() {}


        virtual void postRenderQueues() {}
        virtual void renderQueueStarted( RenderQueue *rq, uint8 queueGroupId, const String& invocation,
                                         bool& skipThisInvocation)
        { (void)rq; (void)queueGroupId; (void)invocation; (void)skipThisInvocation; }
        virtual void renderQueueEnded(uint8 queueGroupId, const String& invocation,
            bool& repeatThisInvocation)
        { (void)queueGroupId; (void)invocation; (void)repeatThisInvocation; }
    };



}
namespace Ogre {

    class Pass;
    class Renderable;




    class RenderObjectListener
    {
    public:
        virtual ~RenderObjectListener() {}
        virtual void notifyRenderSingleObject(Renderable* rend, const Pass* pass, const AutoParamDataSource* source,
            const LightList* pLightList, bool suppressRenderStateChanges) = 0;
    };

}
namespace Ogre {
    class StringConverter
    {
    public:


        static String toString(Real val, unsigned short precision = 6,
            unsigned short width = 0, char fill = ' ',
            std::ios::fmtflags flags = std::ios::fmtflags(0));
        static String toString(double val, unsigned short precision = 6,
                               unsigned short width = 0, char fill = ' ',
                               std::ios::fmtflags flags = std::ios::fmtflags(0));


        static String toString(Radian val, unsigned short precision = 6,
            unsigned short width = 0, char fill = ' ',
            std::ios::fmtflags flags = std::ios::fmtflags(0))
        {
            return toString(val.valueAngleUnits(), precision, width, fill, flags);
        }

        static String toString(Degree val, unsigned short precision = 6,
            unsigned short width = 0, char fill = ' ',
            std::ios::fmtflags flags = std::ios::fmtflags(0))
        {
            return toString(val.valueAngleUnits(), precision, width, fill, flags);
        }

        static String toString(int val, unsigned short width = 0,
            char fill = ' ',
            std::ios::fmtflags flags = std::ios::fmtflags(0));


        static String toString(unsigned int val,
            unsigned short width = 0, char fill = ' ',
            std::ios::fmtflags flags = std::ios::fmtflags(0));

        static String toString(size_t val,
            unsigned short width = 0, char fill = ' ',
            std::ios::fmtflags flags = std::ios::fmtflags(0));
        static String toString(long val,
            unsigned short width = 0, char fill = ' ',
            std::ios::fmtflags flags = std::ios::fmtflags(0));



        static String toString(bool val, bool yesNo = false);




        static String toString(const Vector2& val);




        static String toString(const Vector3& val);




        static String toString(const Vector4& val);




        static String toString(const Matrix3& val);





        static String toString(const Matrix4& val);




        static String toString(const Quaternion& val);




        static String toString(const ColourValue& val);





        static String toString(const StringVector& val);





        static Real parseReal(const String& val, Real defaultValue = 0);




        static inline Radian parseAngle(const String& val, Radian defaultValue = Radian(0)) {
            return Angle(parseReal(val, defaultValue.valueRadians()));
        }




        static int parseInt(const String& val, int defaultValue = 0);




        static unsigned int parseUnsignedInt(const String& val, unsigned int defaultValue = 0);




        static long parseLong(const String& val, long defaultValue = 0);




        static unsigned long parseUnsignedLong(const String& val, unsigned long defaultValue = 0);




        static size_t parseSizeT(const String& val, size_t defaultValue = 0);






        static bool parseBool(const String& val, bool defaultValue = 0);





        static Vector2 parseVector2(const String& val, const Vector2& defaultValue = Vector2::ZERO);





        static Vector3 parseVector3(const String& val, const Vector3& defaultValue = Vector3::ZERO);





        static Vector4 parseVector4(const String& val, const Vector4& defaultValue = Vector4::ZERO);





        static Matrix3 parseMatrix3(const String& val, const Matrix3& defaultValue = Matrix3::IDENTITY);





        static Matrix4 parseMatrix4(const String& val, const Matrix4& defaultValue = Matrix4::IDENTITY);





        static Quaternion parseQuaternion(const String& val, const Quaternion& defaultValue = Quaternion::IDENTITY);





        static ColourValue parseColourValue(const String& val, const ColourValue& defaultValue = ColourValue::Black);






        static StringVector parseStringVector(const String& val);

        static bool isNumber(const String& val);





  static String toString(ColourBufferType val);





  static ColourBufferType parseColourBuffer(const String& val, ColourBufferType defaultValue = CBT_BACK);





  static String toString(StereoModeType val);





  static StereoModeType parseStereoMode(const String& val, StereoModeType defaultValue = SMT_NONE);


        static void setDefaultStringLocale(const String &loc)
        {
            msDefaultStringLocale = loc;
            msLocale = std::locale(msDefaultStringLocale.c_str());
        }

        static String getDefaultStringLocale(void) { return msDefaultStringLocale; }

        static void setUseLocale(bool useLocale) { msUseLocale = useLocale; }

        static bool isUseLocale() { return msUseLocale; }


    protected:
        static String msDefaultStringLocale;
        static std::locale msLocale;
        static bool msUseLocale;
    };




}
namespace Ogre
{
    enum CapabilitiesCategory
    {
        CAPS_CATEGORY_COMMON = 0,
        CAPS_CATEGORY_COMMON_2 = 1,
        CAPS_CATEGORY_COMMON_3 = 2,
        CAPS_CATEGORY_D3D9 = 3,
        CAPS_CATEGORY_GL = 4,

        CAPS_CATEGORY_COUNT = 5
    };





    enum Capabilities
    {

        RSC_AUTOMIPMAP = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 0)),
        RSC_BLENDING = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 1)),

        RSC_ANISOTROPY = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 2)),

        RSC_DOT3 = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 3)),

        RSC_CUBEMAPPING = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 4)),

        RSC_HWSTENCIL = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 5)),

        RSC_VBO = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 7)),

        RSC_32BIT_INDEX = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 8)),

        RSC_VERTEX_PROGRAM = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 9)),

        RSC_FRAGMENT_PROGRAM = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 10)),




        RSC_TEXTURE_SIGNED_INT = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 11)),

        RSC_TWO_SIDED_STENCIL = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 12)),

        RSC_STENCIL_WRAP = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 13)),

        RSC_HWOCCLUSION = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 14)),

        RSC_USER_CLIP_PLANES = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 15)),

        RSC_VERTEX_FORMAT_UBYTE4 = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 16)),

        RSC_INFINITE_FAR_PLANE = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 17)),

        RSC_HWRENDER_TO_TEXTURE = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 18)),

        RSC_TEXTURE_FLOAT = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 19)),

        RSC_NON_POWER_OF_2_TEXTURES = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 20)),

        RSC_TEXTURE_3D = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 21)),

        RSC_POINT_SPRITES = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 22)),

        RSC_POINT_EXTENDED_PARAMETERS = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 23)),

        RSC_VERTEX_TEXTURE_FETCH = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 24)),

        RSC_MIPMAP_LOD_BIAS = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 25)),

        RSC_GEOMETRY_PROGRAM = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 26)),

        RSC_HWRENDER_TO_VERTEX_BUFFER = ((CAPS_CATEGORY_COMMON << (32 - 4)) | (1 << 27)),


        RSC_TEXTURE_COMPRESSION = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 0)),

        RSC_TEXTURE_COMPRESSION_DXT = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 1)),

        RSC_TEXTURE_COMPRESSION_VTC = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 2)),

        RSC_TEXTURE_COMPRESSION_PVRTC = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 3)),

        RSC_TEXTURE_COMPRESSION_ATC = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 4)),

        RSC_TEXTURE_COMPRESSION_ETC1 = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 5)),

        RSC_TEXTURE_COMPRESSION_ETC2 = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 6)),

        RSC_TEXTURE_COMPRESSION_BC4_BC5 = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 7)),

        RSC_TEXTURE_COMPRESSION_BC6H_BC7 = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 8)),

        RSC_FIXED_FUNCTION = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 9)),

        RSC_MRT_DIFFERENT_BIT_DEPTHS = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 10)),

        RSC_ALPHA_TO_COVERAGE = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 11)),





        RSC_HW_GAMMA = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 12)),

        RSC_RTT_SEPARATE_DEPTHBUFFER = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 13)),


        RSC_RTT_MAIN_DEPTHBUFFER_ATTACHABLE = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 14)),


        RSC_RTT_DEPTHBUFFER_RESOLUTION_LESSEQUAL = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 15)),

        RSC_VERTEX_BUFFER_INSTANCE_DATA = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 16)),

        RSC_CAN_GET_COMPILED_SHADER_BUFFER = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 17)),

        RSC_SHADER_SUBROUTINE = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 18)),

        RSC_HWRENDER_TO_TEXTURE_3D = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 19)),

        RSC_TEXTURE_1D = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 20)),

        RSC_TESSELLATION_HULL_PROGRAM = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 21)),

        RSC_TESSELLATION_DOMAIN_PROGRAM = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 22)),

        RSC_COMPUTE_PROGRAM = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 23)),

        RSC_HWOCCLUSION_ASYNCHRONOUS = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 24)),

        RSC_ATOMIC_COUNTERS = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 25)),

        RSC_READ_BACK_AS_TEXTURE = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 26)),

        RSC_EXPLICIT_FSAA_RESOLVE = ((CAPS_CATEGORY_COMMON_2 << (32 - 4)) | (1 << 27)),


        RSC_COMPLETE_TEXTURE_BINDING = ((CAPS_CATEGORY_COMMON_3 << (32 - 4)) | (1 << 0)),

        RSC_TEXTURE_2D_ARRAY = ((CAPS_CATEGORY_COMMON_3 << (32 - 4)) | (1 << 1)),

        RSC_TEXTURE_CUBE_MAP_ARRAY = ((CAPS_CATEGORY_COMMON_3 << (32 - 4)) | (1 << 2)),

        RSC_TEXTURE_GATHER = ((CAPS_CATEGORY_COMMON_3 << (32 - 4)) | (1 << 3)),

        RSC_UAV = ((CAPS_CATEGORY_COMMON_3 << (32 - 4)) | (1 << 4)),



        RSC_EXPLICIT_API = ((CAPS_CATEGORY_COMMON_3 << (32 - 4)) | (1 << 5)),



        RSC_PERSTAGECONSTANT = ((CAPS_CATEGORY_D3D9 << (32 - 4)) | (1 << 0)),



        RSC_GL1_5_NOVBO = ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 1)),

        RSC_FBO = ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 2)),

        RSC_FBO_ARB = ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 3)),

        RSC_FBO_ATI = ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 4)),

        RSC_PBUFFER = ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 5)),

        RSC_GL1_5_NOHWOCCLUSION = ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 6)),

        RSC_POINT_EXTENDED_PARAMETERS_ARB = ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 7)),

        RSC_POINT_EXTENDED_PARAMETERS_EXT = ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 8)),

        RSC_SEPARATE_SHADER_OBJECTS = ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 9)),

        RSC_VAO = ((CAPS_CATEGORY_GL << (32 - 4)) | (1 << 10))
    };



    struct DriverVersion
    {
        int major;
        int minor;
        int release;
        int build;

        DriverVersion()
        {
            major = minor = release = build = 0;
        }

        String toString() const
        {
            StringStream str;
            str << major << "." << minor << "." << release << "." << build;
            return str.str();
        }

        void fromString(const String& versionString)
        {
            StringVector tokens = StringUtil::split(versionString, ".");
            if(!tokens.empty())
            {
                major = StringConverter::parseInt(tokens[0]);
                if (tokens.size() > 1)
                    minor = StringConverter::parseInt(tokens[1]);
                if (tokens.size() > 2)
                    release = StringConverter::parseInt(tokens[2]);
                if (tokens.size() > 3)
                    build = StringConverter::parseInt(tokens[3]);
            }

        }
    };


    enum GPUVendor
    {
        GPU_UNKNOWN = 0,
        GPU_NVIDIA = 1,
        GPU_AMD = 2,
        GPU_INTEL = 3,
        GPU_S3 = 4,
        GPU_MATROX = 5,
        GPU_3DLABS = 6,
        GPU_SIS = 7,
        GPU_IMAGINATION_TECHNOLOGIES = 8,
        GPU_APPLE = 9,
        GPU_NOKIA = 10,
        GPU_MS_SOFTWARE = 11,
        GPU_MS_WARP = 12,
        GPU_ARM = 13,
        GPU_QUALCOMM = 14,
        GPU_MOZILLA = 15,
        GPU_WEBKIT = 16,

        GPU_VENDOR_COUNT = 17
    };






    class RenderSystemCapabilities : public RenderSysAlloc
    {

    public:

        typedef set<String>::type ShaderProfiles;
    private:



        DriverVersion mDriverVersion;

        GPUVendor mVendor;

        static StringVector msGPUVendorStrings;
        static void initVendorStrings();


        ushort mNumWorldMatrices;

        ushort mNumTextureUnits;

        ushort mStencilBufferBitDepth;

        ushort mNumVertexBlendMatrices;

        int mCapabilities[CAPS_CATEGORY_COUNT];

        bool mCategoryRelevant[CAPS_CATEGORY_COUNT];

        String mDeviceName;

        String mRenderSystemName;


        ushort mVertexProgramConstantFloatCount;

        ushort mVertexProgramConstantIntCount;

        ushort mVertexProgramConstantBoolCount;

        ushort mGeometryProgramConstantFloatCount;

        ushort mGeometryProgramConstantIntCount;

        ushort mGeometryProgramConstantBoolCount;

        ushort mFragmentProgramConstantFloatCount;

        ushort mFragmentProgramConstantIntCount;

        ushort mFragmentProgramConstantBoolCount;

        ushort mNumMultiRenderTargets;

        ushort mMaxTextureResolution2D;

        ushort mMaxTextureResolution3D;

        ushort mMaxTextureResolutionCubemap;

        Real mMaxPointSize;

        bool mNonPOW2TexturesLimited;

        Real mMaxSupportedAnisotropy;

        ushort mNumVertexTextureUnits;

        bool mVertexTextureUnitsShared;

        int mGeometryProgramNumOutputVertices;



        ShaderProfiles mSupportedShaderProfiles;



        ushort mTessellationHullProgramConstantFloatCount;

        ushort mTessellationHullProgramConstantIntCount;

        ushort mTessellationHullProgramConstantBoolCount;

        ushort mTessellationDomainProgramConstantFloatCount;

        ushort mTessellationDomainProgramConstantIntCount;

        ushort mTessellationDomainProgramConstantBoolCount;

        ushort mComputeProgramConstantFloatCount;

        ushort mComputeProgramConstantIntCount;

        ushort mComputeProgramConstantBoolCount;



    public:
        RenderSystemCapabilities ();
        virtual ~RenderSystemCapabilities ();

        virtual size_t calculateSize() const {return 0;}


        void setDriverVersion(const DriverVersion& version)
        {
            mDriverVersion = version;
        }

        void parseDriverVersionFromString(const String& versionString)
        {
            DriverVersion version;
            version.fromString(versionString);
            setDriverVersion(version);
        }


        DriverVersion getDriverVersion() const
        {
            return mDriverVersion;
        }

        GPUVendor getVendor() const
        {
            return mVendor;
        }

        void setVendor(GPUVendor v)
        {
            mVendor = v;
        }


        void parseVendorFromString(const String& vendorString)
        {
            setVendor(vendorFromString(vendorString));
        }


        static GPUVendor vendorFromString(const String& vendorString);

        static String vendorToString(GPUVendor v);

        bool isDriverOlderThanVersion(const DriverVersion &v) const
        {
            if (mDriverVersion.major < v.major)
                return true;
            else if (mDriverVersion.major == v.major &&
                mDriverVersion.minor < v.minor)
                return true;
            else if (mDriverVersion.major == v.major &&
                mDriverVersion.minor == v.minor &&
                mDriverVersion.release < v.release)
                return true;
            else if (mDriverVersion.major == v.major &&
                mDriverVersion.minor == v.minor &&
                mDriverVersion.release == v.release &&
                mDriverVersion.build < v.build)
                return true;
            return false;
        }

        void setNumWorldMatrices(ushort num)
        {
            mNumWorldMatrices = num;
        }

        void setNumTextureUnits(ushort num)
        {
            mNumTextureUnits = num;
        }

        void setStencilBufferBitDepth(ushort num)
        {
            mStencilBufferBitDepth = num;
        }

        void setNumVertexBlendMatrices(ushort num)
        {
            mNumVertexBlendMatrices = num;
        }


        void setNumMultiRenderTargets(ushort num)
        {
            mNumMultiRenderTargets = num;
        }

        ushort getNumWorldMatrices(void) const
        {
            return mNumWorldMatrices;
        }
        ushort getNumTextureUnits(void) const
        {
            return mNumTextureUnits;
        }







        ushort getStencilBufferBitDepth(void) const
        {
            return mStencilBufferBitDepth;
        }



        ushort getNumVertexBlendMatrices(void) const
        {
            return mNumVertexBlendMatrices;
        }


        ushort getNumMultiRenderTargets(void) const
        {
            return mNumMultiRenderTargets;
        }



        bool isCapabilityRenderSystemSpecific(const Capabilities c) const
        {
            int cat = c >> (32 - 4);
            if(cat == CAPS_CATEGORY_GL || cat == CAPS_CATEGORY_D3D9)
                return true;
            return false;
        }



        void setCapability(const Capabilities c)
        {
            int index = ((((1 << 4) - 1) << (32 - 4)) & c) >> (32 - 4);

            mCapabilities[index] |= (c & ~(((1 << 4) - 1) << (32 - 4)));
        }



        void unsetCapability(const Capabilities c)
        {
            int index = ((((1 << 4) - 1) << (32 - 4)) & c) >> (32 - 4);

            mCapabilities[index] &= (~c | (((1 << 4) - 1) << (32 - 4)));
        }



        bool hasCapability(const Capabilities c) const
        {
            int index = ((((1 << 4) - 1) << (32 - 4)) & c) >> (32 - 4);

            if(mCapabilities[index] & (c & ~(((1 << 4) - 1) << (32 - 4))))
            {
                return true;
            }
            else
            {
                return false;
            }
        }



        void addShaderProfile(const String& profile)
        {
            mSupportedShaderProfiles.insert(profile);

        }



        void removeShaderProfile(const String& profile)
        {
            mSupportedShaderProfiles.erase(profile);
        }



        bool isShaderProfileSupported(const String& profile) const
        {
            return (mSupportedShaderProfiles.end() != mSupportedShaderProfiles.find(profile));
        }




        const ShaderProfiles& getSupportedShaderProfiles() const
        {
            return mSupportedShaderProfiles;
        }



        ushort getVertexProgramConstantFloatCount(void) const
        {
            return mVertexProgramConstantFloatCount;
        }

        ushort getVertexProgramConstantIntCount(void) const
        {
            return mVertexProgramConstantIntCount;
        }

        ushort getVertexProgramConstantBoolCount(void) const
        {
            return mVertexProgramConstantBoolCount;
        }

        ushort getGeometryProgramConstantFloatCount(void) const
        {
            return mGeometryProgramConstantFloatCount;
        }

        ushort getGeometryProgramConstantIntCount(void) const
        {
            return mGeometryProgramConstantIntCount;
        }

        ushort getGeometryProgramConstantBoolCount(void) const
        {
            return mGeometryProgramConstantBoolCount;
        }

        ushort getFragmentProgramConstantFloatCount(void) const
        {
            return mFragmentProgramConstantFloatCount;
        }

        ushort getFragmentProgramConstantIntCount(void) const
        {
            return mFragmentProgramConstantIntCount;
        }

        ushort getFragmentProgramConstantBoolCount(void) const
        {
            return mFragmentProgramConstantBoolCount;
        }


        void setDeviceName(const String& name)
        {
            mDeviceName = name;
        }


        String getDeviceName() const
        {
            return mDeviceName;
        }


        void setVertexProgramConstantFloatCount(ushort c)
        {
            mVertexProgramConstantFloatCount = c;
        }

        void setVertexProgramConstantIntCount(ushort c)
        {
            mVertexProgramConstantIntCount = c;
        }

        void setVertexProgramConstantBoolCount(ushort c)
        {
            mVertexProgramConstantBoolCount = c;
        }

        void setGeometryProgramConstantFloatCount(ushort c)
        {
            mGeometryProgramConstantFloatCount = c;
        }

        void setGeometryProgramConstantIntCount(ushort c)
        {
            mGeometryProgramConstantIntCount = c;
        }

        void setGeometryProgramConstantBoolCount(ushort c)
        {
            mGeometryProgramConstantBoolCount = c;
        }

        void setFragmentProgramConstantFloatCount(ushort c)
        {
            mFragmentProgramConstantFloatCount = c;
        }

        void setFragmentProgramConstantIntCount(ushort c)
        {
            mFragmentProgramConstantIntCount = c;
        }

        void setFragmentProgramConstantBoolCount(ushort c)
        {
            mFragmentProgramConstantBoolCount = c;
        }

        void setMaximumResolutions( ushort res2d, ushort res3d, ushort resCube )
        {
            mMaxTextureResolution2D = res2d;
            mMaxTextureResolution3D = res3d;
            mMaxTextureResolutionCubemap = resCube;
        }

        ushort getMaximumResolution2D(void) const
        {
            return mMaxTextureResolution2D;
        }

        ushort getMaximumResolution3D(void) const
        {
            return mMaxTextureResolution3D;
        }

        ushort getMaximumResolutionCubemap(void) const
        {
            return mMaxTextureResolutionCubemap;
        }

        void setMaxPointSize(Real s)
        {
            mMaxPointSize = s;
        }

        Real getMaxPointSize(void) const
        {
            return mMaxPointSize;
        }

        void setNonPOW2TexturesLimited(bool l)
        {
            mNonPOW2TexturesLimited = l;
        }
        bool getNonPOW2TexturesLimited(void) const
        {
            return mNonPOW2TexturesLimited;
        }

        void setMaxSupportedAnisotropy(Real s)
        {
            mMaxSupportedAnisotropy = s;
        }

        Real getMaxSupportedAnisotropy()
        {
            return mMaxSupportedAnisotropy;
        }


        void setNumVertexTextureUnits(ushort n)
        {
            mNumVertexTextureUnits = n;
        }

        ushort getNumVertexTextureUnits(void) const
        {
            return mNumVertexTextureUnits;
        }

        void setVertexTextureUnitsShared(bool shared)
        {
            mVertexTextureUnitsShared = shared;
        }

        bool getVertexTextureUnitsShared(void) const
        {
            return mVertexTextureUnitsShared;
        }


        void setGeometryProgramNumOutputVertices(int numOutputVertices)
        {
            mGeometryProgramNumOutputVertices = numOutputVertices;
        }

        int getGeometryProgramNumOutputVertices(void) const
        {
            return mGeometryProgramNumOutputVertices;
        }


        String getRenderSystemName(void) const
        {
            return mRenderSystemName;
        }

        void setRenderSystemName(const String& rs)
        {
            mRenderSystemName = rs;
        }


        void setCategoryRelevant(CapabilitiesCategory cat, bool relevant)
        {
            mCategoryRelevant[cat] = relevant;
        }


        bool isCategoryRelevant(CapabilitiesCategory cat)
        {
            return mCategoryRelevant[cat];
        }




        void log(Log* pLog);



        void setTessellationHullProgramConstantFloatCount(ushort c)
        {
            mTessellationHullProgramConstantFloatCount = c;
        }

        void setTessellationHullProgramConstantIntCount(ushort c)
        {
            mTessellationHullProgramConstantIntCount = c;
        }

        void setTessellationHullProgramConstantBoolCount(ushort c)
        {
            mTessellationHullProgramConstantBoolCount = c;
        }

        ushort getTessellationHullProgramConstantFloatCount(void) const
        {
            return mTessellationHullProgramConstantFloatCount;
        }

        ushort getTessellationHullProgramConstantIntCount(void) const
        {
            return mTessellationHullProgramConstantIntCount;
        }

        ushort getTessellationHullProgramConstantBoolCount(void) const
        {
            return mTessellationHullProgramConstantBoolCount;
        }


        void setTessellationDomainProgramConstantFloatCount(ushort c)
        {
            mTessellationDomainProgramConstantFloatCount = c;
        }

        void setTessellationDomainProgramConstantIntCount(ushort c)
        {
            mTessellationDomainProgramConstantIntCount = c;
        }

        void setTessellationDomainProgramConstantBoolCount(ushort c)
        {
            mTessellationDomainProgramConstantBoolCount = c;
        }

        ushort getTessellationDomainProgramConstantFloatCount(void) const
        {
            return mTessellationDomainProgramConstantFloatCount;
        }

        ushort getTessellationDomainProgramConstantIntCount(void) const
        {
            return mTessellationDomainProgramConstantIntCount;
        }

        ushort getTessellationDomainProgramConstantBoolCount(void) const
        {
            return mTessellationDomainProgramConstantBoolCount;
        }


        void setComputeProgramConstantFloatCount(ushort c)
        {
            mComputeProgramConstantFloatCount = c;
        }

        void setComputeProgramConstantIntCount(ushort c)
        {
            mComputeProgramConstantIntCount = c;
        }

        void setComputeProgramConstantBoolCount(ushort c)
        {
            mComputeProgramConstantBoolCount = c;
        }

        ushort getComputeProgramConstantFloatCount(void) const
        {
            return mComputeProgramConstantFloatCount;
        }

        ushort getComputeProgramConstantIntCount(void) const
        {
            return mComputeProgramConstantIntCount;
        }

        ushort getComputeProgramConstantBoolCount(void) const
        {
            return mComputeProgramConstantBoolCount;
        }

    };



}



namespace Ogre {
    typedef struct _ConfigOption
    {
        String name;
        String currentValue;
        StringVector possibleValues;
        bool immutable;
    } ConfigOption;

    typedef map< String, ConfigOption >::type ConfigOptionMap;


}




namespace Ogre
{







    namespace ResourceLayout
    {
    enum Layout
    {
        Undefined,
        Texture,
        TextureDepth,
        RenderTarget,
        RenderDepth,
        Clear,
        Uav,
        CopySrc,
        CopyDst,

        NumResourceLayouts
    };
    }

    namespace WriteBarrier
    {
    enum WriteBarrier
    {

        CpuWrite = 0x00000001,

        Uav = 0x00000002,

        RenderTarget = 0x00000004,

        DepthStencil = 0x00000008,


        All = 0xffffffff
    };
    }

    namespace ReadBarrier
    {
    enum ReadBarrier
    {

        CpuRead = 0x00000001,

        Indirect = 0x00000002,

        VertexBuffer = 0x00000004,

        IndexBuffer = 0x00000008,

        ConstBuffer = 0x00000010,

        Texture = 0x00000020,

        Uav = 0x00000040,

        RenderTarget = 0x00000080,

        DepthStencil = 0x00000100,

        All = 0xffffffff
    };
    }

    namespace ResourceAccess
    {

    enum ResourceAccess
    {
        Undefined = 0x00,
        Read = 0x01,
        Write = 0x10,
        ReadWrite = Read | Write
    };

    const char* toString( ResourceAccess value );
    }

    struct ResourceTransition
    {

        ResourceLayout::Layout oldLayout;
        ResourceLayout::Layout newLayout;

        uint32 writeBarrierBits;
        uint32 readBarrierBits;

        void *mRsData;
    };

    typedef map<RenderTarget*, ResourceLayout::Layout>::type ResourceLayoutMap;
    typedef map<RenderTarget*, ResourceAccess::ResourceAccess>::type ResourceAccessMap;



}



namespace Ogre
{







    typedef vector<DepthBuffer*>::type DepthBufferVec;
    typedef map< uint16, DepthBufferVec >::type DepthBufferMap;
    typedef map< String, RenderTarget * >::type RenderTargetMap;

    class TextureManager;

    enum TexCoordCalcMethod
    {

        TEXCALC_NONE,

        TEXCALC_ENVIRONMENT_MAP,

        TEXCALC_ENVIRONMENT_MAP_PLANAR,
        TEXCALC_ENVIRONMENT_MAP_REFLECTION,
        TEXCALC_ENVIRONMENT_MAP_NORMAL,

        TEXCALC_PROJECTIVE_TEXTURE
    };
    class RenderSystem : public RenderSysAlloc
    {
    public:


        RenderSystem();



        virtual ~RenderSystem();



        virtual const String& getName(void) const = 0;



  virtual const String& getFriendlyName(void) const = 0;
        virtual ConfigOptionMap& getConfigOptions(void) = 0;
        virtual void setConfigOption(const String &name, const String &value) = 0;



        virtual HardwareOcclusionQuery* createHardwareOcclusionQuery(void) = 0;



        virtual void destroyHardwareOcclusionQuery(HardwareOcclusionQuery *hq);





        virtual String validateConfigOptions(void) = 0;
        virtual RenderWindow* _initialise(bool autoCreateWindow, const String& windowTitle = "OGRE Render Window");






        virtual bool isStaticBufferLockable() const { return true; }


        virtual RenderSystemCapabilities* createRenderSystemCapabilities() const = 0;
        RenderSystemCapabilities* getMutableCapabilities(){ return mCurrentCapabilities; }







        virtual void useCustomRenderSystemCapabilities(RenderSystemCapabilities* capabilities);



        virtual void reinitialise(void) = 0;



        virtual void shutdown(void);







        void setWBufferEnabled(bool enabled);



        bool getWBufferEnabled(void) const;
        virtual RenderWindow* _createRenderWindow(const String &name, unsigned int width, unsigned int height,
            bool fullScreen, const NameValuePairList *miscParams = 0) = 0;
        virtual bool _createRenderWindows(const RenderWindowDescriptionList& renderWindowDescriptions,
            RenderWindowList& createdWindows);






        virtual MultiRenderTarget * createMultiRenderTarget(const String & name) = 0;


        virtual void destroyRenderWindow(const String& name);

        virtual void destroyRenderTexture(const String& name);

        virtual void destroyRenderTarget(const String& name);



        virtual void attachRenderTarget( RenderTarget &target );



        virtual RenderTarget * getRenderTarget( const String &name );





        virtual RenderTarget * detachRenderTarget( const String &name );


        typedef MapIterator<Ogre::RenderTargetMap> RenderTargetIterator;


        virtual RenderTargetIterator getRenderTargetIterator(void) {
            return RenderTargetIterator( mRenderTargets.begin(), mRenderTargets.end() );
        }


        virtual String getErrorDescription(long errorNumber) const = 0;



        v1::HardwareVertexBufferSharedPtr getGlobalInstanceVertexBuffer() const;


        void setGlobalInstanceVertexBuffer(const v1::HardwareVertexBufferSharedPtr &val);


        v1::VertexDeclaration* getGlobalInstanceVertexBufferVertexDeclaration() const;


        void setGlobalInstanceVertexBufferVertexDeclaration( v1::VertexDeclaration* val);


        size_t getGlobalNumberOfInstances() const;


        void setGlobalNumberOfInstances(const size_t val);



        bool getFixedPipelineEnabled(void) const;






        virtual void setDepthBufferFor( RenderTarget *renderTarget, bool exactMatch );

        virtual void createUniqueDepthBufferFor( RenderTarget *renderTarget, bool exactMatch );

        virtual void _destroyDepthBuffer( DepthBuffer *depthBuffer );
        virtual void _useLights(const LightList& lights, unsigned short limit) = 0;


        virtual bool areFixedFunctionLightsInViewSpace() const { return false; }

        virtual void _setWorldMatrix(const Matrix4 &m) = 0;

        virtual void _setWorldMatrices(const Matrix4* m, unsigned short count);

        virtual void _setViewMatrix(const Matrix4 &m) = 0;

        virtual void _setProjectionMatrix(const Matrix4 &m) = 0;





        virtual void _setTextureUnitSettings(size_t texUnit, TextureUnitState& tl);

        virtual void _setBindingType(TextureUnitState::BindingType bindigType);

        virtual void _disableTextureUnit(size_t texUnit);

        virtual void _disableTextureUnitsFrom(size_t texUnit);
        virtual void _setSurfaceParams(const ColourValue &ambient,
            const ColourValue &diffuse, const ColourValue &specular,
            const ColourValue &emissive, Real shininess,
            TrackVertexColourType tracking = TVC_NONE) = 0;






        virtual void _setPointSpritesEnabled(bool enabled) = 0;
        virtual void _setPointParameters(Real size, bool attenuationEnabled,
            Real constant, Real linear, Real quadratic, Real minSize, Real maxSize) = 0;
        virtual void _setTexture(size_t unit, bool enabled, Texture *texPtr) = 0;
        virtual void setUavStartingSlot( uint32 startingSlot );
        virtual void queueBindUAV( uint32 slot, TexturePtr texture,
                                   ResourceAccess::ResourceAccess access = ResourceAccess::ReadWrite,
                                   int32 mipmapLevel = 0, int32 textureArrayIndex = 0,
                                   PixelFormat pixelFormat = PF_UNKNOWN ) = 0;



        virtual void clearUAVs(void) = 0;



        virtual void flushUAVs(void) = 0;
        virtual void _setTexture(size_t unit, bool enabled, const String &texname);

        virtual void _resourceTransitionCreated( ResourceTransition *resTransition ) {}
        virtual void _resourceTransitionDestroyed( ResourceTransition *resTransition ) {}
        virtual void _executeResourceTransition( ResourceTransition *resTransition ) {}

        virtual void _hlmsMacroblockCreated( HlmsMacroblock *newBlock ) {}
        virtual void _hlmsMacroblockDestroyed( HlmsMacroblock *block ) {}
        virtual void _hlmsBlendblockCreated( HlmsBlendblock *newBlock ) {}
        virtual void _hlmsBlendblockDestroyed( HlmsBlendblock *block ) {}
        virtual void _hlmsSamplerblockCreated( HlmsSamplerblock *newBlock ) {}
        virtual void _hlmsSamplerblockDestroyed( HlmsSamplerblock *block ) {}

        virtual void _setIndirectBuffer( IndirectBufferPacked *indirectBuffer ) = 0;
        virtual void _setVertexTexture(size_t unit, const TexturePtr& tex);
        virtual void _setGeometryTexture(size_t unit, const TexturePtr& tex);
        virtual void _setComputeTexture(size_t unit, const TexturePtr& tex);
        virtual void _setTessellationHullTexture(size_t unit, const TexturePtr& tex);
        virtual void _setTessellationDomainTexture(size_t unit, const TexturePtr& tex);
        virtual void _setTextureCoordSet(size_t unit, size_t index) = 0;
        virtual void _setTextureCoordCalculation(size_t unit, TexCoordCalcMethod m,
            const Frustum* frustum = 0) = 0;







        virtual void _setTextureBlendMode(size_t unit, const LayerBlendModeEx& bm) = 0;





        virtual void _setTextureMatrix(size_t unit, const Matrix4& xform) = 0;




        virtual void _setTextureProjectionRelativeTo(bool enabled, const Vector3& pos);
        virtual DepthBuffer* _createDepthBufferFor( RenderTarget *renderTarget,
                                                    bool exactMatchFormat ) = 0;
        void _cleanupDepthBuffers( bool bCleanManualBuffers=true );



        virtual void _beginFrameOnce(void);





        virtual void _beginFrame(void) = 0;



        struct RenderSystemContext { };





        virtual RenderSystemContext* _pauseFrame(void);






        virtual void _resumeFrame(RenderSystemContext* context);




        virtual void _endFrame(void) = 0;


        void _update(void);
        virtual void _setViewport(Viewport *vp) = 0;

        virtual Viewport* _getViewport(void);


        virtual void _setHlmsMacroblock( const HlmsMacroblock *macroblock ) = 0;


        virtual void _setHlmsBlendblock( const HlmsBlendblock *blendblock ) = 0;



        virtual void _setHlmsSamplerblock( uint8 texUnit, const HlmsSamplerblock *Samplerblock ) = 0;


        virtual void _setProgramsFromHlms( const HlmsCache *hlmsCache ) = 0;
        virtual void _beginGeometryCount(void);

        virtual unsigned int _getFaceCount(void) const;

        virtual unsigned int _getBatchCount(void) const;

        virtual unsigned int _getVertexCount(void) const;
        virtual void convertColourValue(const ColourValue& colour, uint32* pDest);



        virtual VertexElementType getColourVertexElementType(void) const = 0;







        virtual void _convertProjectionMatrix(const Matrix4& matrix,
            Matrix4& dest, bool forGpuProgram = false) = 0;







        virtual void _makeProjectionMatrix(const Radian& fovy, Real aspect, Real nearPlane, Real farPlane,
            Matrix4& dest, bool forGpuProgram = false) = 0;







        virtual void _makeProjectionMatrix(Real left, Real right, Real bottom, Real top,
            Real nearPlane, Real farPlane, Matrix4& dest, bool forGpuProgram = false) = 0;






        virtual void _makeOrthoMatrix(const Radian& fovy, Real aspect, Real nearPlane, Real farPlane,
            Matrix4& dest, bool forGpuProgram = false) = 0;
        virtual void _applyObliqueDepthProjection(Matrix4& matrix, const Plane& plane,
            bool forGpuProgram) = 0;
        virtual void setStencilCheckEnabled(bool enabled) = 0;
        virtual void setStencilBufferParams(CompareFunction func = CMPF_ALWAYS_PASS,
            uint32 refValue = 0, uint32 compareMask = 0xFFFFFFFF, uint32 writeMask = 0xFFFFFFFF,
            StencilOperation stencilFailOp = SOP_KEEP,
            StencilOperation depthFailOp = SOP_KEEP,
            StencilOperation passOp = SOP_KEEP,
            bool twoSidedOperation = false,
            bool readBackAsTexture = false) {};




        virtual void setVertexDeclaration(v1::VertexDeclaration* decl) = 0;

        virtual void setVertexBufferBinding(v1::VertexBufferBinding* binding) = 0;
        virtual void _render(const v1::RenderOperation& op);







        virtual void _setVertexArrayObject( const VertexArrayObject *vao ) = 0;


        virtual void _render( const CbDrawCallIndexed *cmd ) = 0;
        virtual void _render( const CbDrawCallStrip *cmd ) = 0;
        virtual void _renderEmulated( const CbDrawCallIndexed *cmd ) = 0;
        virtual void _renderEmulated( const CbDrawCallStrip *cmd ) = 0;


        virtual void _startLegacyV1Rendering(void) {}
        virtual void _setRenderOperation( const v1::CbRenderOp *cmd ) = 0;

        virtual void _render( const v1::CbDrawCallIndexed *cmd ) = 0;
        virtual void _render( const v1::CbDrawCallStrip *cmd ) = 0;

        virtual void _renderUsingReadBackAsTexture(unsigned int secondPass,Ogre::String variableName,unsigned int StartSlot);


        const RenderSystemCapabilities* getCapabilities(void) const { return mCurrentCapabilities; }




        virtual const DriverVersion& getDriverVersion(void) const { return mDriverVersion; }
        virtual const String& _getDefaultViewportMaterialScheme(void) const;





        virtual void bindGpuProgram(GpuProgram* prg);






        virtual void bindGpuProgramParameters(GpuProgramType gptype,
            GpuProgramParametersSharedPtr params, uint16 variabilityMask) = 0;



        virtual void bindGpuProgramPassIterationParameters(GpuProgramType gptype) = 0;




        virtual void unbindGpuProgram(GpuProgramType gptype);


        virtual bool isGpuProgramBound(GpuProgramType gptype);

        VaoManager* getVaoManager(void) const { return mVaoManager; }






        uint16 getNativeShadingLanguageVersion() const { return mNativeShadingLanguageVersion; }



        virtual void setClipPlanes(const PlaneList& clipPlanes);


        virtual void addClipPlane (const Plane &p);

        virtual void addClipPlane (Real A, Real B, Real C, Real D);



        virtual void resetClipPlanes();


        virtual void _initRenderTargets(void);



        virtual void setInvertVertexWinding(bool invert);




        virtual bool getInvertVertexWinding(void) const;
        virtual void clearFrameBuffer(unsigned int buffers,
            const ColourValue& colour = ColourValue::Black,
            Real depth = 1.0f, unsigned short stencil = 0) = 0;


        virtual void discardFrameBuffer( unsigned int buffers ) = 0;
        virtual Real getHorizontalTexelOffset(void) = 0;
        virtual Real getVerticalTexelOffset(void) = 0;
        virtual Real getMinimumDepthInputValue(void) = 0;
        virtual Real getMaximumDepthInputValue(void) = 0;





        virtual void setCurrentPassIterationCount(const size_t count) { mCurrentPassIterationCount = count; }
        virtual void setDeriveDepthBias(bool derive, float baseValue = 0.0f,
            float multiplier = 0.0f, float slopeScale = 0.0f)
        {
            mDerivedDepthBias = derive;
            mDerivedDepthBiasBase = baseValue;
            mDerivedDepthBiasMultiplier = multiplier;
            mDerivedDepthBiasSlopeScale = slopeScale;
        }







        virtual void _setRenderTarget(RenderTarget *target, bool colourWrite) = 0;





        class Listener
        {
        public:
            Listener() {}
            virtual ~Listener() {}






            virtual void eventOccurred(const String& eventName,
                const NameValuePairList* parameters = 0) = 0;
        };
        virtual void addListener(Listener* l);


        virtual void removeListener(Listener* l);





        virtual const StringVector& getRenderSystemEvents(void) const { return mEventNames; }
        virtual void preExtraThreadsStarted() = 0;





        virtual void postExtraThreadsStarted() = 0;
        virtual void registerThread() = 0;




        virtual void unregisterThread() = 0;





        virtual unsigned int getDisplayMonitorCount() const = 0;




        virtual void beginProfileEvent( const String &eventName ) = 0;




        virtual void endProfileEvent( void ) = 0;





        virtual void markProfileEvent( const String &event ) = 0;



        virtual bool hasAnisotropicMipMapFilter() const = 0;






        virtual void getCustomAttribute(const String& name, void* pData);
  virtual bool setDrawBuffer(ColourBufferType colourBuffer) { return false; };


        virtual bool checkExtension( const String &ext ) const { return false; }

    protected:

        void cleanReleasedDepthBuffers(void);


        DepthBufferMap mDepthBufferPool;
        DepthBufferVec mReleasedDepthBuffers;


        RenderTargetMap mRenderTargets;

        RenderTarget * mActiveRenderTarget;


        GpuProgramParametersSharedPtr mActiveVertexGpuProgramParameters;
        GpuProgramParametersSharedPtr mActiveGeometryGpuProgramParameters;
        GpuProgramParametersSharedPtr mActiveFragmentGpuProgramParameters;
        GpuProgramParametersSharedPtr mActiveTessellationHullGpuProgramParameters;
        GpuProgramParametersSharedPtr mActiveTessellationDomainGpuProgramParameters;
        GpuProgramParametersSharedPtr mActiveComputeGpuProgramParameters;





        TextureManager* mTextureManager;

        VaoManager *mVaoManager;


        Viewport* mActiveViewport;

        bool mWBuffer;

        size_t mBatchCount;
        size_t mFaceCount;
        size_t mVertexCount;


        ColourValue mManualBlendColours[16][2];

        bool mInvertVertexWinding;


        size_t mDisabledTexUnitsFrom;


        size_t mCurrentPassIterationCount;
        size_t mCurrentPassIterationNum;

        bool mDerivedDepthBias;
        float mDerivedDepthBiasBase;
        float mDerivedDepthBiasMultiplier;
        float mDerivedDepthBiasSlopeScale;

        uint32 mUavStartingSlot;


        v1::HardwareVertexBufferSharedPtr mGlobalInstanceVertexBuffer;

        v1::VertexDeclaration* mGlobalInstanceVertexBufferVertexDeclaration;

        size_t mGlobalNumberOfInstances;





        bool updatePassIterationRenderState(void);


        StringVector mEventNames;


        virtual void fireEvent(const String& name, const NameValuePairList* params = 0);

        typedef list<Listener*>::type ListenerList;
        ListenerList mEventListeners;

        typedef list<HardwareOcclusionQuery*>::type HardwareOcclusionQueryList;
        HardwareOcclusionQueryList mHwOcclusionQueries;

        bool mVertexProgramBound;
        bool mGeometryProgramBound;
        bool mFragmentProgramBound;
        bool mTessellationHullProgramBound;
        bool mTessellationDomainProgramBound;
        bool mComputeProgramBound;


        PlaneList mClipPlanes;

        bool mClipPlanesDirty;


        RenderSystemCapabilities* mRealCapabilities;
        RenderSystemCapabilities* mCurrentCapabilities;
        bool mUseCustomCapabilities;


        virtual void setClipPlanesImpl(const PlaneList& clipPlanes) = 0;


        virtual void initialiseFromRenderSystemCapabilities(RenderSystemCapabilities* caps, RenderTarget* primary) = 0;


        DriverVersion mDriverVersion;
        uint16 mNativeShadingLanguageVersion;

        bool mTexProjRelative;
        Vector3 mTexProjRelativeOrigin;



    };


}


namespace Ogre {
    struct RenderTargetEvent
    {

        RenderTarget* source;
    };



    struct RenderTargetViewportEvent
    {

        Viewport* source;
    };
    class RenderTargetListener
    {
    public:
        virtual ~RenderTargetListener() {}
        virtual void preRenderTargetUpdate(const RenderTargetEvent& evt)
        { (void)evt; }
        virtual void postRenderTargetUpdate(const RenderTargetEvent& evt)
        { (void)evt; }







        virtual void preViewportUpdate(const RenderTargetViewportEvent& evt)
        { (void)evt; }






        virtual void postViewportUpdate(const RenderTargetViewportEvent& evt)
        { (void)evt; }




        virtual void viewportAdded(const RenderTargetViewportEvent& evt)
                { (void)evt; }



        virtual void viewportRemoved(const RenderTargetViewportEvent& evt)
                { (void)evt; }
    };


}








namespace Ogre {
    class RenderTarget : public RenderSysAlloc
    {
    public:
        enum StatFlags
        {
            SF_NONE = 0,
            SF_FPS = 1,
            SF_AVG_FPS = 2,
            SF_BEST_FPS = 4,
            SF_WORST_FPS = 8,
            SF_TRIANGLE_COUNT = 16,
            SF_ALL = 0xFFFF
        };

        struct FrameStats
        {
            size_t triangleCount;
            size_t batchCount;
            int vBlankMissCount;
        };

        enum FrameBuffer
        {
            FB_FRONT,
            FB_BACK,
            FB_AUTO
        };

        RenderTarget();
        virtual ~RenderTarget();


        virtual const String& getName(void) const;


        virtual void getMetrics(unsigned int& width, unsigned int& height, unsigned int& colourDepth);

        virtual uint32 getWidth(void) const;
        virtual uint32 getHeight(void) const;
        virtual uint32 getColourDepth(void) const;
        virtual void setDepthBufferPool( uint16 poolId );


        uint16 getDepthBufferPool() const;
        void setPreferDepthTexture( bool preferDepthTexture );


        bool prefersDepthTexture() const;
        void setDesiredDepthBufferFormat( PixelFormat desiredDepthBufferFormat );


        PixelFormat getDesiredDepthBufferFormat(void) const;

        DepthBuffer* getDepthBuffer() const;


        virtual bool attachDepthBuffer( DepthBuffer *depthBuffer, bool exactFormatMatch );

        virtual void detachDepthBuffer();





        virtual void _detachDepthBuffer();
        virtual void swapBuffers(void) { mFsaaResolveDirty = false; }

        virtual void setFsaaResolveDirty(void)
        {
            mFsaaResolveDirty = true;
            mMipmapsDirty = true;
        }
        virtual Viewport* addViewport( float left = 0.0f, float top = 0.0f,
                                        float width = 1.0f, float height = 1.0f );


        virtual unsigned short getNumViewports(void) const;


        virtual Viewport* getViewport(unsigned short index);



        virtual void removeViewport( Viewport *vp );



        virtual void removeAllViewports(void);

        virtual const FrameStats& getStatistics(void) const;



        virtual void resetStatistics(void);
        virtual void getCustomAttribute(const String& name, void* pData);
        virtual void addListener(RenderTargetListener* listener);

        virtual void removeListener(RenderTargetListener* listener);

        virtual void removeAllListeners(void);
        virtual void setPriority( uchar priority ) { mPriority = priority; }

        virtual uchar getPriority() const { return mPriority; }



        virtual bool isActive() const;



        virtual void setActive( bool state );






        virtual void copyContentsToMemory(const PixelBox &dst, FrameBuffer buffer = FB_AUTO) = 0;




        virtual PixelFormat suggestPixelFormat() const { return PF_BYTE_RGBA; }


        void writeContentsToFile(const String& filename);



        virtual String writeContentsToTimestampedFile(const String& filenamePrefix, const String& filenameSuffix);

        virtual bool requiresTextureFlipping() const = 0;


        virtual size_t getTriangleCount(void) const;

        virtual size_t getBatchCount(void) const;







        virtual bool isPrimary(void) const;


  virtual bool isStereoEnabled(void) const;
        virtual bool isHardwareGammaEnabled() const { return mHwGamma; }



        virtual uint getFSAA() const { return mFSAA; }



        virtual const String& getFSAAHint() const { return mFSAAHint; }

        bool isFsaaResolveDirty(void) const { return mFsaaResolveDirty; }







        virtual void setFSAA(uint fsaa, const String& fsaaHint) { }

        void _setMipmapsUpdated(void) { mMipmapsDirty = false; }
        bool isMipmapsDirty(void) const { return mMipmapsDirty; }




        class Impl
        {
        protected:
            ~Impl() { }
        };





        virtual Impl *_getImpl();
        virtual void _beginUpdate();

        void _updateViewportCullPhase01(Viewport* viewport, Camera *camera, const Camera *lodCamera,
                                        uint8 firstRq, uint8 lastRq );
        virtual void _updateViewportRenderPhase02( Viewport* viewport, Camera *camera,
                                                   const Camera *lodCamera,uint8 firstRq, uint8 lastRq,
                                                   bool updateStatistics );


        virtual bool isRenderWindow(void) const { return false; }







        virtual void _endUpdate();




        virtual bool getForceDisableColourWrites(void) const { return false; }

    protected:

        String mName;

        uchar mPriority;

        uint32 mWidth;
        uint32 mHeight;
        uint32 mColourDepth;
        uint16 mDepthBufferPoolId;
        bool mPreferDepthTexture;
        PixelFormat mDesiredDepthBufferFormat;
        DepthBuffer *mDepthBuffer;


        FrameStats mStats;

        bool mActive;

        bool mHwGamma;

        uint mFSAA;
        String mFSAAHint;
        bool mFsaaResolveDirty;
        bool mMipmapsDirty;
        bool mStereoEnabled;

        typedef vector<Viewport*>::type ViewportList;

        ViewportList mViewportList;

        typedef vector<RenderTargetListener*>::type RenderTargetListenerList;
        RenderTargetListenerList mListeners;



        virtual void firePreUpdate(void);

        virtual void firePostUpdate(void);

        virtual void fireViewportPreUpdate(Viewport* vp);

        virtual void fireViewportPostUpdate(Viewport* vp);

        virtual void fireViewportAdded(Viewport* vp);

        virtual void fireViewportRemoved(Viewport* vp);
    };



}



namespace Ogre
{
    class RenderTexture: public RenderTarget
    {
    public:
        RenderTexture(v1::HardwarePixelBuffer *buffer, uint32 zoffset);
        virtual ~RenderTexture();

        virtual void copyContentsToMemory(const PixelBox &dst, FrameBuffer buffer);
        PixelFormat suggestPixelFormat() const;

    protected:
        v1::HardwarePixelBuffer *mBuffer;
        uint32 mZOffset;
    };
    class MultiRenderTarget: public RenderTarget
    {
    public:
        MultiRenderTarget(const String &name);
        virtual void bindSurface(size_t attachment, RenderTexture *target)
        {
            for (size_t i = mBoundSurfaces.size(); i <= attachment; ++i)
            {
                mBoundSurfaces.push_back(0);
            }
            mBoundSurfaces[attachment] = target;

            bindSurfaceImpl(attachment, target);
        }






        virtual void unbindSurface(size_t attachment)
        {
            if (attachment < mBoundSurfaces.size())
                mBoundSurfaces[attachment] = 0;
            unbindSurfaceImpl(attachment);
        }




        virtual void copyContentsToMemory(const PixelBox &dst, FrameBuffer buffer);
        virtual void setFsaaResolveDirty(void);
        virtual void swapBuffers(void);


        PixelFormat suggestPixelFormat() const { return PF_UNKNOWN; }

        typedef vector<RenderTexture*>::type BoundSufaceList;

        const BoundSufaceList& getBoundSurfaceList() const { return mBoundSurfaces; }


        RenderTexture* getBoundSurface(size_t index)
        {
            assert (index < mBoundSurfaces.size());
            return mBoundSurfaces[index];
        }


    protected:
        BoundSufaceList mBoundSurfaces;


        virtual void bindSurfaceImpl(size_t attachment, RenderTexture *target) = 0;

        virtual void unbindSurfaceImpl(size_t attachment) = 0;


    };


}


namespace Ogre
{
    class RenderWindow : public RenderTarget
    {

    public:


        RenderWindow();
        virtual float getViewPointToPixelScale() { return 1.0f; }
        virtual void create(const String& name, unsigned int widthPt, unsigned int heightPt,
                bool fullScreen, const NameValuePairList *miscParams) = 0;
        virtual void setFullscreen(bool fullScreen, unsigned int widthPt, unsigned int heightPt)
                { (void)fullScreen; (void)widthPt; (void)heightPt; }



        virtual void destroy(void) = 0;



        virtual void resize(unsigned int widthPt, unsigned int heightPt) = 0;





        virtual void windowMovedOrResized() {}



        virtual void reposition(int leftPt, int topPt) = 0;



        virtual bool isVisible(void) const { return true; }



        virtual void setVisible(bool visible)
        { (void)visible; }



        virtual bool isHidden(void) const { return false; }
        virtual void setHidden(bool hidden)
        { (void)hidden; }



        virtual void setVSyncEnabled(bool vsync)
        { (void)vsync; }



        virtual bool isVSyncEnabled() const { return false; }




        virtual void setVSyncInterval(unsigned int interval)
        { (void)interval; }



        virtual unsigned int getVSyncInterval() const { return 1; }




        virtual bool isActive(void) const { return mActive && isVisible(); }



        virtual bool isClosed(void) const = 0;







        virtual bool isPrimary(void) const;



        virtual bool isFullScreen(void) const;




        virtual void getMetrics(unsigned int& width, unsigned int& height, unsigned int& colourDepth,
            int& left, int& top) const;


        PixelFormat suggestPixelFormat() const { return PF_BYTE_RGB; }



        bool isDeactivatedOnFocusChange() const;





        void setDeactivateOnFocusChange(bool deactivate);

        virtual bool isRenderWindow(void) const { return true; }

    protected:
        bool mIsFullScreen;
        bool mIsPrimary;
        bool mAutoDeactivatedOnFocusChange;
        int mLeft;
        int mTop;




        void _setPrimary() { mIsPrimary = true; }

        friend class Root;
    };



}

namespace Ogre
{
    class WorkQueue : public UtilityAlloc
    {
    protected:
        typedef map<String, uint16>::type ChannelMap;
        ChannelMap mChannelMap;
        uint16 mNextChannel;
                                    ;
    public:

        typedef unsigned long long int RequestID;



        class Request : public UtilityAlloc
        {
            friend class WorkQueue;
        protected:

            uint16 mChannel;

            uint16 mType;

            Any mData;

            uint8 mRetryCount;

            RequestID mID;

            mutable bool mAborted;

        public:

            Request(uint16 channel, uint16 rtype, const Any& rData, uint8 retry, RequestID rid);
            ~Request();

            void abortRequest() const { mAborted = true; }

            uint16 getChannel() const { return mChannel; }

            uint16 getType() const { return mType; }

            const Any& getData() const { return mData; }

            uint8 getRetryCount() const { return mRetryCount; }

            RequestID getID() const { return mID; }

            bool getAborted() const { return mAborted; }
        };



        struct Response : public UtilityAlloc
        {

            const Request* mRequest;

            bool mSuccess;

            String mMessages;

            Any mData;

        public:
            Response(const Request* rq, bool success, const Any& data, const String& msg = BLANKSTRING);
            ~Response();

            const Request* getRequest() const { return mRequest; }

            bool succeeded() const { return mSuccess; }

            const String& getMessages() const { return mMessages; }

            const Any& getData() const { return mData; }

            void abortRequest() { mRequest->abortRequest(); mData.destroy(); }
        };
        class RequestHandler
        {
        public:
            RequestHandler() {}
            virtual ~RequestHandler() {}







            virtual bool canHandleRequest(const Request* req, const WorkQueue* srcQ)
            { (void)srcQ; return !req->getAborted(); }
            virtual Response* handleRequest(const Request* req, const WorkQueue* srcQ) = 0;
        };
        class ResponseHandler
        {
        public:
            ResponseHandler() {}
            virtual ~ResponseHandler() {}







            virtual bool canHandleResponse(const Response* res, const WorkQueue* srcQ)
            { (void)srcQ; return !res->getRequest()->getAborted(); }
            virtual void handleResponse(const Response* res, const WorkQueue* srcQ) = 0;
        };

        WorkQueue() : mNextChannel(0) {}
        virtual ~WorkQueue() {}





        virtual void startup(bool forceRestart = true) = 0;
        virtual void addRequestHandler(uint16 channel, RequestHandler* rh) = 0;

        virtual void removeRequestHandler(uint16 channel, RequestHandler* rh) = 0;
        virtual void addResponseHandler(uint16 channel, ResponseHandler* rh) = 0;

        virtual void removeResponseHandler(uint16 channel, ResponseHandler* rh) = 0;
        virtual RequestID addRequest(uint16 channel, uint16 requestType, const Any& rData, uint8 retryCount = 0,
            bool forceSynchronous = false, bool idleThread = false) = 0;






        virtual void abortRequest(RequestID id) = 0;







        virtual void abortRequestsByChannel(uint16 channel) = 0;







        virtual void abortPendingRequestsByChannel(uint16 channel) = 0;





        virtual void abortAllRequests() = 0;






        virtual void setPaused(bool pause) = 0;

        virtual bool isPaused() const = 0;





        virtual void setRequestsAccepted(bool accept) = 0;

        virtual bool getRequestsAccepted() const = 0;
        virtual void processResponses() = 0;




        virtual unsigned long getResponseProcessingTimeLimit() const = 0;






        virtual void setResponseProcessingTimeLimit(unsigned long ms) = 0;



        virtual void shutdown() = 0;
        virtual uint16 getChannel(const String& channelName);

    };



    class DefaultWorkQueueBase : public WorkQueue
    {
    public:





        DefaultWorkQueueBase(const String& name = BLANKSTRING);
        virtual ~DefaultWorkQueueBase();

        const String& getName() const;



        virtual size_t getWorkerThreadCount() const;






        virtual void setWorkerThreadCount(size_t c);
        virtual bool getWorkersCanAccessRenderSystem() const;
        virtual void setWorkersCanAccessRenderSystem(bool access);
        virtual void _processNextRequest();


        virtual void _threadMain() = 0;


        virtual bool isShuttingDown() const { return mShuttingDown; }


        virtual void addRequestHandler(uint16 channel, RequestHandler* rh);

        virtual void removeRequestHandler(uint16 channel, RequestHandler* rh);

        virtual void addResponseHandler(uint16 channel, ResponseHandler* rh);

        virtual void removeResponseHandler(uint16 channel, ResponseHandler* rh);


        virtual RequestID addRequest(uint16 channel, uint16 requestType, const Any& rData, uint8 retryCount = 0,
            bool forceSynchronous = false, bool idleThread = false);

        virtual void abortRequest(RequestID id);

        virtual void abortRequestsByChannel(uint16 channel);

        virtual void abortPendingRequestsByChannel(uint16 channel);

        virtual void abortAllRequests();

        virtual void setPaused(bool pause);

        virtual bool isPaused() const;

        virtual void setRequestsAccepted(bool accept);

        virtual bool getRequestsAccepted() const;

        virtual void processResponses();

        virtual unsigned long getResponseProcessingTimeLimit() const { return mResposeTimeLimitMS; }

        virtual void setResponseProcessingTimeLimit(unsigned long ms) { mResposeTimeLimitMS = ms; }
    protected:
        String mName;
        size_t mWorkerThreadCount;
        bool mWorkerRenderSystemAccess;
        bool mIsRunning;
        unsigned long mResposeTimeLimitMS;

        typedef deque<Request*>::type RequestQueue;
        typedef deque<Response*>::type ResponseQueue;
        RequestQueue mRequestQueue;
        RequestQueue mProcessQueue;
        ResponseQueue mResponseQueue;


        struct WorkerFunc
        {
            DefaultWorkQueueBase* mQueue;

            WorkerFunc(DefaultWorkQueueBase* q)
                : mQueue(q) {}

            void operator()();

            void operator()() const;

            void run();
        };
        WorkerFunc* mWorkerFunc;





        class RequestHandlerHolder : public UtilityAlloc
        {
        protected:
                                   ;
            RequestHandler* mHandler;
        public:
            RequestHandlerHolder(RequestHandler* handler)
                : mHandler(handler) {}


            void disconnectHandler()
            {

                                                  ;
                mHandler = 0;
            }




            RequestHandler* getHandler() { return mHandler; }




            Response* handleRequest(const Request* req, const WorkQueue* srcQ)
            {


                                                 ;
                Response* response = 0;
                if (mHandler)
                {
                    if (mHandler->canHandleRequest(req, srcQ))
                    {
                        response = mHandler->handleRequest(req, srcQ);
                    }
                }
                return response;
            }

        };

        typedef SharedPtr<RequestHandlerHolder> RequestHandlerHolderPtr;

        typedef list<RequestHandlerHolderPtr>::type RequestHandlerList;
        typedef list<ResponseHandler*>::type ResponseHandlerList;
        typedef map<uint16, RequestHandlerList>::type RequestHandlerListByChannel;
        typedef map<uint16, ResponseHandlerList>::type ResponseHandlerListByChannel;

        RequestHandlerListByChannel mRequestHandlers;
        ResponseHandlerListByChannel mResponseHandlers;
        RequestID mRequestCount;
        bool mPaused;
        bool mAcceptRequests;
        bool mShuttingDown;





                              ;
                                 ;
                                 ;
                                  ;
                                           ;


        void processRequestResponse(Request* r, bool synchronous);
        Response* processRequest(Request* r);
        void processResponse(Response* r);

        virtual void notifyWorkers() = 0;

        void addRequestWithRID(RequestID rid, uint16 channel, uint16 requestType, const Any& rData, uint8 retryCount);

        RequestQueue mIdleRequestQueue;
        bool mIdleThreadRunning;
        Request* mIdleProcessed;


        bool processIdleRequests();
    };
}



namespace Ogre {
    typedef WorkQueue::RequestID BackgroundProcessTicket;


    struct BackgroundProcessResult
    {

        bool error;

        String message;

        BackgroundProcessResult() : error(false) {}
    };
    class ResourceBackgroundQueue : public Singleton<ResourceBackgroundQueue>, public ResourceAlloc,
        public WorkQueue::RequestHandler, public WorkQueue::ResponseHandler
    {
    public:
        class Listener
        {
        public:






            virtual void operationCompleted(BackgroundProcessTicket ticket, const BackgroundProcessResult& result) = 0;

            virtual ~Listener() {}

        };

    protected:

        uint16 mWorkQueueChannel;

        enum RequestType
        {
            RT_INITIALISE_GROUP = 0,
            RT_INITIALISE_ALL_GROUPS = 1,
            RT_PREPARE_GROUP = 2,
            RT_PREPARE_RESOURCE = 3,
            RT_LOAD_GROUP = 4,
            RT_LOAD_RESOURCE = 5,
            RT_UNLOAD_GROUP = 6,
            RT_UNLOAD_RESOURCE = 7
        };

        struct ResourceRequest
        {
            RequestType type;
            String resourceName;
            ResourceHandle resourceHandle;
            String resourceType;
            String groupName;
            bool isManual;
            ManualResourceLoader* loader;
            NameValuePairList* loadParams;
            Listener* listener;
            BackgroundProcessResult result;

                        friend std::ostream& operator<<(std::ostream& o, const ResourceRequest& r)
            { (void)r; return o; }
        };

        typedef set<BackgroundProcessTicket>::type OutstandingRequestSet;
        OutstandingRequestSet mOutstandingRequestSet;


        struct ResourceResponse
        {
            ResourceResponse(ResourcePtr r, const ResourceRequest& req)
                : resource(r), request(req)
            {}

            ResourcePtr resource;
            ResourceRequest request;

                        friend std::ostream& operator<<(std::ostream& o, const ResourceResponse& r)
            { (void)r; return o; }
        };

        BackgroundProcessTicket addRequest(ResourceRequest& req);

    public:
        ResourceBackgroundQueue();
        virtual ~ResourceBackgroundQueue();




        virtual void initialise(void);




        virtual void shutdown(void);
        virtual BackgroundProcessTicket initialiseResourceGroup(
            const String& name, Listener* listener = 0);
        virtual BackgroundProcessTicket initialiseAllResourceGroups(
            Listener* listener = 0);
        virtual BackgroundProcessTicket prepareResourceGroup(const String& name,
            Listener* listener = 0);
        virtual BackgroundProcessTicket loadResourceGroup(const String& name,
            Listener* listener = 0);
        virtual BackgroundProcessTicket unload(
            const String& resType, const String& name,
            Listener* listener = 0);







        virtual BackgroundProcessTicket unload(
            const String& resType, ResourceHandle handle,
            Listener* listener = 0);







        virtual BackgroundProcessTicket unloadResourceGroup(const String& name,
            Listener* listener = 0);
        virtual BackgroundProcessTicket prepare(
            const String& resType, const String& name,
            const String& group, bool isManual = false,
            ManualResourceLoader* loader = 0,
            const NameValuePairList* loadParams = 0,
            Listener* listener = 0);
        virtual BackgroundProcessTicket load(
            const String& resType, const String& name,
            const String& group, bool isManual = false,
            ManualResourceLoader* loader = 0,
            const NameValuePairList* loadParams = 0,
            Listener* listener = 0);
        virtual bool isProcessComplete(BackgroundProcessTicket ticket);



        void abortRequest( BackgroundProcessTicket ticket );


        bool canHandleRequest(const WorkQueue::Request* req, const WorkQueue* srcQ);

        WorkQueue::Response* handleRequest(const WorkQueue::Request* req, const WorkQueue* srcQ);

        bool canHandleResponse(const WorkQueue::Response* res, const WorkQueue* srcQ);

        void handleResponse(const WorkQueue::Response* res, const WorkQueue* srcQ);
        static ResourceBackgroundQueue& getSingleton(void);
        static ResourceBackgroundQueue* getSingletonPtr(void);

    };




}




namespace Ogre {
namespace v1 {
    class RibbonTrail : public BillboardChain, public Node::Listener
    {
    public:
        RibbonTrail( IdType id, ObjectMemoryManager *objectMemoryManager, SceneManager *manager,
                     size_t maxElements = 20, size_t numberOfChains = 1, bool useTextureCoords = true,
                     bool useVertexColours = true );

        virtual ~RibbonTrail();

        typedef vector<Node*>::type NodeList;
        typedef ConstVectorIterator<NodeList> NodeIterator;




        virtual void addNode(Node* n);

        virtual void removeNode(Node* n);

        virtual NodeIterator getNodeIterator(void) const;

        virtual size_t getChainIndexForNode(const Node* n);







        virtual void setTrailLength(Real len);

        virtual Real getTrailLength(void) const { return mTrailLength; }


        void setMaxChainElements(size_t maxElements);

        void setNumberOfChains(size_t numChains);

        void clearChain(size_t chainIndex);







        virtual void setInitialColour(size_t chainIndex, const ColourValue& col);






        virtual void setInitialColour(size_t chainIndex, Real r, Real g, Real b, Real a = 1.0);

        virtual const ColourValue& getInitialColour(size_t chainIndex) const;





        virtual void setColourChange(size_t chainIndex, const ColourValue& valuePerSecond);





        virtual void setInitialWidth(size_t chainIndex, Real width);

        virtual Real getInitialWidth(size_t chainIndex) const;





        virtual void setWidthChange(size_t chainIndex, Real widthDeltaPerSecond);

        virtual Real getWidthChange(size_t chainIndex) const;





        virtual void setColourChange(size_t chainIndex, Real r, Real g, Real b, Real a);


        virtual const ColourValue& getColourChange(size_t chainIndex) const;


        void nodeUpdated(const Node* node);

        void nodeDestroyed(const Node* node);


        virtual void _timeUpdate(Real time);


        const String& getMovableType(void) const;

    protected:

        NodeList mNodeList;

        typedef vector<size_t>::type IndexVector;

        IndexVector mNodeToChainSegment;

        IndexVector mFreeChains;



        typedef map<const Node*, size_t>::type NodeToChainSegmentMap;
        NodeToChainSegmentMap mNodeToSegMap;


        Real mTrailLength;

        Real mElemLength;

        Real mSquaredElemLength;
        typedef vector<ColourValue>::type ColourValueList;
        typedef vector<Real>::type RealList;

        ColourValueList mInitialColour;

        ColourValueList mDeltaColour;

        RealList mInitialWidth;

        RealList mDeltaWidth;

        Controller<Real>* mFadeController;

        ControllerValueRealPtr mTimeControllerValue;


        virtual void manageController(void);

        virtual void updateTrail(size_t index, const Node* node);

        virtual void resetTrail(size_t index, Node* node);

        virtual void resetAllTrails(void);

    };



    class RibbonTrailFactory : public MovableObjectFactory
    {
    protected:
        virtual MovableObject* createInstanceImpl( IdType id, ObjectMemoryManager *objectMemoryManager,
                                                   SceneManager *manager,
                                                   const NameValuePairList* params = 0 );
    public:
        RibbonTrailFactory() {}
        ~RibbonTrailFactory() {}

        static String FACTORY_TYPE_NAME;

        const String& getType(void) const;
        void destroyInstance( MovableObject* obj);

    };



}
}


namespace Ogre {
    class Ray
    {
    protected:
        Vector3 mOrigin;
        Vector3 mDirection;
    public:
        Ray():mOrigin(Vector3::ZERO), mDirection(Vector3::UNIT_Z) {}
        Ray(const Vector3& origin, const Vector3& direction)
            :mOrigin(origin), mDirection(direction) {}


        void setOrigin(const Vector3& origin) {mOrigin = origin;}

        const Vector3& getOrigin(void) const {return mOrigin;}


        void setDirection(const Vector3& dir) {mDirection = dir;}

        const Vector3& getDirection(void) const {return mDirection;}


        Vector3 getPoint(Real t) const {
            return Vector3(mOrigin + (mDirection * t));
        }


        Vector3 operator*(Real t) const {
            return getPoint(t);
        }







        std::pair<bool, Real> intersects(const Plane& p) const
        {
            return Math::intersects(*this, p);
        }






        std::pair<bool, Real> intersects(const PlaneBoundedVolume& p) const
        {
            return Math::intersects(*this, p.planes, p.outside == Plane::POSITIVE_SIDE);
        }






        std::pair<bool, Real> intersects(const Sphere& s) const
        {
            return Math::intersects(*this, s);
        }






        std::pair<bool, Real> intersects(const AxisAlignedBox& box) const
        {
            return Math::intersects(*this, box);
        }

    };



}

namespace Ogre {
    class SceneQuery : public SceneMgtAlloc
    {
    public:






        enum WorldFragmentType {

            WFT_NONE,

            WFT_PLANE_BOUNDED_REGION,

            WFT_SINGLE_INTERSECTION,

            WFT_CUSTOM_GEOMETRY,

            WFT_RENDER_OPERATION
        };
        struct WorldFragment {

            WorldFragmentType fragmentType;

            Vector3 singleIntersection;

            list<Plane>::type* planes;

            void* geometry;

            v1::RenderOperation* renderOp;

        };
    protected:
        SceneManager* mParentSceneMgr;
        uint32 mQueryMask;
        set<WorldFragmentType>::type mSupportedWorldFragments;
        WorldFragmentType mWorldFragmentType;

    public:
        uint8 mFirstRq;
        uint8 mLastRq;


        SceneQuery(SceneManager* mgr);
        virtual ~SceneQuery();
        virtual void setQueryMask(uint32 mask);

        virtual uint32 getQueryMask(void) const;
        virtual void setWorldFragmentType(enum WorldFragmentType wft);


        virtual WorldFragmentType getWorldFragmentType(void) const;


        virtual const set<WorldFragmentType>::type* getSupportedWorldFragmentTypes(void) const
            {return &mSupportedWorldFragments;}


    };







    class SceneQueryListener
    {
    public:
        virtual ~SceneQueryListener() { }





        virtual bool queryResult(MovableObject* object) = 0;





        virtual bool queryResult(SceneQuery::WorldFragment* fragment) = 0;

    };

    typedef list<MovableObject*>::type SceneQueryResultMovableList;
    typedef list<SceneQuery::WorldFragment*>::type SceneQueryResultWorldFragmentList;

    struct SceneQueryResult : public SceneMgtAlloc
    {

        SceneQueryResultMovableList movables;

        SceneQueryResultWorldFragmentList worldFragments;
    };







    class RegionSceneQuery
        : public SceneQuery, public SceneQueryListener
    {
    protected:
        SceneQueryResult* mLastResult;
    public:

        RegionSceneQuery(SceneManager* mgr);
        virtual ~RegionSceneQuery();
        virtual SceneQueryResult& execute(void);
        virtual void execute(SceneQueryListener* listener) = 0;




        virtual SceneQueryResult& getLastResults(void) const;






        virtual void clearResults(void);


        bool queryResult(MovableObject* first);

        bool queryResult(SceneQuery::WorldFragment* fragment);
    };


    class AxisAlignedBoxSceneQuery : public RegionSceneQuery
    {
    protected:
        AxisAlignedBox mAABB;
    public:
        AxisAlignedBoxSceneQuery(SceneManager* mgr);
        virtual ~AxisAlignedBoxSceneQuery();


        void setBox(const AxisAlignedBox& box);


        const AxisAlignedBox& getBox(void) const;

    };


    class SphereSceneQuery : public RegionSceneQuery
    {
    protected:
        Sphere mSphere;
    public:
        SphereSceneQuery(SceneManager* mgr);
        virtual ~SphereSceneQuery();

        void setSphere(const Sphere& sphere);


        const Sphere& getSphere() const;

    };



    class PlaneBoundedVolumeListSceneQuery : public RegionSceneQuery
    {
    protected:
        PlaneBoundedVolumeList mVolumes;
    public:
        PlaneBoundedVolumeListSceneQuery(SceneManager* mgr);
        virtual ~PlaneBoundedVolumeListSceneQuery();

        void setVolumes(const PlaneBoundedVolumeList& volumes);


        const PlaneBoundedVolumeList& getVolumes() const;

    };
    class RaySceneQueryListener
    {
    public:
        virtual ~RaySceneQueryListener() { }






        virtual bool queryResult(MovableObject* obj, Real distance) = 0;







        virtual bool queryResult(SceneQuery::WorldFragment* fragment, Real distance) = 0;

    };


    struct RaySceneQueryResultEntry
    {

        Real distance;

        MovableObject* movable;

        SceneQuery::WorldFragment* worldFragment;

        bool operator < (const RaySceneQueryResultEntry& rhs) const
        {
            return this->distance < rhs.distance;
        }

    };
    typedef vector<RaySceneQueryResultEntry>::type RaySceneQueryResult;


    class RaySceneQuery : public SceneQuery, public RaySceneQueryListener
    {
    protected:
        Ray mRay;
        bool mSortByDistance;
        ushort mMaxResults;
        RaySceneQueryResult mResult;

    public:
        RaySceneQuery(SceneManager* mgr);
        virtual ~RaySceneQuery();

        virtual void setRay(const Ray& ray);

        virtual const Ray& getRay(void) const;
        virtual void setSortByDistance(bool sort, ushort maxresults = 0);

        virtual bool getSortByDistance(void) const;


        virtual ushort getMaxResults(void) const;
        virtual RaySceneQueryResult& execute(void);
        virtual void execute(RaySceneQueryListener* listener) = 0;




        virtual RaySceneQueryResult& getLastResults(void);






        virtual void clearResults(void);


        bool queryResult(MovableObject* obj, Real distance);

        bool queryResult(SceneQuery::WorldFragment* fragment, Real distance);




    };






    class IntersectionSceneQueryListener
    {
    public:
        virtual ~IntersectionSceneQueryListener() { }






        virtual bool queryResult(MovableObject* first, MovableObject* second) = 0;







        virtual bool queryResult(MovableObject* movable, SceneQuery::WorldFragment* fragment) = 0;






    };

    typedef std::pair<MovableObject*, MovableObject*> SceneQueryMovableObjectPair;
    typedef std::pair<MovableObject*, SceneQuery::WorldFragment*> SceneQueryMovableObjectWorldFragmentPair;
    typedef list<SceneQueryMovableObjectPair>::type SceneQueryMovableIntersectionList;
    typedef list<SceneQueryMovableObjectWorldFragmentPair>::type SceneQueryMovableWorldFragmentIntersectionList;

    struct IntersectionSceneQueryResult : public SceneMgtAlloc
    {

        SceneQueryMovableIntersectionList movables2movables;

        SceneQueryMovableWorldFragmentIntersectionList movables2world;



    };
    class IntersectionSceneQuery
        : public SceneQuery, public IntersectionSceneQueryListener
    {
    protected:
        IntersectionSceneQueryResult* mLastResult;
    public:
        IntersectionSceneQuery(SceneManager* mgr);
        virtual ~IntersectionSceneQuery();
        virtual IntersectionSceneQueryResult& execute(void);
        virtual void execute(IntersectionSceneQueryListener* listener) = 0;




        virtual IntersectionSceneQueryResult& getLastResults(void) const;






        virtual void clearResults(void);


        bool queryResult(MovableObject* first, MovableObject* second);

        bool queryResult(MovableObject* movable, SceneQuery::WorldFragment* fragment);
    };




}


namespace Ogre {


    class CompositorShadowNode;
    class AutoParamDataSource : public SceneMgtAlignedAlloc
    {
    protected:
        const Light& getLight(size_t index) const;
        mutable Matrix4 mWorldMatrix[256] __attribute__((__aligned__(16)));
        mutable size_t mWorldMatrixCount;
        mutable const Matrix4* mWorldMatrixArray;
        mutable Matrix4 mWorldViewMatrix;
        mutable Matrix4 mViewProjMatrix;
        mutable Matrix4 mWorldViewProjMatrix;
        mutable Matrix4 mInverseWorldMatrix;
        mutable Matrix4 mInverseWorldViewMatrix;
        mutable Matrix4 mInverseViewMatrix;
        mutable Matrix4 mInverseTransposeWorldMatrix;
        mutable Matrix4 mInverseTransposeWorldViewMatrix;
        mutable Vector4 mCameraPosition;
        mutable Vector4 mCameraPositionObjectSpace;
        mutable Matrix4 mTextureViewProjMatrix[8];
        mutable Matrix4 mTextureWorldViewProjMatrix[8];
        mutable Matrix4 mSpotlightViewProjMatrix[8];
        mutable Matrix4 mSpotlightWorldViewProjMatrix[8];
        mutable Vector4 mShadowCamDepthRanges[8];
        mutable Matrix4 mViewMatrix;
        mutable Matrix4 mProjectionMatrix;
        mutable Real mDirLightExtrusionDistance;
        mutable Vector4 mLodCameraPosition;
        mutable Vector4 mLodCameraPositionObjectSpace;

        mutable bool mWorldMatrixDirty;
        mutable bool mViewMatrixDirty;
        mutable bool mProjMatrixDirty;
        mutable bool mWorldViewMatrixDirty;
        mutable bool mViewProjMatrixDirty;
        mutable bool mWorldViewProjMatrixDirty;
        mutable bool mInverseWorldMatrixDirty;
        mutable bool mInverseWorldViewMatrixDirty;
        mutable bool mInverseViewMatrixDirty;
        mutable bool mInverseTransposeWorldMatrixDirty;
        mutable bool mInverseTransposeWorldViewMatrixDirty;
        mutable bool mCameraPositionDirty;
        mutable bool mCameraPositionObjectSpaceDirty;
        mutable bool mTextureViewProjMatrixDirty[8];
        mutable bool mTextureWorldViewProjMatrixDirty[8];
        mutable bool mSpotlightViewProjMatrixDirty[8];
        mutable bool mSpotlightWorldViewProjMatrixDirty[8];
        mutable bool mShadowCamDepthRangesDirty[8];
        mutable ColourValue mAmbientLight[2];
        mutable Vector3 mAmbientLightHemisphereDir;
        mutable ColourValue mFogColour;
        mutable Vector4 mFogParams;
        mutable int mPassNumber;
        mutable Vector4 mSceneDepthRange;
        mutable bool mSceneDepthRangeDirty;
        mutable bool mLodCameraPositionDirty;
        mutable bool mLodCameraPositionObjectSpaceDirty;

        const Renderable* mCurrentRenderable;
        const Camera* mCurrentCamera;
        const LightList* mCurrentLightList;
        const Frustum* mCurrentTextureProjector[8];
        const RenderTarget* mCurrentRenderTarget;
        const Viewport* mCurrentViewport;
        const SceneManager* mCurrentSceneManager;
        const Pass* mCurrentPass;
        const CompositorShadowNode *mCurrentShadowNode;
        vector<Real>::type mNullPssmSplitPoint;

        ObjectMemoryManager mObjectMemoryManager;
        NodeMemoryManager *mNodeMemoryManager;
        SceneNode *mBlankLightNode;
        Light mBlankLight;
    public:
        AutoParamDataSource();
        virtual ~AutoParamDataSource();

         void setCurrentRenderable(const Renderable* rend);

         void setWorldMatrices(const Matrix4* m, size_t count);

         void setCurrentCamera(const Camera* cam);

         void setCurrentLightList(const LightList* ll);

         void setTextureProjector(const Frustum* frust, size_t index);

         void setCurrentViewport(const Viewport* viewport);

         void setShadowDirLightExtrusionDistance(Real dist);

         void setCurrentSceneManager(const SceneManager* sm);

         void setCurrentPass(const Pass* pass);
         void setCurrentShadowNode(const CompositorShadowNode *sn);

         const Camera* getCurrentCamera() const;


         const Matrix4& getWorldMatrix(void) const;
         const Matrix4* getWorldMatrixArray(void) const;
         size_t getWorldMatrixCount(void) const;
         const Matrix4& getViewMatrix(void) const;
         const Matrix4& getViewProjectionMatrix(void) const;
         const Matrix4& getProjectionMatrix(void) const;
         const Matrix4& getWorldViewProjMatrix(void) const;
         const Matrix4& getWorldViewMatrix(void) const;
         const Matrix4& getInverseWorldMatrix(void) const;
         const Matrix4& getInverseWorldViewMatrix(void) const;
         const Matrix4& getInverseViewMatrix(void) const;
         const Matrix4& getInverseTransposeWorldMatrix(void) const;
         const Matrix4& getInverseTransposeWorldViewMatrix(void) const;
         const Vector4& getCameraPosition(void) const;
         const Vector4& getCameraPositionObjectSpace(void) const;
         const Vector4& getLodCameraPosition(void) const;
         const Vector4& getLodCameraPositionObjectSpace(void) const;
         bool hasLightList() const { return mCurrentLightList != 0; }
         float getLightCount() const;
         float getLightCastsShadows(size_t index) const;
         const ColourValue& getLightDiffuseColour(size_t index) const;
         const ColourValue& getLightSpecularColour(size_t index) const;
         const ColourValue getLightDiffuseColourWithPower(size_t index) const;
         const ColourValue getLightSpecularColourWithPower(size_t index) const;
         Vector3 getLightPosition(size_t index) const;
         Vector4 getLightAs4DVector(size_t index) const;
         Vector3 getLightDirection(size_t index) const;
         Real getLightPowerScale(size_t index) const;
         Vector4 getLightAttenuation(size_t index) const;
         Vector4 getSpotlightParams(size_t index) const;
         void setAmbientLightColour( const ColourValue hemispheres[2],
                                     const Vector3 &hemisphereDir );
         const ColourValue& getAmbientLightColour(void) const;
         const ColourValue& getSurfaceAmbientColour(void) const;
         const ColourValue& getSurfaceDiffuseColour(void) const;
         const ColourValue& getSurfaceSpecularColour(void) const;
         const ColourValue& getSurfaceEmissiveColour(void) const;
         Real getSurfaceShininess(void) const;
         Real getSurfaceAlphaRejectionValue(void) const;
         ColourValue getDerivedAmbientLightColour(void) const;
         ColourValue getDerivedSceneColour(void) const;
         void setFog(FogMode mode, const ColourValue& colour, Real expDensity, Real linearStart, Real linearEnd);
         const ColourValue& getFogColour(void) const;
         const Vector4& getFogParams(void) const;
         const Matrix4& getTextureViewProjMatrix(size_t index) const;
         const Matrix4& getTextureWorldViewProjMatrix(size_t index) const;
         const Matrix4& getSpotlightViewProjMatrix(size_t index) const;
         const Matrix4& getSpotlightWorldViewProjMatrix(size_t index) const;
         const Matrix4& getTextureTransformMatrix(size_t index) const;
         const vector<Real>::type& getPssmSplits( size_t shadowMapIdx ) const;
         const RenderTarget* getCurrentRenderTarget(void) const;
         const Renderable* getCurrentRenderable(void) const;
         const Pass* getCurrentPass(void) const;
         Vector4 getTextureSize(size_t index) const;
         Vector4 getInverseTextureSize(size_t index) const;
         Vector4 getPackedTextureSize(size_t index) const;
         Real getShadowExtrusionDistance(void) const;
         const Vector4& getSceneDepthRange() const;
         const Vector4& getShadowSceneDepthRange(size_t index) const;
         const ColourValue& getShadowColour() const;
         Matrix4 getInverseViewProjMatrix(void) const;
         Matrix4 getInverseTransposeViewProjMatrix() const;
         Matrix4 getTransposeViewProjMatrix() const;
         Matrix4 getTransposeViewMatrix() const;
         Matrix4 getInverseTransposeViewMatrix() const;
         Matrix4 getTransposeProjectionMatrix() const;
         Matrix4 getInverseProjectionMatrix() const;
         Matrix4 getInverseTransposeProjectionMatrix() const;
         Matrix4 getTransposeWorldViewProjMatrix() const;
         Matrix4 getInverseWorldViewProjMatrix() const;
         Matrix4 getInverseTransposeWorldViewProjMatrix() const;
         Matrix4 getTransposeWorldViewMatrix() const;
         Matrix4 getTransposeWorldMatrix() const;
         Real getTime(void) const;
         Real getTime_0_X(Real x) const;
         Real getCosTime_0_X(Real x) const;
         Real getSinTime_0_X(Real x) const;
         Real getTanTime_0_X(Real x) const;
         Vector4 getTime_0_X_packed(Real x) const;
         Real getTime_0_1(Real x) const;
         Real getCosTime_0_1(Real x) const;
         Real getSinTime_0_1(Real x) const;
         Real getTanTime_0_1(Real x) const;
         Vector4 getTime_0_1_packed(Real x) const;
         Real getTime_0_2Pi(Real x) const;
         Real getCosTime_0_2Pi(Real x) const;
         Real getSinTime_0_2Pi(Real x) const;
         Real getTanTime_0_2Pi(Real x) const;
         Vector4 getTime_0_2Pi_packed(Real x) const;
         Real getFrameTime(void) const;
         Real getFPS() const;
         Real getViewportWidth() const;
         Real getViewportHeight() const;
         Real getInverseViewportWidth() const;
         Real getInverseViewportHeight() const;
         Vector3 getViewDirection() const;
         Vector3 getViewSideVector() const;
         Vector3 getViewUpVector() const;
         Real getFOV() const;
         Real getNearClipDistance() const;
         Real getFarClipDistance() const;
         int getPassNumber(void) const;
         void setPassNumber(const int passNumber);
         void incPassNumber(void);
         void updateLightCustomGpuParameter(const GpuProgramParameters::AutoConstantEntry& constantEntry, GpuProgramParameters *params) const;

   const Light& _getBlankLight(void) const { return mBlankLight; }
    };


}




namespace Ogre
{






    typedef vector<TexturePtr>::type ShadowTextureList;


    struct ShadowTextureConfig
    {
        unsigned int width;
        unsigned int height;
        PixelFormat format;
        unsigned int fsaa;
        uint16 depthBufferPoolId;

        ShadowTextureConfig()
            : width(512), height(512), format(PF_X8R8G8B8), fsaa(0), depthBufferPoolId(1) {}
    };

    typedef vector<ShadowTextureConfig>::type ShadowTextureConfigList;
    typedef ConstVectorIterator<ShadowTextureConfigList> ConstShadowTextureConfigIterator;

    inline bool operator== ( const ShadowTextureConfig& lhs, const ShadowTextureConfig& rhs );
    inline bool operator!= ( const ShadowTextureConfig& lhs, const ShadowTextureConfig& rhs );
    class ShadowTextureManager : public Singleton<ShadowTextureManager>, public ShadowDataAlloc
    {
    protected:
        ShadowTextureList mTextureList;
        ShadowTextureList mNullTextureList;
        size_t mCount;

    public:
        ShadowTextureManager();
        virtual ~ShadowTextureManager();




        virtual void getShadowTextures(const ShadowTextureConfigList& config,
            ShadowTextureList& listToPopulate);



        virtual void getAllShadowTextures(ShadowTextureList& listToPopulate) { listToPopulate = mTextureList; }




        virtual TexturePtr getNullShadowTexture(PixelFormat format);






        virtual void clearUnused();




        virtual void clear();
        static ShadowTextureManager& getSingleton(void);
        static ShadowTextureManager* getSingletonPtr(void);

    };



}




namespace Ogre {
    struct MovableObjectLodChangedEvent
    {

        MovableObject *movableObject;


        Camera *camera;
    };


    struct EntityMeshLodChangedEvent
    {

        v1::Entity *entity;


        Camera *camera;


        Real lodValue;


        ushort previousLodIndex;


        ushort newLodIndex;
    };


    struct EntityMaterialLodChangedEvent
    {

        v1::SubEntity *subEntity;


        Camera *camera;


        Real lodValue;


        ushort previousLodIndex;


        ushort newLodIndex;
    };
    class LodListener
    {
    public:

        virtual ~LodListener() {}
        virtual bool prequeueMovableObjectLodChanged(const MovableObjectLodChangedEvent& evt)
        { (void)evt; return false; }







        virtual void postqueueMovableObjectLodChanged(const MovableObjectLodChangedEvent& evt)
        { (void)evt; }
        virtual bool prequeueEntityMeshLodChanged(EntityMeshLodChangedEvent& evt)
        { (void)evt; return false; }







        virtual void postqueueEntityMeshLodChanged(const EntityMeshLodChangedEvent& evt)
        { (void)evt; }
        virtual bool prequeueEntityMaterialLodChanged(EntityMaterialLodChangedEvent& evt)
        { (void)evt; return false; }







        virtual void postqueueEntityMaterialLodChanged(const EntityMaterialLodChangedEvent& evt)
        { (void)evt; }

    };


}
namespace Ogre
{
    class IndexBufferPacked : public BufferPacked
    {
    public:
        enum IndexType
        {
            IT_16BIT,
            IT_32BIT
        };

        IndexBufferPacked( size_t internalBufferStartBytes, size_t numElements, uint32 bytesPerElement,
                           BufferType bufferType, void *initialData, bool keepAsShadow,
                           VaoManager *vaoManager, BufferInterface *bufferInterface ) :
            BufferPacked( internalBufferStartBytes, numElements, bytesPerElement, bufferType,
                          initialData, keepAsShadow, vaoManager, bufferInterface )
        {
        }

        virtual BufferPackedTypes getBufferPackedType(void) const { return BP_TYPE_INDEX; }

        IndexType getIndexType(void) const { return mBytesPerElement == 2 ? IT_16BIT : IT_32BIT; }
    };
}



namespace Ogre
{
    typedef vector<StagingBuffer*>::type StagingBufferVec;
    typedef unordered_set<VertexArrayObject*>::type VertexArrayObjectSet;

    class VaoManager : public RenderSysAlloc
    {
    protected:
        Timer *mTimer;


        uint32 mDefaultStagingBufferUnfencedTime;
        uint32 mDefaultStagingBufferLifetime;


        StagingBufferVec mRefedStagingBuffers[2];
        StagingBufferVec mZeroRefStagingBuffers[2];

        bool mSupportsPersistentMapping;
        bool mSupportsIndirectBuffers;
        uint8 mDynamicBufferMultiplier;
        uint8 mDynamicBufferCurrentFrame;
        unsigned long mNextStagingBufferTimestampCheckpoint;
        uint32 mFrameCount;

        BufferPackedSet mBuffers[NUM_BUFFER_PACKED_TYPES];
        VertexArrayObjectSet mVertexArrayObjects;
        uint32 mNumGeneratedVaos;

        struct DelayedBuffer
        {
            BufferPacked *bufferPacked;
            uint32 frame;
            uint8 frameNumDynamic;

            DelayedBuffer( BufferPacked *_bufferPacked, uint32 _frame, uint8 _frameNumDynamic ) :
                bufferPacked( _bufferPacked ), frame( _frame ), frameNumDynamic( _frameNumDynamic ) {}
        };

        typedef vector<DelayedBuffer>::type DelayedBufferVec;
        DelayedBufferVec mDelayedDestroyBuffers;

        uint32 mConstBufferAlignment;
        uint32 mTexBufferAlignment;
        size_t mConstBufferMaxSize;
        size_t mTexBufferMaxSize;

        virtual VertexBufferPacked* createVertexBufferImpl( size_t numElements,
                                                            uint32 bytesPerElement,
                                                            BufferType bufferType,
                                                            void *initialData, bool keepAsShadow,
                                                            const VertexElement2Vec &vertexElements )
                                                            = 0;

        virtual void destroyVertexBufferImpl( VertexBufferPacked *vertexBuffer ) = 0;

        virtual MultiSourceVertexBufferPool* createMultiSourceVertexBufferPoolImpl(
                                                    const VertexElement2VecVec &vertexElementsBySource,
                                                    size_t maxNumVertices, size_t totalBytesPerVertex,
                                                    BufferType bufferType ) = 0;

        virtual IndexBufferPacked* createIndexBufferImpl( size_t numElements,
                                                          uint32 bytesPerElement,
                                                          BufferType bufferType,
                                                          void *initialData, bool keepAsShadow ) = 0;

        virtual void destroyIndexBufferImpl( IndexBufferPacked *indexBuffer ) = 0;

        virtual ConstBufferPacked* createConstBufferImpl( size_t sizeBytes, BufferType bufferType,
                                                          void *initialData, bool keepAsShadow ) = 0;
        virtual void destroyConstBufferImpl( ConstBufferPacked *constBuffer ) = 0;

        virtual TexBufferPacked* createTexBufferImpl( PixelFormat pixelFormat, size_t sizeBytes,
                                                      BufferType bufferType,
                                                      void *initialData, bool keepAsShadow ) = 0;
        virtual void destroyTexBufferImpl( TexBufferPacked *texBuffer ) = 0;

        virtual IndirectBufferPacked* createIndirectBufferImpl( size_t sizeBytes,
                                                                BufferType bufferType,
                                                                void *initialData,
                                                                bool keepAsShadow ) = 0;
        virtual void destroyIndirectBufferImpl( IndirectBufferPacked *indirectBuffer ) = 0;

        virtual VertexArrayObject* createVertexArrayObjectImpl( const VertexBufferPackedVec &vertexBuffers,
                                                                IndexBufferPacked *indexBuffer,
                                                                v1::RenderOperation::OperationType opType ) = 0;

        virtual void destroyVertexArrayObjectImpl( VertexArrayObject *vao ) = 0;





        void destroyAllVertexArrayObjects(void);



        void deleteAllBuffers(void);






        void destroyDelayedBuffers( uint8 fromDynamicFrame );

        inline void callDestroyBufferImpl( BufferPacked *bufferPacked );

    public:
        VaoManager();
        virtual ~VaoManager();


        static uint32 calculateVertexSize( const VertexElement2Vec &vertexElements );
        VertexBufferPacked* createVertexBuffer( const VertexElement2Vec &vertexElements,
                                                size_t numVertices, BufferType bufferType,
                                                void *initialData, bool keepAsShadow );

        MultiSourceVertexBufferPool* createMultiSourceVertexBufferPool(
                                const VertexElement2VecVec &vertexElementsBySource,
                                size_t maxNumVertices, BufferType bufferType );







        void destroyVertexBuffer( VertexBufferPacked *vertexBuffer );
        IndexBufferPacked* createIndexBuffer( IndexBufferPacked::IndexType indexType,
                                              size_t numIndices, BufferType bufferType,
                                              void *initialData, bool keepAsShadow );





        void destroyIndexBuffer( IndexBufferPacked *indexBuffer );
        ConstBufferPacked* createConstBuffer( size_t sizeBytes, BufferType bufferType,
                                              void *initialData, bool keepAsShadow );





        void destroyConstBuffer( ConstBufferPacked *constBuffer );
        TexBufferPacked* createTexBuffer( PixelFormat pixelFormat, size_t sizeBytes,
                                          BufferType bufferType,
                                          void *initialData, bool keepAsShadow );





        void destroyTexBuffer( TexBufferPacked *texBuffer );





        IndirectBufferPacked* createIndirectBuffer( size_t sizeBytes, BufferType bufferType,
                                                    void *initialData, bool keepAsShadow );





        void destroyIndirectBuffer( IndirectBufferPacked *indirectBuffer );
        VertexArrayObject* createVertexArrayObject( const VertexBufferPackedVec &vertexBuffers,
                                                    IndexBufferPacked *indexBuffer,
                                                    v1::RenderOperation::OperationType opType );
        void destroyVertexArrayObject( VertexArrayObject *vao );






        virtual StagingBuffer* createStagingBuffer( size_t sizeBytes, bool forUpload ) = 0;
        StagingBuffer* getStagingBuffer( size_t minSizeBytes, bool forUpload );

        virtual AsyncTicketPtr createAsyncTicket( BufferPacked *creator, StagingBuffer *stagingBuffer,
                                                  size_t elementStart, size_t elementCount ) = 0;

        virtual void _beginFrame(void) {}
        virtual void _update(void);

        void _notifyStagingBufferEnteredZeroRef( StagingBuffer *stagingBuffer );
        void _notifyStagingBufferLeftZeroRef( StagingBuffer *stagingBuffer );

        uint32 getConstBufferAlignment(void) const { return mConstBufferAlignment; }
        uint32 getTexBufferAlignment(void) const { return mTexBufferAlignment; }
        size_t getConstBufferMaxSize(void) const { return mConstBufferMaxSize; }
        size_t getTexBufferMaxSize(void) const { return mTexBufferMaxSize; }

        bool supportsPersistentMapping(void) const { return mSupportsPersistentMapping; }



        bool supportsIndirectBuffers(void) const { return mSupportsIndirectBuffers; }

        Timer* getTimer(void) { return mTimer; }

        uint32 getFrameCount(void) { return mFrameCount; }
        void setDefaultStagingBufferlifetime( uint32 lifetime, uint32 unfencedTime );

        uint32 getDefaultStagingBufferUnfencedTime(void) const
                                            { return mDefaultStagingBufferUnfencedTime; }
        uint32 getDefaultStagingBufferLifetime(void) const
                                            { return mDefaultStagingBufferLifetime; }

        uint8 _getDynamicBufferCurrentFrameNoWait(void) const { return mDynamicBufferCurrentFrame; }
        uint8 getDynamicBufferMultiplier(void) const { return mDynamicBufferMultiplier; }




        virtual uint8 waitForTailFrameToFinish(void) = 0;
    };
}
namespace Ogre
{
    typedef vector<VertexBufferPacked*>::type VertexBufferPackedVec;




    typedef map<VertexBufferPacked*, VertexBufferPacked*>::type SharedVertexBufferMap;
    struct VertexArrayObject : public VertexArrayObjectAlloc
    {
        friend class RenderQueue;
        friend class RenderSystem;
        friend class D3D11RenderSystem;
        friend class GL3PlusRenderSystem;

    protected:




        uint32 mVaoName;




        uint32 mRenderQueueId;

        uint32 mPrimStart;
        uint32 mPrimCount;
        VertexBufferPackedVec mVertexBuffers;
        IndexBufferPacked *mIndexBuffer;

        VertexBufferPacked *mBaseVertexBuffer;


        v1::RenderOperation::OperationType mOperationType;

    public:
        VertexArrayObject( uint32 vaoName, uint32 renderQueueId,
                           const VertexBufferPackedVec &vertexBuffers,
                           IndexBufferPacked *indexBuffer,
                           v1::RenderOperation::OperationType operationType );

        uint32 getRenderQueueId(void) const { return mRenderQueueId; }
        uint32 getVaoName(void) const { return mVaoName; }

        const VertexBufferPackedVec& getVertexBuffers(void) const { return mVertexBuffers; }
        IndexBufferPacked* getIndexBuffer(void) const { return mIndexBuffer; }

        v1::RenderOperation::OperationType getOperationType(void) const { return mOperationType; }

        uint32 getPrimitiveStart(void) const { return mPrimStart; }
        uint32 getPrimitiveCount(void) const { return mPrimCount; }
        void setPrimitiveRange( uint32 primStart, uint32 primCount );
        const VertexElement2* findBySemantic( VertexElementSemantic semantic, size_t &outIndex,
                                              size_t &outOffset ) const;




        VertexElement2VecVec getVertexDeclaration(void) const;
        VertexArrayObject* clone( VaoManager *vaoManager, SharedVertexBufferMap *sharedBuffers,
                                  int vertexBufferType = -1, int indexBufferType = -1 ) const;

        struct ReadRequests
        {
            VertexElementSemantic semantic;
            VertexElementType type;
            AsyncTicketPtr asyncTicket;

            char const *data;
            size_t offset;
            VertexBufferPacked const *vertexBuffer;

            ReadRequests( VertexElementSemantic _semantic ) :
                semantic( _semantic ), type(VET_FLOAT1), data( 0 ), offset( 0 ), vertexBuffer( 0 ) {}
        };

        typedef FastArray<ReadRequests> ReadRequestsArray;
        void readRequests( ReadRequestsArray &requests );


        static void mapAsyncTickets( ReadRequestsArray &tickets );


        static void unmapAsyncTickets( ReadRequestsArray &tickets );



        static VertexBufferPacked msDummyVertexBuffer;
    };
}

namespace Ogre
{
    class ManualObject : public MovableObject
    {
    public:
        class ManualObjectSection;

        ManualObject( IdType id, ObjectMemoryManager *objectMemoryManager, SceneManager *manager );
        virtual ~ManualObject();
                   void clear(void);






                   void estimateVertexCount(size_t vcount);






                   void estimateIndexCount(size_t icount);
                   void begin(const String& datablockName,
                           v1::RenderOperation::OperationType opType = v1::RenderOperation::OT_TRIANGLE_LIST);
                   void beginUpdate(size_t sectionIndex);







                   void position(const Vector3& pos);

                   void position(Real x, Real y, Real z);






                   void normal(const Vector3& norm);

                   void normal(Real x, Real y, Real z);
                   void tangent(const Vector3& tan);

                   void tangent(Real x, Real y, Real z);
                   void textureCoord(Real u);

                   void textureCoord(Real u, Real v);

                   void textureCoord(Real u, Real v, Real w);

                   void textureCoord(Real x, Real y, Real z, Real w);

                   void textureCoord(const Vector2& uv);

                   void textureCoord(const Vector3& uvw);

                   void textureCoord(const Vector4& xyzw);



                   void colour(const ColourValue& col);



                   void colour(Real r, Real g, Real b, Real a = 1.0f);



                   void specular(const ColourValue& col);



                   void specular(Real r, Real g, Real b, Real a = 1.0f);
                   void index(uint32 idx);
                   void line(uint32 i1, uint32 i2);
                   void triangle(uint32 i1, uint32 i2, uint32 i3);
                   void quad(uint32 i1, uint32 i2, uint32 i3, uint32 i4);


                   size_t getCurrentVertexCount() const;


                   size_t getCurrentIndexCount() const;





                   ManualObjectSection* end(void);
        void setDatablock(size_t subIndex, const String& name);



        ManualObjectSection* getSection(unsigned int index) const;



        ManualObjectSection* getSection(const Ogre::String & name) const;



        unsigned int getNumSections(void) const;




        void removeSection(unsigned int idx);




        size_t currentIndexCount();




        size_t currentVertexCount();



        const String& getMovableType(void) const;


        class ManualObjectSection : public Renderable, public MovableAlloc
        {
        protected:
            ManualObject* mParent;
            Aabb mAabb;
            VertexArrayObject * mVao;
            VaoManager * mVaoManager;
            v1::RenderOperation::OperationType mOperationType;
            VertexElement2Vec mVertexElements;
            bool m32BitIndices;
            Ogre::String mName;

            void clear();

        public:
            friend class ManualObject;

            ManualObjectSection(ManualObject* parent, const String& datablockName, v1::RenderOperation::OperationType opType);
            virtual ~ManualObjectSection();



            virtual void getRenderOperation(v1::RenderOperation& op, bool casterPass) override;

            virtual void getWorldTransforms(Matrix4* xform) const override;

            virtual const LightList &getLights(void) const override;

            virtual bool getCastsShadows(void) const;



            void setName(const Ogre::String & name);




            const Ogre::String & getName();
        };

        typedef vector<ManualObjectSection*>::type SectionList;


    protected:

        SectionList mSectionList;

        ManualObjectSection* mCurrentSection;


        bool mCurrentUpdating;
        String mCurrentDatablockName;

        size_t mVertices;
        size_t mIndices;

        size_t mEstimatedVertices;
        size_t mEstimatedIndices;


        float * mTempVertexBuffer;
        size_t mTempVertexBufferSize;

        char * mTempIndexBuffer;
        size_t mTempIndexBufferSize;


        float * mVertexBuffer;
        char * mIndexBuffer;
        float * mVertexBufferCursor;
        char * mIndexBufferCursor;


        size_t mDeclSize;


        void resetBuffers(void);

        void resizeVertexBufferIfNeeded(size_t numVerts);

        void resizeIndexBufferIfNeeded(size_t numInds);
    };



    class ManualObjectFactory : public MovableObjectFactory
    {
    protected:
        virtual MovableObject* createInstanceImpl( IdType id, ObjectMemoryManager *objectMemoryManager,
                                                   SceneManager *manager,
                                                   const NameValuePairList* params = 0 );
    public:
        ManualObjectFactory() {}
        ~ManualObjectFactory() {}

        static String FACTORY_TYPE_NAME;

        const String& getType(void) const;
        void destroyInstance( MovableObject* obj);

    };


}



namespace Ogre
{
    enum SceneMemoryMgrTypes;
    class NodeMemoryManager : ArrayMemoryManager::RebaseListener
    {
        typedef vector<NodeArrayMemoryManager>::type ArrayMemoryManagerVec;

        ArrayMemoryManagerVec mMemoryManagers;


        SceneNode *mDummyNode;
        Transform mDummyTransformPtrs;





        SceneMemoryMgrTypes mMemoryManagerType;
        NodeMemoryManager *mTwinMemoryManager;





        void growToDepth( size_t newDepth );

    public:
        NodeMemoryManager();
        virtual ~NodeMemoryManager();


        void _setTwin( SceneMemoryMgrTypes memoryManagerType, NodeMemoryManager *twinMemoryManager );

        SceneNode* _getDummyNode(void) const { return mDummyNode; }


        NodeMemoryManager* getTwin() const { return mTwinMemoryManager; }
        SceneMemoryMgrTypes getMemoryManagerType() const { return mMemoryManagerType; }







        void nodeCreated( Transform &outTransform, size_t depth );
        void nodeAttached( Transform &outTransform, size_t depth );
        void nodeDettached( Transform &outTransform, size_t depth );







        void nodeDestroyed( Transform &outTransform, size_t depth );
        void nodeMoved( Transform &inOutTransform, size_t oldDepth, size_t newDepth );
        void migrateTo( Transform &inOutTransform, size_t depth,
                        NodeMemoryManager *dstNodeMemoryManager );
        void migrateTo( Transform &inOutTransform, size_t oldDepth, size_t newDepth,
                        NodeMemoryManager *dstNodeMemoryManager );






        void migrateToAndAttach( Transform &inOutTransform, size_t depth,
                                 NodeMemoryManager *dstNodeMemoryManager );







        void migrateToAndDetach( Transform &inOutTransform, size_t depth,
                                 NodeMemoryManager *dstNodeMemoryManager );






        size_t getNumDepths() const;
        size_t getFirstNode( Transform &outTransform, size_t depth );


        virtual void buildDiffList( ArrayMemoryManager::ManagerType managerType, uint16 level,
                                    const MemoryPoolVec &basePtrs,
                                    ArrayMemoryManager::PtrdiffVec &outDiffsList );
        virtual void applyRebase( ArrayMemoryManager::ManagerType managerType, uint16 level,
                                    const MemoryPoolVec &newBasePtrs,
                                    const ArrayMemoryManager::PtrdiffVec &diffsList );
        virtual void performCleanup( ArrayMemoryManager::ManagerType managerType, uint16 level,
                                     const MemoryPoolVec &basePtrs, size_t const *elementsMemSizes,
                                     size_t startInstance, size_t diffInstances );
    };



}

namespace Ogre
{
    class BoneArrayMemoryManager : public ArrayMemoryManager
    {
    protected:

        virtual void slotsRecreated( size_t prevNumSlots );

    public:
        enum MemoryTypes
        {
            Owner = 0,
            Position,
            Orientation,
            Scale,
            ParentMat,
            ParentNode,
            WorldMat,
            FinalMat,
            InheritOrientation,
            InheritScale,
            NumMemoryTypes
        };

        static const size_t ElementsMemSize[NumMemoryTypes];
        static const CleanupRoutines BoneCleanupRoutines[NumMemoryTypes];


        BoneArrayMemoryManager(uint16 depthLevel, size_t hintMaxNodes,
                                size_t cleanupThreshold=100,
                                size_t maxHardLimit=MAX_MEMORY_SLOTS,
                                RebaseListener *rebaseListener=0 );






        void createNewNode( BoneTransform &outTransform );







        void destroyNode( BoneTransform &inOutTransform );
        size_t getFirstNode( BoneTransform &outTransform );
    };



}


namespace Ogre
{







    struct BySkeletonDef;
    class BoneMemoryManager : ArrayMemoryManager::RebaseListener
    {
        typedef vector<BoneArrayMemoryManager>::type ArrayMemoryManagerVec;

        ArrayMemoryManagerVec mMemoryManagers;

        BySkeletonDef *mBoneRebaseListener;





        void growToDepth( size_t newDepth );

    public:
        BoneMemoryManager();
        virtual ~BoneMemoryManager();




        void _growToDepth( const vector<size_t>::type &bonesPerDepth );







        void nodeCreated( BoneTransform &outTransform, size_t depth );
        void nodeAttached( BoneTransform &outTransform, size_t depth );
        void nodeDettached( BoneTransform &outTransform, size_t depth );







        void nodeDestroyed( BoneTransform &outTransform, size_t depth );
        void nodeMoved( BoneTransform &inOutTransform, size_t oldDepth, size_t newDepth );
        void migrateTo( BoneTransform &inOutTransform, size_t depth,
                        BoneMemoryManager *dstBoneMemoryManager );






        size_t getNumDepths() const;
        size_t getFirstNode( BoneTransform &outTransform, size_t depth );

        void setBoneRebaseListener( BySkeletonDef *l ) { mBoneRebaseListener = l; }


        virtual void buildDiffList( ArrayMemoryManager::ManagerType managerType, uint16 level,
                                    const MemoryPoolVec &basePtrs,
                                    ArrayMemoryManager::PtrdiffVec &outDiffsList );
        virtual void applyRebase( ArrayMemoryManager::ManagerType managerType, uint16 level,
                                    const MemoryPoolVec &newBasePtrs,
                                    const ArrayMemoryManager::PtrdiffVec &diffsList );
        virtual void performCleanup( ArrayMemoryManager::ManagerType managerType, uint16 level,
                                     const MemoryPoolVec &basePtrs, size_t const *elementsMemSizes,
                                     size_t startInstance, size_t diffInstances );
    };



}




namespace Ogre
{







    struct BySkeletonDef
    {
        SkeletonDef const *skeletonDef;
        IdString skeletonDefName;
        BoneMemoryManager boneMemoryManager;





        FastArray<SkeletonInstance*> skeletons;





        FastArray<size_t> threadStarts;

        BySkeletonDef( const SkeletonDef *skeletonDef, size_t threadCount );

        void initializeMemoryManager(void);

        void updateThreadStarts(void);
        void _updateBoneStartTransforms(void);

        bool operator == ( IdString name ) const { return skeletonDefName == name; }
    };
    struct SkeletonAnimManager
    {
        typedef list<BySkeletonDef>::type BySkeletonDefList;
        BySkeletonDefList bySkeletonDefs;


        SkeletonInstance* createSkeletonInstance( const SkeletonDef *skeletonDef,
                                                    size_t numWorkerThreads );
        void destroySkeletonInstance( SkeletonInstance *skeletonInstance );
    };



}








namespace Ogre
{
    class CompositorNodeDef;

    typedef vector<IdString>::type IdStringVec;







    enum CompositorPassType
    {
        PASS_INVALID = 0,
        PASS_SCENE,
        PASS_QUAD,
        PASS_CLEAR,
        PASS_STENCIL,
        PASS_RESOLVE,
        PASS_DEPTHCOPY,
        PASS_UAV,
        PASS_MIPMAP,
        PASS_CUSTOM
    };
    class CompositorPassDef : public CompositorInstAlloc
    {
        CompositorPassType mPassType;


        uint32 mRtIndex;

    public:

        float mVpLeft;
        float mVpTop;
        float mVpWidth;
        float mVpHeight;
        float mVpScissorLeft;
        float mVpScissorTop;
        float mVpScissorWidth;
        float mVpScissorHeight;


        uint32 mShadowMapIdx;


        uint32 mNumInitialPasses;


        uint32 mIdentifier;



        bool mBeginRtUpdate;

        bool mEndRtUpdate;





        bool mColourWrite;




        bool mIncludeOverlays;

        uint8 mExecutionMask;
        uint8 mViewportModifierMask;

        IdStringVec mExposedTextures;

        struct UavDependency
        {


            uint32 uavSlot;





            ResourceAccess::ResourceAccess access;
            bool allowWriteAfterWrite;

            UavDependency( uint32 _uavSlot, ResourceAccess::ResourceAccess _access,
                           bool _allowWriteAfterWrite ) :
                uavSlot( _uavSlot ), access( _access ), allowWriteAfterWrite( _allowWriteAfterWrite ) {}
        };
        typedef vector<UavDependency>::type UavDependencyVec;
        UavDependencyVec mUavDependencies;

    public:
        CompositorPassDef( CompositorPassType passType, uint32 rtIndex ) :
            mPassType( passType ), mRtIndex( rtIndex ),
            mVpLeft( 0 ), mVpTop( 0 ),
            mVpWidth( 1 ), mVpHeight( 1 ),
            mVpScissorLeft( 0 ), mVpScissorTop( 0 ),
            mVpScissorWidth( 1 ), mVpScissorHeight( 1 ),
            mShadowMapIdx( 0 ),
            mNumInitialPasses( -1 ), mIdentifier( 0 ),
            mBeginRtUpdate( true ), mEndRtUpdate( true ),
            mColourWrite( true ),
            mIncludeOverlays( false ),
            mExecutionMask( 0xFF ),
            mViewportModifierMask( 0xFF ) {}
        virtual ~CompositorPassDef() {}

        CompositorPassType getType() const { return mPassType; }
        uint32 getRtIndex(void) const { return mRtIndex; }
    };

    typedef vector<CompositorPassDef*>::type CompositorPassDefVec;

    class CompositorTargetDef : public CompositorInstAlloc
    {

        IdString mRenderTargetName;
        CompositorPassDefVec mCompositorPasses;


        uint32 mRtIndex;

        CompositorNodeDef *mParentNodeDef;

    public:
        CompositorTargetDef( IdString renderTargetName, uint32 rtIndex,
                             CompositorNodeDef *parentNodeDef ) :
                mRenderTargetName( renderTargetName ),
                mRtIndex( rtIndex ),
                mParentNodeDef( parentNodeDef ) {}
        ~CompositorTargetDef();

        IdString getRenderTargetName() const { return mRenderTargetName; }







        void setNumPasses( size_t numPasses ) { mCompositorPasses.reserve( numPasses ); }

        CompositorPassDef* addPass( CompositorPassType passType, IdString customId = IdString() );

        const CompositorPassDefVec& getCompositorPasses() const { return mCompositorPasses; }


        CompositorPassDefVec& getCompositorPassesNonConst() { return mCompositorPasses; }
    };



}



namespace Ogre
{
    class RenderTarget;
    struct CompositorChannel;
    class CompositorNode;
    typedef vector<TexturePtr>::type TextureVec;

    struct CompositorTexture
    {
        IdString name;
        TextureVec const *textures;

        CompositorTexture( IdString _name, const TextureVec *_textures ) :
                name( _name ), textures( _textures ) {}

        bool operator == ( IdString right ) const
        {
            return name == right;
        }
    };

    typedef vector<CompositorTexture>::type CompositorTextureVec;

    struct BoundUav
    {
        RenderTarget *renderTarget;
        ResourceAccess::ResourceAccess boundAccess;
    };
    class CompositorPass : public CompositorInstAlloc
    {
        CompositorPassDef const *mDefinition;
    protected:
        static const Quaternion CubemapRotations[6];

        RenderTarget *mTarget;
        Viewport *mViewport;

        uint32 mNumPassesLeft;

        CompositorNode *mParentNode;

        CompositorTextureVec mTextureDependencies;

        typedef vector<ResourceTransition>::type ResourceTransitionVec;
        ResourceTransitionVec mResourceTransitions;





        uint32 mNumValidResourceTransitions;

        void populateTextureDependenciesFromExposedTextures(void);

        void executeResourceTransitions(void);

        RenderTarget* calculateRenderTarget( size_t rtIndex, const CompositorChannel &source );

    public:
        CompositorPass( const CompositorPassDef *definition, const CompositorChannel &target,
                        CompositorNode *parentNode );
        virtual ~CompositorPass();

        virtual void execute( const Camera *lodCameraconst ) = 0;

        void addResourceTransition( ResourceLayoutMap::iterator currentLayout,
                                    ResourceLayout::Layout newLayout,
                                    uint32 readBarrierBits );
        virtual void _placeBarriersAndEmulateUavExecution( BoundUav boundUavs[64],
                                                           ResourceAccessMap &uavsAccess,
                                                           ResourceLayoutMap &resourcesLayout );


        virtual void notifyRecreated( const CompositorChannel &oldChannel,
                                        const CompositorChannel &newChannel );


        virtual void notifyDestroyed( const CompositorChannel &channel );


        virtual void notifyCleared(void);

        void resetNumPassesLeft(void);

        CompositorPassType getType() const { return mDefinition->getType(); }

        Viewport* getViewport() const { return mViewport; }

        RenderTarget* getRenderTarget(void) const { return mTarget; }

        const CompositorPassDef* getDefinition(void) const { return mDefinition; }

  const CompositorNode* getParentNode(void) const { return mParentNode; }

        const CompositorTextureVec& getTextureDependencies(void) const { return mTextureDependencies; }
    };



}


namespace Ogre
{
    class ThreadHandle
    {



        pthread_t mThread;

        size_t mThreadIdx;
        void *mUserParam;

    public:
        ThreadHandle( size_t threadIdx, void *userParam );
        ~ThreadHandle();

        size_t getThreadIdx() const { return mThreadIdx; }
        void* getUserParam() const { return mUserParam; }
        void _setOsHandle( pthread_t &handle ) { mThread = handle; }

        pthread_t _getOsHandle() const { return mThread; }

    };

    typedef SharedPtr<ThreadHandle> ThreadHandlePtr;
    typedef vector<ThreadHandlePtr>::type ThreadHandleVec;




    typedef void* ( *THREAD_ENTRY_POINT)( void *lpThreadParameter );


    class Threads
    {
    public:
        static ThreadHandlePtr CreateThread( THREAD_ENTRY_POINT entryPoint,
                                             size_t threadIdx, void *param );
        static void WaitForThreads( size_t numThreadHandles, const ThreadHandlePtr *threadHandles );
        static void WaitForThreads( const ThreadHandleVec &threadHandles );



        static void Sleep( uint32 milliseconds );
    };
}

namespace Ogre {
    struct ViewPoint
    {
        Vector3 position;
        Quaternion orientation;
    };
    enum InstancingThreadedCullingMethod
    {
        INSTANCING_CULLING_SINGLETHREAD,
        INSTANCING_CULLING_THREADED,
    };

    typedef FastArray<MovableObject::MovableObjectArray> VisibleObjectsPerRq;
    typedef FastArray<VisibleObjectsPerRq> VisibleObjectsPerThreadArray;


    class DefaultIntersectionSceneQuery;
    class DefaultRaySceneQuery;
    class DefaultSphereSceneQuery;
    class DefaultAxisAlignedBoxSceneQuery;
    class LodListener;
    struct MovableObjectLodChangedEvent;
    struct EntityMeshLodChangedEvent;
    struct EntityMaterialLodChangedEvent;
    class CompositorShadowNode;
    class UniformScalableTask;

    namespace v1
    {
        class Rectangle2D;
    }


    struct CullFrustumRequest
    {
        typedef vector<ObjectMemoryManager*>::type ObjectMemoryManagerVec;

        uint8 firstRq;

        uint8 lastRq;

        bool casterPass;

        bool addToRenderQueue;




        ObjectMemoryManagerVec const *objectMemManager;

        Camera const *camera;

        Camera const *lodCamera;

        CullFrustumRequest() :
            firstRq( 0 ), lastRq( 0 ), casterPass( false ), addToRenderQueue( true ),
            objectMemManager( 0 ), camera( 0 ), lodCamera( 0 )
        {
        }
        CullFrustumRequest( uint8 _firstRq, uint8 _lastRq, bool _casterPass,
                            bool _addToRenderQueue,
                            const ObjectMemoryManagerVec *_objectMemManager,
                            const Camera *_camera, const Camera *_lodCamera ) :
            firstRq( _firstRq ), lastRq( _lastRq ), casterPass( _casterPass ),
            addToRenderQueue( _addToRenderQueue ), objectMemManager( _objectMemManager ),
            camera( _camera ), lodCamera( _lodCamera )
        {
        }
    };

    struct UpdateLodRequest : public CullFrustumRequest
    {
        Real lodBias;

        UpdateLodRequest() :
            CullFrustumRequest(), lodBias( 0 )
        {
        }
        UpdateLodRequest( uint8 _firstRq, uint8 _lastRq,
                            const ObjectMemoryManagerVec *_objectMemManager,
                            const Camera *_camera, const Camera *_lodCamera, Real _lodBias ) :
            CullFrustumRequest( _firstRq, _lastRq, false, false,
                                _objectMemManager, _camera, _lodCamera ),
            lodBias( _lodBias )
        {
        }
    };

    struct UpdateTransformRequest
    {
        Transform t;

        size_t numNodesPerThread;
        size_t numTotalNodes;

        UpdateTransformRequest() :
            numNodesPerThread( 0 ), numTotalNodes( 0 ) {}

        UpdateTransformRequest( const Transform &_t, size_t _numNodesPerThread, size_t _numTotalNodes ) :
            t( _t ), numNodesPerThread( _numNodesPerThread ), numTotalNodes( _numTotalNodes )
        {
        }
    };

    struct InstanceBatchCullRequest
    {
        Frustum const *frustum;
        Camera const *lodCamera;
        uint32 combinedVisibilityFlags;
        InstanceBatchCullRequest() : frustum( 0 ), lodCamera( 0 ), combinedVisibilityFlags( 0 ) {}
        InstanceBatchCullRequest( const Frustum *_frustum, const Camera *_lodCamera,
                                  uint32 _combinedVisibilityFlags ) :
                        frustum( _frustum ), lodCamera( _lodCamera ),
                        combinedVisibilityFlags( _combinedVisibilityFlags )
        {
        }
    };

    struct BuildLightListRequest
    {
        size_t startLightIdx;

        BuildLightListRequest() :
            startLightIdx( 0 ) {}
        BuildLightListRequest( size_t _startLightIdx ) :
            startLightIdx( _startLightIdx )
        {
        }
    };
    class SceneManager : public SceneMgtAlignedAlloc
    {
    public:

        static uint32 QUERY_ENTITY_DEFAULT_MASK;

        static uint32 QUERY_FX_DEFAULT_MASK;

        static uint32 QUERY_STATICGEOMETRY_DEFAULT_MASK;

        static uint32 QUERY_LIGHT_DEFAULT_MASK;

        static uint32 QUERY_FRUSTUM_DEFAULT_MASK;


        enum IlluminationRenderStage
        {

            IRS_NONE,

            IRS_RENDER_TO_TEXTURE
        };

        struct SkyDomeGenParameters
        {
            Real skyDomeCurvature;
            Real skyDomeTiling;
            Real skyDomeDistance;
            int skyDomeXSegments;
            int skyDomeYSegments;
            int skyDomeYSegments_keep;
        };

        struct SkyPlaneGenParameters
        {
            Real skyPlaneScale;
            Real skyPlaneTiling;
            Real skyPlaneBow;
            int skyPlaneXSegments;
            int skyPlaneYSegments;
        };

        struct SkyBoxGenParameters
        {
            Real skyBoxDistance;
        };




        class Listener
        {
        public:
            Listener() {}
            virtual ~Listener() {}
            virtual void preFindVisibleObjects(SceneManager* source,
                IlluminationRenderStage irs, Viewport* v)
                        { (void)source; (void)irs; (void)v; }
            virtual void postFindVisibleObjects(SceneManager* source,
                IlluminationRenderStage irs, Viewport* v)
                        { (void)source; (void)irs; (void)v; }
            virtual void shadowTexturesUpdated(size_t numberOfShadowTextures)
                        { (void)numberOfShadowTextures; }
            virtual void shadowTextureCasterPreViewProj( const Light* light,
                Camera* camera, size_t iteration)
                        { (void)light; (void)camera; (void)iteration; }
            virtual bool sortLightsAffectingFrustum(LightList& lightList)
                        { (void)lightList; return false; }


            virtual void sceneManagerDestroyed(SceneManager* source)
                        { (void)source; }
        };

    protected:

        virtual SceneNode* createSceneNodeImpl( SceneNode *parent,
                                                NodeMemoryManager *nodeMemoryManager );
        virtual TagPoint* createTagPointImpl( SceneNode *parent,
                                              NodeMemoryManager *nodeMemoryManager );

        typedef vector<NodeMemoryManager*>::type NodeMemoryManagerVec;
        typedef vector<ObjectMemoryManager*>::type ObjectMemoryManagerVec;
        typedef vector<SkeletonAnimManager*>::type SkeletonAnimManagerVec;
        NodeMemoryManager mNodeMemoryManager[NUM_SCENE_MEMORY_MANAGER_TYPES];
        ObjectMemoryManager mEntityMemoryManager[NUM_SCENE_MEMORY_MANAGER_TYPES];
        ObjectMemoryManager mLightMemoryManager;
        SkeletonAnimManager mSkeletonAnimationManager;
        NodeMemoryManager mTagPointNodeMemoryManager;

        NodeMemoryManagerVec mNodeMemoryManagerUpdateList;
        NodeMemoryManagerVec mTagPointNodeMemoryManagerUpdateList;
        ObjectMemoryManagerVec mEntitiesMemoryManagerCulledList;
        ObjectMemoryManagerVec mEntitiesMemoryManagerUpdateList;
        ObjectMemoryManagerVec mLightsMemoryManagerCulledList;
        SkeletonAnimManagerVec mSkeletonAnimManagerCulledList;







        uint16 mStaticMinDepthLevelDirty;




        bool mStaticEntitiesDirty;


        String mName;


        RenderQueue* mRenderQueue;

        Forward3D *mForward3DImpl;




        LightListInfo mGlobalLightList;
        typedef FastArray<LightArray> LightArrayPerThread;
        typedef FastArray<BuildLightListRequest> BuildLightListRequestPerThread;
        LightArrayPerThread mGlobalLightListPerThread;
        BuildLightListRequestPerThread mBuildLightListRequestPerThread;


        ColourValue mAmbientLight[2];
        Vector3 mAmbientLightHemisphereDir;


        RenderSystem *mDestRenderSystem;

        typedef vector<Camera*>::type CameraList;
        typedef map<IdString, Camera*>::type CameraMap;



        CameraList mCameras;
        CameraMap mCamerasByName;
        FrustumVec mVisibleCameras;
        FrustumVec mCubeMapCameras;

        typedef map<String, v1::StaticGeometry* >::type StaticGeometryList;
        StaticGeometryList mStaticGeometryList;

        typedef vector<v1::InstanceManager*>::type InstanceManagerVec;
        InstanceManagerVec mInstanceManagers;

        typedef vector<SceneNode*>::type SceneNodeList;







        SceneNodeList mSceneNodes;
        SceneNodeList mSceneNodesWithListeners;


        Camera* mCameraInProgress;

        Viewport* mCurrentViewport;

        CompositorShadowNode* mCurrentShadowNode;
        bool mShadowNodeIsReused;


        SceneNode* mSceneRoot[NUM_SCENE_MEMORY_MANAGER_TYPES];


  struct AutoTrackingSceneNode
  {
   SceneNode *source;
   SceneNode *target;

   Vector3 offset;

   Vector3 localDirection;

   AutoTrackingSceneNode( SceneNode *_source, SceneNode *_target,
           const Vector3 &_offset, const Vector3 &_localDirection ) :
    source( _source ), target( _target ),
    offset( _offset ), localDirection( _localDirection )
   {
   }
  };

  typedef vector<AutoTrackingSceneNode>::type AutoTrackingSceneNodeVec;
  AutoTrackingSceneNodeVec mAutoTrackingSceneNodes;



        v1::Entity* mSkyPlaneEntity;
        v1::Entity* mSkyDomeEntity[5];
        v1::ManualObject* mSkyBoxObj;

        SceneNode* mSkyPlaneNode;
        SceneNode* mSkyDomeNode;
        SceneNode* mSkyBoxNode;


        bool mSkyPlaneEnabled;
        Plane mSkyPlane;
        SkyPlaneGenParameters mSkyPlaneGenParameters;

        bool mSkyBoxEnabled;
        Quaternion mSkyBoxOrientation;
        SkyBoxGenParameters mSkyBoxGenParameters;

        bool mSkyDomeEnabled;
        Quaternion mSkyDomeOrientation;
        SkyDomeGenParameters mSkyDomeGenParameters;


        FogMode mFogMode;
        ColourValue mFogColour;
        Real mFogStart;
        Real mFogEnd;
        Real mFogDensity;

        unsigned long mLastFrameNumber;
        Matrix4 mTempXform[256] __attribute__((__aligned__(16)));
        bool mResetIdentityView;
        bool mResetIdentityProj;

        bool mFlipCullingOnNegativeScale;
        CullingMode mPassCullingMode;

    protected:

        vector<size_t>::type mShadowTextureIndexLightList;


        struct LightInfo
        {
            Light* light;
            int type;
            Real range;
            Vector3 position;
            uint32 lightMask;

            bool operator== (const LightInfo& rhs) const
            {
                return light == rhs.light && type == rhs.type &&
                    range == rhs.range && position == rhs.position && lightMask == rhs.lightMask;
            }

            bool operator!= (const LightInfo& rhs) const
            {
                return !(*this == rhs);
            }
        };

        typedef vector<LightInfo>::type LightInfoList;

        typedef vector<MovableObject*>::type MovableObjectVec;

        struct MovableObjectCollection
        {
            MovableObjectVec movableObjects;
                             ;
        };
        typedef map<String, MovableObjectCollection*>::type MovableObjectCollectionMap;
        MovableObjectCollectionMap mMovableObjectCollectionMap;




        MovableObjectCollection* getMovableObjectCollection(const String& typeName);




        const MovableObjectCollection* getMovableObjectCollection(const String& typeName) const;

                                                    ;


        Pass* mShadowCasterPlainBlackPass;
                   const Pass* deriveShadowCasterPass(const Pass* pass);







                   bool validatePassForRendering(const Pass* pass);

        enum BoxPlane
        {
            BP_FRONT = 0,
            BP_BACK = 1,
            BP_LEFT = 2,
            BP_RIGHT = 3,
            BP_UP = 4,
            BP_DOWN = 5
        };



        virtual v1::MeshPtr createSkyboxPlane(
            BoxPlane bp,
            Real distance,
            const Quaternion& orientation,
            const String& groupName);



        virtual v1::MeshPtr createSkydomePlane(
            BoxPlane bp,
            Real curvature, Real tiling, Real distance,
            const Quaternion& orientation,
            int xsegments, int ysegments, int ySegmentsToKeep,
            const String& groupName);


        bool mDisplayNodes;


        typedef map<String, v1::Animation*>::type AnimationList;
        AnimationList mAnimationsList;
                                        ;
        v1::AnimationStateSet mAnimationStates;




        virtual void useRenderableViewProjMode(const Renderable* pRend, bool fixedFunction);



        virtual void resetViewProjMode(bool fixedFunction);

        typedef vector<RenderQueueListener*>::type RenderQueueListenerList;
        RenderQueueListenerList mRenderQueueListeners;

        typedef vector<RenderObjectListener*>::type RenderObjectListenerList;
        RenderObjectListenerList mRenderObjectListeners;
        typedef vector<Listener*>::type ListenerList;
        ListenerList mListeners;

        virtual void firePreRenderQueues();

        virtual void firePostRenderQueues();

        virtual bool fireRenderQueueStarted(uint8 id, const String& invocation);

        virtual bool fireRenderQueueEnded(uint8 id, const String& invocation);

        virtual void fireRenderSingleObject(Renderable* rend, const Pass* pass,
                                            const AutoParamDataSource* source,
                                            const LightList* pLightList,
                                            bool suppressRenderStateChanges);


        virtual void fireShadowTexturesUpdated(size_t numberOfShadowTextures);

        virtual void fireShadowTexturesPreCaster(const Light* light, Camera* camera, size_t iteration);

        virtual void firePreFindVisibleObjects(Viewport* v);

        virtual void firePostFindVisibleObjects(Viewport* v);

        virtual void fireSceneManagerDestroyed();

        virtual void setViewport(Viewport *vp);


        bool mShowBoundingBoxes;


        virtual void prepareRenderQueue(void);
                   void renderSingleObject(Renderable* rend, const Pass* pass,
            bool lightScissoringClipping, bool doLightIteration);


        virtual AutoParamDataSource* createAutoParamDataSource(void) const
        {
            return new AutoParamDataSource();
        }


        AutoParamDataSource* mAutoParamDataSource;

        bool mLateMaterialResolving;

        ColourValue mShadowColour;
        v1::HardwareIndexBufferSharedPtr mShadowIndexBuffer;
        size_t mShadowIndexBufferUsedSize;
        v1::Rectangle2D* mFullScreenQuad;
        Real mShadowDirLightExtrudeDist;
        IlluminationRenderStage mIlluminationStage;

        struct LightClippingInfo
        {
            RealRect scissorRect;
            PlaneList clipPlanes;
            bool scissorValid;
            unsigned long clipPlanesValid;
            LightClippingInfo() : scissorValid(false), clipPlanesValid(false) {}

        };
        typedef map<Light const *, LightClippingInfo>::type LightClippingInfoMap;
        LightClippingInfoMap mLightClippingInfoMap;
        unsigned long mLightClippingInfoMapFrameNumber;
        template<typename T>
        void checkMovableObjectIntegrity( const typename vector<T*>::type &container,
                                            const T *mo ) const;



        void updateInstanceManagerAnimations(void);




        void updateInstanceManagersThread( size_t threadIdx );


        void updateInstanceManagers(void);
        virtual void highLevelCull();
        void propagateRelativeOrigin( SceneNode *sceneNode, const Vector3 &relativeOrigin );

    public:


        struct RenderContext
        {
            RenderQueue* renderQueue;
            Viewport* viewport;
            Camera* camera;
            RenderSystem::RenderSystemContext* rsContext;
        };




        virtual RenderContext* _pauseRendering();



        virtual void _resumeRendering(RenderContext* context);

    protected:
        Real mDefaultShadowFarDist;
        Real mDefaultShadowFarDistSquared;
        Real mShadowTextureOffset;
        Real mShadowTextureFadeStart;
        Real mShadowTextureFadeEnd;
        Pass* mShadowTextureCustomCasterPass;
        String mShadowTextureCustomCasterVertexProgram;
        String mShadowTextureCustomCasterFragmentProgram;
        GpuProgramParametersSharedPtr mShadowTextureCustomCasterVPParams;
        GpuProgramParametersSharedPtr mShadowTextureCustomCasterFPParams;

        CompositorTextureVec mCompositorTextures;


        uint32 mVisibilityMask;
        bool mFindVisibleObjects;

        enum RequestType
        {
            CULL_FRUSTUM,
            UPDATE_ALL_ANIMATIONS,
            UPDATE_ALL_TRANSFORMS,
            UPDATE_ALL_BONE_TO_TAG_TRANSFORMS,
            UPDATE_ALL_TAG_ON_TAG_TRANSFORMS,
            UPDATE_ALL_BOUNDS,
            UPDATE_ALL_LODS,
            UPDATE_INSTANCE_MANAGERS,
            CULL_FRUSTUM_INSTANCEDENTS,
            BUILD_LIGHT_LIST01,
            BUILD_LIGHT_LIST02,
            USER_UNIFORM_SCALABLE_TASK,
            STOP_THREADS,
            NUM_REQUESTS
        };

        size_t mNumWorkerThreads;

        CullFrustumRequest mCurrentCullFrustumRequest;
        UpdateLodRequest mUpdateLodRequest;
        UpdateTransformRequest mUpdateTransformRequest;
        ObjectMemoryManagerVec const *mUpdateBoundsRequest;
        InstancingThreadedCullingMethod mInstancingThreadedCullingMethod;
        InstanceBatchCullRequest mInstanceBatchCullRequest;
        UniformScalableTask *mUserTask;
        RequestType mRequestType;
        Barrier *mWorkerThreadsBarrier;
        ThreadHandleVec mWorkerThreads;







        VisibleObjectsPerThreadArray mVisibleObjects;







        VisibleObjectsPerThreadArray mTmpVisibleObjects;


        bool mSuppressRenderStateChanges;


        virtual ClipResult buildAndSetScissor(const LightList& ll, const Camera* cam);

        virtual void buildScissor(const Light* l, const Camera* cam, RealRect& rect);

        virtual ClipResult buildAndSetLightClip(const LightList& ll);
        virtual void buildLightClip(const Light* l, PlaneList& planes);
        virtual void resetLightClip();
        virtual void checkCachedLightClippingInfo();


        Matrix4 mCachedViewMatrix;
        Vector3 mRelativeOffset;


        uint32 mLastLightHash;
        unsigned short mLastLightLimit;
        uint32 mLastLightHashGpuProgram;

        uint16 mGpuParamsDirty;

        virtual void useLights(const LightList& lights, unsigned short limit);
        virtual void setViewMatrix(const Matrix4& m);
        virtual void useLightsGpuProgram(const Pass* pass, const LightList* lights);
        virtual void bindGpuProgram(GpuProgram* prog);
        virtual void updateGpuProgramParameters(const Pass* p);
        typedef set<LodListener*>::type LodListenerSet;
        LodListenerSet mLodListeners;


        typedef vector<MovableObjectLodChangedEvent>::type MovableObjectLodChangedEventList;
        MovableObjectLodChangedEventList mMovableObjectLodChangedEvents;


        typedef vector<EntityMeshLodChangedEvent>::type EntityMeshLodChangedEventList;
        EntityMeshLodChangedEventList mEntityMeshLodChangedEvents;


        typedef vector<EntityMaterialLodChangedEvent>::type EntityMaterialLodChangedEventList;
        EntityMaterialLodChangedEventList mEntityMaterialLodChangedEvents;






        void updateAllAnimationsThread( size_t threadIdx );
        void updateAnimationTransforms( BySkeletonDef &bySkeletonDef, size_t threadIdx );
        void updateAllTransformsThread( const UpdateTransformRequest &request, size_t threadIdx );


        void updateAllTransformsBoneToTagThread( const UpdateTransformRequest &request,
                                                 size_t threadIdx );


        void updateAllTransformsTagOnTagThread( const UpdateTransformRequest &request,
                                                size_t threadIdx );






        void updateAllBoundsThread( const ObjectMemoryManagerVec &objectMemManager, size_t threadIdx );






        void updateAllLodsThread( const UpdateLodRequest &request, size_t threadIdx );







        void instanceBatchCullFrustumThread( const InstanceBatchCullRequest &request, size_t threadIdx );
        void cullFrustum( const CullFrustumRequest &request, size_t threadIdx );







        void buildLightList();

        void buildLightListThread01( const BuildLightListRequest &buildLightListRequest,
                                     size_t threadIdx );
        void buildLightListThread02( size_t threadIdx );

    public:


        SceneManager(const String& instanceName, size_t numWorkerThreads,
                    InstancingThreadedCullingMethod threadedCullingMethod);



        virtual ~SceneManager();
                                   ;


        const String& getName(void) const { return mName; }







        virtual const String& getTypeName(void) const = 0;

        size_t getNumWorkerThreads() const { return mNumWorkerThreads; }
        virtual Camera* createCamera(const String& name, bool notShadowCaster=true, bool forCubemapping=false);







        virtual Camera* findCamera( IdString name ) const;







        virtual Camera* findCameraNoThrow( IdString name ) const;
        virtual void destroyCamera(Camera *cam);







        virtual void destroyAllCameras(void);
        virtual Light* createLight();


        void clearFrameData(void);

        const LightListInfo& getGlobalLightList(void) const { return mGlobalLightList; }



        virtual const PlaneList& getLightClippingPlanes(const Light* l);



        virtual const RealRect& getLightScissorRect(const Light* l, const Camera* cam);





        virtual void destroyLight(Light* light);


        virtual void destroyAllLights(void);


        virtual TagPoint* _createTagPoint( SceneNode *parent, NodeMemoryManager *nodeMemoryManager );



        virtual TagPoint* createTagPoint(void);






        virtual SceneNode* _createSceneNode( SceneNode *parent, NodeMemoryManager *nodeMemoryManager );
        virtual SceneNode* createSceneNode( SceneMemoryMgrTypes sceneType = SCENE_DYNAMIC );







        virtual void destroySceneNode(SceneNode* sn);
        SceneNode* getRootSceneNode( SceneMemoryMgrTypes sceneType = SCENE_DYNAMIC );







                   SceneNode* getSceneNode( IdType id );
                   const SceneNode* getSceneNode( IdType id ) const;




        virtual void registerSceneNodeListener( SceneNode *sceneNode );



        virtual void unregisterSceneNodeListener( SceneNode *sceneNode );


        RenderQueue* getRenderQueue(void) const { return mRenderQueue; }
        void setForward3D( bool bEnable, uint32 width, uint32 height, uint32 numSlices,
                           uint32 lightsPerCell, float minDistance, float maxDistance );

        Forward3D* getForward3D(void) { return mForward3DImpl; }

        NodeMemoryManager& _getNodeMemoryManager(SceneMemoryMgrTypes sceneType)
                                                                { return mNodeMemoryManager[sceneType]; }
        NodeMemoryManager& _getTagPointNodeMemoryManager(void) { return mTagPointNodeMemoryManager; }







        ObjectMemoryManager& _getEntityMemoryManager(SceneMemoryMgrTypes sceneType)
                                                            { return mEntityMemoryManager[sceneType]; }






        virtual Item* createItem( const String& meshName,
                                  const String& groupName = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME,
                                  SceneMemoryMgrTypes sceneType = SCENE_DYNAMIC );





        virtual Item* createItem( const MeshPtr& pMesh,
                                  SceneMemoryMgrTypes sceneType = SCENE_DYNAMIC );


        virtual void destroyItem( Item *item );


        virtual void destroyAllItems(void);






        virtual v1::Entity* createEntity( const String& meshName,
                                          const String& groupName = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME,
                                          SceneMemoryMgrTypes sceneType = SCENE_DYNAMIC );





        virtual v1::Entity* createEntity( const v1::MeshPtr& pMesh,
                                          SceneMemoryMgrTypes sceneType = SCENE_DYNAMIC );







        enum PrefabType {
            PT_PLANE,
            PT_CUBE,
            PT_SPHERE
        };




        virtual v1::Entity* createEntity( PrefabType ptype,
                                          SceneMemoryMgrTypes sceneType = SCENE_DYNAMIC );
        virtual void destroyEntity(v1::Entity* ent);
        virtual void destroyAllEntities(void);
        virtual v1::Rectangle2D* createRectangle2D( bool bQuad,
                                                    SceneMemoryMgrTypes sceneType = SCENE_STATIC );






        virtual void destroyRectangle2D( v1::Rectangle2D *rect );
        virtual void destroyAllRectangle2D(void);
        void _addCompositorTexture( IdString name, const TextureVec *texs );



        const CompositorTextureVec& getCompositorTextures(void) const { return mCompositorTextures; }


        size_t getNumCompositorTextures(void) const { return mCompositorTextures.size(); }


        void _removeCompositorTextures( size_t from );


        SkeletonInstance* createSkeletonInstance( const SkeletonDef *skeletonDef );

        void destroySkeletonInstance( SkeletonInstance *skeletonInstance );




        virtual ManualObject* createManualObject( SceneMemoryMgrTypes sceneType = SCENE_DYNAMIC );


        virtual void destroyManualObject(ManualObject* obj);


        virtual void destroyAllManualObjects(void);



        virtual v1::BillboardChain* createBillboardChain();


        virtual void destroyBillboardChain(v1::BillboardChain* obj);


        virtual void destroyAllBillboardChains(void);



        virtual v1::RibbonTrail* createRibbonTrail();


        virtual void destroyRibbonTrail(v1::RibbonTrail* obj);


        virtual void destroyAllRibbonTrails(void);
        virtual ParticleSystem* createParticleSystem( const String& templateName );
        virtual ParticleSystem* createParticleSystem( size_t quota = 500,
            const String& resourceGroup = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME );



        virtual void destroyParticleSystem(ParticleSystem* obj);


        virtual void destroyAllParticleSystems(void);






        virtual void clearScene(void);
        void setAmbientLight( const ColourValue& upperHemisphere, const ColourValue& lowerHemisphere,
                              const Vector3 &hemisphereDir, Real envmapScale = 1.0f );



        const ColourValue& getAmbientLightUpperHemisphere(void) const { return mAmbientLight[0]; }
        const ColourValue& getAmbientLightLowerHemisphere(void) const { return mAmbientLight[1]; }
        const Vector3& getAmbientLightHemisphereDir(void) const { return mAmbientLightHemisphereDir; }
        virtual void prepareWorldGeometry(const String& filename);
        virtual void prepareWorldGeometry(DataStreamPtr& stream,
            const String& typeName = BLANKSTRING);
        virtual void setWorldGeometry(const String& filename);
        virtual void setWorldGeometry(DataStreamPtr& stream,
            const String& typeName = BLANKSTRING);
        virtual size_t estimateWorldGeometry(const String& filename)
        { (void)filename; return 0; }
        virtual size_t estimateWorldGeometry(DataStreamPtr& stream,
            const String& typeName = BLANKSTRING)
        { (void)stream; (void)typeName; return 0; }
        virtual ViewPoint getSuggestedViewpoint(bool random = false);
        virtual bool setOption( const String& strKey, const void* pValue )
        { (void)strKey; (void)pValue; return false; }
        virtual bool getOption( const String& strKey, void* pDestValue )
        { (void)strKey; (void)pDestValue; return false; }
        virtual bool hasOption( const String& strKey ) const
        { (void)strKey; return false; }
        virtual bool getOptionValues( const String& strKey, StringVector& refValueList )
        { (void)strKey; (void)refValueList; return false; }







        virtual bool getOptionKeys( StringVector& refKeys )
        { (void)refKeys; return false; }


        VisibleObjectsPerThreadArray& _getTmpVisibleObjectsList() { return mTmpVisibleObjects; }

        InstancingThreadedCullingMethod getInstancingThreadedCullingMethod() const
                                                            { return mInstancingThreadedCullingMethod; }






        void notifyStaticAabbDirty( MovableObject *movableObject );
        void notifyStaticDirty( Node *node );






        void updateAllAnimations();
        void updateAllTransforms();






        void updateAllTagPoints(void);
        void updateAllBounds( const ObjectMemoryManagerVec &objectMemManager );



        void updateAllLods( const Camera *lodCamera, Real lodBias, uint8 firstRq, uint8 lastRq );



        void updateSceneGraph();





        virtual void _applySceneAnimations(void);
        virtual void _cullPhase01(Camera* camera, const Camera *lodCamera,
                                  Viewport* vp, uint8 firstRq, uint8 lastRq );
        virtual void _renderPhase02( Camera* camera, const Camera* lodCamera, Viewport* vp,
                                     uint8 firstRq, uint8 lastRq, bool includeOverlays );

        void cullLights( Camera *camera, Light::LightTypes startType,
                         Light::LightTypes endType, LightArray &outLights );


        void _frameEnded(void);




        virtual void _queueSkiesForRendering(Camera* cam);
        virtual void _setDestinationRenderSystem(RenderSystem* sys);

        void _setViewport( Viewport *vp ) { setViewport( vp ); }
        virtual void setSkyPlane(
            bool enable,
            const Plane& plane, const String& materialName, Real scale = 1000,
            Real tiling = 10, bool drawFirst = true, Real bow = 0,
            int xsegments = 1, int ysegments = 1,
            const String& groupName = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
        virtual void _setSkyPlane(
            bool enable,
            const Plane& plane, const String& materialName, uint8 renderQueue, Real scale = 1000,
            Real tiling = 10, Real bow = 0, int xsegments = 1, int ysegments = 1,
            const String& groupName = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);


        virtual void setSkyPlaneEnabled(bool enable) { mSkyPlaneEnabled = enable; }


        virtual bool isSkyPlaneEnabled(void) const { return mSkyPlaneEnabled; }


        virtual SceneNode* getSkyPlaneNode(void) const { return mSkyPlaneNode; }


        virtual const SkyPlaneGenParameters& getSkyPlaneGenParameters(void) const { return mSkyPlaneGenParameters; }
        virtual void setSkyBox(
            bool enable, const String& materialName, Real distance = 5000,
            bool drawFirst = true, const Quaternion& orientation = Quaternion::IDENTITY,
            const String& groupName = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
        virtual void _setSkyBox(
            bool enable, const String& materialName, uint8 renderQueue, Real distance = 5000,
            const Quaternion& orientation = Quaternion::IDENTITY,
            const String& groupName = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);


        virtual void setSkyBoxEnabled(bool enable) { mSkyBoxEnabled = enable; }


        virtual bool isSkyBoxEnabled(void) const { return mSkyBoxEnabled; }


        virtual SceneNode* getSkyBoxNode(void) const { return mSkyBoxNode; }


        virtual const SkyBoxGenParameters& getSkyBoxGenParameters(void) const { return mSkyBoxGenParameters; }
        virtual void setSkyDome(
            bool enable, const String& materialName, Real curvature = 10,
            Real tiling = 8, Real distance = 4000, bool drawFirst = true,
            const Quaternion& orientation = Quaternion::IDENTITY,
            int xsegments = 16, int ysegments = 16, int ysegments_keep = -1,
            const String& groupName = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
        virtual void _setSkyDome(
            bool enable, const String& materialName, uint8 renderQueue,
            Real curvature = 10, Real tiling = 8, Real distance = 4000,
            const Quaternion& orientation = Quaternion::IDENTITY,
            int xsegments = 16, int ysegments = 16, int ysegments_keep = -1,
            const String& groupName = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);


        virtual void setSkyDomeEnabled(bool enable) { mSkyDomeEnabled = enable; }


        virtual bool isSkyDomeEnabled(void) const { return mSkyDomeEnabled; }


        virtual SceneNode* getSkyDomeNode(void) const { return mSkyDomeNode; }


        virtual const SkyDomeGenParameters& getSkyDomeGenParameters(void) const { return mSkyDomeGenParameters; }
        void setFog(
            FogMode mode = FOG_NONE, const ColourValue& colour = ColourValue::White,
            Real expDensity = 0.001, Real linearStart = 0.0, Real linearEnd = 1.0);



        virtual FogMode getFogMode(void) const;



        virtual const ColourValue& getFogColour(void) const;



        virtual Real getFogStart(void) const;



        virtual Real getFogEnd(void) const;



        virtual Real getFogDensity(void) const;
        virtual v1::BillboardSet* createBillboardSet(unsigned int poolSize = 20);







        virtual void destroyBillboardSet(v1::BillboardSet* set);
        virtual void destroyAllBillboardSets(void);
        virtual void setDisplaySceneNodes(bool display);

        virtual bool getDisplaySceneNodes(void) const {return mDisplayNodes;}
        virtual v1::Animation* createAnimation(const String& name, Real length);




        virtual v1::Animation* getAnimation(const String& name) const;


        virtual bool hasAnimation(const String& name) const;






        virtual void destroyAnimation(const String& name);


        virtual void destroyAllAnimations(void);
        virtual v1::AnimationState* createAnimationState(const String& animName);




        virtual v1::AnimationState* getAnimationState(const String& animName) const;


        virtual bool hasAnimationState(const String& name) const;






        virtual void destroyAnimationState(const String& name);


        virtual void destroyAllAnimationStates(void);
        virtual void manualRender(v1::RenderOperation* rend, Pass* pass, Viewport* vp,
            const Matrix4& worldMatrix, const Matrix4& viewMatrix, const Matrix4& projMatrix,
            bool doBeginEndFrame = false) ;
        virtual void manualRender(Renderable* rend, const Pass* pass, Viewport* vp,
            const Matrix4& viewMatrix, const Matrix4& projMatrix, bool doBeginEndFrame = false,
            bool lightScissoringClipping = true, bool doLightIteration = true);




        virtual void addRenderQueueListener(RenderQueueListener* newListener);


        virtual void removeRenderQueueListener(RenderQueueListener* delListener);



        virtual void addRenderObjectListener(RenderObjectListener* newListener);

        virtual void removeRenderObjectListener(RenderObjectListener* delListener);


        virtual void showBoundingBoxes(bool bShow);


        virtual bool getShowBoundingBoxes() const;


  virtual void _addAutotrackingSceneNode( SceneNode* source, SceneNode* target,
            const Vector3 &offset, const Vector3 &localDirection );
  virtual void _removeAutotrackingSceneNode( SceneNode* source );
        virtual AxisAlignedBoxSceneQuery*
            createAABBQuery(const AxisAlignedBox& box, uint32 mask = QUERY_ENTITY_DEFAULT_MASK);
        virtual SphereSceneQuery*
            createSphereQuery(const Sphere& sphere, uint32 mask = QUERY_ENTITY_DEFAULT_MASK);
        virtual PlaneBoundedVolumeListSceneQuery* createPlaneBoundedVolumeQuery(
                const PlaneBoundedVolumeList& volumes, uint32 mask = QUERY_ENTITY_DEFAULT_MASK);
        virtual RaySceneQuery* createRayQuery(const Ray& ray, uint32 mask = QUERY_ENTITY_DEFAULT_MASK);
        virtual IntersectionSceneQuery* createIntersectionQuery(uint32 mask = QUERY_ENTITY_DEFAULT_MASK);


        virtual void destroyQuery(SceneQuery* query);

        typedef VectorIterator<CameraList> CameraIterator;
        typedef MapIterator<AnimationList> AnimationIterator;



        CameraIterator getCameraIterator(void) {
            return CameraIterator(mCameras.begin(), mCameras.end());
        }


        const CameraList& getCameras() const { return mCameras; }

        AnimationIterator getAnimationIterator(void) {
            return AnimationIterator(mAnimationsList.begin(), mAnimationsList.end());
        }


        const AnimationList& getAnimations() const { return mAnimationsList; }

        v1::AnimationStateIterator getAnimationStateIterator(void) {
            return mAnimationStates.getAnimationStateIterator();
        }







        virtual void setShadowColour(const ColourValue& colour);






        virtual const ColourValue& getShadowColour(void) const;
        virtual void setShadowDirectionalLightExtrusionDistance(Real dist);


        virtual Real getShadowDirectionalLightExtrusionDistance(void) const;
        virtual void setShadowFarDistance(Real distance);



        virtual Real getShadowFarDistance(void) const
        { return mDefaultShadowFarDist; }
        virtual Real getShadowFarDistanceSquared(void) const
        { return mDefaultShadowFarDistSquared; }
        virtual void setShadowDirLightTextureOffset(Real offset) { mShadowTextureOffset = offset;}



        virtual Real getShadowDirLightTextureOffset(void) const { return mShadowTextureOffset; }







        virtual void setShadowTextureFadeStart(Real fadeStart)
        { mShadowTextureFadeStart = fadeStart; }







        virtual void setShadowTextureFadeEnd(Real fadeEnd)
        { mShadowTextureFadeEnd = fadeEnd; }
        virtual void setShadowTextureCasterMaterial(const String& name);

        void _setCurrentShadowNode( CompositorShadowNode *shadowNode, bool isReused );
        const CompositorShadowNode* getCurrentShadowNode(void) const { return mCurrentShadowNode; }
        bool isCurrentShadowNodeReused(void) const { return mShadowNodeIsReused; }






        virtual void setLateMaterialResolving(bool isLate) { mLateMaterialResolving = isLate; }



        virtual bool isLateMaterialResolving() const { return mLateMaterialResolving; }



        virtual void addListener(Listener* s);


        virtual void removeListener(Listener* s);
        virtual v1::StaticGeometry* createStaticGeometry(const String& name);



        virtual v1::StaticGeometry* getStaticGeometry(const String& name) const;

        virtual bool hasStaticGeometry(const String& name) const;

        virtual void destroyStaticGeometry(v1::StaticGeometry* geom);

        virtual void destroyStaticGeometry(const String& name);

        virtual void destroyAllStaticGeometry(void);
        virtual v1::InstanceManager* createInstanceManager( const String &customName,
                                                            const String &meshName,
                                                            const String &groupName,
                                                            v1::InstanceManager::InstancingTechnique technique,
                                                            size_t numInstancesPerBatch, uint16 flags=0,
                                                            unsigned short subMeshIdx=0 );




        virtual v1::InstanceManager* getInstanceManager( IdString name ) const;


    virtual bool hasInstanceManager( IdString managerName ) const;







        virtual void destroyInstanceManager( IdString name );
        virtual void destroyInstanceManager( v1::InstanceManager *instanceManager );

        virtual void destroyAllInstanceManagers(void);
        virtual size_t getNumInstancesPerBatch( const String &meshName, const String &groupName,
                                                const String &materialName,
                                                v1::InstanceManager::InstancingTechnique technique,
                                                size_t numInstancesPerBatch, uint16 flags=0,
                                                unsigned short subMeshIdx=0 );
        virtual v1::InstancedEntity* createInstancedEntity( const String &materialName,
                                                            const String &managerName );





        virtual void destroyInstancedEntity( v1::InstancedEntity *instancedEntity );
        virtual MovableObject* createMovableObject(const String& typeName,
                                                    ObjectMemoryManager *objectMemMgr,
                                                    const NameValuePairList* params = 0);



        virtual bool hasMovableObject( MovableObject *m );





        virtual void destroyMovableObject( MovableObject *m, const String& typeName );





        virtual void destroyMovableObject(MovableObject* m);

        virtual void destroyAllMovableObjectsByType(const String& typeName);

        virtual void destroyAllMovableObjects(void);
        typedef VectorIterator<MovableObjectVec> MovableObjectIterator;





        virtual MovableObjectIterator getMovableObjectIterator(const String& typeName);
        virtual void injectMovableObject(MovableObject* m);






        virtual void extractMovableObject(MovableObject* m);






        virtual void extractAllMovableObjectsByType(const String& typeName);







                   void setVisibilityMask(uint32 vmask)
                                { mVisibilityMask = vmask & VisibilityFlags::RESERVED_VISIBILITY_FLAGS; }




                   uint32 getVisibilityMask(void) const { return mVisibilityMask; }




        uint32 _getCombinedVisibilityMask(void) const;







        virtual void setFindVisibleObjects(bool find) { mFindVisibleObjects = find; }




        virtual bool getFindVisibleObjects(void) { return mFindVisibleObjects; }
        virtual void setFlipCullingOnNegativeScale(bool n) { mFlipCullingOnNegativeScale = n; }




        virtual bool getFlipCullingOnNegativeScale() const { return mFlipCullingOnNegativeScale; }

        virtual void _renderSingleObject( Renderable* pRend, const MovableObject *pMovableObject,
                                          bool casterPass, bool dualParaboloid );
        virtual void _injectRenderWithPass( Pass *pass, Renderable *rend, Camera *activeCamera=0,
                                            bool shadowDerivation = true,
                                            bool doLightIteration = false );
        virtual void _suppressRenderStateChanges(bool suppress);




        virtual bool _areRenderStateChangesSuppressed(void) const
        { return mSuppressRenderStateChanges; }
        virtual const Pass* _setPass(const Pass* pass,
            bool evenIfSuppressed = false, bool shadowDerivation = true);
        virtual void _markGpuParamsDirty(uint16 mask);




        RenderSystem *getDestinationRenderSystem();



        Viewport* getCurrentViewport(void) const { return mCurrentViewport; }



        Camera* getCameraInProgress(void) const { return mCameraInProgress; }

        AxisAlignedBox _calculateCurrentCastersBox( uint32 viewportVisibilityMask,
                                                    uint8 firstRq, uint8 lastRq ) const;





        const AxisAlignedBox& getCurrentCastersBox(void) const;





        void getMinMaxDepthRange( const Frustum *shadowMapCamera, Real &outMin, Real &outMax ) const;
        virtual void setRelativeOrigin( const Vector3 &relativeOrigin, bool bPermanent );


        Vector3 getRelativeOrigin(void) const;
        void addLodListener(LodListener *listener);






        void removeLodListener(LodListener *listener);


        void _notifyMovableObjectLodChanged(MovableObjectLodChangedEvent& evt);


        void _notifyEntityMeshLodChanged(EntityMeshLodChangedEvent& evt);


        void _notifyEntityMaterialLodChanged(EntityMaterialLodChangedEvent& evt);


        void _handleLodEvents();

        void _setCurrentRenderStage( IlluminationRenderStage stage ) { mIlluminationStage = stage; }
        IlluminationRenderStage _getCurrentRenderStage() const {return mIlluminationStage;}

    protected:

        void fireWorkerThreadsAndWait(void);





        void fireCullFrustumThreads( const CullFrustumRequest &request );
        void fireCullFrustumInstanceBatchThreads( const InstanceBatchCullRequest &request );
        void startWorkerThreads();
        void stopWorkerThreads();

    public:
        void executeUserScalableTask( UniformScalableTask *task, bool bBlock );





        void waitForPendingUserScalableTask();




        unsigned long _updateWorkerThread( ThreadHandle *threadHandle );
    };


    class DefaultIntersectionSceneQuery :
        public IntersectionSceneQuery
    {
    public:
        DefaultIntersectionSceneQuery(SceneManager* creator);
        ~DefaultIntersectionSceneQuery();


        void execute(IntersectionSceneQueryListener* listener);
    };


    class DefaultRaySceneQuery : public RaySceneQuery
    {
    public:
        DefaultRaySceneQuery(SceneManager* creator);
        ~DefaultRaySceneQuery();


        virtual void execute(RaySceneQueryListener* listener);
        bool execute( ObjectData objData, size_t numNodes, RaySceneQueryListener* listener );
    };

    class DefaultSphereSceneQuery : public SphereSceneQuery
    {
    public:
        DefaultSphereSceneQuery(SceneManager* creator);
        ~DefaultSphereSceneQuery();


        virtual void execute(SceneQueryListener* listener);
        bool execute( ObjectData objData, size_t numNodes, SceneQueryListener* listener );
    };

    class DefaultPlaneBoundedVolumeListSceneQuery : public PlaneBoundedVolumeListSceneQuery
    {
    public:
        DefaultPlaneBoundedVolumeListSceneQuery(SceneManager* creator);
        ~DefaultPlaneBoundedVolumeListSceneQuery();


        void execute(SceneQueryListener* listener);
        bool execute(ObjectData objData, size_t numNodes, SceneQueryListener* listener);
    private:

        struct ArrayPlane
        {
            ArrayVector3 planeNormal;
            ArrayVector3 signFlip;
            ArrayReal planeNegD;
        };


        RawSimdUniquePtr<ArrayPlane, MEMCATEGORY_GENERAL> mSimdPlaneList;
    };

    class DefaultAxisAlignedBoxSceneQuery : public AxisAlignedBoxSceneQuery
    {
    public:
        DefaultAxisAlignedBoxSceneQuery(SceneManager* creator);
        ~DefaultAxisAlignedBoxSceneQuery();


        virtual void execute(SceneQueryListener* listener);
        bool execute( ObjectData objData, size_t numNodes, SceneQueryListener* listener );
    };



    typedef uint16 SceneTypeMask;




    enum SceneType
    {
        ST_GENERIC = 1,
        ST_EXTERIOR_CLOSE = 2,
        ST_EXTERIOR_FAR = 4,
        ST_EXTERIOR_REAL_FAR = 8,
        ST_INTERIOR = 16
    };


    struct SceneManagerMetaData
    {

        String typeName;

        String description;

        SceneTypeMask sceneTypeMask;

        bool worldGeometrySupported;
    };




    class SceneManagerFactory : public SceneMgtAlloc
    {
    protected:
        mutable SceneManagerMetaData mMetaData;
        mutable bool mMetaDataInit;

        virtual void initMetaData(void) const = 0;
    public:
        SceneManagerFactory() : mMetaDataInit(true) {}
        virtual ~SceneManagerFactory() {}

        virtual const SceneManagerMetaData& getMetaData(void) const
        {
            if (mMetaDataInit)
            {
                initMetaData();
                mMetaDataInit = false;
            }
            return mMetaData;
        }




        virtual SceneManager* createInstance(const String& instanceName, size_t numWorkerThreads,
                                            InstancingThreadedCullingMethod threadedCullingMethod) = 0;

        virtual void destroyInstance(SceneManager* instance) = 0;

    };





}




namespace Ogre {
    class DefaultSceneManagerFactory : public SceneManagerFactory
    {
    protected:
        void initMetaData(void) const;
    public:
        DefaultSceneManagerFactory() {}
        ~DefaultSceneManagerFactory() {}

        static const String FACTORY_TYPE_NAME;
        SceneManager* createInstance(const String& instanceName, size_t numWorkerThreads,
                                    InstancingThreadedCullingMethod threadedCullingMethod);
        void destroyInstance(SceneManager* instance);
    };

    class DefaultSceneManager : public SceneManager
    {
    public:
        DefaultSceneManager(const String& name, size_t numWorkerThreads,
                            InstancingThreadedCullingMethod threadedCullingMethod);
        ~DefaultSceneManager();
        const String& getTypeName(void) const;
    };
    class SceneManagerEnumerator : public Singleton<SceneManagerEnumerator>, public SceneMgtAlloc
    {
    public:

        typedef map<String, SceneManager*>::type Instances;

        typedef vector<const SceneManagerMetaData*>::type MetaDataList;
    private:

        typedef list<SceneManagerFactory*>::type Factories;
        Factories mFactories;
        Instances mInstances;

        MetaDataList mMetaDataList;

        DefaultSceneManagerFactory mDefaultFactory;

        unsigned long mInstanceCreateCount;

        RenderSystem* mCurrentRenderSystem;


    public:
        SceneManagerEnumerator();
        ~SceneManagerEnumerator();





        void addFactory(SceneManagerFactory* fact);



        void removeFactory(SceneManagerFactory* fact);
        const SceneManagerMetaData* getMetaData(const String& typeName) const;

        typedef ConstVectorIterator<MetaDataList> MetaDataIterator;



        MetaDataIterator getMetaDataIterator(void) const;
        SceneManager* createSceneManager(const String& typeName, size_t numWorkerThreads,
            InstancingThreadedCullingMethod threadedCullingMethod,
            const String& instanceName = BLANKSTRING);
        SceneManager* createSceneManager(SceneTypeMask typeMask, size_t numWorkerThreads,
            InstancingThreadedCullingMethod threadedCullingMethod,
            const String& instanceName = BLANKSTRING );


        void destroySceneManager(SceneManager* sm);





        SceneManager* getSceneManager(const String& instanceName) const;




        bool hasSceneManager(const String& instanceName) const;

        typedef MapIterator<Instances> SceneManagerIterator;

        SceneManagerIterator getSceneManagerIterator(void);



        void setRenderSystem(RenderSystem* rs);


        void shutdownAll(void);
        static SceneManagerEnumerator& getSingleton(void);
        static SceneManagerEnumerator* getSingletonPtr(void);

    };




}









namespace Ogre
{







    class FrameStats;
    typedef vector<RenderSystem*>::type RenderSystemList;
    class Root : public Singleton<Root>, public RootAlloc
    {


        friend class RenderSystem;
    protected:
        RenderSystemList mRenderers;
        RenderSystem* mActiveRenderer;
        String mVersion;
        String mConfigFileName;
        bool mQueuedEnd;

        bool mFirstTimePostWindowInit;


        LogManager* mLogManager;
        ControllerManager* mControllerManager;
        SceneManagerEnumerator* mSceneManagerEnum;
        typedef deque<SceneManager*>::type SceneManagerStack;
        SceneManagerStack mSceneManagerStack;
        DynLibManager* mDynLibManager;
        ArchiveManager* mArchiveManager;
        MaterialManager* mMaterialManager;
        v1::MeshManager* mMeshManagerV1;
        MeshManager* mMeshManager;
        ParticleSystemManager* mParticleManager;
        v1::OldSkeletonManager* mOldSkeletonManager;
        SkeletonManager* mSkeletonManager;

        ArchiveFactory *mZipArchiveFactory;
        ArchiveFactory *mEmbeddedZipArchiveFactory;
        ArchiveFactory *mFileSystemArchiveFactory;





        ResourceGroupManager* mResourceGroupManager;
        ResourceBackgroundQueue* mResourceBackgroundQueue;
        ShadowTextureManager* mShadowTextureManager;
        RenderSystemCapabilitiesManager* mRenderSystemCapabilitiesManager;
        ScriptCompilerManager *mCompilerManager;
        LodStrategyManager *mLodStrategyManager;

        FrameStats* mFrameStats;
        Timer* mTimer;
        RenderWindow* mAutoWindow;
        Profiler* mProfiler;
        HighLevelGpuProgramManager* mHighLevelGpuProgramManager;
        ExternalTextureSourceManager* mExternalTextureSourceManager;
        HlmsManager *mHlmsManager;
        HlmsLowLevel *mHlmsLowLevelProxy;
        CompositorManager2 *mCompositorManager2;
        unsigned long mNextFrame;
        Real mFrameSmoothingTime;
        bool mRemoveQueueStructuresOnClear;
        Real mDefaultMinPixelSize;
        v1::HardwareBuffer::UploadOptions mFreqUpdatedBuffersUploadOption;

    public:
        typedef vector<DynLib*>::type PluginLibList;
        typedef vector<Plugin*>::type PluginInstanceList;
    protected:

        PluginLibList mPluginLibs;

        PluginInstanceList mPlugins;

        typedef map<String, MovableObjectFactory*>::type MovableObjectFactoryMap;
        MovableObjectFactoryMap mMovableObjectFactoryMap;
        uint32 mNextMovableObjectTypeFlag;

        MovableObjectFactory* mEntityFactory;
        MovableObjectFactory* mItemFactory;
        MovableObjectFactory* mLightFactory;
        MovableObjectFactory* mBillboardSetFactory;
        MovableObjectFactory* mManualObjectFactory;
        MovableObjectFactory* mBillboardChainFactory;
        MovableObjectFactory* mRibbonTrailFactory;


        bool mIsInitialised;

        WorkQueue* mWorkQueue;


        bool mIsBlendIndicesGpuRedundant;

        bool mIsBlendWeightsGpuRedundant;
        void loadPlugins(const String& pluginsfile = "plugins" "" ".cfg");



        void initialisePlugins();



        void shutdownPlugins();



        void unloadPlugins();


        void oneTimePostWindowInit(void);


        set<FrameListener*>::type mFrameListeners;


        set<FrameListener*>::type mRemovedFrameListeners;
        set<FrameListener*>::type mAddedFrameListeners;
        void _syncAddedRemovedFrameListeners();


        enum FrameEventTimeType {
            FETT_ANY = 0,
            FETT_STARTED = 1,
            FETT_QUEUED = 2,
            FETT_ENDED = 3,
            FETT_COUNT = 4
        };


        typedef deque<unsigned long>::type EventTimesQueue;
        EventTimesQueue mEventTimes[FETT_COUNT];





        Real calculateEventTime(unsigned long now, FrameEventTimeType type);


        void populateFrameEvent(FrameEventTimeType type, FrameEvent& evtToUpdate);

    public:
        Root(const String& pluginFileName = "plugins" "" ".cfg",
            const String& configFileName = "ogre.cfg",
            const String& logFileName = "Ogre.log");
        ~Root();






        void saveConfig(void);
        bool restoreConfig(void);
        bool showConfigDialog(void);
        void addRenderSystem(RenderSystem* newRend);







        const RenderSystemList& getAvailableRenderers(void);







        RenderSystem* getRenderSystemByName(const String& name);
        void setRenderSystem(RenderSystem* system);



        RenderSystem* getRenderSystem(void);


        HlmsManager* getHlmsManager(void) const { return mHlmsManager; }

        CompositorManager2* getCompositorManager2() const { return mCompositorManager2; }
        RenderWindow* initialise(bool autoCreateWindow, const String& windowTitle = "OGRE Render Window",
                                    const String& customCapabilitiesConfig = BLANKSTRING);


  bool isInitialised(void) const { return mIsInitialised; }






        void useCustomRenderSystemCapabilities(RenderSystemCapabilities* capabilities);




        bool getRemoveRenderQueueStructuresOnClear() const { return mRemoveQueueStructuresOnClear; }




        void setRemoveRenderQueueStructuresOnClear(bool r) { mRemoveQueueStructuresOnClear = r; }






        void addSceneManagerFactory(SceneManagerFactory* fact);



        void removeSceneManagerFactory(SceneManagerFactory* fact);
        const SceneManagerMetaData* getSceneManagerMetaData(const String& typeName) const;




        SceneManagerEnumerator::MetaDataIterator getSceneManagerMetaDataIterator(void) const;
        SceneManager* createSceneManager(const String& typeName, size_t numWorkerThreads,
                                        InstancingThreadedCullingMethod threadedCullingMethod,
                                        const String& instanceName = BLANKSTRING);
        SceneManager* createSceneManager(SceneTypeMask typeMask, size_t numWorkerThreads,
                                        InstancingThreadedCullingMethod threadedCullingMethod,
                                        const String& instanceName = BLANKSTRING);


        void destroySceneManager(SceneManager* sm);





        SceneManager* getSceneManager(const String& instanceName) const;




        bool hasSceneManager(const String& instanceName) const;

        SceneManagerEnumerator::SceneManagerIterator getSceneManagerIterator(void);
        TextureManager* getTextureManager(void);






        v1::MeshManager* getMeshManagerV1(void);




        String getErrorDescription(long errorNumber);
        void addFrameListener(FrameListener* newListener);





        void removeFrameListener(FrameListener* oldListener);
        void queueEndRendering(bool state = true);







        bool endRenderingQueued(void);

        const FrameStats* getFrameStats(void) const { return mFrameStats; }
        void startRendering(void);






        bool renderOneFrame(void);







        bool renderOneFrame(Real timeSinceLastFrame);
        void shutdown(void);
        void addResourceLocation(const String& name, const String& locType,
            const String& groupName = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
            bool recursive = false);







        void removeResourceLocation(const String& name,
            const String& groupName = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
        DataStreamPtr createFileStream(const String& filename, const String& groupName = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
            bool overwrite = false, const String& locationPattern = BLANKSTRING);
        DataStreamPtr openFileStream(const String& filename, const String& groupName = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
            const String& locationPattern = BLANKSTRING);
        void convertColourValue(const ColourValue& colour, uint32* pDest);
        RenderWindow* getAutoCreatedWindow(void);



        RenderWindow* createRenderWindow(const String &name, unsigned int width, unsigned int height,
            bool fullScreen, const NameValuePairList *miscParams = 0) ;



        bool createRenderWindows(const RenderWindowDescriptionList& renderWindowDescriptions,
            RenderWindowList& createdWindows);






        RenderTarget* detachRenderTarget( RenderTarget* pWin );






        RenderTarget* detachRenderTarget( const String & name );



        void destroyRenderTarget(RenderTarget* target);



        void destroyRenderTarget(const String &name);



        RenderTarget * getRenderTarget(const String &name);
        void loadPlugin(const String& pluginName);
        void unloadPlugin(const String& pluginName);
        void installPlugin(Plugin* plugin);
        void uninstallPlugin(Plugin* plugin);


        const PluginInstanceList& getInstalledPlugins() const { return mPlugins; }


        Timer* getTimer(void);
        bool _fireFrameStarted(FrameEvent& evt);
        bool _fireFrameRenderingQueued(FrameEvent& evt);
        bool _fireFrameEnded(FrameEvent& evt);
        bool _fireFrameStarted();
        bool _fireFrameRenderingQueued();
        bool _fireFrameEnded();
        unsigned long getNextFrameNumber(void) const { return mNextFrame; }






        SceneManager* _getCurrentSceneManager(void) const;




        void _pushCurrentSceneManager(SceneManager* sm);




        void _popCurrentSceneManager(SceneManager* sm);
        bool _updateAllRenderTargets(void);
        bool _updateAllRenderTargets(FrameEvent& evt);
        static Root& getSingleton(void);
        static Root* getSingletonPtr(void);
        void clearEventTimes(void);
        void setFrameSmoothingPeriod(Real period) { mFrameSmoothingTime = period; }

        Real getFrameSmoothingPeriod(void) const { return mFrameSmoothingTime; }
        void addMovableObjectFactory(MovableObjectFactory* fact,
            bool overrideExisting = false);







        void removeMovableObjectFactory(MovableObjectFactory* fact);

        bool hasMovableObjectFactory(const String& typeName) const;

        MovableObjectFactory* getMovableObjectFactory(const String& typeName);

        typedef ConstMapIterator<MovableObjectFactoryMap> MovableObjectFactoryIterator;



        MovableObjectFactoryIterator getMovableObjectFactoryIterator(void) const;




        unsigned int getDisplayMonitorCount() const;







        WorkQueue* getWorkQueue() const { return mWorkQueue; }
        void setWorkQueue(WorkQueue* queue);







        void setBlendIndicesGpuRedundant(bool redundant) { mIsBlendIndicesGpuRedundant = redundant; }



        bool isBlendIndicesGpuRedundant() const { return mIsBlendIndicesGpuRedundant; }







        void setBlendWeightsGpuRedundant(bool redundant) { mIsBlendWeightsGpuRedundant = redundant; }



        bool isBlendWeightsGpuRedundant() const { return mIsBlendWeightsGpuRedundant; }





        void setDefaultMinPixelSize(Real pixelSize) { mDefaultMinPixelSize = pixelSize; }



        Real getDefaultMinPixelSize() { return mDefaultMinPixelSize; }






        void setFreqUpdatedBuffersUploadOption(v1::HardwareBuffer::UploadOptions uploadOp) { mFreqUpdatedBuffersUploadOption = uploadOp; }




        v1::HardwareBuffer::UploadOptions getFreqUpdatedBuffersUploadOption() const { return mFreqUpdatedBuffersUploadOption; }

    };


}




namespace Ogre {
namespace v1 {
    class SimpleRenderable : public MovableObject, public Renderable
    {
    protected:
        RenderOperation mRenderOp;

        Matrix4 mWorldTransform;
        AxisAlignedBox mBox;

        String mMatName;
        MaterialPtr mMaterial;


        SceneManager *mParentSceneManager;

    public:

        SimpleRenderable( IdType id, ObjectMemoryManager *objectMemoryManager, SceneManager *manager );

        virtual void setMaterial( const String& matName );
        virtual const MaterialPtr& getMaterial(void) const;

        virtual void setRenderOperation( const RenderOperation& rend );
        virtual void getRenderOperation(RenderOperation& op, bool casterPass);

        void setWorldTransform( const Matrix4& xform );
        virtual void getWorldTransforms( Matrix4* xform ) const;

        void setBoundingBox( const AxisAlignedBox& box );
        virtual const AxisAlignedBox& getBoundingBox(void) const;

        virtual ~SimpleRenderable();


        virtual const String& getMovableType(void) const;


        const LightList& getLights(void) const;

    };


}
}




namespace Ogre {
namespace v1 {
    enum SkeletonAnimationBlendMode {

        ANIMBLEND_AVERAGE = 0,

        ANIMBLEND_CUMULATIVE = 1
    };




    struct LinkedSkeletonAnimationSource;
    class Skeleton : public Resource, public AnimationContainer
    {
        friend class OldSkeletonInstance;
    protected:

        Skeleton();

    public:





        Skeleton(ResourceManager* creator, const String& name, ResourceHandle handle,
            const String& group, bool isManual = false, ManualResourceLoader* loader = 0);
        virtual ~Skeleton();
        virtual OldBone* createBone(void);
        virtual OldBone* createBone(unsigned short handle);
        virtual OldBone* createBone(const String& name);
        virtual OldBone* createBone(const String& name, unsigned short handle);


        virtual unsigned short getNumBones(void) const;
        virtual OldBone* getRootBone(void) const;

        typedef vector<OldBone*>::type BoneList;
        typedef VectorIterator<BoneList> BoneIterator;
        typedef ConstVectorIterator<BoneList> ConstBoneIterator;

        virtual BoneIterator getRootBoneIterator(void);

        virtual BoneIterator getBoneIterator(void);
        ConstBoneIterator getBoneIteratorConst(void) const;


        virtual OldBone* getBone(unsigned short handle) const;


        virtual OldBone* getBone(const String& name) const;


        virtual bool hasBone(const String& name) const;




        virtual void setBindingPose(void);
        virtual void reset(bool resetManualBones = false);





        virtual Animation* createAnimation(const String& name, Real length);
        virtual Animation* getAnimation(const String& name,
            const LinkedSkeletonAnimationSource** linker) const;







        virtual Animation* getAnimation(const String& name) const;


        virtual Animation* _getAnimationImpl(const String& name,
            const LinkedSkeletonAnimationSource** linker = 0) const;



        virtual bool hasAnimation(const String& name) const;


        virtual void removeAnimation(const String& name);
        virtual void setAnimationState(const AnimationStateSet& animSet);






        virtual void _initAnimationState(AnimationStateSet* animSet);





        virtual void _refreshAnimationState(AnimationStateSet* animSet);







        virtual void _getBoneMatrices(Matrix4* pMatrices);


        virtual unsigned short getNumAnimations(void) const;






        virtual Animation* getAnimation(unsigned short index) const;



        virtual SkeletonAnimationBlendMode getBlendMode() const;

        virtual void setBlendMode(SkeletonAnimationBlendMode state);


        virtual void _updateTransforms(void);






        virtual void optimiseAllAnimations(bool preservingIdentityNodeTracks = false);
        virtual void addLinkedSkeletonAnimationSource(const String& skelName,
            Real scale = 1.0f);

        virtual void removeAllLinkedSkeletonAnimationSources(void);

        typedef vector<LinkedSkeletonAnimationSource>::type
            LinkedSkeletonAnimSourceList;
        typedef ConstVectorIterator<LinkedSkeletonAnimSourceList>
            LinkedSkeletonAnimSourceIterator;

        virtual LinkedSkeletonAnimSourceIterator
            getLinkedSkeletonAnimationSourceIterator(void) const;


        virtual void _notifyManualBonesDirty(void);

        virtual void _notifyManualBoneStateChange(OldBone* bone);


        virtual bool getManualBonesDirty(void) const { return mManualBonesDirty; }

        virtual bool hasManualBones(void) const { return !mManualBones.empty(); }


        typedef vector<ushort>::type BoneHandleMap;
        virtual void _mergeSkeletonAnimations(const Skeleton* source,
            const BoneHandleMap& boneHandleMap,
            const StringVector& animations = StringVector());





        virtual void _buildMapBoneByHandle(const Skeleton* source,
            BoneHandleMap& boneHandleMap) const;





        virtual void _buildMapBoneByName(const Skeleton* source,
            BoneHandleMap& boneHandleMap) const;

    protected:
        SkeletonAnimationBlendMode mBlendState;

        BoneList mBoneList;

        typedef map<String, OldBone*>::type BoneListByName;
        BoneListByName mBoneListByName;



        mutable BoneList mRootBones;

        unsigned short mNextAutoHandle;
        typedef set<OldBone*>::type BoneSet;

        BoneSet mManualBones;

        bool mManualBonesDirty;



        typedef map<String, Animation*>::type AnimationList;
        AnimationList mAnimationsList;


        mutable LinkedSkeletonAnimSourceList mLinkedSkeletonAnimSourceList;






        void deriveRootBone(void) const;


        void _dumpContents(const String& filename);



        void loadImpl(void);



        void unloadImpl(void);

        size_t calculateSize(void) const;

    };


    struct LinkedSkeletonAnimationSource
    {
        String skeletonName;
        SkeletonPtr pSkeleton;
        Real scale;
        LinkedSkeletonAnimationSource(const String& skelName, Real scl)
            : skeletonName(skelName), scale(scl) {}
            LinkedSkeletonAnimationSource(const String& skelName, Real scl,
                SkeletonPtr skelPtr)
                : skeletonName(skelName), pSkeleton(skelPtr), scale(scl) {}
    };


}
}



namespace Ogre {
namespace v1 {
    class OldSkeletonInstance : public Skeleton
    {
    public:



        OldSkeletonInstance(const SkeletonPtr& masterCopy);
        ~OldSkeletonInstance();


        unsigned short getNumAnimations(void) const;


        Animation* getAnimation(unsigned short index) const;

        Animation* _getAnimationImpl(const String& name,
            const LinkedSkeletonAnimationSource** linker = 0) const;







        Animation* createAnimation(const String& name, Real length);


        Animation* getAnimation(const String& name,
            const LinkedSkeletonAnimationSource** linker = 0) const;





        void removeAnimation(const String& name);



        TagPoint* createTagPointOnBone(OldBone* bone,
            const Quaternion &offsetOrientation = Quaternion::IDENTITY,
            const Vector3 &offsetPosition = Vector3::ZERO);


        void freeTagPoint(TagPoint* tagPoint);


        void addLinkedSkeletonAnimationSource(const String& skelName,
            Real scale = 1.0f);

        void removeAllLinkedSkeletonAnimationSources(void);

        LinkedSkeletonAnimSourceIterator
            getLinkedSkeletonAnimationSourceIterator(void) const;


        void _initAnimationState(AnimationStateSet* animSet);


        void _refreshAnimationState(AnimationStateSet* animSet);


        const String& getName(void) const;

        ResourceHandle getHandle(void) const;

        const String& getGroup(void) const;

    protected:

        SkeletonPtr mSkeleton;

        typedef list<TagPoint*>::type TagPointList;
        TagPointList mActiveTagPoints;
        TagPointList mFreeTagPoints;


        unsigned short mNextTagPointAutoHandle;

        void cloneBoneAndChildren(OldBone* source, OldBone* parent);


        void loadImpl(void);


        void unloadImpl(void);

    };



}
}


namespace Ogre {
namespace v1 {
    class OldSkeletonManager: public ResourceManager, public Singleton<OldSkeletonManager>
    {
    public:

        OldSkeletonManager();
        ~OldSkeletonManager();



        SkeletonPtr create (const String& name, const String& group,
                            bool isManual = false, ManualResourceLoader* loader = 0,
                            const NameValuePairList* createParams = 0);



        SkeletonPtr getByName(const String& name, const String& groupName = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME);
        static OldSkeletonManager& getSingleton(void);
        static OldSkeletonManager* getSingletonPtr(void);
    protected:


        Resource* createImpl(const String& name, ResourceHandle handle,
            const String& group, bool isManual, ManualResourceLoader* loader,
            const NameValuePairList* createParams);

    };



}
}
namespace Ogre {
namespace v1 {

    struct LinkedSkeletonAnimationSource;


    enum SkeletonVersion
    {

        SKELETON_VERSION_1_0,

        SKELETON_VERSION_1_8,


        SKELETON_VERSION_LATEST = 100
    };
    class SkeletonSerializer : public Serializer
    {

    public:
        SkeletonSerializer();
        virtual ~SkeletonSerializer();
        void exportSkeleton(const Skeleton* pSkeleton, const String& filename,
            SkeletonVersion ver = SKELETON_VERSION_LATEST, Endian endianMode = ENDIAN_NATIVE);
        void exportSkeleton(const Skeleton* pSkeleton, DataStreamPtr stream,
            SkeletonVersion ver = SKELETON_VERSION_LATEST, Endian endianMode = ENDIAN_NATIVE);







        void importSkeleton(DataStreamPtr& stream, Skeleton* pDest);



    protected:

        void setWorkingVersion(SkeletonVersion ver);


        void writeSkeleton(const Skeleton* pSkel, SkeletonVersion ver);
        void writeBone(const Skeleton* pSkel, const OldBone* pBone);
        void writeBoneParent(const Skeleton* pSkel, unsigned short boneId, unsigned short parentId);
        void writeAnimation(const Skeleton* pSkel, const Animation* anim, SkeletonVersion ver);
        void writeAnimationTrack(const Skeleton* pSkel, const OldNodeAnimationTrack* track);
        void writeKeyFrame(const Skeleton* pSkel, const TransformKeyFrame* key);
        void writeSkeletonAnimationLink(const Skeleton* pSkel,
            const LinkedSkeletonAnimationSource& link);


        void readFileHeader(DataStreamPtr& stream);
        void readBone(DataStreamPtr& stream, Skeleton* pSkel);
        void readBoneParent(DataStreamPtr& stream, Skeleton* pSkel);
        void readAnimation(DataStreamPtr& stream, Skeleton* pSkel);
        void readAnimationTrack(DataStreamPtr& stream, Animation* anim, Skeleton* pSkel);
        void readKeyFrame(DataStreamPtr& stream, OldNodeAnimationTrack* track, Skeleton* pSkel);
        void readSkeletonAnimationLink(DataStreamPtr& stream, Skeleton* pSkel);

        size_t calcBoneSize(const Skeleton* pSkel, const OldBone* pBone);
        size_t calcBoneSizeWithoutScale(const Skeleton* pSkel, const OldBone* pBone);
        size_t calcBoneParentSize(const Skeleton* pSkel);
        size_t calcAnimationSize(const Skeleton* pSkel, const Animation* pAnim, SkeletonVersion ver);
        size_t calcAnimationTrackSize(const Skeleton* pSkel, const OldNodeAnimationTrack* pTrack);
        size_t calcKeyFrameSize(const Skeleton* pSkel, const TransformKeyFrame* pKey);
        size_t calcKeyFrameSizeWithoutScale(const Skeleton* pSkel, const TransformKeyFrame* pKey);
        size_t calcSkeletonAnimationLinkSize(const Skeleton* pSkel,
            const LinkedSkeletonAnimationSource& link);




    };


}
}

namespace Ogre {
namespace v1 {
    class StaticGeometry : public BatchedGeometryAlloc
    {
    public:
        class OptimisedSubMeshGeometry : public BatchedGeometryAlloc
        {
        public:
            OptimisedSubMeshGeometry() :vertexData(0), indexData(0) {}
            ~OptimisedSubMeshGeometry()
            {
                delete vertexData;
                delete indexData;
            }
            VertexData *vertexData;
            IndexData *indexData;
        };
        typedef list<OptimisedSubMeshGeometry*>::type OptimisedSubMeshGeometryList;


        struct SubMeshLodGeometryLink
        {
            VertexData* vertexData;
            IndexData* indexData;
        };
        typedef vector<SubMeshLodGeometryLink>::type SubMeshLodGeometryLinkList;
        typedef map<SubMesh*, SubMeshLodGeometryLinkList*>::type SubMeshGeometryLookup;

        struct QueuedSubMesh : public BatchedGeometryAlloc
        {
            SubMesh* submesh;

            SubMeshLodGeometryLinkList* geometryLodList;
            String materialName;
            Vector3 position;
            Quaternion orientation;
            Vector3 scale;

            AxisAlignedBox worldBounds;
        };
        typedef vector<QueuedSubMesh*>::type QueuedSubMeshList;

        struct QueuedGeometry : public BatchedGeometryAlloc
        {
            SubMeshLodGeometryLink* geometry;
            Vector3 position;
            Quaternion orientation;
            Vector3 scale;
        };
        typedef vector<QueuedGeometry*>::type QueuedGeometryList;


        class LODBucket;
        class MaterialBucket;
        class Region;





        class GeometryBucket : public Renderable, public BatchedGeometryAlloc
        {
        protected:

            QueuedGeometryList mQueuedGeometry;

            MaterialBucket* mParent;

            String mFormatString;


            VertexData* mVertexData;


            IndexData* mIndexData;

            HardwareIndexBuffer::IndexType mIndexType;

            size_t mMaxVertexIndex;

            template<typename T>
            void copyIndexes(const T* src, T* dst, size_t count, size_t indexOffset)
            {
                if (indexOffset == 0)
                {
                    memcpy(dst, src, sizeof(T) * count);
                }
                else
                {
                    while(count--)
                    {
                        *dst++ = static_cast<T>(*src++ + indexOffset);
                    }
                }
            }
        public:
            GeometryBucket(MaterialBucket* parent, const String& formatString,
                const VertexData* vData, const IndexData* iData);
            virtual ~GeometryBucket();
            MaterialBucket* getParent(void) { return mParent; }

            const VertexData* getVertexData(void) const { return mVertexData; }

            const IndexData* getIndexData(void) const { return mIndexData; }

            const MaterialPtr& getMaterial(void) const;
            Technique* getTechnique(void) const;
            void getRenderOperation(RenderOperation& op, bool casterPass);
            void getWorldTransforms(Matrix4* xform) const;
            Real getSquaredViewDepth(const Camera* cam) const;
            const LightList& getLights(void) const;
            bool getCastsShadows(void) const;




            bool assign(QueuedGeometry* qsm);

            void build();

            void dump(std::ofstream& of) const;
        };


        class MaterialBucket : public BatchedGeometryAlloc
        {
        public:

            typedef vector<GeometryBucket*>::type GeometryBucketList;
        protected:

            LODBucket* mParent;

            String mMaterialName;

            MaterialPtr mMaterial;

            Technique* mTechnique;


            GeometryBucketList mGeometryBucketList;

            typedef map<String, GeometryBucket*>::type CurrentGeometryMap;
            CurrentGeometryMap mCurrentGeometryMap;

            String getGeometryFormatString(SubMeshLodGeometryLink* geom);

        public:
            MaterialBucket(LODBucket* parent, const String& materialName);
            virtual ~MaterialBucket();
            LODBucket* getParent(void) { return mParent; }

            const String& getMaterialName(void) const { return mMaterialName; }

            void assign(QueuedGeometry* qsm);

            void build();

            void addRenderables(RenderQueue* queue, uint8 group,
                size_t materialLod);

            const MaterialPtr& getMaterial(void) const { return mMaterial; }

            typedef VectorIterator<GeometryBucketList> GeometryIterator;

            GeometryIterator getGeometryIterator(void);

            Technique* getCurrentTechnique(void) const { return mTechnique; }

            void dump(std::ofstream& of) const;
        };





        class LODBucket : public BatchedGeometryAlloc
        {
        public:

            typedef map<String, MaterialBucket*>::type MaterialBucketMap;
        protected:

            Region* mParent;

            unsigned short mLod;

            Real mLodValue;

            MaterialBucketMap mMaterialBucketMap;

            QueuedGeometryList mQueuedGeometryList;

            EdgeData* mEdgeList;

            bool mVertexProgramInUse;
        public:
            LODBucket(Region* parent, unsigned short lod, Real lodValue);
            virtual ~LODBucket();
            Region* getParent(void) { return mParent; }

            ushort getLod(void) const { return mLod; }

            Real getLodValue(void) const { return mLodValue; }

            void assign(QueuedSubMesh* qsm, ushort atLod);

            void build();

            void addRenderables(RenderQueue* queue, uint8 group,
                const FastArray<unsigned char> &currentMatLod);

            typedef MapIterator<MaterialBucketMap> MaterialIterator;

            MaterialIterator getMaterialIterator(void);
            size_t getNumMaterials(void) const { return mMaterialBucketMap.size(); }

            void dump(std::ofstream& of) const;
            EdgeData* getEdgeList() const { return mEdgeList; }
            bool isVertexProgramInUse() const { return mVertexProgramInUse; }

        };
        class Region : public MovableObject
        {
            friend class MaterialBucket;
            friend class GeometryBucket;
        public:

            typedef vector<LODBucket*>::type LODBucketList;
        protected:

            StaticGeometry* mParent;

            SceneManager* mSceneMgr;

            SceneNode* mNode;

            QueuedSubMeshList mQueuedSubMeshes;

            uint32 mRegionID;

            Vector3 mCentre;

            Mesh::LodValueArray mLodValues;

            LODBucketList mLodBucketList;

            mutable LightList mLightList;

            mutable ulong mLightListUpdated;

            Camera const *mCamera;

            Real mSquaredViewDepth;

        public:
            Region( IdType id, ObjectMemoryManager *objectMemoryManager, StaticGeometry* parent,
                    SceneManager* mgr, uint32 regionID, const Vector3& centre );
            virtual ~Region();

            StaticGeometry* getParent(void) const { return mParent;}

            void assign(QueuedSubMesh* qmesh);

            void build( bool parentVisible );

            uint32 getID(void) const { return mRegionID; }

            const Vector3& getCentre(void) const { return mCentre; }
            const String& getMovableType(void) const;
            void _updateRenderQueue(RenderQueue* queue, Camera *camera, const Camera *lodCamera);
            uint32 getTypeFlags(void) const;

            typedef VectorIterator<LODBucketList> LODIterator;

            LODIterator getLODIterator(void);

            EdgeData* getEdgeList(void);

            bool hasEdgeList(void);


            void dump(std::ofstream& of) const;

        };







        typedef map<uint32, Region*>::type RegionMap;
    protected:

        SceneManager* mOwner;
        String mName;
        bool mBuilt;
        Real mUpperDistance;
        Real mSquaredUpperDistance;
        bool mCastShadows;
        Vector3 mRegionDimensions;
        Vector3 mHalfRegionDimensions;
        Vector3 mOrigin;
        bool mVisible;

        uint8 mRenderQueueID;

        bool mRenderQueueIDSet;

        uint32 mVisibilityFlags;

        QueuedSubMeshList mQueuedSubMeshes;



        OptimisedSubMeshGeometryList mOptimisedSubMeshGeometryList;





        SubMeshGeometryLookup mSubMeshGeometryLookup;


        RegionMap mRegionMap;




        virtual Region* getRegion(const AxisAlignedBox& bounds, bool autoCreate);

        virtual Region* getRegion(const Vector3& point, bool autoCreate);

        virtual Region* getRegion(ushort x, ushort y, ushort z, bool autoCreate);

        virtual Region* getRegion(uint32 index);


        virtual void getRegionIndexes(const Vector3& point,
            ushort& x, ushort& y, ushort& z);


        virtual uint32 packIndex(ushort x, ushort y, ushort z);


        virtual Real getVolumeIntersection(const AxisAlignedBox& box,
            ushort x, ushort y, ushort z);


        virtual AxisAlignedBox getRegionBounds(ushort x, ushort y, ushort z);


        virtual Vector3 getRegionCentre(ushort x, ushort y, ushort z);

        virtual AxisAlignedBox calculateBounds(VertexData* vertexData,
            const Vector3& position, const Quaternion& orientation,
            const Vector3& scale);

        SubMeshLodGeometryLinkList* determineGeometry(SubMesh* sm);

        void splitGeometry(VertexData* vd, IndexData* id,
            SubMeshLodGeometryLink* targetGeomLink);

        typedef map<size_t, size_t>::type IndexRemap;




        template <typename T>
        void buildIndexRemap(T* pBuffer, size_t numIndexes, IndexRemap& remap)
        {
            remap.clear();
            for (size_t i = 0; i < numIndexes; ++i)
            {

                remap.insert(IndexRemap::value_type(*pBuffer++, remap.size()));


            }
        }

        template <typename T>
        void remapIndexes(T* src, T* dst, const IndexRemap& remap,
                size_t numIndexes)
        {
            for (size_t i = 0; i < numIndexes; ++i)
            {

                IndexRemap::const_iterator ix = remap.find(*src++);
                assert(ix != remap.end());
                *dst++ = static_cast<T>(ix->second);
            }
        }

    public:

        StaticGeometry(SceneManager* owner, const String& name);

        virtual ~StaticGeometry();


        const String& getName(void) const { return mName; }
        virtual void addEntity(Entity* ent, const Vector3& position,
            const Quaternion& orientation = Quaternion::IDENTITY,
            const Vector3& scale = Vector3::UNIT_SCALE);
        virtual void addSceneNode(const SceneNode* node);
        virtual void build(void);






        virtual void destroy(void);




        virtual void reset(void);
        virtual void setRenderingDistance(Real dist) {
            mUpperDistance = dist;
            mSquaredUpperDistance = mUpperDistance * mUpperDistance;
        }


        virtual Real getRenderingDistance(void) const { return mUpperDistance; }


        virtual Real getSquaredRenderingDistance(void) const
        { return mSquaredUpperDistance; }


        virtual void setVisible(bool visible);


        virtual bool isVisible(void) const { return mVisible; }
        virtual void setCastShadows(bool castShadows);

        virtual bool getCastShadows(void) { return mCastShadows; }
        virtual void setRegionDimensions(const Vector3& size) {
            mRegionDimensions = size;
            mHalfRegionDimensions = size * 0.5;
        }

        virtual const Vector3& getRegionDimensions(void) const { return mRegionDimensions; }
        virtual void setOrigin(const Vector3& origin) { mOrigin = origin; }

        virtual const Vector3& getOrigin(void) const { return mOrigin; }


        void setVisibilityFlags(uint32 flags);

        uint32 getVisibilityFlags() const;
        virtual void setRenderQueueGroup(uint8 queueID);


        virtual uint8 getRenderQueueGroup(void) const;


        typedef MapIterator<RegionMap> RegionIterator;

        RegionIterator getRegionIterator(void);




        virtual void dump(const String& filename) const;


    };



}
}







namespace Ogre {
namespace v1 {
    class SubMesh : public SubMeshAlloc
    {
        friend class Mesh;
        friend class MeshSerializerImpl;
        friend class MeshSerializerImpl_v1_2;
        friend class MeshSerializerImpl_v1_1;
    public:
        SubMesh();
        ~SubMesh();


        bool useSharedVertices;

        uint32 renderOpMeshIndex;


        RenderOperation::OperationType operationType;
        VertexData *vertexData[NumVertexPass];


        IndexData *indexData[NumVertexPass];
        typedef FastArray<unsigned short> IndexMap;
        IndexMap blendIndexToBoneIndexMap;

        typedef vector<IndexData*>::type LODFaceList;
        LODFaceList mLodFaceList[NumVertexPass];
        vector<Vector3>::type extremityPoints;


        Mesh* parent;


        void setMaterialName(const String& matName, const String& groupName = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME );
        const String& getMaterialName(void) const;



        bool isMatInitialised(void) const;







        void _getRenderOperation(RenderOperation& rend, ushort lodIndex, bool casterPass);
        void addBoneAssignment(const VertexBoneAssignment& vertBoneAssign);






        void clearBoneAssignments(void);


        typedef multimap<size_t, VertexBoneAssignment>::type VertexBoneAssignmentList;
        typedef MapIterator<VertexBoneAssignmentList> BoneAssignmentIterator;





        BoneAssignmentIterator getBoneAssignmentIterator(void);



        const VertexBoneAssignmentList& getBoneAssignments() { return mBoneAssignments; }



        void _compileBoneAssignments(void);

        typedef ConstMapIterator<AliasTextureNamePairList> AliasTextureIterator;



        AliasTextureIterator getAliasTextureIterator(void) const;
        void addTextureAlias(const String& aliasName, const String& textureName);





        void removeTextureAlias(const String& aliasName);


        void removeAllTextureAliases(void);


        bool hasTextureAliases(void) const { return !mTextureAliases.empty(); }


        size_t getTextureAliasCount(void) const { return mTextureAliases.size(); }
        bool updateMaterialUsingTextureAliases(void);



        VertexAnimationType getVertexAnimationType(void) const;


        bool getVertexAnimationIncludesNormals() const { return mVertexAnimationIncludesNormals; }






        void generateExtremes(size_t count);



        bool isBuildEdgesEnabled(void) const { return mBuildEdgesEnabled; }
        void setBuildEdgesEnabled(bool b);







        SubMesh * clone(const String& newName, Mesh *parentMesh = 0);


        void importFromV2( Ogre::SubMesh *subMesh );

        void arrangeEfficient( bool halfPos, bool halfTexCoords, bool qTangents );

        void dearrangeToInefficient(void);

    protected:

        void arrangeEfficient( bool halfPos, bool halfTexCoords, bool qTangents, size_t vaoPassIdx );

    protected:


        String mMaterialName;


        bool mMatInitialised;


        AliasTextureNamePairList mTextureAliases;

        VertexBoneAssignmentList mBoneAssignments;


        bool mBoneAssignmentsOutOfDate;


        mutable VertexAnimationType mVertexAnimationType;


        mutable bool mVertexAnimationIncludesNormals;


        bool mBuildEdgesEnabled;


        void removeLodLevels(void);

        static void removeLodLevel( LODFaceList &lodList );
        char* arrangeEfficient( bool halfPos, bool halfTexCoords, VertexElement2Vec *outVertexElements );
    };



}
}


namespace Ogre {
    class Technique : public TechniqueAlloc
    {
    protected:
        typedef vector<Pass*>::type Passes;

        Passes mPasses;

        Material* mParent;
        bool mIsSupported;

        unsigned short mLodIndex;



        unsigned short mSchemeIndex;

        String mName;





        MaterialPtr mShadowCasterMaterial;




        String mShadowCasterMaterialName;


        UserObjectBindings mUserObjectBindings;

    public:



        enum IncludeOrExclude
        {

            INCLUDE = 0,

            EXCLUDE = 1
        };

        struct GPUVendorRule
        {
            GPUVendor vendor;
            IncludeOrExclude includeOrExclude;
            GPUVendorRule()
                : vendor(GPU_UNKNOWN), includeOrExclude(EXCLUDE) {}
            GPUVendorRule(GPUVendor v, IncludeOrExclude ie)
                : vendor(v), includeOrExclude(ie) {}
        };

        struct GPUDeviceNameRule
        {
            String devicePattern;
            IncludeOrExclude includeOrExclude;
            bool caseSensitive;
            GPUDeviceNameRule()
                : includeOrExclude(EXCLUDE), caseSensitive(false) {}
            GPUDeviceNameRule(const String& pattern, IncludeOrExclude ie, bool caseSen)
                : devicePattern(pattern), includeOrExclude(ie), caseSensitive(caseSen) {}
        };
        typedef vector<GPUVendorRule>::type GPUVendorRuleList;
        typedef vector<GPUDeviceNameRule>::type GPUDeviceNameRuleList;
    protected:
        GPUVendorRuleList mGPUVendorRules;
        GPUDeviceNameRuleList mGPUDeviceNameRules;
    public:

        Technique(Material* parent);

        Technique(Material* parent, const Technique& oth);
        ~Technique();





        bool isSupported(void) const;



        String _compile(bool autoManageTextureUnits);

        bool checkGPURules(StringStream& errors);

        bool checkHardwareSupport(bool autoManageTextureUnits, StringStream& compileErrors);
        size_t calculateSize(void) const;
        Pass* createPass(void);

        Pass* getPass(unsigned short index);



        Pass* getPass(const String& name);

        unsigned short getNumPasses(void) const;

        void removePass(unsigned short index);

        void removeAllPasses(void);



        bool movePass(const unsigned short sourceIndex, const unsigned short destinationIndex);
        typedef VectorIterator<Passes> PassIterator;

        const PassIterator getPassIterator(void);

        Material* getParent(void) const { return mParent; }


        Technique& operator=(const Technique& rhs);


        const String& getResourceGroup(void) const;
        bool isTransparent(void) const;


        void _prepare(void);

        void _unprepare(void);

        void _load(void);

        void _unload(void);


        bool isLoaded(void) const;


        void _notifyNeedsRecompile(void);



        Ogre::MaterialPtr getShadowCasterMaterial() const;


        void setShadowCasterMaterial(Ogre::MaterialPtr val);


        void setShadowCasterMaterial(const Ogre::String &name);
        void setPointSize(Real ps);
        void setAmbient(Real red, Real green, Real blue);
        void setAmbient(const ColourValue& ambient);
        void setDiffuse(Real red, Real green, Real blue, Real alpha);
        void setDiffuse(const ColourValue& diffuse);
        void setSpecular(Real red, Real green, Real blue, Real alpha);
        void setSpecular(const ColourValue& specular);
        void setShininess(Real val);
        void setSelfIllumination(Real red, Real green, Real blue);
        void setSelfIllumination(const ColourValue& selfIllum);
        void setShadingMode( ShadeOptions mode );
        void setFog(
            bool overrideScene,
            FogMode mode = FOG_NONE,
            const ColourValue& colour = ColourValue::White,
            Real expDensity = 0.001, Real linearStart = 0.0, Real linearEnd = 1.0 );
        void setSamplerblock( const HlmsSamplerblock &samplerblock );
        void setMacroblock( const HlmsMacroblock &macroblock );
        void setBlendblock( const HlmsBlendblock &blendblock );
        void setLodIndex(unsigned short index);

        unsigned short getLodIndex(void) const { return mLodIndex; }
        void setSchemeName(const String& schemeName);



        const String& getSchemeName(void) const;


        unsigned short _getSchemeIndex(void) const;


        bool isDepthWriteEnabled(void) const;


        bool isDepthCheckEnabled(void) const;


        bool hasColourWriteDisabled(void) const;






        void setName(const String& name);

        const String& getName(void) const { return mName; }
        bool applyTextureAliases(const AliasTextureNamePairList& aliasList, const bool apply = true) const;
        void addGPUVendorRule(GPUVendor vendor, IncludeOrExclude includeOrExclude);
        void addGPUVendorRule(const GPUVendorRule& rule);



        void removeGPUVendorRule(GPUVendor vendor);
        typedef ConstVectorIterator<GPUVendorRuleList> GPUVendorRuleIterator;

        GPUVendorRuleIterator getGPUVendorRuleIterator() const;
        void addGPUDeviceNameRule(const String& devicePattern, IncludeOrExclude includeOrExclude, bool caseSensitive = false);
        void addGPUDeviceNameRule(const GPUDeviceNameRule& rule);



        void removeGPUDeviceNameRule(const String& devicePattern);
        typedef ConstVectorIterator<GPUDeviceNameRuleList> GPUDeviceNameRuleIterator;

        GPUDeviceNameRuleIterator getGPUDeviceNameRuleIterator() const;





        UserObjectBindings& getUserObjectBindings() { return mUserObjectBindings; }





        const UserObjectBindings& getUserObjectBindings() const { return mUserObjectBindings; }

    };




}
namespace Ogre {
    class TextureManager : public ResourceManager, public Singleton<TextureManager>
    {
    public:

        TextureManager(void);
        virtual ~TextureManager();




        TexturePtr create (const String& name, const String& group,
                            bool isManual = false, ManualResourceLoader* loader = 0,
                            const NameValuePairList* createParams = 0);


        TexturePtr getByName(const String& name, const String& groupName = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME);
        virtual ResourceCreateOrRetrieveResult createOrRetrieve(
            const String &name, const String& group, bool isManual = false,
            ManualResourceLoader* loader = 0, const NameValuePairList* createParams = 0,
            TextureType texType = TEX_TYPE_2D, int numMipmaps = MIP_DEFAULT,
            Real gamma = 1.0f, bool isAlpha = false,
            PixelFormat desiredFormat = PF_UNKNOWN, bool hwGammaCorrection = false);
        virtual TexturePtr prepare(
            const String& name, const String& group,
            TextureType texType = TEX_TYPE_2D, int numMipmaps = MIP_DEFAULT,
            Real gamma = 1.0f, bool isAlpha = false,
            PixelFormat desiredFormat = PF_UNKNOWN, bool hwGammaCorrection = false);
        virtual TexturePtr load(
            const String& name, const String& group,
            TextureType texType = TEX_TYPE_2D, int numMipmaps = MIP_DEFAULT,
            Real gamma = 1.0f, bool isAlpha = false,
            PixelFormat desiredFormat = PF_UNKNOWN,
            bool hwGammaCorrection = false);
        virtual TexturePtr loadImage(
            const String &name, const String& group, const Image &img,
            TextureType texType = TEX_TYPE_2D,
            int numMipmaps = MIP_DEFAULT, Real gamma = 1.0f, bool isAlpha = false,
            PixelFormat desiredFormat = PF_UNKNOWN, bool hwGammaCorrection = false);
        virtual TexturePtr loadRawData(const String &name, const String& group,
            DataStreamPtr& stream, ushort width, ushort height,
            PixelFormat format, TextureType texType = TEX_TYPE_2D,
            int numMipmaps = MIP_DEFAULT, Real gamma = 1.0f, bool hwGammaCorrection = false);
        virtual TexturePtr createManual(const String & name, const String& group,
            TextureType texType, uint width, uint height, uint depth,
            int numMipmaps, PixelFormat format, int usage = TU_DEFAULT, ManualResourceLoader* loader = 0,
            bool hwGammaCorrection = false, uint fsaa = 0, const String& fsaaHint = BLANKSTRING,
            bool explicitResolve = false, bool shareableDepthBuffer = true);
        TexturePtr createManual(const String & name, const String& group,
            TextureType texType, uint width, uint height, int numMipmaps,
            PixelFormat format, int usage = TU_DEFAULT, ManualResourceLoader* loader = 0,
            bool hwGammaCorrection = false, uint fsaa = 0, const String& fsaaHint = BLANKSTRING,
            bool explicitResolve = false, bool shareableDepthBuffer = true)
        {
            return createManual(name, group, texType, width, height, 1,
                                numMipmaps, format, usage, loader, hwGammaCorrection,
                                fsaa, fsaaHint, explicitResolve,
                                shareableDepthBuffer);
        }
        virtual void setPreferredIntegerBitDepth(ushort bits, bool reloadTextures = true);



        virtual ushort getPreferredIntegerBitDepth(void) const;
        virtual void setPreferredFloatBitDepth(ushort bits, bool reloadTextures = true);



        virtual ushort getPreferredFloatBitDepth(void) const;
        virtual void setPreferredBitDepths(ushort integerBits, ushort floatBits, bool reloadTextures = true);
        virtual bool isFormatSupported(TextureType ttype, PixelFormat format, int usage);




        virtual bool isEquivalentFormatSupported(TextureType ttype, PixelFormat format, int usage);




        virtual PixelFormat getNativeFormat(TextureType ttype, PixelFormat format, int usage) = 0;
        virtual bool isHardwareFilteringSupported(TextureType ttype, PixelFormat format, int usage,
            bool preciseFormatOnly = false) = 0;
        virtual void setDefaultNumMipmaps(size_t num);



        virtual size_t getDefaultNumMipmaps()
        {
            return mDefaultNumMipmaps;
        }
        static TextureManager& getSingleton(void);
        static TextureManager* getSingletonPtr(void);

    protected:

        ushort mPreferredIntegerBitDepth;
        ushort mPreferredFloatBitDepth;
        size_t mDefaultNumMipmaps;
    };


}

namespace Ogre
{

    class Timer : public TimerAlloc
    {
    private:
        struct timeval start;
        clock_t zeroClock;
    public:
        Timer();
        ~Timer();
        bool setOption( const String& strKey, const void* pValue )
        { (void)strKey; (void)pValue; return false; }


        void reset();


        unsigned long getMilliseconds();


        unsigned long getMicroseconds();


        unsigned long getMillisecondsCPU();


        unsigned long getMicrosecondsCPU();
    };
}


namespace Ogre {
    class Viewport : public ViewportAlloc
    {
    public:

        size_t mGlobalIndex;
        Viewport(
            RenderTarget* target,
            Real left, Real top,
            Real width, Real height );



        virtual ~Viewport();
        void _updateDimensions(void);



        void _updateCullPhase01(Camera* camera, const Camera *lodCamera, uint8 firstRq, uint8 lastRq );
        void _updateRenderPhase02( Camera* camera, const Camera *lodCamera,
                                   uint8 firstRq, uint8 lastRq );
        void clear(unsigned int buffers = FBT_COLOUR | FBT_DEPTH,
                   const ColourValue& colour = ColourValue::Black,
                   Real depth = 1.0f, unsigned short stencil = 0);




        void discard( unsigned int buffers = FBT_COLOUR | FBT_DEPTH );



        RenderTarget* getTarget(void) const;




        Real getLeft(void) const;




        Real getTop(void) const;





        Real getWidth(void) const;




        Real getHeight(void) const;




        int getActualLeft(void) const;




        int getActualTop(void) const;



        int getActualWidth(void) const;



        int getActualHeight(void) const;

        Real getScissorLeft(void) const { return mScissorRelLeft; }
        Real getScissorTop(void) const { return mScissorRelTop; }
        Real getScissorWidth(void) const { return mScissorRelWidth; }
        Real getScissorHeight(void) const { return mScissorRelHeight; }

        int getScissorActualLeft(void) const { return mScissorActLeft; }
        int getScissorActualTop(void) const { return mScissorActTop; }
        int getScissorActualWidth(void) const { return mScissorActWidth; }
        int getScissorActualHeight(void) const { return mScissorActHeight; }
        void setDimensions( Real left, Real top, Real width, Real height, bool overrideScissors=true );
        void setScissors( Real left, Real top, Real width, Real height );



        void setOrientationMode(OrientationMode orientationMode, bool setDefault = true);



        OrientationMode getOrientationMode() const;



        static void setDefaultOrientationMode(OrientationMode orientationMode);



        static OrientationMode getDefaultOrientationMode();
        void setMaterialScheme(const String& schemeName)
        { mMaterialSchemeName = schemeName; }



        const String& getMaterialScheme(void) const
        { return mMaterialSchemeName; }



        void getActualDimensions(
            int &left, int &top, int &width, int &height ) const;

        bool _isUpdated(void) const;
        void _clearUpdatedFlag(void);
        void setOverlaysEnabled(bool enabled);



        bool getOverlaysEnabled(void) const;
        void setSkiesEnabled(bool enabled);



        bool getSkiesEnabled(void) const;
        void _setVisibilityMask(uint32 mask) { mVisibilityMask = mask; }




        uint getVisibilityMask(void) const { return mVisibilityMask; }

        void setColourWrite( bool colourWrite );

        bool getColourWrite(void) const { return mColourWrite; }


        void pointOrientedToScreen(const Vector2 &v, int orientationMode, Vector2 &outv);
        void pointOrientedToScreen(Real orientedX, Real orientedY, int orientationMode,
                                   Real &screenX, Real &screenY);
        void setDrawBuffer(ColourBufferType colourBuffer);


        ColourBufferType getDrawBuffer() const;

    protected:

        RenderTarget* mTarget;

        float mRelLeft, mRelTop, mRelWidth, mRelHeight;

        int mActLeft, mActTop, mActWidth, mActHeight;


        float mScissorRelLeft, mScissorRelTop, mScissorRelWidth, mScissorRelHeight;

        int mScissorActLeft, mScissorActTop, mScissorActWidth, mScissorActHeight;


        int mZOrder;
        bool mColourWrite;

        bool mUpdated;
        bool mShowOverlays;
        bool mShowSkies;
        uint32 mVisibilityMask;

        String mMaterialSchemeName;

        OrientationMode mOrientationMode;
        static OrientationMode mDefaultOrientationMode;
        ColourBufferType mColourBuffer;
    };



}


namespace Ogre
{
    class WindowEventListener
    {
    public:
        virtual ~WindowEventListener() {}







        virtual void windowMoved(RenderWindow* rw)
                { (void)rw; }







        virtual void windowResized(RenderWindow* rw)
                { (void)rw; }
        virtual bool windowClosing(RenderWindow* rw)
        { (void)rw; return true; }
        virtual void windowClosed(RenderWindow* rw)
                { (void)rw; }







        virtual void windowFocusChange(RenderWindow* rw)
                { (void)rw; }
    };





    class WindowEventUtilities
    {
    public:





        static void messagePump();
        static void addWindowEventListener( RenderWindow* window, WindowEventListener* listener );
        static void removeWindowEventListener( RenderWindow* window, WindowEventListener* listener );
        static void _addRenderWindow(RenderWindow* window);
        static void _removeRenderWindow(RenderWindow* window);
        typedef multimap<RenderWindow*, WindowEventListener*>::type WindowEventListeners;
        static WindowEventListeners _msListeners;
        static RenderWindowList _msWindows;
    };


}



namespace Ogre {
    class ShadowCameraSetup : public ShadowDataAlloc
    {
    protected:

        mutable Real mMinDistance;
        mutable Real mMaxDistance;

    public:

        virtual void getShadowCamera (const SceneManager *sm, const Camera *cam,
                                      const Light *light, Camera *texCam, size_t iteration) const = 0;
        ShadowCameraSetup() : mMinDistance( 0.0f ), mMaxDistance( 1000000.0f ) {}

        virtual ~ShadowCameraSetup() {}

        Real getMinDistance() const { return mMinDistance; }
        Real getMaxDistance() const { return mMaxDistance; }
    };
    class DefaultShadowCameraSetup : public ShadowCameraSetup
    {
    public:

        DefaultShadowCameraSetup();

        virtual ~DefaultShadowCameraSetup();


        virtual void getShadowCamera (const SceneManager *sm, const Camera *cam,
                                      const Light *light, Camera *texCam, size_t iteration) const;
    };




}




namespace Ogre {
    class FocusedShadowCameraSetup : public DefaultShadowCameraSetup
    {
    public:




        FocusedShadowCameraSetup(void);





        virtual ~FocusedShadowCameraSetup(void);



        virtual void getShadowCamera(const SceneManager *sm, const Camera *cam,
                                    const Light *light, Camera *texCam, size_t iteration) const;

    };




}



